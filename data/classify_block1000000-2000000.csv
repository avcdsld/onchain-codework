block_number,address,is_erc20,is_erc721,code,artistic_score,artistic_reason,duplicate_of_address
1014288,0xfd2487cc0e5dce97f08be1bc8ef1dce8d5988b4d,false,false,"contract Doubler {\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees;\n    uint public balance = 0;\n\n    address public owner;\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function Doubler() {\n        owner = msg.sender;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n        if (msg.value < 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n\n      	// add a new participant to array\n        uint idx = participants.length;\n        participants.length += 1;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value;\n        \n        // collect fees and update contract balance\n        if (idx != 0) {\n            collectedFees += msg.value / 10;\n            balance += msg.value;\n        } \n        else {\n            // first participant has no one above him,\n            // so it goes all to fees\n            collectedFees += msg.value;\n        }\n\n	// if there are enough ether on the balance we can pay out to an earlier participant\n        if (balance > participants[payoutIdx].amount * 2) {\n            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 10);\n            participants[payoutIdx].etherAddress.send(transactionAmount);\n\n            balance -= participants[payoutIdx].amount * 2;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1019866,0x3ae8b3ae07cb09f4ca2b6250eec03d016017755e,false,false,,,,0xfd2487cc0e5dce97f08be1bc8ef1dce8d5988b4d
1021992,0x2ef76694fbfd691141d83f921a5ba710525de9b0,false,false,"// LooneyLottery that pays out the full pool once a day\n//\n// git: https://github.com/thelooneyfarm/contracts/tree/master/src/lottery\n// url: http://the.looney.farm/game/lottery\ncontract LooneyLottery {\n  // modifier for the owner protected functions\n  modifier owneronly {\n    // yeap, you need to own this contract to action it\n    if (msg.sender != owner) {\n      throw;\n    }\n\n    // function execution inserted here\n    _\n  }\n\n  // constants for the Lehmer RNG\n  uint constant private LEHMER_MOD = 4294967291;\n  uint constant private LEHMER_MUL = 279470273;\n  uint constant private LEHMER_SDA = 1299709;\n  uint constant private LEHMER_SDB = 7919;\n\n  // various game-related constants, also available in the interface\n  uint constant public CONFIG_DURATION = 24 hours;\n  uint constant public CONFIG_MIN_PLAYERS  = 5;\n  uint constant public CONFIG_MAX_PLAYERS  = 222;\n  uint constant public CONFIG_MAX_TICKETS = 100;\n  uint constant public CONFIG_PRICE = 10 finney;\n  uint constant public CONFIG_FEES = 50 szabo;\n  uint constant public CONFIG_RETURN = CONFIG_PRICE - CONFIG_FEES;\n  uint constant public CONFIG_MIN_VALUE = CONFIG_PRICE;\n  uint constant public CONFIG_MAX_VALUE = CONFIG_PRICE * CONFIG_MAX_TICKETS;\n\n  // our owner, stored for owner-related functions\n  address private owner = msg.sender;\n\n  // basic initialisation for the RNG\n  uint private random = uint(sha3(block.coinbase, block.blockhash(block.number - 1), now));\n  uint private seeda = LEHMER_SDA;\n  uint private seedb = LEHMER_SDB;\n\n  // we allow 222 * 100 max tickets, allocate a bit more and store the mapping of entry => address\n  uint8[22500] private tickets;\n  mapping (uint => address) private players;\n\n  // public game-related values\n  uint public round = 1;\n  uint public numplayers = 0;\n  uint public numtickets = 0;\n  uint public start = now;\n  uint public end = start + CONFIG_DURATION;\n\n  // lifetime stats\n  uint public txs = 0;\n  uint public tktotal = 0;\n  uint public turnover = 0;\n\n  // nothing much to do in the constructor, we have the owner set & init done\n  function LooneyLottery() {\n  }\n\n  // owner withdrawal of fees\n  function ownerWithdraw() owneronly public {\n    // calculate the fees collected previously (excluding current round)\n    uint fees = this.balance - (numtickets * CONFIG_PRICE);\n\n    // return it if we have someting\n    if (fees > 0) {\n      owner.call.value(fees)();\n    }\n  }\n\n  // calculate the next random number with a two-phase Lehmer\n  function randomize() private {\n    // calculate the next seed for the first phase\n    seeda = (seeda * LEHMER_MUL) % LEHMER_MOD;\n\n    // adjust the random accordingly, getting extra info from the blockchain together with the seeds\n    random ^= uint(sha3(block.coinbase, block.blockhash(block.number - 1), seeda, seedb));\n\n    // adjust the second phase seed for the next iteration\n    seedb = (seedb * LEHMER_MUL) % LEHMER_MOD;\n  }\n\n  // pick a random winner when the time is right\n  function pickWinner() private {\n    // do we have >222 players or >= 5 tickets and an expired timer\n    if ((numplayers >= CONFIG_MAX_PLAYERS ) || ((numplayers >= CONFIG_MIN_PLAYERS ) && (now > end))) {\n      // get the winner based on the number of tickets (each player has multiple tickets)\n      uint winidx = tickets[random % numtickets];\n      uint output = numtickets * CONFIG_RETURN;\n\n      // send the winnings to the winner and let the world know\n      players[winidx].call.value(output)();\n      notifyWinner(players[winidx], output);\n\n      // reset the round, and start a new one\n      numplayers = 0;\n      numtickets = 0;\n      start = now;\n      end = start + CONFIG_DURATION;\n      round++;\n    }\n  }\n\n  // allocate tickets to the entry based on the value of the transaction\n  function allocateTickets(uint number) private {\n    // the last index of the ticket we will be adding to the pool\n    uint ticketmax = numtickets + number;\n\n    // loop through and allocate a ticket based on the number bought\n    for (uint idx = numtickets; idx < ticketmax; idx++) {\n      tickets[idx] = uint8(numplayers);\n    }\n\n    // our new value of total tickets (for this round) is the same as max, store it\n    numtickets = ticketmax;\n\n    // store the actual player info so we can reference it from the tickets\n    players[numplayers] = msg.sender;\n    numplayers++;\n\n    // let the world know that we have yet another player\n    notifyPlayer(number);\n  }\n\n  // we only have a default function, send an amount and it gets allocated, no ABI needed\n  function() public {\n    // oops, we need at least 10 finney to play :(\n    if (msg.value < CONFIG_MIN_VALUE) {\n      throw;\n    }\n\n    // adjust the random value based on the pseudo rndom inputs\n    randomize();\n\n    // pick a winner at the end of a round\n    pickWinner();\n\n    // here we store the number of tickets in this transaction\n    uint number = 0;\n\n    // get either a max number based on the over-the-top entry or calculate based on inputs\n    if (msg.value >= CONFIG_MAX_VALUE) {\n      number = CONFIG_MAX_TICKETS;\n    } else {\n      number = msg.value / CONFIG_PRICE;\n    }\n\n    // overflow is the value to be returned, >max or not a multiple of min\n    uint input = number * CONFIG_PRICE;\n    uint overflow = msg.value - input;\n\n    // store the actual turnover, transaction increment and total tickets\n    turnover += input;\n    tktotal += number;\n    txs += 1;\n\n    // allocate the actual tickets now\n    allocateTickets(number);\n\n    // send back the overflow where applicable\n    if (overflow > 0) {\n      msg.sender.call.value(overflow)();\n    }\n  }\n\n  // log events\n  event Player(address addr, uint32 at, uint32 round, uint32 tickets, uint32 numtickets, uint tktotal, uint turnover);\n  event Winner(address addr, uint32 at, uint32 round, uint32 numtickets, uint output);\n\n  // notify that a new player has entered the fray\n  function notifyPlayer(uint number) private {\n    Player(msg.sender, uint32(now), uint32(round), uint32(number), uint32(numtickets), tktotal, turnover);\n  }\n\n  // create the Winner event and send it\n  function notifyWinner(address addr, uint output) private {\n    Winner(addr, uint32(now), uint32(round), uint32(numtickets), output);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1026442,0xa39fcb48adf288f143459d57a1a0756718c919ae,false,false,"contract x15{\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees;\n    uint public balance = 0;\n\n    address public owner;\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function Doubler() {\n        owner = msg.sender;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n        if (msg.value < 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n\n      	// add a new participant to array\n        uint idx = participants.length;\n        participants.length += 1;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value;\n        \n        // collect fees and update contract balance\n        if (idx != 0) {\n            collectedFees += msg.value / 30;\n            balance += msg.value;\n        } \n        else {\n            // first participant has no one above him,\n            // so it goes all to fees\n            collectedFees += msg.value;\n        }\n\n	// if there are enough ether on the balance we can pay out to an earlier participant\n        if (balance > participants[payoutIdx].amount * 2) {\n            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 30);\n            participants[payoutIdx].etherAddress.send(transactionAmount);\n\n            balance -= participants[payoutIdx].amount * 2;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1026742,0x827ce5d8943d69c8538cd5662daf72be52176ed6,false,false,,,,0xa39fcb48adf288f143459d57a1a0756718c919ae
1030553,0xdc84953d7c6448e498eb3c33ab0f815da5d13999,false,false,"contract Doubler{\n\n    struct Participant {\n        address etherAddress;\n        uint PayAmount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees = 0;\n    uint public balance = 0;\n	uint public timeout = now + 1 weeks;\n\n    address public owner;\n\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function Doubler() {\n		collectedFees += msg.value;\n        owner = msg.sender;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n		//send more than 0.1 ether and less than 50, otherwise loss all\n		if (msg.value >= 100 finney && msg.value <= 50 ether) {\n	        // collect fees and update contract balance\n	        collectedFees += msg.value / 20;\n	        balance += msg.value - msg.value / 20;\n	\n	      	// add a new participant to array and calculate need balance to payout\n	        uint idx = participants.length;\n	        participants.length += 1;\n	        participants[idx].etherAddress = msg.sender;\n	        participants[idx].PayAmount = 2 * (msg.value - msg.value / 20);\n			\n			uint NeedAmount = participants[payoutIdx].PayAmount;\n			// if there are enough ether on the balance we can pay out to an earlier participant\n		    if (balance >= NeedAmount) {\n	            participants[payoutIdx].etherAddress.send(NeedAmount);\n	\n	            balance -= NeedAmount;\n	            payoutIdx += 1;\n	        }\n		}\n		else {\n			collectedFees += msg.value;\n            return;\n		}\n    }\n\n	function NextPayout() {\n        balance += msg.value;\n		uint NeedAmount = participants[payoutIdx].PayAmount;\n\n	    if (balance >= NeedAmount) {\n            participants[payoutIdx].etherAddress.send(NeedAmount);\n\n            balance -= NeedAmount;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n		collectedFees += msg.value;\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function collectBalance() onlyowner {\n		balance += msg.value;\n        if (balance == 0 && now > timeout) return;\n\n        owner.send(balance);\n        balance = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n		collectedFees += msg.value;\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1033952,0x177fa14aafde5ed17ab6c514fec4715adeb95bf0,false,false,,,,0xfd2487cc0e5dce97f08be1bc8ef1dce8d5988b4d
1049304,0xa9e4e3b1da2462752aea980698c335e70e9ab26c,false,false,"contract DynamicPyramid {\n\n    //Declare variables for storage critical to contract\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address private creator;\n    \n    //Sets creator\n    function DynamicPyramid() {\n        creator = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == creator) _ }\n    \n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n\n    Participant[] private participants;\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    //init function run on fallback\n    function init() private{\n        //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n        if (msg.value < 1 ether) {\n            collectedFees += msg.value;\n            return;\n        }\n        \n        uint _fee = feePercent;\n        //50% fee rebate on any ether value of 50 or greater\n        if (msg.value >= 50 ether) _fee /= 2;\n        \n        addPayout(_fee);\n    }\n    \n    //Function called for valid tx to the contract \n    function addPayout(uint _fee) private {\n        //Adds new address to participant array\n        participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n        \n        //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n        if (participants.length == 10)  pyramidMultiplier = 200;\n        else if (participants.length == 25)  pyramidMultiplier = 150;\n        \n        // collect fees and update contract balance\n        balance += (msg.value * (100 - _fee))/100;\n        collectedFees += (msg.value * _fee)/100;\n        \n	//Pays earlier participiants if balance sufficient\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.send(payoutToSend);\n\n            balance -= participants[payoutOrder].payout;\n            payoutOrder += 1;\n        }\n    }\n\n    //Fee functions for creator\n    function collectAllFees() onlyowner {\n        if (collectedFees == 0) throw;\n\n        creator.send(collectedFees);\n        collectedFees = 0;\n    }\n    \n    function collectFeesInEther(uint _amt) onlyowner {\n        _amt *= 1 ether;\n        if (_amt > collectedFees) collectAllFees();\n        \n        if (collectedFees == 0) throw;\n\n        creator.send(_amt);\n        collectedFees -= _amt;\n    }\n    \n    function collectPercentOfFees(uint _pcent) onlyowner {\n        if (collectedFees == 0 || _pcent > 100) throw;\n        \n        uint feesToCollect = collectedFees / 100 * _pcent;\n        creator.send(feesToCollect);\n        collectedFees -= feesToCollect;\n    }\n\n    //Functions for changing variables related to the contract\n    function changeOwner(address _owner) onlyowner {\n        creator = _owner;\n    }\n    \n    function changeMultiplier(uint _mult) onlyowner {\n        if (_mult > 300 || _mult < 120) throw;\n        \n        pyramidMultiplier = _mult;\n    }\n    \n    function changeFeePercentage(uint _fee) onlyowner {\n        if (_fee > 10) throw;\n        \n        feePercent = _fee;\n    }\n    \n    //Functions to provide information to end-user using JSON interface or other interfaces\n    function currentMultiplier() constant returns (uint multiplier, string info) {\n        multiplier = pyramidMultiplier;\n        info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n    }\n    \n    function currentFeePercentage() constant returns (uint fee, string info) {\n        fee = feePercent;\n        info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n    }\n    \n    function currentPyramidBalanceApproximately() constant returns (uint pyramidBalance, string info) {\n        pyramidBalance = balance / 1 ether;\n        info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n    }\n    \n    function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns (uint balancePayout) {\n            balancePayout = participants[payoutOrder].payout / 1 ether;\n    }\n    \n    function feesSeperateFromBalanceApproximately() constant returns (uint fees) {\n        fees = collectedFees / 1 ether;\n    }\n    \n    function totalParticipants() constant returns (uint count) {\n        count = participants.length;\n    }\n    \n    function numberOfParticipantsWaitingForPayout() constant returns (uint count) {\n        count = participants.length - payoutOrder;\n    }\n    \n    function participantDetails(uint orderInPyramid) constant returns (address Address, uint Payout)\n    {\n        if (orderInPyramid <= participants.length) {\n            Address = participants[orderInPyramid].etherAddress;\n            Payout = participants[orderInPyramid].payout / 1 ether;\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1079252,0x78df284ed555c6bc62ae3ae37632dedc00a6c7f2,false,false,"//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\ncontract multiowned {\n\n    // TYPES\n\n    // struct for the status of a pending operation.\n    struct PendingState {\n        uint yetNeeded;\n        uint ownersDone;\n        uint index;\n    }\n\n    // EVENTS\n\n    // this contract only has five types of events: it can accept a confirmation, in which case\n    // we record owner and operation (hash) alongside it.\n    event Confirmation(address owner, bytes32 operation);\n    event Revoke(address owner, bytes32 operation);\n    // some others are in the case of an owner changing.\n    event OwnerChanged(address oldOwner, address newOwner);\n    event OwnerAdded(address newOwner);\n    event OwnerRemoved(address oldOwner);\n    // the last one is emitted if the required signatures change\n    event RequirementChanged(uint newRequirement);\n\n    // MODIFIERS\n\n    // simple single-sig function modifier.\n    modifier onlyowner {\n        if (isOwner(tx.origin))\n            _\n    }\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\n    // that later attempts can be realised as the same underlying operation and\n    // thus count as confirmations.\n    modifier onlymanyowners(bytes32 _operation) {\n        if (confirmAndCheck(_operation))\n            _\n    }\n\n    // METHODS\n\n    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions\n    // as well as the selection of addresses capable of confirming them.\n    function multiowned(address[] _owners, uint _required) {\n        m_numOwners = _owners.length + 1;\n        m_owners[1] = uint(tx.origin);\n        m_ownerIndex[uint(tx.origin)] = 1;\n        for (uint i = 0; i < _owners.length; ++i)\n        {\n            m_owners[2 + i] = uint(_owners[i]);\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\n        }\n        m_required = _required;\n    }\n    \n    // Revokes a prior confirmation of the given operation\n    function revoke(bytes32 _operation) external {\n        uint ownerIndex = m_ownerIndex[uint(tx.origin)];\n        // make sure they're an owner\n        if (ownerIndex == 0) return;\n        uint ownerIndexBit = 2**ownerIndex;\n        var pending = m_pending[_operation];\n        if (pending.ownersDone & ownerIndexBit > 0) {\n            pending.yetNeeded++;\n            pending.ownersDone -= ownerIndexBit;\n            Revoke(tx.origin, _operation);\n        }\n    }\n    \n    // Replaces an owner `_from` with another `_to`.\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\n        if (isOwner(_to)) return;\n        uint ownerIndex = m_ownerIndex[uint(_from)];\n        if (ownerIndex == 0) return;\n\n        clearPending();\n        m_owners[ownerIndex] = uint(_to);\n        m_ownerIndex[uint(_from)] = 0;\n        m_ownerIndex[uint(_to)] = ownerIndex;\n        OwnerChanged(_from, _to);\n    }\n    \n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\n        if (isOwner(_owner)) return;\n\n        clearPending();\n        if (m_numOwners >= c_maxOwners)\n            reorganizeOwners();\n        if (m_numOwners >= c_maxOwners)\n            return;\n        m_numOwners++;\n        m_owners[m_numOwners] = uint(_owner);\n        m_ownerIndex[uint(_owner)] = m_numOwners;\n        OwnerAdded(_owner);\n    }\n    \n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\n        if (ownerIndex == 0) return;\n        if (m_required > m_numOwners - 1) return;\n\n        m_owners[ownerIndex] = 0;\n        m_ownerIndex[uint(_owner)] = 0;\n        clearPending();\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n        OwnerRemoved(_owner);\n    }\n    \n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\n        if (_newRequired > m_numOwners) return;\n        m_required = _newRequired;\n        clearPending();\n        RequirementChanged(_newRequired);\n    }\n    \n    function isOwner(address _addr) returns (bool) {\n        return m_ownerIndex[uint(_addr)] > 0;\n    }\n    \n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\n        var pending = m_pending[_operation];\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n        // make sure they're an owner\n        if (ownerIndex == 0) return false;\n\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n    \n    // INTERNAL METHODS\n\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n        // determine what index the present sender is:\n        uint ownerIndex = m_ownerIndex[uint(tx.origin)];\n        // make sure they're an owner\n        if (ownerIndex == 0) return;\n\n        var pending = m_pending[_operation];\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\n        if (pending.yetNeeded == 0) {\n            // reset count of confirmations needed.\n            pending.yetNeeded = m_required;\n            // reset which owners have confirmed (none) - set our bitmap to 0.\n            pending.ownersDone = 0;\n            pending.index = m_pendingIndex.length++;\n            m_pendingIndex[pending.index] = _operation;\n        }\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        // make sure we (the message sender) haven't confirmed this operation previously.\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            Confirmation(tx.origin, _operation);\n            // ok - check if count is enough to go ahead.\n            if (pending.yetNeeded <= 1) {\n                // enough confirmations: reset and run interior.\n                delete m_pendingIndex[m_pending[_operation].index];\n                delete m_pending[_operation];\n                return true;\n            }\n            else\n            {\n                // not enough: record that this owner in particular confirmed.\n                pending.yetNeeded--;\n                pending.ownersDone |= ownerIndexBit;\n            }\n        }\n    }\n\n    function reorganizeOwners() private returns (bool) {\n        uint free = 1;\n        while (free < m_numOwners)\n        {\n            while (free < m_numOwners && m_owners[free] != 0) free++;\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n            {\n                m_owners[free] = m_owners[m_numOwners];\n                m_ownerIndex[m_owners[free]] = free;\n                m_owners[m_numOwners] = 0;\n            }\n        }\n    }\n    \n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            if (m_pendingIndex[i] != 0)\n                delete m_pending[m_pendingIndex[i]];\n        delete m_pendingIndex;\n    }\n        \n    // FIELDS\n\n    // the number of owners that must confirm the same operation before it is run.\n    uint public m_required;\n    // pointer used to find a free slot in m_owners\n    uint public m_numOwners;\n    \n    // list of owners\n    uint[256] m_owners;\n    uint constant c_maxOwners = 250;\n    // index on the list of owners to allow reverse lookup\n    mapping(uint => uint) m_ownerIndex;\n    // the ongoing operations.\n    mapping(bytes32 => PendingState) m_pending;\n    bytes32[] m_pendingIndex;\n}\n\n// inheritable ""property"" contract that enables methods to be protected by placing a linear limit (specifiable)\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\n// uses is specified in the modifier.\ncontract daylimit is multiowned {\n\n    // MODIFIERS\n\n    // simple modifier for daily limit.\n    modifier limitedDaily(uint _value) {\n        if (underLimit(_value))\n            _\n    }\n\n    // METHODS\n\n    // constructor - stores initial daily limit and records the present day's index.\n    function daylimit(uint _limit) {\n        m_dailyLimit = _limit;\n        m_lastDay = today();\n    }\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\n        m_dailyLimit = _newLimit;\n    }\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\n        m_spentToday = 0;\n    }\n    \n    // INTERNAL METHODS\n    \n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n    // returns true. otherwise just returns false.\n    function underLimit(uint _value) internal onlyowner returns (bool) {\n        // reset the spend limit if we're on a different day to last time.\n        if (today() > m_lastDay) {\n            m_spentToday = 0;\n            m_lastDay = today();\n        }\n        // check to see if there's enough left - if so, subtract and return true.\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n            m_spentToday += _value;\n            return true;\n        }\n        return false;\n    }\n    // determines today's index.\n    function today() private constant returns (uint) { return now / 1 days; }\n\n    // FIELDS\n\n    uint public m_dailyLimit;\n    uint public m_spentToday;\n    uint public m_lastDay;\n}\n\n// interface contract for multisig proxy contracts; see below for docs.\ncontract multisig {\n\n    // EVENTS\n\n    // logged events:\n    // Funds has arrived into the wallet (record how much).\n    event Deposit(address from, uint value);\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n    event SingleTransact(address owner, uint value, address to, bytes data);\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\n    // Confirmation still needed for a transaction.\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n    \n    // FUNCTIONS\n    \n    // TODO: document\n    function changeOwner(address _from, address _to) external;\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\n    function confirm(bytes32 _h) returns (bool);\n}\n\n// usage:\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\n// Wallet(w).from(anotherOwner).confirm(h);\ncontract Wallet is multisig, multiowned, daylimit {\n\n    uint public version = 2;\n\n    // TYPES\n\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n    }\n\n    // METHODS\n\n    // constructor - just pass on the owner array to the multiowned and\n    // the limit to daylimit\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\n            multiowned(_owners, _required) daylimit(_daylimit) {\n    }\n    \n    // kills the contract sending everything to `_to`.\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\n        suicide(_to);\n    }\n    \n    // gets called when no other function matches\n    function() {\n        // just being sent some cash?\n        if (msg.value > 0)\n            Deposit(tx.origin, msg.value);\n    }\n    \n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n    // and _data arguments). They still get the option of using them if they want, anyways.\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\n        // first, take the opportunity to check that we're under the daily limit.\n        if (underLimit(_value)) {\n            SingleTransact(tx.origin, _value, _to, _data);\n            // yes - just execute the call.\n            _to.call.value(_value)(_data);\n            return 0;\n        }\n        // determine our operation hash.\n        _r = sha3(msg.data, block.number);\n        if (!confirm(_r) && m_txs[_r].to == 0) {\n            m_txs[_r].to = _to;\n            m_txs[_r].value = _value;\n            m_txs[_r].data = _data;\n            ConfirmationNeeded(_r, tx.origin, _value, _to, _data);\n        }\n    }\n    \n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n    // to determine the body of the transaction from the hash provided.\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\n        if (m_txs[_h].to != 0) {\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\n            MultiTransact(tx.origin, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\n            delete m_txs[_h];\n            return true;\n        }\n    }\n    \n    // INTERNAL METHODS\n    \n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            delete m_txs[m_pendingIndex[i]];\n        super.clearPending();\n    }\n\n    // FIELDS\n\n    // pending transactions we have at present.\n    mapping (bytes32 => Transaction) m_txs;\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1081783,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0,false,false,contract owned {\n    function owned() {\n        owner = msg.sender;\n    }\n    modifier onlyowner() { \n        if (msg.sender == owner)\n            _\n    }\n    address owner;\n}\ncontract CoinLock is owned {\n    uint public expiration; // Timestamp in # of seconds.\n    \n    function lock(uint _expiration) onlyowner returns (bool) {\n        if (_expiration > block.timestamp && expiration == 0) {\n            expiration = _expiration;\n            return true;\n        }\n        return false;\n    }\n    function redeem() onlyowner {\n        if (block.timestamp > expiration) {\n            suicide(owner);\n        }\n    }\n},1,標準的な所有者制御と時間ロック機能を持つ実用的なスマートコントラクト。,
1081983,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4,false,false,contract SimpleStorage {\n    uint storedData;\n    function set(uint x) {\n        storedData = x;\n    }\n    function get() constant returns (uint retVal) {\n        return storedData;\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1094660,0x68387152da230ec518154ae8e74bda3be4070049,false,false,,,,TOO_SHORT
1094675,0x5db626cf4e1d803debf81239919625b46aaeeccd,false,false,,,,TOO_SHORT
1094799,0xc7ead5a14215a550f86ca9711339c220c0aae478,false,false,,,,TOO_SHORT
1095094,0x064c268cdfe12acc19fe798a19847fd3dd1f64d7,false,false,,,,TOO_SHORT
1095187,0x448842ea19655f5d4bbd5352cd8b839178093de6,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1095188,0x094fc99751316a0b9566c47b0fcf37e413602df9,false,false,,,,TOO_SHORT
1095273,0x0445dfc0353954bf7f44f640cb95a6d19fe287f1,false,false,,,,TOO_SHORT
1095288,0x27af7ccc47d6d68909b1fcd0729c9c3b6a6a626c,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1095303,0x97b77ffb2f03162b266d41878f8aca01e577c751,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1095549,0x00b6eaa5668ca3b62a3c32e6d14c48e46e563cdd,false,false,,,,TOO_SHORT
1095800,0x190de110166cddd43aad65464df1b2f5802d5eba,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1095819,0xe6edeb0763cb24988a2da8c4655c01b63e6a30e6,false,false,,,,TOO_SHORT
1095903,0xc2d4290aa2dee92c6ad85ecd580d1216010e92d0,false,false,,,,TOO_SHORT
1096488,0x9344b8cee3cf1acee8c723b23d24b60dc7af0151,false,false,,,,TOO_SHORT
1096514,0x34b8d4beeee2fe65eeb32531e932a5411b45226e,false,false,,,,TOO_SHORT
1096735,0x176907f26626d0aa35bf71554c6237a83bcec8ee,false,false,,,,TOO_SHORT
1097083,0xce6ab75f6880389dca5af79ce3acd5d2a99c6681,false,false,,,,TOO_SHORT
1097156,0xf6b7f2d9eae5994b2d66b56f7befb59e90ee2791,false,false,,,,TOO_SHORT
1097291,0xf56d876c63dde2a94eb123b846cd3f33dc94cd52,false,false,,,,TOO_SHORT
1097316,0x7ee9eefe1e93acc2a8e9f51f0c4c875ca24bf168,false,false,,,,TOO_SHORT
1097642,0x7b252097d5239dba1d0d587904865038be83279d,false,false,,,,TOO_SHORT
1097696,0x8a85848d503dfd8817157d90aa27220e3e4cfb67,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1097750,0xfd1c3314bf64c12017093351cdd2fb6b07e0c0bd,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1098459,0x48c51d51b983858dbc045c16bdddd4a9406556a4,false,false,,,,TOO_SHORT
1098619,0x109d4bd6359de130de29e6ec82dbbaedbaf07e2b,false,false,,,,TOO_SHORT
1098818,0xc2901e231dbbb6cf2c8d966780e12a2aafe53cd6,false,false,,,,TOO_SHORT
1098968,0x5fd88581057b6b9cb56494a238cc4f6ae7c47dbc,false,false,,,,TOO_SHORT
1099482,0x82e6bf4a0c4bb241f938dcf36197c8966692b4a9,false,false,,,,TOO_SHORT
1099604,0x0a699188dddd0da01baf1d8044fdfbe8860edc9a,false,false,,,,TOO_SHORT
1099642,0xcb7193381b959ea2f1e98ec1f9790682c35c4887,false,false,,,,TOO_SHORT
1099656,0xf2c6ecd95d6eeee5242b58c66e6b5e359ae5d97c,false,false,,,,TOO_SHORT
1099701,0xc8535710822cf289df831de544ba5069f79afc77,false,false,,,,TOO_SHORT
1099702,0x63194b3488f271b8af7a43ca2c57b105ddc14175,false,false,,,,TOO_SHORT
1099916,0xefc6676da14d4986a492e926f19b5a0d811b0523,false,false,,,,TOO_SHORT
1100166,0x109529dd74495a88de91fe67fb80079105fe1208,false,false,,,,TOO_SHORT
1100458,0x4e73f824bcb509580544d46abcdebf38ea6f2d41,false,false,,,,TOO_SHORT
1100480,0xcae7e9cba29adfbb750ec521aa4c7dd5b0737430,false,false,,,,TOO_SHORT
1100487,0x67f88f893b04333469888e66ab4809e8c23265d8,false,false,,,,TOO_SHORT
1100534,0xff2daa9c2b418898fbdc4daef19df81d4e0fe414,false,false,,,,TOO_SHORT
1100535,0x3523565b646c815ffc01dbae357a046e18e0ac0b,false,false,,,,TOO_SHORT
1100571,0xb998a6cc3679eb924eb2d2781d57be7f287c2eff,false,false,,,,TOO_SHORT
1100820,0xaef44db90669709070e584812e833a5d20b702eb,false,false,,,,TOO_SHORT
1100834,0x325f50d4bd27e22d86a4575d1283f84666ef849c,false,false,,,,TOO_SHORT
1100839,0x06c325e85990c23c95538d173e49678b89dfbd13,false,false,,,,TOO_SHORT
1100843,0x57e0b69f4f70134ee0ae96e6aaf465444cc0df61,false,false,,,,TOO_SHORT
1100874,0x02921c5f91a6e6abe5ff58f7a0a282591bc8f339,false,false,,,,TOO_SHORT
1100912,0x22dd82d76adcd964c34dd492c9b743eba8cd13a4,false,false,,,,TOO_SHORT
1100914,0x387cf6ed98fb99eb8a759d5670a6ed612c4de9e5,false,false,,,,TOO_SHORT
1101215,0x192e6299345b636575ecf1fd8509f7da45d3b1c9,false,false,,,,TOO_SHORT
1101239,0xad190633460b9347a7f27c2c00ff010a7c422b65,false,false,,,,TOO_SHORT
1101327,0x67d0fe50b9d8a01f5664410a962540efaa1b8e07,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1101348,0x1f948ed78530d5f5b379dadab54f4d4985e0a147,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1101364,0x98aca4a93f3a1b0227b11fd6c252dee438889e49,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1101372,0xadbf7458bd4d25fdbe7d36beb35aa3906482ac92,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1101393,0xcf681f6f99d06cf567cc4c630d46b67d039d2ea9,false,false,,,,TOO_SHORT
1101450,0x27d5433083c0c05b5957531b9f7c8886234dad14,false,false,,,,TOO_SHORT
1101456,0x0e06e7b42cfc4e2f8f750680f13bc9717d5bdd49,false,false,,,,TOO_SHORT
1101459,0xa3d5b78a5b8a76f8707ee77a2c24afa07f7d5f57,false,false,,,,TOO_SHORT
1101650,0x6999d007ed0aaa8cdff141ab3d369e94612d3660,false,false,,,,TOO_SHORT
1101979,0x606fa99195b65033d605628ff74a6b583ec15ca4,false,false,,,,TOO_SHORT
1102052,0xe073ed27399e9b5684bfc5d13faa42ee5b395863,false,false,,,,TOO_SHORT
1102218,0xfc963926273fe309f168539d66e6300aa77bcbc1,false,false,,,,TOO_SHORT
1102242,0x88fb3ec6b06ed16a645e1339c428cacd9ab5f428,false,false,,,,TOO_SHORT
1102309,0x88fc279ba71cc805d8fac92583459d08c47bb568,false,false,,,,TOO_SHORT
1102383,0xec08093c1d9b322bc7570f120bd93e81dbecce12,false,false,,,,TOO_SHORT
1102422,0xc0bf93c40290e505e151206260df6d8766c9ec95,false,false,,,,TOO_SHORT
1102580,0xc9f236381ae557c7c87ffe07e1dc8a4a49757b64,false,false,,,,TOO_SHORT
1102595,0xca2785abb2c4db7d0ef9c8ae24ec3a2e9d9b96ef,false,false,,,,TOO_SHORT
1102629,0x02d51258b4ded5925bdf72698d0f5a54c8bcbbe8,false,false,,,,TOO_SHORT
1102796,0x12f9d03c5896eed942260463b13fbda05c3053e2,false,false,,,,TOO_SHORT
1102942,0x9ec4db79bfe434eb629ab74d705cfeea0e68a650,false,false,,,,TOO_SHORT
1103108,0xc979c5b4146659da34a7e7b2ab2b605c96193007,false,false,,,,TOO_SHORT
1103200,0x668f8945f35fe3450b5361436bc8b5e1239a72df,false,false,,,,TOO_SHORT
1103309,0xcca6e8130e7232f125aab3e1291752004b1eea64,false,false,,,,TOO_SHORT
1103459,0x2557b8fa42b60b2be8c167d40782f777e0e91762,false,false,,,,TOO_SHORT
1103490,0x3ffe13525e6657b36b0ca1bf8a7e07d8a3b9a17b,false,false,,,,TOO_SHORT
1103722,0x88af42d2405a6ab78b9a3c2064d9dd6a779bfe0c,false,false,,,,TOO_SHORT
1103731,0x03220563b172700d6e98143646a367a43ab3bb16,false,false,,,,TOO_SHORT
1103762,0xb864a1f4caabbb7df5e487398af24681b65f1ce9,false,false,,,,TOO_SHORT
1103773,0xb8eb67c080e9a0fb31a6082d6761b4efcd711e07,false,false,,,,TOO_SHORT
1103866,0x8d0c60ef28e1b7b9089c63730724a1cd5727c434,false,false,,,,TOO_SHORT
1103933,0x24a7dee4bedf5a785dfc9e2ed2584e9012630a1b,false,false,,,,TOO_SHORT
1104016,0x448c64f5db5467471fec8e98cda7933bf2f43888,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1104062,0x76d694ef9e2c57380d36b1b54f7e007fd5a9c490,false,false,,,,TOO_SHORT
1104224,0x2f083698082289383a2d11b306737546b3974c75,false,false,,,,TOO_SHORT
1104227,0xd1f58d00c1c575ec9902e4c11e1fd574c5ee6f22,false,false,,,,TOO_SHORT
1104263,0x551329ca263322173cd6b324c278dbf9e0396a52,false,false,,,,TOO_SHORT
1104401,0xba2c5f76b8157bd9a933a975af1ac82863987369,false,false,,,,TOO_SHORT
1104473,0xe6540c23ce159c0c92fafac28c24261f015485de,false,false,,,,TOO_SHORT
1104524,0xa7ea73f64e8f59b3f11709121c0c8efc6e649a79,false,false,,,,TOO_SHORT
1104534,0x727201a53c02f5e3b604a35aa9bfc9797f3c63a6,false,false,,,,TOO_SHORT
1104610,0x9f39f99ece4937dcfaa7c84485471808557b8e3f,false,false,,,,TOO_SHORT
1104640,0xe1d45f25970e3a1905165e52ae3a32758d16eda4,false,false,,,,TOO_SHORT
1104679,0x7329c8c3c4406fb255b87ff2f34132a5cfa2ad1c,false,false,,,,TOO_SHORT
1104691,0x07b7553143984c6502ec0eb8346293d053a42728,false,false,,,,TOO_SHORT
1104723,0x9e75683dd47d128570d4c68760e9be4c1c3e1072,false,false,,,,TOO_SHORT
1105111,0x4a795e00a30d51a95c4be5a07c35551adf14e9f6,false,false,,,,TOO_SHORT
1105223,0x4f841039dfd7bfe41ea238b57f51fb3e5048dd8d,false,false,,,,TOO_SHORT
1105241,0xa6a455ce63f58db65ecc359b639ef4475340ffa0,false,false,,,,TOO_SHORT
1105245,0x8a2746d5c97d319b2945f50ac1d25d014309f0dc,false,false,,,,TOO_SHORT
1105246,0xef1d14d7ae9257d1f4f52e57624ab7a9b55a3545,false,false,,,,TOO_SHORT
1105401,0x51251bfdb875d839bf0053312b97f47627fc0880,false,false,,,,TOO_SHORT
1105624,0xdd852783fa12b6cf64fabbaeb02dd174e070041b,false,false,,,,TOO_SHORT
1105689,0x1c6e1527c07527c5ac33e28257ad42b0b977e1bf,false,false,,,,TOO_SHORT
1106091,0xa42cdc525b44cbe7c16dca3114d4f0e22466e06f,false,false,,,,TOO_SHORT
1106220,0x11844188bc9026278256b94bd1f001df0eb05ade,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1106348,0x0e642aa8c3c682c880fe1dc4139add0468170909,false,false,,,,TOO_SHORT
1106467,0x72cca5a13e411f048aea7b35b7925100d10528f5,false,false,,,,TOO_SHORT
1107006,0x9519010412cf15c5e3735b493b8851fe8d9b763b,false,false,,,,TOO_SHORT
1107142,0x852ab94b539b5793f38734ebeecf4f90ed949ec9,false,false,,,,TOO_SHORT
1107252,0xd53a4a3ce032a7412962cd3244e580dc482d88e9,false,false,,,,TOO_SHORT
1107423,0xcbdea9c91d892665287b347bb06fe517b93b3ad4,false,false,,,,TOO_SHORT
1107519,0xcbf952f1bdfd38b1ddca2f3cf694f29fce2e2696,false,false,,,,TOO_SHORT
1107716,0x8b8ac0e47386f68b1132371d11922d9707b16edc,false,false,,,,TOO_SHORT
1107732,0x348bd9ea980916d8bc6cbd4eef8ade0dbe5996cc,false,false,,,,TOO_SHORT
1107844,0x30969c9988f0e91d727d06013f00db6496c759b4,false,false,,,,TOO_SHORT
1108126,0x482381fcd81341e44a19d08adf19f94ad051180c,false,false,,,,TOO_SHORT
1108268,0x53efe246e31b01e5f3fa7323373c6decf173e17a,false,false,,,,TOO_SHORT
1108269,0xa89b8d7bf18fb039cab7b1c2dfbf85415c312528,false,false,,,,TOO_SHORT
1108279,0x1816a29f323a7dccd9c2a75e5c2c2678e0b681ce,false,false,,,,TOO_SHORT
1108310,0xd9bbba0f2a4bb4348ffe6c6ee46e576cced26afe,false,false,,,,TOO_SHORT
1108361,0x605f34efd838f85fc1a00e153b6c21ce591df186,false,false,,,,TOO_SHORT
1108363,0xb6aa6486204cee9888dd899e65d2bba3fe63e108,false,false,,,,TOO_SHORT
1108567,0xaf54f7e64f6c77f110209dd4975975af5a4b47d1,false,false,,,,TOO_SHORT
1108681,0x5dbaa02c3a6b77c8a286211ab9558412221ebe12,false,false,,,,TOO_SHORT
1108721,0x635ebd14e1fc11b3d0766259118999b55e7dd7be,false,false,,,,TOO_SHORT
1108910,0xc7957d91865c7488d842ee78228e50113e2af905,false,false,,,,TOO_SHORT
1109028,0x87cc35c29c25c8d8445a18d3fc559059e1fb94bf,false,false,,,,TOO_SHORT
1109131,0x73e7e10d4a2a27b3f8f08c72f19cea81bb935fc4,false,false,,,,TOO_SHORT
1109382,0x44be6fd308b050a83a6d88def85adc3956f2d797,false,false,,,,TOO_SHORT
1109631,0xc69311709fc7576c6059bbde123ba03ff2680806,false,false,,,,TOO_SHORT
1109699,0xdd4a42744af80de9ddd3bbf6ee75e25b13cd0f8c,false,false,,,,TOO_SHORT
1109703,0xe283cd8eb5b32399870b0cca20c8401d07465ccc,false,false,,,,TOO_SHORT
1109780,0x6e058c64f97534a78adc22fa57ef2cc869a89d4d,false,false,,,,TOO_SHORT
1109802,0x54725f6efbdc38156aac6c7f2609a99572fa385c,false,false,,,,TOO_SHORT
1110514,0x7aac7b9b21fcf85178774e354f95bfd4c6eca2ce,false,false,,,,TOO_SHORT
1110661,0x1df627880d9ffe85809afe6b0a5d03aa15f19cb2,false,false,,,,TOO_SHORT
1110894,0x599118553312268709d438e66e99d67572b26a25,false,false,,,,TOO_SHORT
1110938,0xa2d646a8e056c6998de91131a89be7b516ada092,false,false,,,,TOO_SHORT
1111066,0xc4bae9c6c7582707f00c917e39afc65d2e107d55,false,false,,,,TOO_SHORT
1111085,0xca92fa37ecac19042bfdd0e0f4facb7a422aa587,false,false,,,,TOO_SHORT
1111353,0xb2ec2f1c3e1d429e9efe570d621dba6a6f67c79d,false,false,,,,TOO_SHORT
1111369,0xf5955e023f02a7bd82f3bffd79d84165ad94019e,false,false,,,,TOO_SHORT
1111856,0x185bbfa8975db2b58405959fca82c4b23eef6cdf,false,false,,,,TOO_SHORT
1111896,0xd2c606ad5a7a7305a6e718d0598ca3935d224d82,false,false,,,,TOO_SHORT
1112106,0x337f6827664389740e2d85ccef5d875ea845edfd,false,false,,,,TOO_SHORT
1112337,0x92c745feb7cb2e77982deeb35587a85fb82ba4cc,false,false,,,,TOO_SHORT
1112465,0x6bcae979198ce5cad43a5857ce74836fe8f28ba6,false,false,,,,TOO_SHORT
1112514,0x658d4066bc69e0f42429d63c577419a31d45fe75,false,false,,,,TOO_SHORT
1112670,0x86c88b9acb712339644a5f7edb813ef383db0eac,false,false,,,,TOO_SHORT
1112773,0x448970828a1ad554d8d92ca16f80562333233e45,false,false,,,,TOO_SHORT
1112784,0xd545e9882dc0a02622196a8f2a80224baf2835b8,false,false,,,,TOO_SHORT
1112818,0x2927290332cef5f6cb2e9a06e3c7902d8426cdad,false,false,,,,TOO_SHORT
1112959,0x5417bad7456842cd86615ade7120f38530571254,false,false,,,,TOO_SHORT
1112969,0x0971cffe9813c20736e993ba58742b0a91370256,false,false,,,,TOO_SHORT
1113132,0xcbe97c85daf6cafe20c2b8f40e7c5a63f12293eb,false,false,,,,TOO_SHORT
1113514,0x0a6dc5fe56856b7ce92655f10d8faa37e18a9373,false,false,,,,TOO_SHORT
1113575,0x5a6d99a266ebfad1767dca7032135ab89e2fd120,false,false,,,,TOO_SHORT
1113580,0x537c82bd70f534879cc65019a66a9d42acd94b9e,false,false,,,,TOO_SHORT
1113769,0x51d41504f2c79828bde873d343ea02d690e7d241,false,false,,,,TOO_SHORT
1113883,0xbf390736488f2ccf1d4bbb5e5a4abb44c9ebaa00,false,false,,,,TOO_SHORT
1114007,0x7da03ff86e4fe97437f1fd9036ed80daaf505111,false,false,,,,TOO_SHORT
1114405,0xf6a77b9cac1eb9c2d1b22bcca38700b14f404d89,false,false,,,,TOO_SHORT
1114412,0x486b41dfaf292fa74caa29917ec6def33c145aaf,false,false,,,,TOO_SHORT
1114612,0x6de655c6fbb3abaa6f5b86ac0c667d81770d9fdb,false,false,,,,TOO_SHORT
1114757,0x1714845f0288aaa74be388f11b21fa3c89894d7d,false,false,,,,TOO_SHORT
1114797,0xbd021d087a3f8dc644227eff7a48b6e5e46a8efc,false,false,,,,TOO_SHORT
1114864,0xa44df6705a3c5050d6b940379f7849e2c58a6786,false,false,,,,TOO_SHORT
1114902,0x95093e6f41462bb45bc1f8a7f91bf191ee2aba8c,false,false,,,,TOO_SHORT
1114906,0xb8869c5f264739dde064941c372c551ec47aab44,false,false,contract mortal {\n    /* Define variable owner of the type address*/\n    address owner;\n\n    /* this function is executed at initialization and sets the owner of the contract */\n    function mortal() { owner = msg.sender; }\n\n    /* Function to recover the funds on the contract */\n    function kill() { if (msg.sender == owner) suicide(owner); }\n},1,基本的な所有者管理と自己破壊機能を持つ標準的なスマートコントラクト。,
1115033,0x89c70ee7262c52dc395568cf931febc42153d3c7,false,false,,,,TOO_SHORT
1115262,0x7f49e5f947f64c1ed0a0fb17475e6e0a9d25c4f8,false,false,,,,TOO_SHORT
1115289,0x7897e855016c8c718953a5fcb3fd4f0dbdbc05e7,false,false,,,,TOO_SHORT
1115329,0x7d8536bbad96de1ca3ac19eb063fb2be69769fcd,false,false,,,,TOO_SHORT
1115372,0xff065f041f2321801b5c3e34b8de876616981653,false,false,,,,TOO_SHORT
1115393,0xb468719730ab74fa37b4454d82e26009ed64c12a,false,false,,,,TOO_SHORT
1115470,0x4aa34cd32c0f81494b05e3330ac2cd163aa162d4,false,false,,,,TOO_SHORT
1115509,0xf45717552f12ef7cb65e95476f217ea008167ae3,false,false,"contract Government {\n\n    // Global Variables\n    uint32 public lastCreditorPayedOut;\n    uint public lastTimeOfNewCredit;\n    uint public profitFromCrash;\n    address[] public creditorAddresses;\n    uint[] public creditorAmounts;\n    address public corruptElite;\n    mapping (address => uint) buddies;\n    uint constant TWELVE_HOURS = 43200;\n    uint8 public round;\n\n    function Government() {\n        // The corrupt elite establishes a new government\n        // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n        profitFromCrash = msg.value;\n        corruptElite = msg.sender;\n        lastTimeOfNewCredit = block.timestamp;\n    }\n\n    function lendGovernmentMoney(address buddy) returns (bool) {\n        uint amount = msg.value;\n        // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n        // 12h are on average = 60*60*12/12.5 = 3456\n        if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n            // Return money to sender\n            msg.sender.send(amount);\n            // Sends all contract money to the last creditor\n            creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n            corruptElite.send(this.balance);\n            // Reset contract state\n            lastCreditorPayedOut = 0;\n            lastTimeOfNewCredit = block.timestamp;\n            profitFromCrash = 0;\n            creditorAddresses = new address[](0);\n            creditorAmounts = new uint[](0);\n            round += 1;\n            return false;\n        }\n        else {\n            // the system needs to collect at least 1% of the profit from a crash to stay alive\n            if (amount >= 10 ** 18) {\n                // the System has received fresh money, it will survive at leat 12h more\n                lastTimeOfNewCredit = block.timestamp;\n                // register the new creditor and his amount with 10% interest rate\n                creditorAddresses.push(msg.sender);\n                creditorAmounts.push(amount * 110 / 100);\n                // now the money is distributed\n                // first the corrupt elite grabs 5% - thieves!\n                corruptElite.send(amount * 5/100);\n                // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                if (profitFromCrash < 10000 * 10**18) {\n                    profitFromCrash += amount * 5/100;\n                }\n                // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                // Make a deal with him.\n                if(buddies[buddy] >= amount) {\n                    buddy.send(amount * 5/100);\n                }\n                buddies[msg.sender] += amount * 110 / 100;\n                // 90% of the money will be used to pay out old creditors\n                if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                    lastCreditorPayedOut += 1;\n                }\n                return true;\n            }\n            else {\n                msg.sender.send(amount);\n                return false;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        lendGovernmentMoney(0);\n    }\n\n    function totalDebt() returns (uint debt) {\n        for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n            debt += creditorAmounts[i];\n        }\n    }\n\n    function totalPayedOut() returns (uint payout) {\n        for(uint i=0; i<lastCreditorPayedOut; i++){\n            payout += creditorAmounts[i];\n        }\n    }\n\n    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    function investInTheSystem() {\n        profitFromCrash += msg.value;\n    }\n\n    // From time to time the corrupt elite inherits it's power to the next generation\n    function inheritToNextGeneration(address nextGeneration) {\n        if (msg.sender == corruptElite) {\n            corruptElite = nextGeneration;\n        }\n    }\n\n    function getCreditorAddresses() returns (address[]) {\n        return creditorAddresses;\n    }\n\n    function getCreditorAmounts() returns (uint[]) {\n        return creditorAmounts;\n    }\n}",1,標準的なスマートコントラクトで、実用的な金融ロジックを実装しています。,
1115605,0x353988448458c2e8eabfcf34170a42b30dfe0d94,false,false,,,,TOO_SHORT
1115654,0xa6afc720edc9e2f039d375763f83ebcb0e445d21,false,false,,,,TOO_SHORT
1115711,0x6b97b3a783f4e6d8741d06377306b51e25d79a5f,false,false,,,,TOO_SHORT
1115995,0xb154eba2a5ac11d337ad639f9dd48d990c03393a,false,false,,,,TOO_SHORT
1116012,0x68efb7c5309f673193deb7824366d44c6bc4e6ec,false,false,,,,TOO_SHORT
1116093,0x637ae02a99bc79114e395f08decf9f6d7f450aaf,false,false,,,,TOO_SHORT
1116353,0x8ac3cd03f2a2c0c858806a3ab1e90a8ac2e68aff,false,false,,,,TOO_SHORT
1116678,0x62e8ab708005d97394be917dc54d68e7f9cefc36,false,false,,,,TOO_SHORT
1116870,0xbd3c58001735af1260807834e16abfd9a68e1222,false,false,,,,TOO_SHORT
1116928,0x027d74e66f49d7b1b750ea8aee9920a4caa92887,false,false,,,,TOO_SHORT
1117110,0x9ae77b2a2bb992d99e476876fa95979dc6f736c6,false,false,,,,TOO_SHORT
1117170,0x918b96dd436d1f1b65846f5960a065579634b670,false,false,,,,TOO_SHORT
1117375,0x17a896062e9a54f5222a28b2dcbf2129c3373558,false,false,,,,TOO_SHORT
1117383,0xeda11ca9f25df69dc623676cff24dd091b57fba8,false,false,,,,TOO_SHORT
1117405,0x7bfa859a317feb0284cc8bd169ba5624cdf23ea5,false,false,,,,TOO_SHORT
1117620,0x3ed8a7d3a46e047d8464c3e84c7a10898d60f3db,false,false,,,,TOO_SHORT
1117791,0xb0987717c18bc42bda86f2af75a0e92b4ac3e01a,false,false,,,,TOO_SHORT
1117929,0x20c6e28609ab29d62318eb489a2aeaff611fa92b,false,false,,,,TOO_SHORT
1117930,0xa8efc69437fbe6f13f35d5e512b64816f7058633,false,false,,,,TOO_SHORT
1118317,0x5ce95d425b319cbdc48b308906e01863e2c59dcd,false,false,,,,TOO_SHORT
1118623,0x61bd31fff7be4d6dc74db0d218fac4635d86b41e,false,false,,,,TOO_SHORT
1118702,0x7f53cb0d2db0a1f05efa6003740e3bab15305d7c,false,false,,,,TOO_SHORT
1118705,0xe065203d5dfb628a8aa6ccbc1f2487a67e70a3d8,false,false,,,,TOO_SHORT
1118962,0x3f235a4b4d98924487853a2a152f665268cdb5a9,false,false,,,,TOO_SHORT
1119114,0x6eb333482965fcd49af083cff6a9f6297823a6df,false,false,,,,TOO_SHORT
1119175,0x18d3ac02d78f989182f92ecfbf37161f07c42c91,false,false,,,,TOO_SHORT
1119179,0x2a7636c6252bc590c8b241bba00e3d4e80d99270,false,false,,,,TOO_SHORT
1119188,0x9fddfae7e52d53e71bc490dc137bc74eeeb05c59,false,false,,,,TOO_SHORT
1119277,0x9f203965ed3e8d3d025650c29240807c4f018927,false,false,,,,TOO_SHORT
1119721,0x1dbfc6daa0c5ad7d000ce41aa137961a570f5fe1,false,false,,,,TOO_SHORT
1119978,0xb9cf4145ca7547ab0726cf5aca820f59d946a6a6,false,false,,,,TOO_SHORT
1119980,0x4eae8f5884339bb631421109921316ef1b31db1d,false,false,,,,TOO_SHORT
1119981,0xdfa40d43632df694c7fdea454a1adbec1125cfd6,false,false,,,,TOO_SHORT
1120087,0xc0a1afab2cca7a5a9dfa94b66fd4bb39b7d388ec,false,false,,,,TOO_SHORT
1120113,0xa6f3622d5a72cae5fe4a55cc0b9b21abbf3014c8,false,false,,,,TOO_SHORT
1120114,0xb98d2483b178e7b367cf634466e463a2652c0e12,false,false,,,,TOO_SHORT
1120146,0x52ecf2960a79f9195afd54e5fd66be91ac4ecabd,false,false,,,,TOO_SHORT
1120513,0x70e2138b976102437b81e85c501bad1bd7c26552,false,false,,,,TOO_SHORT
1120521,0xda5ec8e498d5b2566e1753871e5ee7a32a0f278c,false,false,,,,TOO_SHORT
1120538,0x83abd88ff6cb58009164dab9ed225414a80b398a,false,false,,,,TOO_SHORT
1120805,0xbf33d876b5ad8b8d3dca4550e8fb062755ec166d,false,false,,,,TOO_SHORT
1120959,0x53fa57be43d82fe9a5ce6527652f3f244a2983df,false,false,,,,TOO_SHORT
1121120,0x8484708536ea8cb41dbb1e49e5a4660dedf12704,false,false,,,,TOO_SHORT
1121169,0x3401308a68cd09e3803e966aa4095e49f6f5e68c,false,false,,,,TOO_SHORT
1121298,0x6123785333f2147287dfcbef42afd1a0ae9714f1,false,false,,,,TOO_SHORT
1121503,0x772b6326b993f54042fe1b6509b12a508f5d0a9e,false,false,,,,TOO_SHORT
1121728,0x65c3a8fdfbfefccb6e56ca22df1589ecc9d4f0c2,false,false,,,,TOO_SHORT
1121937,0xaa9a6db4d57beaea71f13a649052c91e7797289c,false,false,,,,TOO_SHORT
1122493,0xa8f7d530d6e77bf3813254c79759aedc13d96ad1,false,false,,,,TOO_SHORT
1122495,0xff270139ed85d9583fdb2a4e84554a10574680b7,false,false,,,,TOO_SHORT
1122608,0x9cc45a54e3fbcf56703b0954c8c02afcebb15658,false,false,,,,TOO_SHORT
1122872,0x39ad6a82426eb656b3a3f7f779e6ec146fc5f1e5,false,false,,,,TOO_SHORT
1122917,0x8da742d0f7d99e2f31c36aef8ecfe6fa76e781eb,false,false,,,,TOO_SHORT
1122988,0x6adc77e30e678d765ee3bf58eaadcbc9622979a8,false,false,,,,TOO_SHORT
1123000,0xa894bc92653608aedd3028930c8b525898c5b4fc,false,false,,,,TOO_SHORT
1123213,0xf6336337418318cbccf80ab6c08b0885519652b4,false,false,,,,TOO_SHORT
1123245,0x3de10b7aff0908b2dd9af408f871b659b5a68706,false,false,,,,TOO_SHORT
1123251,0x4d8212482ec144462d3b088b3a389d4337cdcb13,false,false,,,,TOO_SHORT
1123371,0x167b7fa6ea9275d6386911aa0e15bc34e8972160,false,false,,,,TOO_SHORT
1123381,0x95cd243e7a4735316d9d623978182619371befd6,false,false,,,,TOO_SHORT
1123495,0x5279e0ee8b78e1c596eb00a6dcd48ec08851dba3,false,false,,,,TOO_SHORT
1124176,0xd3b32269b0aa103f530ff980f8ac58204952ac1d,false,false,,,,TOO_SHORT
1124262,0x151b99421883e18cecf41f194c2cd9a83a6bbce2,false,false,,,,TOO_SHORT
1124346,0xef79239fd238e3e28f059292858d2bca51bfd66a,false,false,,,,TOO_SHORT
1124402,0xbaf7f3782a12775f02b7a8c25ec3e989743fac1c,false,false,,,,TOO_SHORT
1124403,0x64f86ebbeeeb00c583a42ef5877633e6d1928a4b,false,false,,,,TOO_SHORT
1124438,0x25f17bd7ad1d869d446f99bce242c49bfa4b0d77,false,false,,,,TOO_SHORT
1124457,0xdaae18ccadaed3fc89b40d1e49d35510527a9488,false,false,,,,TOO_SHORT
1124681,0xa04e7c63f75421770313af2d3946048a53424799,false,false,,,,TOO_SHORT
1124815,0x348637c037f91a172b00fe1994dd9084352782be,false,false,,,,TOO_SHORT
1124984,0x5de3b8f4f6fb87ffe271ebbb102527f4352991a8,false,false,,,,TOO_SHORT
1125094,0xfad3418c87c8f566782287658f426ca56d199232,false,false,,,,TOO_SHORT
1125185,0x7320785200f74861b69c49e4ab32399a71b34f1a,false,false,,,,TOO_SHORT
1125266,0xea356afeef1aec4194281964c61c8f86abe892fa,false,false,,,,TOO_SHORT
1125283,0xd107ea4e8b64f3a6c777dcb210b5834aaa36a1b2,false,false,,,,TOO_SHORT
1125371,0x0605102785cc8be04f697e1a10b5f097e72b7804,false,false,,,,TOO_SHORT
1125571,0x385295d56fb64a1be7206f3d593e718520bb8950,false,false,,,,TOO_SHORT
1125679,0x25bddf44b1b93643f6b8407cfbb7995012c78dc6,false,false,,,,TOO_SHORT
1125971,0x92ce9f618d0433211c150472b7b0459002b1d1e0,false,false,,,,TOO_SHORT
1126013,0x76ba2b0bfaef80742afad6268e6ed567f901d0c8,false,false,,,,TOO_SHORT
1126162,0x8c3df9f18a9511ecd97739fe3a746579858d0e1b,false,false,,,,TOO_SHORT
1126301,0x3a9ccb354e26e5f3cf712b1acd4b172308fcc3df,false,false,,,,TOO_SHORT
1126604,0xb8f96c82a0472c535f93305d2a2a524e2a483fe7,false,false,,,,TOO_SHORT
1127433,0xadaa0450c9680f745a4b0f3e6828403813ddff18,false,false,,,,TOO_SHORT
1127511,0x88905c32f93d1f888f045833ce9860344c22db74,false,false,,,,TOO_SHORT
1127730,0x3f81fc937a919ff512967d1ef9eb2592227e85ee,false,false,,,,TOO_SHORT
1127756,0xa205e234e545c86280706349a0562becd46ff692,false,false,,,,TOO_SHORT
1128347,0xc157cf87f2f72711375e7b45e31dfa6c809edfb4,false,false,,,,TOO_SHORT
1128371,0xe998d55a2f63ed1a80a14cbba794699f460fc3c0,false,false,,,,TOO_SHORT
1128395,0x81c0ce57edaaf7f7903ba23afb2ac8255ce1f4e9,false,false,,,,TOO_SHORT
1128471,0x3677a0d580b4769a7d684ae44f9620ab8471b3c2,false,false,,,,TOO_SHORT
1128560,0x3f7072088861e3f3ddabc99233ec4c56a3a1487e,false,false,,,,TOO_SHORT
1128589,0xde815ffa64c918b373d93bcb6da567a0f8134dcd,false,false,,,,TOO_SHORT
1128730,0x7729d3b44342526187ad1fa244aa355f968125e5,false,false,,,,TOO_SHORT
1128832,0x1567c0c5dfaff58efa6e13764b764e475f268d4b,false,false,,,,TOO_SHORT
1128842,0x068abd01efff87943c6853abff3d20edfa9f9a18,false,false,,,,0xdc84953d7c6448e498eb3c33ab0f815da5d13999
1128987,0x76241f1f5f09d8dad4d681e68f7982ab01cbbbe9,false,false,,,,TOO_SHORT
1129129,0x13b6bf100efb4d91362c1bc448d4cd933ed917a0,false,false,,,,TOO_SHORT
1129149,0xe4861a666e4f4612222a5bcbaa1cb8bc7df97bbc,false,false,,,,TOO_SHORT
1129298,0x1007d0db6fd2a865e4c1ee9f43eb5eda770ce73e,false,false,,,,TOO_SHORT
1129360,0x88c34fd8a935b4a9ded9a5d5f35cb18c3d0ffdab,false,false,,,,TOO_SHORT
1129663,0x73126a7c24ebcc01118e04f3883b2671fb103081,false,false,,,,TOO_SHORT
1129675,0x0bc921e09f5c4f7941f6a6116f53c7812f63beb4,false,false,,,,TOO_SHORT
1129699,0x7d11e1a37cdc204b96ac3003f144c13abd846536,false,false,,,,TOO_SHORT
1129816,0xbafe5173320abf230ce3b869cb45d8f54470fa7b,false,false,,,,TOO_SHORT
1129908,0xd0f1cb00bec88280fa9c2c9cc6fe9cde9d6e5fd5,false,false,,,,TOO_SHORT
1130082,0x7256ad2b018c2446cf00b9c13056ccddc6fd33ac,false,false,,,,TOO_SHORT
1130097,0x60fbc2e1fba1262d17d52f0ef3740e791f4e82e4,false,false,,,,TOO_SHORT
1130099,0xb53c298f945b6ce066ef1a09190d4dfdee845dad,false,false,,,,TOO_SHORT
1130100,0x25670761fd73a8db483fb71df7c6cfa7e45ca5f1,false,false,,,,TOO_SHORT
1130209,0x929b6aa5b5ee48fac83424fed41164aa0b5ecd48,false,false,,,,TOO_SHORT
1130342,0x9bb92673b6ef433b6a0bbd51d1fc73be593a0d7e,false,false,,,,TOO_SHORT
1130376,0x21f597c6334b8d965f882c05dfdfe08e0e8e3087,false,false,,,,TOO_SHORT
1130395,0x2ffd9610abd6a0a2ad0ef6d406e1e1d368194d8f,false,false,,,,TOO_SHORT
1130414,0x09b4592064f184119112a3a6356fb1a33a924e4c,false,false,,,,TOO_SHORT
1130471,0x4e5655d187e8b6f716508df247b15115fff1678b,false,false,,,,TOO_SHORT
1131071,0x4f354326dce10c2711840cae858042d777da1070,false,false,,,,TOO_SHORT
1131140,0x663b4e927bced1bd4118c25e976377eac862eef0,false,false,,,,TOO_SHORT
1131267,0xb8dee42b56b8349547b71772736abc5a1e499eda,false,false,,,,TOO_SHORT
1131293,0x4353f9e7fbd2892d9fbe33afab64874e123fb31e,false,false,,,,TOO_SHORT
1131358,0xdbdb278eebf2bd434ac523810f6e7b926f5865fd,false,false,,,,TOO_SHORT
1131398,0x5533fb35f7fc1aa8430126006a31d352df4f90b4,false,false,,,,TOO_SHORT
1131518,0x11c5698047447102b9832c305789ed5194a8051a,false,false,,,,TOO_SHORT
1131703,0xfeb33285f7423196669cbbccce31f7e3b84d477d,false,false,,,,TOO_SHORT
1131944,0xa6f3920286a7c796fc96ebb18a37095256befdb9,false,false,,,,TOO_SHORT
1131978,0x7ec697ec85e3dad836d80c1a7133417cb29a32b6,false,false,,,,TOO_SHORT
1132947,0xf0fc944fc0d0eb5e3c9af7798c63a9d7704a6104,false,false,,,,TOO_SHORT
1133241,0x5034da3cb10890dfca286fb5bedb4a5606b50cff,false,false,,,,TOO_SHORT
1133336,0xca6641a0c9ad8a4e60f211d241c0fc81912cdf06,false,false,,,,TOO_SHORT
1133856,0xb4e27e2a97135663651aa5f9b1ec7d0b346384d4,false,false,,,,TOO_SHORT
1133858,0x4d7d1c1ba51179165e32380c50151be3077f49e2,false,false,,,,TOO_SHORT
1133922,0xa68780dd261cfea0d479728db3ed318940bfa9f9,false,false,,,,TOO_SHORT
1134114,0x12a4412cc84095d6429238896321639fe584194d,false,false,,,,TOO_SHORT
1134162,0x98d05de3c60461c9755b0f67e6bcaa536cc7738e,false,false,,,,TOO_SHORT
1134383,0xa3660f2e54b7f7e18a4ca62f3cde406fa85589e2,false,false,,,,TOO_SHORT
1134726,0x9148de7f38fa277a8456068bf790958e801feabc,false,false,,,,TOO_SHORT
1134858,0x20c07a69a358cd126ca800e44ece844a07d57007,false,false,,,,TOO_SHORT
1134867,0xbaaf34e0e7865cb178913c0b9782f48e2e13e71a,false,false,,,,TOO_SHORT
1134949,0xba9ae98a17adf33b0c6186a98520f0c77c52ae8c,false,false,,,,TOO_SHORT
1135204,0x355d79c8ad295670143050111ded8ec7e0d1ad3b,false,false,,,,TOO_SHORT
1135209,0xab92a5c0a51855fbfab1c65f8a16fb6e81be475f,false,false,,,,TOO_SHORT
1135385,0x61a633798bb9a884b0c9a575aadfecfc9ea62786,false,false,,,,TOO_SHORT
1135749,0x6c8ae39b691db4af03e2483fbce7daaee86e580e,false,false,,,,TOO_SHORT
1135895,0x8c788fcb6bcd5d0e92a823f2c83a5995182ca1a2,false,false,,,,TOO_SHORT
1135904,0x5a848b91c1c0e35d8786b51d5fc2f7b03f8743b6,false,false,,,,TOO_SHORT
1135954,0x52297d26cdfe4fa2eca48de3dee3112b60254cad,false,false,,,,TOO_SHORT
1136091,0x57486ab796ee1f89bb3c0f5920b5473ff39c6044,false,false,,,,TOO_SHORT
1136186,0x64f3eae6e25a751f09036d186d7f539cd7c5d218,false,false,,,,TOO_SHORT
1136208,0x0274670cf01bac2558d994f1ded367055429261b,false,false,,,,TOO_SHORT
1136314,0xde661e71f1fe9ac193f3abc7413d0ba5cbb2f3ab,false,false,,,,TOO_SHORT
1136351,0x2b5bd3537d3bdd3c4e87e40262b1e9ee76bbb570,false,false,,,,TOO_SHORT
1136576,0x22dd665a2daa3fc38a02c7100fcb1eec01ce5793,false,false,,,,TOO_SHORT
1136736,0x6b62497fc36e1f47c4c2d9f29fdf28cc3ebed72d,false,false,,,,0xa9e4e3b1da2462752aea980698c335e70e9ab26c
1136911,0x9c9b71ce5b970d1b187b6cde697bd872719cc160,false,false,,,,TOO_SHORT
1136994,0x15a552c80fdb3af9edae412ce7c99f4cb288408e,false,false,,,,TOO_SHORT
1137754,0x48ba630669551a781c2b1d9dad76b732b2f39df8,false,false,,,,TOO_SHORT
1137787,0xa57df2b6a3cc1ab18a6dee48545f896710f06023,false,false,,,,TOO_SHORT
1137933,0x451121eae198e772368ada6c08665a3f48d819c5,false,false,,,,TOO_SHORT
1137935,0xb34160dac048f2f81acdc3b3b908f46c390a776f,false,false,,,,TOO_SHORT
1137948,0x47de904dac4a6e18e28a8e796e114931aea19d43,false,false,,,,TOO_SHORT
1138193,0xa77a8133db65b88cf502cdbb8ad4d55bd431d408,false,false,,,,TOO_SHORT
1138330,0xb9e08a28c7a45db82b86ad9d3855853ace83d3f1,false,false,,,,TOO_SHORT
1138393,0x25803e9f09644ee8d133d54159703291806485bc,false,false,,,,TOO_SHORT
1138582,0x370c11c666e65f7704d6c92da9bbb824bc27f9ef,false,false,,,,TOO_SHORT
1138775,0x518ebecbf5db01a624278a084dbdd1597d4090d4,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1139163,0xf6725965f3eaefbe87d5abfa6b489730a9c18a4e,false,false,,,,TOO_SHORT
1139177,0x31f7ea4aadf651a2131517deba777f73c7ac0737,false,false,,,,TOO_SHORT
1139178,0xdcb7c8dd00da03a47f99b2e4cbd0a2334ddb2382,false,false,,,,TOO_SHORT
1139201,0x27b38bd29e6f8a75fe0e3ca3c8c3b868cdbab5a9,false,false,,,,TOO_SHORT
1139228,0x5aa44c4e8dd374d147f427e2601ccadb267b7ec4,false,false,,,,TOO_SHORT
1139290,0x0624a5b3be666504a1b1d01c8cfb003a03f0bb41,false,false,,,,TOO_SHORT
1139452,0x35c621eb83ffc493f89d5ea8e754b1dd25b68ba6,false,false,,,,TOO_SHORT
1139474,0x0b40521c1b2b3ce89a7352aea0370968bb8f365e,false,false,,,,TOO_SHORT
1139546,0xf3c95dbe565cff98f8bd45613ba0d4a37525ed95,false,false,,,,TOO_SHORT
1139835,0xcfcaf42edcfa85e0388ed806e0970f0a4988516d,false,false,,,,TOO_SHORT
1139878,0x195fefadafb30bf358c6571b5a21ecd626edb76c,false,false,,,,TOO_SHORT
1139881,0x53551ddcb5d1bdf285371b6351ab70f58332d13c,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1139893,0x2cdc24bf783862ec0b87620d54cc3027bf448027,false,false,,,,TOO_SHORT
1139933,0xa59525668668dc784f0da04054eda3f94d95e1d3,false,false,,,,TOO_SHORT
1139944,0xf51231b4b8a5e19c76b031ce928e5e255cb15381,false,false,,,,TOO_SHORT
1139957,0xd956f73950e731f2db3047a4a5b5569f3cccc926,false,false,,,,TOO_SHORT
1140015,0x0efeb6e795c93a75ca90ededea5548883eff195c,false,false,,,,TOO_SHORT
1140410,0xdde236d8e8615d678c69253d3a64743b34fec60d,false,false,,,,TOO_SHORT
1140433,0x36f67b415d9f775bbf505dd64b99d5e58cffbe02,false,false,,,,TOO_SHORT
1140473,0xef150baf890f8e44c87748196f69724502240839,false,false,,,,TOO_SHORT
1140762,0xa782e3e8dd9992042de55fdfa490355faf6bb4eb,false,false,,,,TOO_SHORT
1140765,0x1ef3ce3978b58f07d155ba8837083368e5ef879c,false,false,,,,TOO_SHORT
1140902,0x437f5c9506927e88c37fec9fff3708005116ddc5,false,false,,,,TOO_SHORT
1140908,0x7c4579f5073c0692fee27551eac7e640a32c1fbf,false,false,,,,TOO_SHORT
1140909,0x296f155fd6feb7f0e07529d49ee96f4335b3e36e,false,false,,,,TOO_SHORT
1140920,0x9c1285d573109b4a899da9b9caf6c9a8b72dc6ff,false,false,,,,TOO_SHORT
1141001,0x7443c1c5f66895de244579e94d4f4fc40e731c02,false,false,,,,TOO_SHORT
1141045,0x2db438b1ab8dd62bb7f270334d22b5bd83b977b3,false,false,,,,TOO_SHORT
1141067,0x770643cfbc62f626bc25bd8c30d32662e949d5cd,false,false,,,,TOO_SHORT
1141129,0x864745cd1052fcd7d67eca11bb930dadb6240ff7,false,false,,,,TOO_SHORT
1141194,0x5ad665e0e6e5e0a48a1ac9f6c4d450b58a11bbd1,false,false,,,,TOO_SHORT
1141218,0x416881aa5564ea14adb4446f4a048acc48ae7c7c,false,false,,,,TOO_SHORT
1141301,0x455f63e5f92dbe9d100d291bc2a1b8844fe2f1e9,false,false,,,,TOO_SHORT
1141366,0x35ed9ca7d585ded2474db8472e1ce95de05ff292,false,false,,,,TOO_SHORT
1141413,0x7d4ac4c82d1dd59c2235d1bca3709b1bfbedf20d,false,false,,,,TOO_SHORT
1141683,0x66c602bb6204d6506a9b9b595f03df69af2dfec9,false,false,,,,TOO_SHORT
1141788,0x47115a7ba105453c5b5b4eb16fac6b8b7c025fd4,false,false,,,,TOO_SHORT
1141912,0x1ea6d13e5c03791990892e3a34807f9b7f361762,false,false,,,,TOO_SHORT
1142163,0x2e2e46250973478e5391883dc590b78b9f8ab6da,false,false,,,,TOO_SHORT
1142183,0x34443b36ce00dd8bf767d6024c80552898903a7d,false,false,,,,TOO_SHORT
1142243,0xe2c57b2577b5a6bae102c4e99e0c1a9b753bea2b,false,false,,,,TOO_SHORT
1142397,0x28aba9b56107b3aa55303c33f9aa57e540a6890c,false,false,,,,TOO_SHORT
1142601,0xcc8e1ec08d5023a76ff18e67cb20c897029fc2f2,false,false,,,,TOO_SHORT
1142792,0x77f02299d5464af874045ac1c74f1f058a4c38f0,false,false,,,,TOO_SHORT
1142839,0x614d0ad52ad697115169ed506f4245b043a3fd08,false,false,,,,TOO_SHORT
1143053,0x090e81db24ccf5aec5e102d511dd78e34b428e2b,false,false,,,,TOO_SHORT
1143177,0xbc80093638ec45c948f440ce4ecdb031d5549b2c,false,false,,,,TOO_SHORT
1143199,0x9e69dd151d2a1f7402d709eba1199a864c16f35c,false,false,,,,TOO_SHORT
1143234,0x5f5d64b514a18e77f542325c46aa8d62d8b081cf,false,false,,,,TOO_SHORT
1143364,0x0c0650d39b73009f0aba359f0eae98be77a18fe6,false,false,,,,TOO_SHORT
1143382,0x70d78760457327a11f232c5c9a51dc53f57b323c,false,false,,,,TOO_SHORT
1143402,0x1499514548ca0b1c60c59b692942ad7933d26051,false,false,,,,TOO_SHORT
1143410,0x0b70d28e07a0913afb865c9575dadaf45f62ea4a,false,false,,,,TOO_SHORT
1143459,0xddadb74ceeb2aa36184f073edcac2b140f82b704,false,false,,,,TOO_SHORT
1143464,0xf3c6c1d7aaec42b698d186419a8954ccb181a5f4,false,false,,,,TOO_SHORT
1143646,0x5110c69be286c61551706e5ee0a2bde03893d755,false,false,,,,TOO_SHORT
1143677,0xc37ec9010fab2e135b6e8de26002b21bad19e59f,false,false,,,,TOO_SHORT
1143898,0x5cb61e4933fa5bf8462a67e8746c2b71861c66d3,false,false,,,,TOO_SHORT
1143990,0xfea2f1019ce0f218455b51f1a75d5cdd91ff2108,false,false,,,,TOO_SHORT
1144227,0x6b0158726e5d26e8d47c17517879f64c484762ae,false,false,,,,TOO_SHORT
1144246,0xe5e4ef872db112fcd33238c59dbaca14713c8025,false,false,,,,TOO_SHORT
1144295,0x10c44346d4ef234e1b0293b185bda2dbf90f64df,false,false,,,,TOO_SHORT
1144298,0xca41c649b04f053f1ec2b6ba535c769dde441d34,false,false,,,,TOO_SHORT
1144330,0x878ee1398d123af62869dcc5684ff2c549c4ce4a,false,false,,,,TOO_SHORT
1144341,0x63b3ad73c12ddd4f0734e4e793ab540d38640e72,false,false,,,,TOO_SHORT
1144404,0x2db963e0f438a0d4c28e6bfeeb40e17e97d050d7,false,false,,,,TOO_SHORT
1144508,0x32bcca0074aeae6e74bf4b05f92a00b9e2a949a6,false,false,,,,TOO_SHORT
1144939,0xaaeee96a403c749590610df97b517e0e50e1f9c2,false,false,,,,TOO_SHORT
1144989,0x853253a83249a8a1f4dfa987e7f38289adf38d28,false,false,,,,TOO_SHORT
1145005,0xe7fcc93d7e29cee91fc3c79a9922e246d009b6a0,false,false,,,,TOO_SHORT
1145011,0xc1bc8eab5b33e41f05ccaece5160aa9750dc8864,false,false,,,,TOO_SHORT
1145055,0x366b90b3d5c3aee70740e9cf323bfba2010cacd5,false,false,,,,TOO_SHORT
1145096,0x0914d62c671b7917ae911f71c29cfc0a9af900d4,false,false,,,,TOO_SHORT
1145235,0x27bc70c75955e16d6b86b94ba4151cda311629c9,false,false,,,,TOO_SHORT
1145249,0x1a7b0edb9178863df03d5483dc85b31680e6241a,false,false,,,,TOO_SHORT
1145282,0x1286bd0dcbbe8f03c9871c808b34ab580225c3e1,false,false,,,,TOO_SHORT
1145304,0xf1dc31a433bd6f21a957245d620242fd41dbe72f,false,false,,,,TOO_SHORT
1145371,0x8cad99a99e3901c8a34ed8b85d7696e614e26702,false,false,,,,TOO_SHORT
1145462,0x81848a0094c7aea6ceb7e1666fc9b7152cf3a7e4,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1145489,0x2587fa75a30158f91a86d0f59ead05a6198c0c63,false,false,,,,TOO_SHORT
1145515,0xb601fcea8b42933369d449efd3562085878ac01d,false,false,,,,TOO_SHORT
1145545,0x65023158160f3b035298af10a1e7f8c45eb3fb3b,false,false,,,,TOO_SHORT
1145574,0xb7c77d044234891cf13182e67ec64cefe5ecc923,false,false,,,,TOO_SHORT
1145575,0xa25534e04e458038ddb2aaa91b80eaa0ac9df24c,false,false,,,,TOO_SHORT
1145629,0x478c117dddbad2c1be5ab754303faaefbbe185ea,false,false,,,,TOO_SHORT
1145654,0x1f80b3be910555bbedd991ebd78a8c2ec2e08387,false,false,,,,TOO_SHORT
1145679,0x7e766ded6c1642b9a2794d2e739cb5009b97a942,false,false,,,,TOO_SHORT
1145720,0xd8553651a0fdc346a9a38b6018247cc059f1f9d2,false,false,,,,TOO_SHORT
1145751,0x5b93929716318de4aa5d025b209d6be2916f4291,false,false,,,,TOO_SHORT
1145777,0x88056671b1f5029f01d1a0d2b59e4e7bae26b879,false,false,,,,TOO_SHORT
1145799,0x0ff927991d576eab0eb38805cdf58b5d837964b7,false,false,,,,TOO_SHORT
1145811,0xfdb6608fcf3e187c8c022bce6e7f8d0775ca8592,false,false,,,,TOO_SHORT
1145878,0x27abf397240954b20870bdf99f6f1e53b98ac7e5,false,false,,,,TOO_SHORT
1145978,0x999d7a6b6abd2606746b88cb5f2d430a97871b99,false,false,,,,TOO_SHORT
1146065,0x43d70d8133974597cbd7f7d162a08303316805c4,false,false,,,,TOO_SHORT
1146089,0x9611d3c72c7098b21d4a547cd44cbacf0b287387,false,false,,,,TOO_SHORT
1146173,0x275632e308855d832b0a9988ed49de023be55246,false,false,,,,TOO_SHORT
1146388,0xeb318ce87be840b67941c0e4cce70ac837a54c73,false,false,,,,TOO_SHORT
1146411,0xca157f70b633bd1d6866f2b79844528636d9847e,false,false,,,,TOO_SHORT
1146441,0xc980279d1de56e01086d786c633ba3bb20829f2b,false,false,,,,TOO_SHORT
1146552,0x5ea5d26d03910c2e2d2b57681b461d9e1862675c,false,false,,,,TOO_SHORT
1146762,0xd5c5c5f4dccbdf6ad94489e09817840ea1c8d6eb,false,false,,,,TOO_SHORT
1147105,0x14da995da994cf8dcab57b9d6eaa0b1f952e66b6,false,false,,,,TOO_SHORT
1147112,0x41bd1a99134dbe7b407c14573e715cf6e836f606,false,false,,,,TOO_SHORT
1147251,0x5e94f302a54a607959071338682832e1835ccb63,false,false,,,,TOO_SHORT
1147258,0x142817776a4c2b95b7850e592947db21e3214fd4,false,false,,,,TOO_SHORT
1147450,0x50637171edd493a6874402f0fc11a5d7c794b702,false,false,,,,TOO_SHORT
1147527,0xffc0480415fc862cd04d15067624a03d36af7e70,false,false,,,,TOO_SHORT
1147542,0x5a570a9dc03f7227b30cc812a0390e4a0a05ec56,false,false,,,,TOO_SHORT
1147585,0x6dd42ce38a7dc9473482a865b4fcdcb726686a86,false,false,,,,TOO_SHORT
1147819,0x2f1fbca2c2925eaa0271e08f757884497eac6d84,false,false,,,,TOO_SHORT
1147855,0x54943c1bb30b2921a40457f1fc1fa627b7bf7f27,false,false,,,,TOO_SHORT
1147956,0xea69d14302cf0c337ac56cd68a46391b7f6682f3,false,false,,,,TOO_SHORT
1148077,0xd5965bae149095fb3e48c654f919f0c0f73f26f7,false,false,,,,TOO_SHORT
1148091,0x65345bb4fff0415b105fa96722f71a56f285d910,false,false,,,,TOO_SHORT
1148142,0xbabb5d43c3133303338de738a2c07d0ce079d788,false,false,,,,TOO_SHORT
1148171,0xe50215c48603a8ffee58a1832a850e6d316e2971,false,false,,,,TOO_SHORT
1148195,0x24045a6c6941aa025601092a74c7550cbb779195,false,false,,,,TOO_SHORT
1148209,0x96cd976f41dbda4f616980729ca68f970e8b64c1,false,false,,,,TOO_SHORT
1148305,0x7b144b44cb60b270359389fb741d52832ec79299,false,false,,,,TOO_SHORT
1148335,0x4195ecbb3d2634c99f4ef8692ea54444c837d28e,false,false,,,,TOO_SHORT
1148337,0x9e29e8397a3213ab23c270f3061cac4fcf68d071,false,false,,,,TOO_SHORT
1148392,0xb168734833a374a73aaf46a5a344c66d44be6e06,false,false,,,,TOO_SHORT
1148422,0x8b2e1c78f60d4f92dbad9946f66b004a813ac761,false,false,,,,TOO_SHORT
1148503,0x604bdd22082d5e3a90c29a69f49b86b5e302cab7,false,false,,,,TOO_SHORT
1148589,0x1e52023c0e55e515c15006d98df4ef6be17487fa,false,false,,,,TOO_SHORT
1148622,0x78136c5a48cdece9bea5b90d55af9b0f5f36f504,false,false,,,,TOO_SHORT
1148759,0x61064305c8548ff1a55fd68694c9b7e96183d69c,false,false,,,,TOO_SHORT
1148805,0xbf1677520a877251c74bb7b2f0d19568a031395f,false,false,,,,TOO_SHORT
1148829,0x9f556fdc32f0e18c8b31623103d569552995404e,false,false,,,,TOO_SHORT
1148835,0x394f3a7eaabe22c121bc63b33c2b924aa7afb8d0,false,false,,,,TOO_SHORT
1148846,0x6c43d319697975f49b161e09347dde126f303aaf,false,false,,,,TOO_SHORT
1148888,0x491bbd3dadb1f9158e682fab273501a7fe575b1c,false,false,,,,TOO_SHORT
1148896,0xdc504ec913c69fb578b7c86146f6359241559ea5,false,false,,,,TOO_SHORT
1148924,0x685446cfff9a2eee12cdb898f2bc3a0e0796f588,false,false,,,,TOO_SHORT
1149080,0xeb95dd2d4effa7374fdeb2eb09f18de2afc092f9,false,false,,,,TOO_SHORT
1149146,0xba5a15b3207d4257a61f019ecdf2d5748578fa22,false,false,,,,TOO_SHORT
1149185,0xf83f2f64f90dc83ebe4065bff681421aeb2fa7b6,false,false,,,,TOO_SHORT
1149299,0xff3155c825fe0bf7acd60e5513b1cceb07c5b647,false,false,,,,TOO_SHORT
1149351,0x9a0d599228c91aa5cf423b53b14a21bd3c04d037,false,false,,,,TOO_SHORT
1149535,0x81c48f0475500a9853f89f6c783c2483318a3080,false,false,,,,TOO_SHORT
1149594,0x31a45c5194b4ff8847a65d795ccdac38cc950e1b,false,false,,,,TOO_SHORT
1149643,0xcb1a957dc9ff505a516602319ce23b141e281dea,false,false,,,,TOO_SHORT
1149710,0x2d516b1fbe09d511be3d5af56a62f3fbfba52577,false,false,,,,TOO_SHORT
1149759,0xc478bd055c8de52d3644dec7ab607c13f5d233c7,false,false,,,,TOO_SHORT
1149809,0x5a2fa169bce29f789fab2a25d37f37dfc32b7c53,false,false,,,,TOO_SHORT
1149855,0x5d5995726f4b7104b16d355356ff2aa7eabea78d,false,false,,,,TOO_SHORT
1149862,0x39f1fcd9577f96545e20d12f0fd5bec93c0b3939,false,false,,,,TOO_SHORT
1149868,0x24ec083b6a022099003e3d035fed48b9a58296e5,false,false,"contract Tomeka {\n\n    //Declare variables for storage critical to contract\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address private creator;\n    \n    //Sets creator\n    function Tomeka() {\n        creator = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == creator) _ }\n    \n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n\n    Participant[] private participants;\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    //init function run on fallback\n    function init() private{\n        //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n        if (msg.value < 1 ether) {\n            collectedFees += msg.value;\n            return;\n        }\n        \n        uint _fee = feePercent;\n        //50% fee rebate on any ether value of 50 or greater\n        if (msg.value >= 50 ether) _fee /= 2;\n        \n        addPayout(_fee);\n    }\n    \n    //Function called for valid tx to the contract \n    function addPayout(uint _fee) private {\n        //Adds new address to participant array\n        participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n        \n        //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n        if (participants.length == 10)  pyramidMultiplier = 200;\n        else if (participants.length == 25)  pyramidMultiplier = 150;\n        \n        // collect fees and update contract balance\n        balance += (msg.value * (100 - _fee))/100;\n        collectedFees += (msg.value * _fee)/100;\n        \n	//Pays earlier participiants if balance sufficient\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.send(payoutToSend);\n\n            balance -= participants[payoutOrder].payout;\n            payoutOrder += 1;\n        }\n    }\n\n    //Fee functions for creator\n    function collectAllFees() onlyowner {\n        if (collectedFees == 0) throw;\n\n        creator.send(collectedFees);\n        collectedFees = 0;\n    }\n    \n    function collectFeesInEther(uint _amt) onlyowner {\n        _amt *= 1 ether;\n        if (_amt > collectedFees) collectAllFees();\n        \n        if (collectedFees == 0) throw;\n\n        creator.send(_amt);\n        collectedFees -= _amt;\n    }\n    \n    function collectPercentOfFees(uint _pcent) onlyowner {\n        if (collectedFees == 0 || _pcent > 100) throw;\n        \n        uint feesToCollect = collectedFees / 100 * _pcent;\n        creator.send(feesToCollect);\n        collectedFees -= feesToCollect;\n    }\n\n    //Functions for changing variables related to the contract\n    function changeOwner(address _owner) onlyowner {\n        creator = _owner;\n    }\n    \n    function changeMultiplier(uint _mult) onlyowner {\n        if (_mult > 300 || _mult < 120) throw;\n        \n        pyramidMultiplier = _mult;\n    }\n    \n    function changeFeePercentage(uint _fee) onlyowner {\n        if (_fee > 10) throw;\n        \n        feePercent = _fee;\n    }\n    \n    //Functions to provide information to end-user using JSON interface or other interfaces\n    function currentMultiplier() constant returns (uint multiplier, string info) {\n        multiplier = pyramidMultiplier;\n        info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n    }\n    \n    function currentFeePercentage() constant returns (uint fee, string info) {\n        fee = feePercent;\n        info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n    }\n    \n    function currentPyramidBalanceApproximately() constant returns (uint pyramidBalance, string info) {\n        pyramidBalance = balance / 1 ether;\n        info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n    }\n    \n    function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns (uint balancePayout) {\n            balancePayout = participants[payoutOrder].payout / 1 ether;\n    }\n    \n    function feesSeperateFromBalanceApproximately() constant returns (uint fees) {\n        fees = collectedFees / 1 ether;\n    }\n    \n    function totalParticipants() constant returns (uint count) {\n        count = participants.length;\n    }\n    \n    function numberOfParticipantsWaitingForPayout() constant returns (uint count) {\n        count = participants.length - payoutOrder;\n    }\n    \n    function participantDetails(uint orderInPyramid) constant returns (address Address, uint Payout)\n    {\n        if (orderInPyramid <= participants.length) {\n            Address = participants[orderInPyramid].etherAddress;\n            Payout = participants[orderInPyramid].payout / 1 ether;\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1149886,0x439949ffdd7108ad7f1e0c5d35070ed57d13cddf,false,false,,,,TOO_SHORT
1149938,0x0d7248bd2cd945307c895625c57ec4a8a7990c70,false,false,,,,TOO_SHORT
1149979,0x35bd93a989d272c9b27df3587c65e4c63899251b,false,false,,,,TOO_SHORT
1149980,0x7573d5b9ab7a8a108eb0d1fa178edf5912ad72cb,false,false,,,,TOO_SHORT
1150061,0x13e6a6aeabb2a9981f56da965b50a10a0854f0c9,false,false,,,,TOO_SHORT
1150062,0x2b1722b3f1797376ee59db7dafc4c34d2149466d,false,false,,,,TOO_SHORT
1150080,0x17ab52bea0c64cd3086d4b32500c45c7a751d539,false,false,,,,TOO_SHORT
1150137,0x3fa148af8c1dc2ae4f7c5d94f08b6d638a80da04,false,false,,,,TOO_SHORT
1150149,0xa51b9902ffe88b3d0905fe264b7c48a5a1dfbb31,false,false,,,,TOO_SHORT
1150168,0xa711b8d3520a49ceb5ba159ef43e9cc927140b34,false,false,,,,TOO_SHORT
1150181,0xc9c31bcc90775b2e9a2a37ef06d568b3bc25d712,false,false,,,,TOO_SHORT
1150191,0x071ef6b397afd9a5858169f6c2625d3039f798ca,false,false,,,,TOO_SHORT
1150205,0xc88f3bbbcedb3488f540960ee6622c62e96a880c,false,false,,,,TOO_SHORT
1150262,0x794a614b3be336a51f03b9a6ce6e415c055f4605,false,false,,,,TOO_SHORT
1150285,0xcad45a64075d770337c646ff8191c7a988798ab0,false,false,,,,TOO_SHORT
1150327,0x36de3bdf0bdf05032cb5834ac6b6dae3f4bcca56,false,false,,,,TOO_SHORT
1150360,0x30831216a731f89d3e9efc21f3fb43f89437b8ae,false,false,,,,TOO_SHORT
1150481,0xe82719202e5965cf5d9b6673b7503a3b92de20be,false,false,"contract Rubixi {\n\n        //Declare variables for storage critical to contract\n        uint private balance = 0;\n        uint private collectedFees = 0;\n        uint private feePercent = 10;\n        uint private pyramidMultiplier = 300;\n        uint private payoutOrder = 0;\n\n        address private creator;\n\n        //Sets creator\n        function DynamicPyramid() {\n                creator = msg.sender;\n        }\n\n        modifier onlyowner {\n                if (msg.sender == creator) _\n        }\n\n        struct Participant {\n                address etherAddress;\n                uint payout;\n        }\n\n        Participant[] private participants;\n\n        //Fallback function\n        function() {\n                init();\n        }\n\n        //init function run on fallback\n        function init() private {\n                //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                if (msg.value < 1 ether) {\n                        collectedFees += msg.value;\n                        return;\n                }\n\n                uint _fee = feePercent;\n                //50% fee rebate on any ether value of 50 or greater\n                if (msg.value >= 50 ether) _fee /= 2;\n\n                addPayout(_fee);\n        }\n\n        //Function called for valid tx to the contract \n        function addPayout(uint _fee) private {\n                //Adds new address to participant array\n                participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                if (participants.length == 10) pyramidMultiplier = 200;\n                else if (participants.length == 25) pyramidMultiplier = 150;\n\n                // collect fees and update contract balance\n                balance += (msg.value * (100 - _fee)) / 100;\n                collectedFees += (msg.value * _fee) / 100;\n\n                //Pays earlier participiants if balance sufficient\n                while (balance > participants[payoutOrder].payout) {\n                        uint payoutToSend = participants[payoutOrder].payout;\n                        participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                        balance -= participants[payoutOrder].payout;\n                        payoutOrder += 1;\n                }\n        }\n\n        //Fee functions for creator\n        function collectAllFees() onlyowner {\n                if (collectedFees == 0) throw;\n\n                creator.send(collectedFees);\n                collectedFees = 0;\n        }\n\n        function collectFeesInEther(uint _amt) onlyowner {\n                _amt *= 1 ether;\n                if (_amt > collectedFees) collectAllFees();\n\n                if (collectedFees == 0) throw;\n\n                creator.send(_amt);\n                collectedFees -= _amt;\n        }\n\n        function collectPercentOfFees(uint _pcent) onlyowner {\n                if (collectedFees == 0 || _pcent > 100) throw;\n\n                uint feesToCollect = collectedFees / 100 * _pcent;\n                creator.send(feesToCollect);\n                collectedFees -= feesToCollect;\n        }\n\n        //Functions for changing variables related to the contract\n        function changeOwner(address _owner) onlyowner {\n                creator = _owner;\n        }\n\n        function changeMultiplier(uint _mult) onlyowner {\n                if (_mult > 300 || _mult < 120) throw;\n\n                pyramidMultiplier = _mult;\n        }\n\n        function changeFeePercentage(uint _fee) onlyowner {\n                if (_fee > 10) throw;\n\n                feePercent = _fee;\n        }\n\n        //Functions to provide information to end-user using JSON interface or other interfaces\n        function currentMultiplier() constant returns(uint multiplier, string info) {\n                multiplier = pyramidMultiplier;\n                info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n        }\n\n        function currentFeePercentage() constant returns(uint fee, string info) {\n                fee = feePercent;\n                info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n        }\n\n        function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\n                pyramidBalance = balance / 1 ether;\n                info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n        }\n\n        function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\n                balancePayout = participants[payoutOrder].payout / 1 ether;\n        }\n\n        function feesSeperateFromBalanceApproximately() constant returns(uint fees) {\n                fees = collectedFees / 1 ether;\n        }\n\n        function totalParticipants() constant returns(uint count) {\n                count = participants.length;\n        }\n\n        function numberOfParticipantsWaitingForPayout() constant returns(uint count) {\n                count = participants.length - payoutOrder;\n        }\n\n        function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\n                if (orderInPyramid <= participants.length) {\n                        Address = participants[orderInPyramid].etherAddress;\n                        Payout = participants[orderInPyramid].payout / 1 ether;\n                }\n        }\n}",1,実用的なピラミッドスキームのスマートコントラクトで、芸術的要素は特に見られません。,
1150611,0x83ca6a19a4360589b85d24648f16822a315d9e60,false,false,,,,TOO_SHORT
1150703,0x6bf90d201470f6400c93c79288a0dfc97f37cdcf,false,false,,,,TOO_SHORT
1150704,0x8b0854b61d4aee68bc008ed9b85bf3dd09505b8a,false,false,,,,TOO_SHORT
1150846,0x18f5a34701d3c4c49c1f948d35f25f72a493781e,false,false,,,,TOO_SHORT
1150888,0xf539480a6660e041b00cf17b70ab3cededaca906,false,false,,,,TOO_SHORT
1150889,0xadacaaa0c7ba527dd68277ec10c827124e321c0f,false,false,,,,TOO_SHORT
1150999,0x344f44d84d29889b6838e6dcb8f0c1b2bbea6026,false,false,,,,TOO_SHORT
1151382,0xe8d918991f6c8bc170a4638151cf57e2e8f18dc1,false,false,,,,TOO_SHORT
1151485,0x3a410333b71b3c4677f50f14757f575f568a9643,false,false,,,,TOO_SHORT
1151740,0x2b6aa2ea4c052f7c4cefb70422bd075df551f956,false,false,,,,TOO_SHORT
1151829,0xdd7febe3116553b166ac8e9831c7784f35fa29f0,false,false,,,,TOO_SHORT
1151831,0x6c2f6bcef5d6a7a9961421ed51e314ed1dac1bd0,false,false,,,,TOO_SHORT
1151915,0x71ad2df9c45d67d9c3e834baffd0431b0c9564af,false,false,,,,TOO_SHORT
1151937,0x19026c7e4685b6d22a57029763695573980b3a71,false,false,,,,TOO_SHORT
1151995,0xa912201bd862b568756cc57bfe30cbcb8390e686,false,false,,,,TOO_SHORT
1152238,0xea2c9ae7ab039c290615b10ed9f9b6662b332c39,false,false,,,,TOO_SHORT
1152310,0x3d4c180b490f5b03a942bec9043679b15c65f45f,false,false,,,,TOO_SHORT
1152311,0x096346da633cf55e44c71fcda0ff877624cd609a,false,false,,,,TOO_SHORT
1152539,0xd379b998dc75ceaaccdf54353ef7a8f2f4747fcf,false,false,,,,TOO_SHORT
1152646,0xd84a01008d1de318fb1b434e440fe5368f0afff9,false,false,,,,TOO_SHORT
1152686,0xbf27b9dae116972245ae000bf158406ecfe2e1f8,false,false,,,,TOO_SHORT
1152930,0x9ab0b08efc4dd74e31433141beffc4345f43de61,false,false,,,,TOO_SHORT
1152997,0xc727c1ae0ed3a7b8be9ba4147f5e65344c2174fd,false,false,,,,TOO_SHORT
1153110,0x80d90d80d85248e0cb97812fe7e276a7c98f4d0b,false,false,,,,TOO_SHORT
1153123,0xd3109721c92277e07de0ff916abd2e5ed7221faf,false,false,,,,TOO_SHORT
1153140,0xabb014103aceae654d9ad2201089605c37a68a3a,false,false,,,,TOO_SHORT
1153201,0x9d9dafb38fd33bf5ccc3e5838e7c3b573ab406b4,false,false,,,,TOO_SHORT
1153250,0x1067c8c09f4fa1cdbc5e46095f99d06fae66613b,false,false,,,,TOO_SHORT
1153288,0x0a5dbab7357f935200d9e71b067060042ede417d,false,false,,,,TOO_SHORT
1153311,0x5a2d2d4609fedaa571a14ec92d506b61f09d6cf0,false,false,,,,TOO_SHORT
1153351,0x7760ca12a0a3763c91b0cc490542536b256a37b3,false,false,,,,TOO_SHORT
1153437,0x85390b71d201cf0569f355a81f7e697d1fa6d74d,false,false,,,,TOO_SHORT
1153619,0xeda69db41594d3e94a51d4e075ef613ef860d1d6,false,false,,,,TOO_SHORT
1153678,0x570459236f5e698ff2ea8d83638701e066dda128,false,false,,,,TOO_SHORT
1153695,0x0329d1f45863b1af728634aae429e50ee9ebe717,false,false,,,,TOO_SHORT
1153718,0xddcedfa92be3ec7c364ff1306f2cecdecdece113,false,false,,,,TOO_SHORT
1153749,0x2c118f3016c44236c36b1a7f049ddb0d8de76a28,false,false,,,,TOO_SHORT
1153892,0xeb6bcda8e0444aa4e91f59611079ea69dd000790,false,false,,,,TOO_SHORT
1153972,0x5fd1ea8bba2b7746143771cfebe2a02091b76276,false,false,,,,TOO_SHORT
1153979,0xa8b759cc05e07924b07bb3d8c65d1d33f47a98a2,false,false,,,,TOO_SHORT
1154059,0x288eea07b84cf82d525d792162d3a1a3835949d5,false,false,,,,TOO_SHORT
1154153,0xc486fb6bdcb02e16567266c3b62472845e8db154,false,false,,,,TOO_SHORT
1154184,0x550559527083cb991d70bb9193f01ead0233dfa3,false,false,,,,TOO_SHORT
1154253,0x62d366e83a3895ee59322d40e357102e880b9279,false,false,,,,TOO_SHORT
1154703,0xb193f679d80cd027a64213be764e993dff6cd2bf,false,false,,,,TOO_SHORT
1154746,0xa3afe790dc67e2b712a8750f50fb91c89dd8b1ec,false,false,,,,TOO_SHORT
1154794,0x09d8f059b83e663b1c7e8b03406c2620a5620d6a,false,false,,,,TOO_SHORT
1154869,0xd1ee39e42214ea2e1ef8157a9f8cae1754a24070,false,false,,,,TOO_SHORT
1154878,0xd8d0c4d3df0a464b58640614d83962ac90f1da04,false,false,,,,TOO_SHORT
1155074,0xbfa052c066087f0a0b797132d34d432bf4f18457,false,false,,,,TOO_SHORT
1155094,0x63c09571524869bf745019235bae58544b87ec21,false,false,,,,TOO_SHORT
1155102,0x025fb587fdefe8ed3819f2813b2e7c9b30471d38,false,false,,,,TOO_SHORT
1155152,0x3f92d8bce778bb435a0416b8c645a345596af424,false,false,,,,TOO_SHORT
1155160,0xc4aa79a656a6da1d78c8e613ddc18397670fdd60,false,false,,,,TOO_SHORT
1155256,0xc8f69db8fdaa87ff8df88bc899e7d04c7f21059e,false,false,,,,TOO_SHORT
1155518,0x90f94f8f0de0424e547b40db69791ce49734fab8,false,false,,,,TOO_SHORT
1155608,0x56fd53ef1dff3001b276f352a78ffd191f135e81,false,false,,,,TOO_SHORT
1155961,0x2e20ae4beea238c153553ef9c6a20db950201c93,false,false,,,,TOO_SHORT
1155968,0x8e9bfed7b302171c5ae6a0f6a83c365576d86dbc,false,false,,,,TOO_SHORT
1156004,0xe8959fcf9c0bb5603a40d14c3ae246ce86df1023,false,false,,,,TOO_SHORT
1156009,0xbe584700b700ecc740b85bd23d918e676dab366e,false,false,,,,TOO_SHORT
1156181,0x224e5b8e73fda56e795caf430ef832fe72d4d0aa,false,false,,,,TOO_SHORT
1156240,0x111a5860823ffe42272c87c8e16aafd54c28ea8a,false,false,,,,TOO_SHORT
1156304,0x3fe9bcdcbbae7e6fadea34ae2600ede28eb32943,false,false,,,,TOO_SHORT
1156315,0xc4866a1470d9e759272cab4e61a9ae78876e1d1f,false,false,,,,TOO_SHORT
1156374,0x6d7908530b6a2eca862f9d07b67fece93fece7d3,false,false,,,,TOO_SHORT
1156401,0x7910679e620a9b4461554d4bc4bcf517838f21db,false,false,,,,TOO_SHORT
1156410,0x0eb4d5a8d0ececf436ac212120c35027dea41eff,false,false,,,,TOO_SHORT
1156504,0x4822f9cac76e5a43e34b66d6ce2c1f2caed6d21c,false,false,,,,TOO_SHORT
1156558,0xaa8cb0edbeab90f5b3d246f56e4fa9dfc9b2826d,false,false,,,,TOO_SHORT
1156559,0x7d4edb5b152d47d0b5c4e5bee3953e0719cd56d3,false,false,,,,TOO_SHORT
1156565,0x480d7b92bc702bfb57e233f7a37addc9a363b561,false,false,,,,TOO_SHORT
1156633,0x5a6e34223c254a335df9f52a8fb9a12e40396cea,false,false,,,,TOO_SHORT
1156646,0x06bea399e8c58dbaf5e05231338539a21ee4b806,false,false,,,,TOO_SHORT
1156659,0xc09309059159ac80ce5d1a45889fcc936733299a,false,false,,,,TOO_SHORT
1156805,0xaebc7b8513a048803c5a34184b23608c77e7e030,false,false,,,,TOO_SHORT
1156820,0x348a261137b5f8045d8f69cd2471344591e26679,false,false,,,,TOO_SHORT
1156892,0x49341044a33fac96260b4694a534514d2a9b9940,false,false,,,,TOO_SHORT
1156893,0x76fe1db936fce717203d26ea64523201bc898338,false,false,,,,TOO_SHORT
1156896,0xf65395f0d756c4ab0e2b78f5f228df5ae860b309,false,false,,,,TOO_SHORT
1156923,0xe5065086d0fe26eedfb098411c9317e74943f0c5,false,false,,,,TOO_SHORT
1156964,0x20befa4765f9863003b041551e8dc5ee36c560fd,false,false,,,,TOO_SHORT
1157067,0x4b0d531cac2e1ad3596f09549a54af024e5ae3fd,false,false,,,,TOO_SHORT
1157172,0xa7b496e4bbd41fa15a108deda30057a275c4bf72,false,false,,,,TOO_SHORT
1157441,0x35e429e927e6a36bd05217b53ae793e79bea5f41,false,false,,,,TOO_SHORT
1157657,0x239c72c06c8a4beb525428a10ac00bda5a90217f,false,false,,,,TOO_SHORT
1157725,0xc04a1b1b4127a4934120f1927d969d75e4a1549d,false,false,,,,TOO_SHORT
1157755,0xeb2ab9344e9ea74db957ece003e9c979fdb7636a,false,false,,,,TOO_SHORT
1157760,0xbfae7c9f6444fc8a1f457f8201111247860e1b2e,false,false,,,,TOO_SHORT
1157933,0xf9b2a04cc3e0c005321065eb0d2c2fed7c77b5a5,false,false,,,,TOO_SHORT
1157975,0xb9f0dca021b370fe0511bfc917099ee9df8fd2b6,false,false,,,,TOO_SHORT
1158078,0x6eb6c31b4506a5a1f3d4587c363d3f09da64d583,false,false,,,,TOO_SHORT
1158482,0x9c7b7973cb484ca76b7eac3ca07c6d046c42ebc3,false,false,,,,TOO_SHORT
1158507,0x863ba5a3d5d320b0e3195531f311b9f18437fe42,false,false,,,,TOO_SHORT
1158748,0xe41654d9efa4ca74fef281f8fa86c7afcca8fe55,false,false,,,,TOO_SHORT
1158851,0x4e4edc5bf6e63f42e925fb30d6dd39031c4a8d6d,false,false,,,,TOO_SHORT
1158999,0x2f359c461dafa0711cc0d88f895d65dce752c71d,false,false,,,,TOO_SHORT
1159025,0x8603d88df4086bbec451aecd80f9f5ea8eb78ffb,false,false,,,,TOO_SHORT
1159102,0x877e23ce0cdb563ae2a2c839f32dc6fc40699969,false,false,,,,TOO_SHORT
1159220,0x7f9fe874fc7d998a79276532489076cb2854f267,false,false,,,,TOO_SHORT
1159271,0x84ea3f0e73d855dd3fe68b8e9b15655cd226e534,false,false,,,,TOO_SHORT
1159286,0xa7e13bf756d6a384da226c6a33592cde46dd6cbf,false,false,,,,TOO_SHORT
1159383,0xb655cb6e873f6d6b42def8f2baac74efdfd2a468,false,false,,,,TOO_SHORT
1159535,0x37027dd8bccd6afca42f712f597b4f49f38e297d,false,false,,,,TOO_SHORT
1159571,0x8d3fb842624c3ca5273966c00876be8a19e8afb8,false,false,,,,TOO_SHORT
1159581,0x85fb356f099cca46b45c30ae8628da624f82a19c,false,false,,,,TOO_SHORT
1159630,0xd737f9fb6564c62bed3eb49d92b9d6a637dd8817,false,false,,,,TOO_SHORT
1159808,0xab4a6855a1961b1169b8b66c8e3fa4a87633c015,false,false,,,,TOO_SHORT
1159841,0x91887666b397227085380b44705dedc4e3500d73,false,false,,,,TOO_SHORT
1159891,0xe81e6a0ce0137432e9a5453ab831697d10b6a931,false,false,,,,TOO_SHORT
1160056,0xc686a1bce76a44f5bea4fa826f95b38ad7f0d778,false,false,,,,TOO_SHORT
1160158,0x4122ba9e778823582684e08c770e15097c3b5212,false,false,,,,TOO_SHORT
1160205,0x82f9c057b310a6033903625312bacaa80ac0803a,false,false,,,,TOO_SHORT
1160284,0x908ab3b6f96bf59b59e40d6affaa42954ba04b19,false,false,,,,TOO_SHORT
1160348,0x41cabf61556adea5619032a33a7258974d4c0da5,false,false,,,,TOO_SHORT
1160355,0x98d2aabd1cfa4ceba6733eeead58bda054185c11,false,false,,,,TOO_SHORT
1160432,0x3551215d5605a56848cfed6853a3c9a69d1eec83,false,false,,,,TOO_SHORT
1160491,0x34d155c3579bd321926bfb1212f1c62cb13cb940,false,false,,,,TOO_SHORT
1160634,0xf7a437219fa8b64963ecf03ec36e79880ead4fb9,false,false,,,,TOO_SHORT
1160660,0xd649ffe60ed2219fdd7446063f119712ff58ed42,false,false,,,,TOO_SHORT
1160717,0x81780ceac84de9877c5b40b718bb46438ffafa92,false,false,,,,TOO_SHORT
1160724,0xe8126286e988516c803b82c9c08bdc4615ae54c8,false,false,,,,TOO_SHORT
1160786,0x3f0a19eaaa5da6c8c655317dde30c528a2bdc574,false,false,,,,TOO_SHORT
1160793,0xdc78fbb48eec7090ebd5fa2285112c033838dd33,false,false,,,,TOO_SHORT
1160922,0x8f9046fed36848706945ff93dcf1c90b06fe9cda,false,false,,,,TOO_SHORT
1160969,0x379009dcea89c00782542bd0edc5c3d38f398985,false,false,,,,TOO_SHORT
1161003,0x40915a645b8175c9815d2af0a9b8423d9b08354d,false,false,,,,TOO_SHORT
1161006,0x0c3afb65e9e9e6c3d3ccf04fb79d5f174d23d4ef,false,false,,,,TOO_SHORT
1161076,0xeef309fc9305cecbf6b70e6f606c15cce213aeb0,false,false,,,,TOO_SHORT
1161103,0x538ff6e923a74f40aec0d85285a1d47e08acc220,false,false,,,,TOO_SHORT
1161132,0x04eb4a49a1a6c6be295fa806310cbec6cb893b45,false,false,,,,TOO_SHORT
1161187,0x9e21fe9f3aad32399ca2917b31a5ab1f0a876210,false,false,,,,TOO_SHORT
1161292,0x8cc5d7811e29de2946747f9bb007e533d5a0c322,false,false,,,,TOO_SHORT
1161416,0x1038d5ded5b2651a6349d2685b756bcb145dc499,false,false,,,,TOO_SHORT
1161422,0x950bcc3a352f8476e8a83f52bae6e119383cc3cf,false,false,,,,TOO_SHORT
1161634,0x7e30d8893d09248a511b606fda2641d759530c0f,false,false,,,,TOO_SHORT
1161658,0x5daef38879ec19d37728eda724e1aacc08bd6560,false,false,,,,TOO_SHORT
1161688,0x222afa1531e392e945c268f38079321916d7c743,false,false,,,,TOO_SHORT
1161730,0xf393d5d3c7f8287f5992c795cf684995edd26dd9,false,false,,,,TOO_SHORT
1161834,0x04f33b4b825ed79ca3e1604aff5b21216d84e1c3,false,false,,,,TOO_SHORT
1161857,0x5d5ea0d6097206b33047179507280701e5b4f427,false,false,,,,TOO_SHORT
1161907,0x806f92dd78ff22384041d629af1ca58c3512e6c4,false,false,,,,TOO_SHORT
1161947,0xf063a159ed8dec0c2cae2dabb8afc4822fb7968b,false,false,,,,TOO_SHORT
1161965,0x3b59b865bb4ed61968afbf8f00b5b1648a4547c9,false,false,,,,TOO_SHORT
1162642,0x767c7fd9ac2e096f763f7081c22527e374b3c261,false,false,,,,TOO_SHORT
1162654,0x7d38c9d5f806e25422e75412ea9209c2a5a919ec,false,false,,,,TOO_SHORT
1162686,0x00727244c68ad919665ec74073e3d64e4bbca658,false,false,,,,TOO_SHORT
1162784,0x16870e6c0583fd29d7c8a2828cd52deb9d65e581,false,false,,,,TOO_SHORT
1162999,0x0ae3d4802a896fef9f23e07ec9267a672ee3e374,false,false,,,,TOO_SHORT
1163489,0xcf2754e9a7fb4b7659132459accbbb4d3a22b7ab,false,false,,,,TOO_SHORT
1163881,0x6e5e0ef477db8e26cd64f87522a1997f6dda64fb,false,false,,,,TOO_SHORT
1163968,0x1bf113f193cf51b316e00b61080399fca30148be,false,false,,,,TOO_SHORT
1163974,0x18dd810e5e40afd28947de1a6038797b48eb9c06,false,false,,,,TOO_SHORT
1164175,0x0bf73f09e5f6309d838771f1b82b8a13ac45b60d,false,false,,,,TOO_SHORT
1164253,0x4c308d64ded1709e1b8be41794aa75deaa2adb8b,false,false,,,,TOO_SHORT
1164341,0x8c5a6e25304d4121962db0e85cea6d6814b83cc9,false,false,,,,TOO_SHORT
1164425,0x16c97e0ea53c5285761732de0952ca6086f73451,false,false,,,,TOO_SHORT
1165156,0x45c11ceb4b40add05cfbc67203de21d5565d4545,false,false,,,,TOO_SHORT
1165164,0x2fe95804d55e26088cbee72d448001da48e64ec1,false,false,,,,TOO_SHORT
1165503,0xd9872e20ec2e80b75c9138c3975e438e2a030256,false,false,,,,TOO_SHORT
1165743,0xf66471541cdb12acd2513a460295fea439c45e2e,false,false,,,,TOO_SHORT
1165751,0xcd47c77ba731ce63632c93e5ddb72c4042c2437d,false,false,,,,TOO_SHORT
1165942,0x66c6a3d7861d0bee0543b93f78fdf276d5b6cd1e,false,false,,,,TOO_SHORT
1166148,0x3e307a0839e2b94e5e7399109b7c859e0285304d,false,false,,,,TOO_SHORT
1166180,0x112370cf8c0bb4e061804e08f1ae834abc16324c,false,false,,,,TOO_SHORT
1166230,0xc7e472806b3df419449f9b60b051808998f3f323,false,false,,,,TOO_SHORT
1166244,0xb84fad733da5d88df91d074d830f3018e4178802,false,false,,,,TOO_SHORT
1166326,0x1312b8c99b6d1744e2f4dc992244cb477dd07f18,false,false,,,,TOO_SHORT
1166409,0x32e2e0a1b91e03c81d11a88b482a6e378d18fa23,false,false,,,,TOO_SHORT
1166420,0x60ade5fc5587eccf8a5a0ca49be3786e535ff835,false,false,,,,TOO_SHORT
1166874,0x3c9aa0791880ec7f08e1282de5d800caac16a174,false,false,,,,TOO_SHORT
1166963,0xd28c92bf71c5089b8da90535a1a280246f9bf05f,false,false,,,,TOO_SHORT
1166970,0x9451ffaed3b6d6a506fc4ca0184802e4b832843f,false,false,,,,TOO_SHORT
1167244,0xfc704b6eea89a5d9fa57eb6d09e884fa25e7aabf,false,false,,,,TOO_SHORT
1167272,0xb61fa521b2320a52a21758a7adefd7584d2b1722,false,false,,,,TOO_SHORT
1167373,0xa118eaf991d64f58cd412915c120796aa95f0a51,false,false,,,,TOO_SHORT
1167424,0x02cddba2533f7aa25a1da9bf0268ee2d68e01a71,false,false,,,,TOO_SHORT
1167620,0xd9021fc856947fab6af504d439dc7c10ff20b7de,false,false,,,,TOO_SHORT
1167883,0xc632900e89876c3727d5d3cbc5cdc400afe7b3a4,false,false,,,,TOO_SHORT
1167889,0x2052cf04392117aaf260d7266c8347cf2d664f9c,false,false,,,,TOO_SHORT
1168019,0x1075e9d240c6ac90a677e0db31aa965118a4fb6f,false,false,,,,TOO_SHORT
1168179,0x24b0c280bcd835561d094eb437f7f3096d02a07c,false,false,,,,TOO_SHORT
1168217,0xd5b9f68cb44ca6c036c8dbd3220241a345746a64,false,false,,,,TOO_SHORT
1168356,0x954a46a2c76e741420f0074915b4cbd8f155b25f,false,false,,,,TOO_SHORT
1168368,0x3055bac29331f43c77f454b0dee052ad5874071f,false,false,,,,TOO_SHORT
1168406,0x38fa03666eb59a5bfda8eb119fc3769636ca4df8,false,false,,,,TOO_SHORT
1168420,0x5c7f7c76beaa46da0620f8934d84317b2a536e98,false,false,,,,TOO_SHORT
1168600,0x141e4a0b2d8a8d6fa090d122d0a334b574585378,false,false,,,,TOO_SHORT
1168811,0xd5ebd097987adb562449c6eff8dae63ed9bb4b54,false,false,,,,TOO_SHORT
1169009,0xd62dd35451b2474b44e628b30aefc6e5e1fa9dcb,false,false,,,,TOO_SHORT
1169052,0x6453fc7a9f1357bf548db3e7155bbb6d0fea4d13,false,false,,,,TOO_SHORT
1169080,0xf1fcef4544f61c01e95b6bafe21f34af03c2a2bc,false,false,,,,TOO_SHORT
1169231,0x59b674338ce5b8c1f8af5b6b935f64548e5f76aa,false,false,,,,TOO_SHORT
1169447,0x1ceec4087549d50c45d9816501f022d5a5e4845f,false,false,,,,TOO_SHORT
1169486,0x85971b3f9bfdc63aa2abd3b3cca702c2e7bd7e6d,false,false,,,,TOO_SHORT
1169616,0xfbb32e4a09cf71820a49cafc27ada33cca59dcb3,false,false,,,,TOO_SHORT
1169627,0xbab29dcf210706e9b2ed97253567b3d78d1ebc6e,false,false,,,,TOO_SHORT
1170010,0x08ae2870a5d338bcb534b5de8464d2fa57da00aa,false,false,,,,TOO_SHORT
1170108,0xa76000174c56c91838d68db79b92661f8593ecb3,false,false,,,,TOO_SHORT
1170394,0x6f4cd2a17e0e73c073f21a88468a389dc3145dcd,false,false,,,,TOO_SHORT
1170434,0x8b0d83f86672941797e0ae7931d2541e36906eff,false,false,,,,TOO_SHORT
1170465,0x9ebdc1988f39a9aaf03f7a496f0c4bb0566efcba,false,false,,,,TOO_SHORT
1170488,0x1c499b5f61f4ff5d38b6ae8303a1eba04befba40,false,false,,,,TOO_SHORT
1170892,0x41d28c2432fd6b4484121e9e335887223db89710,false,false,,,,TOO_SHORT
1171056,0x0f24b69a41ea2680114c777cf1c7cc62178fbe84,false,false,,,,TOO_SHORT
1171089,0x2491c99454ef753a221c45ee1d3ecb7c915931b4,false,false,,,,TOO_SHORT
1171150,0x702cbe1e371eafb9263dfe3f4aceeca847da9bf0,false,false,,,,TOO_SHORT
1171231,0x3b4dd9505cc53890d3f1df1b258b6664fd0a650d,false,false,,,,TOO_SHORT
1171756,0xd24c55afdc8cd43ae126d7637272f7c09d2f6c7f,false,false,,,,TOO_SHORT
1171889,0xc6effba4845f69a68cab8bb9716a0cb3fc59094c,false,false,,,,TOO_SHORT
1171899,0x64d236e5aa2a032503a8380e890d5ece48b51f76,false,false,,,,TOO_SHORT
1171984,0x226837579dca1cf59c9bb0aabe3e0d86048bf679,false,false,,,,TOO_SHORT
1172000,0x397fe9d5d4685c0ca623538f8b26b5b91282c7e5,false,false,,,,TOO_SHORT
1172024,0xa678887b5529d3893037a6558db0ae2987226cfd,false,false,,,,TOO_SHORT
1172095,0x08b857fd11e341a652334f9a9b16d47d50c4ed5b,false,false,,,,TOO_SHORT
1172100,0xdb0f3b7559b82b673cd7e2321a711c735cc03458,false,false,,,,TOO_SHORT
1172507,0xf5c68e6155ceade73a00d36d7c43741b90f0fdea,false,false,,,,TOO_SHORT
1172708,0x9e7b7e3cc511d6a875caa39eb880cf17fed0bca3,false,false,,,,TOO_SHORT
1172814,0xb36ce92cad11e7a9b903531f30590ebc2e991ea6,false,false,"contract Big{\n    function Big(){\n        Creator=msg.sender;\n    }\n\n    uint8 CategoriesLength=0;\n    mapping(uint8=>Category) Categories;//array representation\n    struct Category{\n        bytes4 Id;\n        uint Sum;//moneys sum for category\n\n        address Owner;\n        uint8 ProjectsFee;\n        uint8 OwnerFee;\n\n        uint24 VotesCount;\n        mapping(address=>uint24) Ranks;//small contract addr->rank\n        mapping(uint24=>Vote) Votes;//array representation\n    }\n    struct Vote{\n        address From;\n        address To;\n		uint8 TransactionId;\n    }\n    uint24 SmallContractsLength=0; \n    mapping(uint24=>address) SmallContracts;//array of small contracts\n    \n    address private Creator;//addres of god\n    uint16 constant defaultRank=1000;\n    uint8 constant koef=2/1;\n	uint constant ThanksCost = 10 finney;\n\n    function GetCategoryNumber(bytes4 categoryId) returns(uint8) {\n        for (uint8 i=0;i<CategoriesLength;i++){\n            if(Categories[i].Id==categoryId)\n                return i;\n        }\n        return 255;\n    }\n    function GetCategoryValue(uint8 categoryNumber) returns (uint){ \n        return Categories[categoryNumber].Sum;\n    }\n	function CheckUserVote(uint8 categoryNumber,uint8 transactionId) returns (bool){\n		for (uint24 i = Categories[categoryNumber].VotesCount-1;i >0;i--){\n            if(Categories[categoryNumber].Votes[i].TransactionId==transactionId) \n                return true;     \n        }\n		if(Categories[categoryNumber].Votes[0].TransactionId==transactionId){\n                return true;  \n        }\n		return false;\n	}\n    function GetUserRank(uint8 categoryNumber,address user) returns (uint24){ \n        return Categories[categoryNumber].Ranks[user];\n    }\n    function GetSmallCotractIndex(address small) returns (uint24){\n        for (uint24 i=0;i<SmallContractsLength;i++){\n            if(SmallContracts[i]==small)\n                return i;\n        }\n        return 16777215;\n    }\n    \n    function AddNewSmallContract(address small){\n        if(msg.sender == Creator && GetSmallCotractIndex(small)==16777215){\n                SmallContracts[SmallContractsLength]=small;\n                SmallContractsLength++;\n        }\n    }\n    function AddNewCategory(bytes4 categoryId,uint8 projectsFee,uint8 ownerFee, address owner){\n        if(msg.sender == Creator && GetCategoryNumber(categoryId)==255){\n            Categories[CategoriesLength].Id= categoryId;\n            Categories[CategoriesLength].ProjectsFee= projectsFee;\n            Categories[CategoriesLength].OwnerFee= ownerFee;\n            Categories[CategoriesLength].Owner= owner;\n            Categories[CategoriesLength].Sum = 0;\n            CategoriesLength++;\n        }\n    }\n\n    \n	struct Calculation{\n		uint16 totalVotes;\n		uint24 rank;\n	}\n    function CalcAll(){\n        if(msg.sender==Creator){//only god can call this method\n            uint24 i;//iterator variable\n			\n            for(uint8 prC=0; prC<CategoriesLength; prC++){\n                Category category = Categories[prC];\n                \n                uint16 smallsCount = 0;//count of small contracts that got some rank\n                mapping(address=>Calculation) temporary;//who->votesCount  (tootal voes from address)\n                //calc users total votes          \n				\n				for (i = 0;i < category.VotesCount;i++){\n                    temporary[category.Votes[i].From].totalVotes = 0; \n                }	\n				\n                for (i = 0;i < category.VotesCount;i++){\n					if(temporary[category.Votes[i].From].totalVotes == 0) {\n						temporary[category.Votes[i].From].rank = category.Ranks[category.Votes[i].From];\n					}\n                    temporary[category.Votes[i].From].totalVotes++; \n					\n                }			\n				\n                // calculate new additional ranks\n                for (i = 0;i < category.VotesCount;i++){ //iterate for each vote in category\n                    Vote vote=category.Votes[i];\n                    category.Ranks[vote.To] += temporary[vote.From].rank / (temporary[vote.From].totalVotes * koef);//add this vote weight\n								// weight of vote measures in the (voters rank/( count of voters total thanks * 2)\n                }                          \n            }\n        }\n    }\n    \n    function NormalizeMoney(){\n        if(msg.sender==Creator){\n            uint sumDifference=this.balance;\n            uint transactionCost = 5 finney;\n			uint8 luckyCategoryIndex = 255;\n			\n        	for (uint8 prC = 0;prC < CategoriesLength;prC++) {\n        	    sumDifference -= Categories[prC].Sum;\n        	    \n        	    uint ownerFee = (Categories[prC].Sum * Categories[prC].OwnerFee) / 100;\n        	    if (ownerFee >0) Categories[prC].Owner.send(ownerFee);\n        	    Categories[prC].Sum -= ownerFee;\n        	    \n            	if (luckyCategoryIndex == 255 && Categories[prC].Sum > transactionCost){\n            	    luckyCategoryIndex = prC;\n            	}\n        	}\n        	\n        	if (sumDifference > transactionCost){\n        	    Creator.send(sumDifference - transactionCost);\n        	}\n        	else{\n        	    if (luckyCategoryIndex != 255){\n        	        Categories[luckyCategoryIndex].Sum -= (transactionCost - sumDifference);\n        	    }\n        	}\n        }\n    }\n    \n	function NormalizeRanks(){\n		if(msg.sender==Creator){\n			uint32 accuracyKoef = 100000; //magic number 100000 is for accuracy\n		\n			uint24 i=0;\n			for(uint8 prC=0; prC<CategoriesLength; prC++){\n                Category category = Categories[prC];\n				uint additionalRanksSum = 0; //sum of all computed additional ranks (rank - default rank) in category\n				uint16 activeSmallContractsInCategoryCount = 0;\n\n				for(i = 0;i<SmallContractsLength;i++){\n					if (category.Ranks[SmallContracts[i]] != 0){\n						additionalRanksSum += category.Ranks[SmallContracts[i]] - defaultRank;\n						activeSmallContractsInCategoryCount++;\n					}			\n				}\n\n				if (additionalRanksSum > activeSmallContractsInCategoryCount * defaultRank)//normalize ranks if addition of ranks is more than all users can have\n                {\n					uint24 normKoef = uint24(additionalRanksSum / activeSmallContractsInCategoryCount);\n					for (i = 0;i < SmallContractsLength;i++){\n						if (category.Ranks[SmallContracts[i]] > defaultRank){\n							category.Ranks[SmallContracts[i]] = defaultRank + uint24(((uint)(category.Ranks[SmallContracts[i]] - defaultRank) * defaultRank)/ normKoef);\n						}\n					}\n					additionalRanksSum = activeSmallContractsInCategoryCount * defaultRank;\n                }\n				if (category.Sum > 0)\n				{\n					for (i = 0;i < SmallContractsLength;i++)\n					{\n						if (category.Ranks[SmallContracts[i]] > defaultRank)\n						{\n							//just split sum in deendence of what rank users have							\n							smallContractsIncoming[i] += accuracyKoef*(category.Sum / (accuracyKoef*additionalRanksSum / (category.Ranks[SmallContracts[i]] - defaultRank)));\n						}\n					}\n				}\n			}	\n		}\n	}\n    mapping(uint24=> uint) smallContractsIncoming;//stores ether count per small contract\n    function SendAllMoney(){\n        if(msg.sender==Creator) { \n            for (uint24 i = 0;i < SmallContractsLength;i++){\n                if(smallContractsIncoming[i] > 0 ){//if more than 0.005 ether\n                    SmallContracts[i].send(smallContractsIncoming[i]);//send ether to wallet\n                    smallContractsIncoming[i]=0;\n                }\n            }\n        }\n    }\n    function Reset(){\n        if(msg.sender==Creator) { \n            for(uint8 prC=0; prC<CategoriesLength; prC++){//in each contract\n              Categories[prC].VotesCount=0; //reset votes\n              Categories[prC].Sum=0; //reset ether sum \n            }\n        }\n    }\n\n    function GetMoney(uint weiAmount,address to){\n        if(msg.sender==Creator) { \n            to.send(weiAmount);\n        }\n    }\n    function SetRank(uint8 categoryNumber,address small,uint16 rank){\n        if(msg.sender == Creator){\n            Category category=Categories[categoryNumber];\n            category.Ranks[small]=rank;\n        }\n    }\n	\n	function SetNewBigContract(address newBigContractAddress){\n		if(msg.sender == Creator){\n			for(uint24 i = 0;i<SmallContractsLength;i++){\n				Small s= Small(SmallContracts[i]);	\n				s.SetBigContract(newBigContractAddress);\n			}\n		}\n	}\n    \n	function ThanksInternal (address from,address to, uint8 categoryNumber,uint8 transactionId) private {\n        if(categoryNumber==255||GetSmallCotractIndex(from)==16777215||GetSmallCotractIndex(to)==16777215) return;\n        \n        Category category=Categories[categoryNumber];\n		\n		Small s= Small(from);\n        s.GetMoney(ThanksCost,this);	\n        category.Sum+=ThanksCost;\n        \n        if(category.Ranks[from]==0){\n            category.Ranks[from]=defaultRank;\n        }      \n        if(category.Ranks[to]==0){\n            category.Ranks[to]=defaultRank;\n        }\n\n		category.Votes[category.VotesCount].From=from;\n        category.Votes[category.VotesCount].To=to;\n		category.Votes[category.VotesCount].TransactionId=transactionId;\n        category.VotesCount++;\n    }	\n	function Thanks (address from,address to,uint8 categoryNumber,uint8 transactionId){\n		if(msg.sender != Creator) return;	\n		ThanksInternal(from,to,categoryNumber,transactionId);\n	}\n	\n    function UniversalFunction(uint8 functionNumber,bytes32 p1,bytes32 p2,bytes32 p3,bytes32 p4,bytes32 p5){\n        if(GetSmallCotractIndex(msg.sender)==16777215) return;\n        \n        if(functionNumber == 1){\n            ThanksInternal(msg.sender,address(p1),uint8(p2),0);\n        }\n        if(functionNumber == 2){\n            Small s= Small(msg.sender);\n            s.GetMoney(uint(p1),address(p2));\n        }\n    }\n}\n\n\ncontract Small {\n    Big b;\n  \n    address private owner;\n\n    function Small(address bigAddress){\n        b=Big(bigAddress);\n        owner = msg.sender;\n    }\n    function GetOwner() returns (address){\n        return owner;\n    }\n    function SetOwner(address newOwner){\n        if(msg.sender == owner) {\n            owner = newOwner;\n        }\n    }\n\n    function SetBigContract(address newAddress){\n        if(msg.sender==address(b)) { \n            b=Big(newAddress);\n        }\n    }\n    function GetMoney(uint weiAmount,address toAddress){\n        if(msg.sender==address(b)) { \n            toAddress.send(weiAmount);\n        }\n    }\n    function UniversalFunctionSecure(uint8 functionNumber,bytes32 p1,bytes32 p2,bytes32 p3,bytes32 p4,bytes32 p5){\n        if(msg.sender == owner) {\n            b.UniversalFunction(functionNumber,p1,p2,p3,p4,p5);\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1173217,0x8ce3e07c4c069a0fbc5c5ab3c3e45c9c7018d2d8,false,false,,,,TOO_SHORT
1173321,0xaa9b48c80674398da24c04484eb0f996dd09c249,false,false,,,,TOO_SHORT
1173724,0x6ecb80fe15e0abbc20160d049a24ee06f5fe8bc0,false,false,,,,TOO_SHORT
1173852,0x9c792212058e60eb356cd9e0d22f0626b5cb93e8,false,false,,,,TOO_SHORT
1173962,0xae707680c6b472bf44624d1e6a2b23cec0a66e44,false,false,,,,TOO_SHORT
1174001,0x5b3020f5c319641061e9126e2c36b49519f97a2c,false,false,,,,TOO_SHORT
1174054,0xad68bd0ceac350af8e4f449f4fe7f2e6712aab3d,false,false,,,,TOO_SHORT
1174071,0x8320bcce0858255ffc2318b460e64d183912019c,false,false,,,,TOO_SHORT
1174127,0x5759399d2219ddaf544945e27453926eb057c5bf,false,false,,,,TOO_SHORT
1174367,0x757475acd9897615b1fa9a8492f10e80f2f6649a,false,false,,,,TOO_SHORT
1174495,0x302b65c4f9d799765f9e472aec97b542acb6d16f,false,false,,,,TOO_SHORT
1174719,0x9bf06c3ff56ad5621ba7e076f6264dba1baca431,false,false,,,,TOO_SHORT
1174872,0x0cba23329d2d764147761b0f3cd1047b7571f831,false,false,,,,TOO_SHORT
1174931,0x7e622490f7cb9e58b05c4fcc1147890fe1e3658b,false,false,,,,TOO_SHORT
1174944,0x1adfcb41d25a234f48fb942c5724072d4fe6b998,false,false,,,,TOO_SHORT
1175444,0x08bd13e5b1fcd2ca7b24d3e11240219818e325db,false,false,,,,TOO_SHORT
1175942,0x1c5e51f1a34e1fadba6724522124c912157d541e,false,false,,,,TOO_SHORT
1176081,0xe8fd59a3834918dcdc982a3342a74050f2dd4192,false,false,,,,TOO_SHORT
1176582,0xf6277096b02d83f7307f88bbb74fdce30a61430a,false,false,,,,TOO_SHORT
1176813,0x7d47f383b23b76a6d63cbc09f21d94c14aa3dd20,false,false,,,,TOO_SHORT
1176838,0x0e4f73d3ddf0be473564d96d8a258321e33e377a,false,false,,,,TOO_SHORT
1177296,0x7fbb1edca823451bfc7c115ac1b5c44c27e275ed,false,false,,,,TOO_SHORT
1177530,0xe91d000af9e78dd8a3249279767492feb9979d99,false,false,,,,TOO_SHORT
1177557,0x0e61ca325b770d13228dde821cb1aacb8196b3f7,false,false,,,,TOO_SHORT
1177589,0xf6a73e837a85c588e32eadb20bf134beaef82767,false,false,,,,TOO_SHORT
1177655,0xed41e39c5e6faba7b9d372027ea8419a3d8e97b7,false,false,,,,TOO_SHORT
1177864,0x9336f6b052b6cb7878a086593f24338355bb2c63,false,false,,,,TOO_SHORT
1178181,0x673f63a45f6f8d4a6d03f72f562d7b763623f96a,false,false,,,,TOO_SHORT
1178245,0x298f6444c7889a2284689badba002b63b383b4e7,false,false,,,,TOO_SHORT
1178478,0xdd8ee9e3f232fdf106a53ab16520bb5dcd27da3e,false,false,,,,TOO_SHORT
1178874,0x72e970951a383793a6a1d50c164a189f980c51e5,false,false,,,,TOO_SHORT
1179054,0x099625360a16bb4a9670b54acdf7f626e80859bf,false,false,,,,TOO_SHORT
1179079,0x4b72350a505151339ab691d0c9349d3b32744b00,false,false,,,,TOO_SHORT
1179110,0x292ac48a1050f3e8c967df295ff7dc00f00ae1e8,false,false,,,,TOO_SHORT
1179137,0xbff94cbd38f388d5f5d6e0bfac656f85aef84da2,false,false,,,,TOO_SHORT
1179233,0x301e7ac2f3033aa3b724e467f03e0713f9fa0d24,false,false,,,,TOO_SHORT
1179303,0xb9af7e481f31b8b0455e4e2a8856bd8b13fff1f4,false,false,,,,TOO_SHORT
1179916,0xb31392aa754ae462ee0144d906d14357facb6ef1,false,false,,,,TOO_SHORT
1179968,0x721d220e68cd9c9369e464006ade2e36e2b448da,false,false,,,,TOO_SHORT
1180000,0xe9f8d6dda4ab781400679c890aae87a92fbb749e,false,false,,,,TOO_SHORT
1180292,0x6e473544ba9e962bbcdc4323d98f4fbdbe7c9db4,false,false,,,,TOO_SHORT
1180421,0x70cbeedad3ca598d3106413b20cc6994cf44f089,false,false,,,,TOO_SHORT
1180587,0x1aa1bebc11bfc3941fc634ad70fe472132f4ac7d,false,false,,,,TOO_SHORT
1180624,0xda3e0b4a5997269836a5e4b1e3a2bf562e02720b,false,false,,,,TOO_SHORT
1180683,0x95421b022eadc1691351ff6edaead5a433b676ec,false,false,,,,TOO_SHORT
1180744,0x43ca97040420049137ec820de5f53e8165bf8048,false,false,,,,TOO_SHORT
1181188,0xced5399ea25a4c899dd6e9641ccf5c202fd0a7ce,false,false,,,,TOO_SHORT
1181253,0x5b901c117fd2808da899aa110a56810e35eb36b7,false,false,,,,TOO_SHORT
1181394,0xd95ee8daf04f087deebd7200775e29a5d9223949,false,false,,,,TOO_SHORT
1181670,0x4dde341f5e2208788205372c1a874add2cc69335,false,false,,,,TOO_SHORT
1181702,0x73b1f8cefdb37a86b31fb155184fbc192681be4d,false,false,,,,TOO_SHORT
1181745,0xa1091500e35e8cbc4e6ae3ac42fc229b959a1a66,false,false,,,,TOO_SHORT
1181860,0x6d0838da78c4e6cdd6d517aae4ca2e98da903fa6,false,false,,,,TOO_SHORT
1182118,0x4b266b4e7113ec16b7cacd41acd9f4ba679bf80d,false,false,,,,TOO_SHORT
1182190,0x1abdad38315258f9cb9ec025b63e9c42300049cd,false,false,,,,TOO_SHORT
1182253,0x9b757fc6d2ae7a472dc50eaa171b56bf073874f8,false,false,,,,TOO_SHORT
1182432,0x00cab64751170cbd9a6ca669a0c4df2f0357339e,false,false,,,,TOO_SHORT
1182472,0x22c0f4f14ba01d941b8d991783b6da2f368c00c1,false,false,,,,TOO_SHORT
1183238,0xaef52bb92edabb8957d8e466e5055378d1e394c8,false,false,,,,TOO_SHORT
1183381,0x2875f8e73aa4e161c113b3d8853fff4b5709b07e,false,false,,,,TOO_SHORT
1183414,0xa4e069ff57d5683379f116d569807ec9646d81c0,false,false,,,,TOO_SHORT
1183746,0x1b7f0a9e95c5be6269b07204b4e23c3f59080cf9,false,false,,,,TOO_SHORT
1183894,0x25b2ce55746f54d88e9fc4d2f0f85e879c30bb05,false,false,,,,TOO_SHORT
1184196,0xe76c5b873caf499fd4527cbcc8d0f21af27f48fd,false,false,,,,TOO_SHORT
1184200,0x51dd1af038850636119d5aadf013716354e98067,false,false,,,,TOO_SHORT
1184243,0xb82d87c6cbac78c0e35a19f78fb6cbc1b7541231,false,false,,,,TOO_SHORT
1184572,0x7d56485e026d5d3881f778e99969d2b1f90c50af,false,false,"contract ProtectTheCastle {\n    // King's Jester\n    address public jester;\n    // Record the last Reparation time\n    uint public lastReparation;\n    // Piggy Bank Amount\n    uint public piggyBank;\n\n    // Collected Fee Amount\n    uint public collectedFee;\n\n    // Track the citizens who helped to repair the castle\n    address[] public citizensAddresses;\n    uint[] public citizensAmounts;\n    uint32 public totalCitizens;\n    uint32 public lastCitizenPaid;\n    // Brided Citizen who made the system works\n    address public bribedCitizen;\n    // Record how many times the castle had fell\n    uint32 public round;\n    // Amount already paid back in this round\n    uint public amountAlreadyPaidBack;\n    // Amount invested in this round\n    uint public amountInvested;\n\n    uint constant SIX_HOURS = 60 * 60 * 6;\n\n    function ProtectTheCastle() {\n        // Define the first castle\n        bribedCitizen = msg.sender;\n        jester = msg.sender;\n        lastReparation = block.timestamp;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n    }\n\n    function repairTheCastle() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 10 finney) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the amount received is more than 100 ETH return the difference\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the Castle has fell\n        if (lastReparation + SIX_HOURS < block.timestamp) {\n            // Send the Piggy Bank to the last 3 citizens\n            // If there is no one who contributed this last 6 hours, no action needed\n            if (totalCitizens == 1) {\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank);\n            } else if (totalCitizens == 2) {\n                // If only 2 citizens contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 65 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\n            } else if (totalCitizens >= 3) {\n                // If there is 3 or more citizens who contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 55 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\n            }\n\n            // Define the new Piggy Bank\n            piggyBank = 0;\n\n            // Define the new Castle\n            jester = msg.sender;\n            lastReparation = block.timestamp;\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 2);\n            totalCitizens += 1;\n            amountInvested += amount;\n\n            // All goes to the Piggy Bank\n            piggyBank += amount;\n\n            // The Jetster take 3%\n            jester.send(amount * 3 / 100);\n\n            // The brided Citizen takes 3%\n            collectedFee += amount * 3 / 100;\n\n            round += 1;\n        } else {\n            // The Castle is still up\n            lastReparation = block.timestamp;\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 2);\n            totalCitizens += 1;\n            amountInvested += amount;\n\n            // 5% goes to the Piggy Bank\n            piggyBank += (amount * 5 / 100);\n\n            // The Jetster takes 3%\n            jester.send(amount * 3 / 100);\n\n            // The brided Citizen takes 3%\n            collectedFee += amount * 3 / 100;\n\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - collectedFee) && lastCitizenPaid <= totalCitizens) {\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\n                lastCitizenPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        repairTheCastle();\n    }\n\n    // When the castle would be no more...\n    function surrender() {\n        if (msg.sender == bribedCitizen) {\n            bribedCitizen.send(address(this).balance);\n            selfdestruct(bribedCitizen);\n        }\n    }\n\n    // When the brided Citizen decides to give his seat to someone else\n    function newBribedCitizen(address newBribedCitizen) {\n        if (msg.sender == bribedCitizen) {\n            bribedCitizen = newBribedCitizen;\n        }\n    }\n\n    // When the brided Citizen decides to collect his fees\n    function collectFee() {\n        if (msg.sender == bribedCitizen) {\n            bribedCitizen.send(collectedFee);\n        }\n    }\n\n    // When the jester can't handle it anymore, he can give his position to someone else\n    function newJester(address newJester) {\n        if (msg.sender == jester) {\n            jester = newJester;\n        }\n    }       \n}",2,詩的な役割名と物語的な要素が含まれ、芸術的な表現が見られる。,
1184689,0xd5e87d76baaafe494f3c0fc4d455d6befabb185c,false,false,,,,TOO_SHORT
1185101,0x12676b5b3af00fbcec06e0e1c226814f195d8cf9,false,false,,,,TOO_SHORT
1185132,0xbe424828844ef9d8d81067a6a81b75dffdfe3900,false,false,,,,TOO_SHORT
1185352,0x7e98273fe6f3d0015d92c8bee6c7d4b6d63130fe,false,false,,,,TOO_SHORT
1185590,0x3f0919b95c3b9b24494ef58c2b0c6af4e1205242,false,false,,,,TOO_SHORT
1185609,0x0ef8edc7236b6193ca88f2e74de1a4068a3cf2c8,false,false,,,,TOO_SHORT
1185654,0x332c08570f1a957377f623a294ec7fc8ec797091,false,false,,,,TOO_SHORT
1185664,0xc714e3f39b349da688aefd9739ffeff42e30a4a7,false,false,,,,TOO_SHORT
1185923,0xe54f9fc05cd7e2a80deadfbe527e1dc9981571bc,false,false,,,,TOO_SHORT
1185938,0xb077ad1acfd08a8096fbf5d84e6fdf56345af77a,false,false,,,,TOO_SHORT
1185955,0xec90e897e3a803d6ff77db3bf8fdb0685a1b1c8f,false,false,,,,TOO_SHORT
1186036,0xde65048dd7dca150e289100446da33f0b9669ea6,false,false,,,,TOO_SHORT
1186165,0x63ae877c27d0705745e32a30d37f301249d4bb04,false,false,,,,TOO_SHORT
1186232,0x1ca493a71fb4b731c235599f1844dfca3e0365b2,false,false,,,,TOO_SHORT
1186233,0xf6f94e05eb5c2c1c717e6593343a42e5fd5f13ac,false,false,,,,TOO_SHORT
1186249,0x5b008263551e188ec716f45ea4551950c759a1b9,false,false,,,,TOO_SHORT
1186284,0x90df2853dcd8aec2c184e9eb4d36bd42f0cd2883,false,false,,,,TOO_SHORT
1186939,0xe5fb44cbcce69ee859cf5ec95ba285e1222bdde7,false,false,,,,TOO_SHORT
1187045,0xb63aacab434c5a2631cfdf2a31b8fd5eb5d0285b,false,false,,,,TOO_SHORT
1187133,0xfc9a71a5171921df7796ed87d2ec5fa52a7aa3e3,false,false,,,,TOO_SHORT
1187147,0xe822d081bc50fd06ee29108aa28a9d1557225a48,false,false,,,,TOO_SHORT
1187386,0x180b0bbe95f5747a48092ebbe5b19ba461d8f1ca,false,false,,,,TOO_SHORT
1187492,0x54ebd4bde76582b6edab15a67d56dfe67d095359,false,false,,,,TOO_SHORT
1187750,0x2d1063f292fac07d9223c2878fbceadf0afab03f,false,false,,,,TOO_SHORT
1187763,0xd049535129621d8dbfbb391f6bb3fe5d0804e825,false,false,,,,TOO_SHORT
1188044,0x16650409e9976c89c44d11de57f4e306c177c2a3,false,false,,,,TOO_SHORT
1188075,0xcc720fda119eeb36353e54497a7b7bf56a8d37f1,false,false,,,,TOO_SHORT
1189274,0x8f16cbc08cee1fd4ecc1b34aba8ea8b6d9c968b5,false,false,,,,TOO_SHORT
1189366,0xf3e5da73adb6ea5462dc6a8c089b6a4573c87757,false,false,,,,TOO_SHORT
1189624,0x4a580dae253bae1830eec7b779de451c1adda046,false,false,,,,TOO_SHORT
1189744,0x43e64ea5482a699cbd413636f6cdf60edd465a4f,false,false,,,,TOO_SHORT
1189821,0x6a77a1942bc15159581a696e82437e69f840361a,false,false,,,,TOO_SHORT
1189905,0x15cbfec6d7b438eb03dc00f3ded99cf0c88682ef,false,false,,,,TOO_SHORT
1190165,0xc6af22d7fb0816b499a8fb1fc7772d6b30592154,false,false,,,,TOO_SHORT
1190456,0x300a3f7ac7e291f8b9f7e9a218c08132cd01783b,false,false,,,,TOO_SHORT
1190510,0xd405d64d884787a41d3b53bf90717002728ae18d,false,false,,,,TOO_SHORT
1190549,0x3712510b210dfcd2b6e86dd631d03e5fa66c7fc2,false,false,,,,TOO_SHORT
1190594,0x1498067713323b8fb8398a2087781629e334d7a9,false,false,,,,TOO_SHORT
1190595,0xe31d9e6f7c0d4be69c63831bb272bb85f67b5227,false,false,,,,TOO_SHORT
1190681,0x52c9badac4f9163d245a42aa4ad9e6939a109393,false,false,,,,TOO_SHORT
1190704,0x13353df679a945da6025d8f0151f90fa2a209d3a,false,false,,,,TOO_SHORT
1190861,0x8c8c372cabf941d879b7096bfdacf6956c34e7ce,false,false,,,,TOO_SHORT
1190876,0x8ff7e2c191f32f36b5116448109685e87ac709ae,false,false,,,,TOO_SHORT
1190951,0x961a8029522db72d765312647cb71f2933d27579,false,false,,,,TOO_SHORT
1190952,0xc934f069e55dd84a73d4d7beacf1211ad117e0be,false,false,,,,TOO_SHORT
1191132,0xd53ebb3a9b1d1af0e0c625a853b3175855ec969b,false,false,,,,TOO_SHORT
1191189,0xe2260349036c9702e187eb76dfb57fb4efe56d68,false,false,,,,TOO_SHORT
1191306,0x61d39074745e7373e54a1b0588dbab41c4b77f3a,false,false,,,,TOO_SHORT
1191637,0x726f2b408bdfa90295fb9b070e429ff8d2b8ea56,false,false,,,,TOO_SHORT
1192290,0x1f451fe124a222a04cecb3c592d98172ebcb8c62,false,false,,,,TOO_SHORT
1192357,0x53c4cb527d2daa8107b861d875055e2a6b06f058,false,false,,,,TOO_SHORT
1192389,0x45433be672868e0c15fa2d9aad8e0bf0a8d19b4f,false,false,,,,TOO_SHORT
1192398,0x45b24878b42cfc857349fc958d430bffd4054af9,false,false,,,,TOO_SHORT
1192452,0xd5ab9bbdc79d7110b4fc1ca685ea150be3d072b2,false,false,,,,TOO_SHORT
1192558,0x654758055e3d83eedc09c3720fda14030e054127,false,false,,,,TOO_SHORT
1192638,0x5568b491099af560ca7c5bc15ea389ef3b623264,false,false,,,,TOO_SHORT
1192903,0x63158d4a01d8367f142beb72689b9647a0ccae30,false,false,,,,TOO_SHORT
1192979,0xf17a1eb77368a297ba1a5e7bfc1fc2b6f48f87a2,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1193207,0x1c77f031e46bb89e691efab26879dcfa2a3862de,false,false,,,,TOO_SHORT
1193357,0xf5daf73f5c624f983be1034fdf5c7b080c85323a,false,false,,,,TOO_SHORT
1193382,0x5ca58e78945c12e30786f4c97b14218d06aa97c5,false,false,,,,TOO_SHORT
1193567,0xf23d48da940da0a5911e2a6ef0045e6c7f730100,false,false,,,,TOO_SHORT
1194074,0xd533e590fb3d45a34337b25b6a6ee0a78da25394,false,false,,,,TOO_SHORT
1194310,0x77460674809072d5c14f77aab4ede9d3d91d6f07,false,false,,,,TOO_SHORT
1194466,0x006c3667b95ee75f41b4745018cd297c0d2d524a,false,false,,,,TOO_SHORT
1194797,0x2469311772bcc0422458a3d6594216b1b4337052,false,false,,,,TOO_SHORT
1194798,0x822442f792081b3affe232ba9b3f52aa0999bc38,false,false,,,,TOO_SHORT
1195384,0xf56f051664e045d5647df6206bf39931e224d03d,false,false,,,,TOO_SHORT
1195457,0x6f9d265b2a723d108bf5d84a9da113a7186f9b58,false,false,,,,TOO_SHORT
1195606,0x6ee276e0b3c3d10d2f21b957b551e8455a67d3b1,false,false,,,,TOO_SHORT
1195721,0x340223c2ad4ab960a56f5fba95fddc7b0f126f72,false,false,,,,TOO_SHORT
1196017,0xdcb13fa157eebf22ddc8c9aa1d6e394810de6fa3,false,false,contract PiggyBank {\n\n  struct InvestorArray {\n      address etherAddress;\n      uint amount;\n  }\n\n  InvestorArray[] public investors;\n\n  uint public k = 0;\n  uint public fees;\n  uint public balance = 0;\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function PiggyBank() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 50 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n    uint amount=msg.value;\n\n\n    // add a new participant to array\n    uint total_inv = investors.length;\n    investors.length += 1;\n    investors[total_inv].etherAddress = msg.sender;\n    investors[total_inv].amount = amount;\n    \n    // collect fees and update contract balance\n \n      fees += amount / 33;             // 3% Fee\n      balance += amount;               // balance update\n\n\n     if (fees != 0) \n     {\n     	if(balance>fees)\n	{\n      	owner.send(fees);\n      	balance -= fees;                 //balance update\n	}\n     }\n \n\n   // 4% interest distributed to the investors\n    uint transactionAmount;\n	\n    while (balance > investors[k].amount * 3/100 && k<total_inv)  //exit condition to avoid infinite loop\n    { \n     \n     if(k%25==0 &&  balance > investors[k].amount * 9/100)\n     {\n      transactionAmount = investors[k].amount * 9/100;  \n      investors[k].etherAddress.send(transactionAmount);\n      balance -= investors[k].amount * 9/100;                      //balance update\n      }\n     else\n     {\n      transactionAmount = investors[k].amount *3/100;  \n      investors[k].etherAddress.send(transactionAmount);\n      balance -= investors[k].amount *3/100;                         //balance update\n      }\n      \n      k += 1;\n    }\n    \n    //----------------end enter\n  }\n\n\n\n  function setOwner(address new_owner) onlyowner {\n      owner = new_owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1196053,0x99451ff76f31ad0c3466753cd6c2c11172b7e24d,false,false,,,,TOO_SHORT
1196457,0x44543fd05586ae4bf3a138c25ac16ebb8cc4ff34,false,false,,,,TOO_SHORT
1196480,0x348fef847ed88ea8df881fa114211702d93df044,false,false,,,,TOO_SHORT
1197045,0x2e41aef355c6df307d9e296cb6260edce1211548,false,false,,,,TOO_SHORT
1197160,0xd4998da1f29bdcc3fb194d48906b739dcfe0c2f9,false,false,,,,TOO_SHORT
1197341,0xb77af9625aa793980dc7f8fa619c6f47d2761c98,false,false,,,,TOO_SHORT
1197386,0x8e9f472d52f9ebdf29abf6d6b2a972c9c3f0b598,false,false,,,,TOO_SHORT
1197462,0xd6484c68e773ae5d3f66c2b55e289a09b7c573e6,false,false,,,,TOO_SHORT
1197591,0x9b54fcf429f32dbf1292fa191272e7f4174741cc,false,false,,,,TOO_SHORT
1197776,0x6372454e1250627752e5a65f3f540446474eea08,false,false,,,,TOO_SHORT
1197905,0x694037bfa0bc6151907eef6119ac679d242780c4,false,false,contract AddressReg{\n\n    address public owner;\n\n    function setOwner(address _owner){\n        if(msg.sender==owner)\n            owner = _owner;\n    }\n\n    function AddressReg(){\n        owner = msg.sender;\n    }\n\n    mapping (address=>bool) isVerifiedMap;\n\n    function verify(address addr){\n        if(msg.sender==owner)\n            isVerifiedMap[addr] = true;\n    }\n\n    function deverify(address addr){\n        if(msg.sender==owner)\n            isVerifiedMap[addr] = false;\n    }\n\n    function hasPhysicalAddress(address addr) constant returns(bool){\n        return isVerifiedMap[addr];\n    }\n\n},1,標準的な所有者管理とアドレス検証機能を持つ実用的なスマートコントラクト。,
1197905,0xb9a13984291e48b97baaaf085f96a05951f5cc05,false,false,,,,0x694037bfa0bc6151907eef6119ac679d242780c4
1198188,0x98f47a14fc8f3956fc2bd246a66a8efd684b7f69,false,false,,,,TOO_SHORT
1198284,0xcea6d45bed2bcf7cd20c0c1328a50747db549291,false,false,,,,TOO_SHORT
1198301,0xc0095de440576a013f1652a769dbfe3060f354c5,false,false,,,,TOO_SHORT
1198339,0xd6be1329e942d89691e283ca992c77e8aa09c629,false,false,,,,TOO_SHORT
1198522,0x6c7cce26e7854b9ad70467a988b782053c9b4708,false,false,,,,TOO_SHORT
1198665,0x5f2ee1308a2216e2b8abfa7741d1fe0bfd86f272,false,false,,,,TOO_SHORT
1198676,0x428e87c30122e3d9aab24768d46e627fc9f528df,false,false,,,,TOO_SHORT
1198727,0x25d6dc49dc22995963493fff1558e534eb010b04,false,false,,,,TOO_SHORT
1198745,0xf5fa273367861b3486622cf61bc013f5bde5edbb,false,false,,,,TOO_SHORT
1198781,0x1b4f3793f2af30ff71420ee8d4e9c9979f397c57,false,false,,,,TOO_SHORT
1198805,0xd255879d0d818f90a558636ce1132b5bf3aa19b2,false,false,,,,TOO_SHORT
1198934,0x5c71f91a79b325d13326edc34a984fa21f173fe4,false,false,,,,TOO_SHORT
1199023,0x97ca8b254f49c2ba8459a61b8a607914ad4f773a,false,false,,,,TOO_SHORT
1199250,0xdfc2609527ba05284615da5b5202c91c237b858d,false,false,,,,TOO_SHORT
1199651,0x5738e30ebf8f262df419213aafd1838ee2350e5b,false,false,,,,TOO_SHORT
1199686,0x1a9df7c7b141fbbb298c794da174ca24751a90a8,false,false,,,,TOO_SHORT
1200151,0x3e6bae524a4ef1f28c59d25f32e8858d8fabb9b0,false,false,,,,TOO_SHORT
1200311,0x4fdf254fb206c099c34f0d38cde7b734ae1c35ee,false,false,,,,TOO_SHORT
1200369,0x3583502593a3bd44e33a2eab455269d9469a79b1,false,false,,,,TOO_SHORT
1200551,0xbad661c5a1970342ade69857689738b6c8d9da51,false,false,,,,0x694037bfa0bc6151907eef6119ac679d242780c4
1200874,0x2040bff3f84412ebd9df56bc214df3fbd2ef035f,false,false,,,,TOO_SHORT
1201305,0x8951ecda07f363281931dc78b131184b5cfe5da6,false,false,,,,TOO_SHORT
1201649,0x271be4d4e24e2e2ba28cfdb28b49a8cf1842a2e2,false,false,,,,TOO_SHORT
1201795,0x89220771b93eebe29393f898e305d028de4cd804,false,false,,,,TOO_SHORT
1201987,0x8398763c52b33401c46da56c72730248a71e1d90,false,false,,,,TOO_SHORT
1202210,0x97e861aaa03e788c2604987b0f0aa4051bc51e5d,false,false,,,,TOO_SHORT
1202432,0xd0dd2bedad975c5bda68f4bc7f4225cb6631ccc6,false,false,,,,TOO_SHORT
1202550,0x540da5b3bbf37947d18665602bb6d1679629fefa,false,false,,,,TOO_SHORT
1202586,0x12f1aab5d5d01ddda9c657969bd6b5738cec27e7,false,false,,,,TOO_SHORT
1202635,0xe017647194a4d409b97194cf8116fc4f41f063c9,false,false,,,,TOO_SHORT
1202709,0xcdeaab409a7464530f776b51a70a4d18460ac89b,false,false,,,,TOO_SHORT
1202711,0x8e65277a4ac9221424efe9ee3c62b8d817bf78c1,false,false,,,,TOO_SHORT
1202799,0xb195b9d4a3368adca92d2f32510d4d29539cb498,false,false,,,,TOO_SHORT
1202924,0x147025349990e81af44765a61f21f40ff9c566c3,false,false,,,,TOO_SHORT
1203532,0xa0775006693ad4e7273f76f53dbd5e1a456b0431,false,false,,,,TOO_SHORT
1203662,0xeebb93764552d9996585a3e47e5eb7296c0f0899,false,false,,,,TOO_SHORT
1203889,0x29e3362118f7cc4daedd5efc1be9427ae03a4fa4,false,false,,,,TOO_SHORT
1203968,0x7de3d9b4bb055441adc6d942cc5121bb94e5bf6d,false,false,,,,TOO_SHORT
1203975,0xa30cae15f434f9d8c1cc672ee29542c700a849ea,false,false,,,,TOO_SHORT
1204402,0x02ad4b92945a0bcd87234747306bc6cfc7e5bbe6,false,false,,,,TOO_SHORT
1204461,0xf2dada516afa3e83f906191e428c1c785b59250b,false,false,,,,TOO_SHORT
1204539,0x424be06be951be91d63d8f436c9e219d27852fc6,false,false,,,,TOO_SHORT
1204651,0x8a0f4ea459188d41403fc896c50ba2548340a771,false,false,,,,TOO_SHORT
1204818,0xff65fc40b0644318b07a0d9010c5b5cd72f25007,false,false,,,,TOO_SHORT
1204831,0xf9c558100e611b2693682d879f3f6c3e12ddecbe,false,false,,,,TOO_SHORT
1204929,0x399fd8780426c76fc44bf40bafe6a4a863cd325e,false,false,,,,TOO_SHORT
1205051,0x7105a8ca63ceadf4d68ea94273a7d9b3e3ee8a90,false,false,,,,TOO_SHORT
1205109,0x37bda3aacef91e02519abfef4eae5855201f7b2b,false,false,,,,TOO_SHORT
1205178,0xf8541c2be03ec09464691dbbee6c43dd2a7c0b72,false,false,,,,TOO_SHORT
1205616,0x3ce2664e11df5e2404ae0975f146e3d043c6724e,false,false,,,,TOO_SHORT
1205627,0x65bf6299f63dae216ba67865a29fa68d86478563,false,false,,,,TOO_SHORT
1205687,0x8dd7fb08f09d24eec53907fdb155e4a47138e241,false,false,,,,TOO_SHORT
1205776,0x060379efc51481b39d109e5b92b5e4c2a152751a,false,false,,,,TOO_SHORT
1205823,0x252b8b14b5ed6f76d78e7293bea5d53b5667dffb,false,false,,,,TOO_SHORT
1205914,0x478c576d2e1fa87536e90be202f42bcfa6ee78ee,false,false,,,,TOO_SHORT
1206234,0x15dfdf34a70c9a9e41af815d0154b08e19161c9e,false,false,,,,TOO_SHORT
1206560,0x530f22434ca2585c583c5263a55d41da2f98fae1,false,false,,,,TOO_SHORT
1206952,0xc6166de9ce1c3bb8a882068e1bc6a34e4ac8bb30,false,false,,,,TOO_SHORT
1206976,0x7a182116e05660af3c285675f6ea1269bdbb4716,false,false,"contract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function sendApproval(address _from, uint256 _value, address _token); }\n\ncontract MyToken is owned { \n    /* Public variables of the token */\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n	uint8 public disableconstruction;\n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyTokenLoad(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {\n		if(disableconstruction != 2){\n            if(centralMinter != 0 ) owner = msg.sender;         // Sets the minter\n            balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens                    \n            name = tokenName;                                   // Set the name for display purposes     \n            symbol = tokenSymbol;                               // Set the symbol for display purposes    \n            decimals = decimalUnits;                            // Amount of decimals for display purposes        \n		}\n    }\n    function MyToken(){\n        MyTokenLoad(10000000000000,'Kraze',8,'KRZ',0);\n		disableconstruction=2;\n    }\n    /* Send coins */\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough   \n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient            \n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n\n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1207013,0x8a772004af0b8fca5e7093c6f277ba7b0e8fa97a,false,false,,,,0x7a182116e05660af3c285675f6ea1269bdbb4716
1207112,0xbd26d8fe73bb847d89a1b589c062e879b06fd12b,false,false,,,,TOO_SHORT
1207312,0x00b1478c56dc9573481e3165d8370d5f05a17677,false,false,,,,TOO_SHORT
1207527,0x6d317a8f0d0584fffb180004eb4ef3a6155186b1,false,false,,,,TOO_SHORT
1207596,0x1d3b016da77916abc98a51639164a78552cfaa22,false,false,,,,TOO_SHORT
1208031,0x0ff54cd1923417f2283dcb152f00908589b45a68,false,false,,,,TOO_SHORT
1208240,0x82d32019a317f81cc563aab4319f33a81afe7359,false,false,,,,TOO_SHORT
1208294,0xb72e740450e60167eb67010ce03c06cc66756ddc,false,false,,,,TOO_SHORT
1208311,0xe99ad3e040965fe74854d0b72e03fa72e3ac1e85,false,false,,,,TOO_SHORT
1208482,0xb70a2aa4dab5d064da372e13e62bc8e1a49f3866,false,false,,,,TOO_SHORT
1208509,0x5578384c5ed9411d2b215971fd76ca0fc969033a,false,false,,,,TOO_SHORT
1208613,0x557f04976400ceea4b264c4c3712f865c1d96d1b,false,false,,,,TOO_SHORT
1208637,0x88780cfa98257008088d5df52211be3aeed48044,false,false,,,,TOO_SHORT
1208657,0x44815128dbacf7edb46fe0bd9f60c62f0a409bf0,false,false,,,,TOO_SHORT
1208780,0xa85800558aa19884b64f1148ac83c500e348d4ea,false,false,,,,TOO_SHORT
1208823,0x89e7a245d5267ecd5bf4ca4c1d9d4d5a14bbd130,false,false,,,,TOO_SHORT
1208879,0xea92bf1732ada34a1b5a178538a6ab0031bd827b,false,false,,,,TOO_SHORT
1209020,0x55c3a624b6b17062515ef9df0fe2b89301114f7d,false,false,,,,TOO_SHORT
1209035,0x0c9769ee5800716e307e17e62767c995aaec3f04,false,false,,,,TOO_SHORT
1209133,0x2338f739e1672756526e5d1f20cce3edd9b4e6ac,false,false,,,,TOO_SHORT
1209239,0x1a1b06fbdfcde52d2697358ae9ef308a0ecb01c3,false,false,,,,TOO_SHORT
1209284,0xb0b1db7ba322cfff69a9dbc0ac39ae7713c702b0,false,false,,,,TOO_SHORT
1209471,0x031b9c027dd15a9e9d39c251db7e03d13832a0c6,false,false,,,,TOO_SHORT
1209501,0x649b4143aed58f0d3bef0a30c355cda1b3929ce7,false,false,,,,TOO_SHORT
1209777,0x82aad9495a2cce6ece405eb685b284ec71065ca2,false,false,,,,TOO_SHORT
1210380,0x2ec903f8f6eaa4ec1fb45a8e366cd4c9dc992e4f,false,false,,,,TOO_SHORT
1210544,0x6f693834e535cbfe086e2774ac99d61a33689c41,false,false,,,,TOO_SHORT
1210662,0x9b5a2424ee7eb7e27217bd27b5abe0209098e288,false,false,,,,TOO_SHORT
1210733,0xfc126a29acb6f34a86b34a5d6980edb7d8a00c0d,false,false,,,,TOO_SHORT
1210829,0xac096212f6b3475ff0ce0d8d5bb3e931e0a4115a,false,false,,,,TOO_SHORT
1210860,0x320c759ee26cc35f41a323b34a7d5a36d967caa8,false,false,,,,TOO_SHORT
1210863,0xc072b4f8c206846ca6d8415a8a488bcd04fb1cde,false,false,,,,TOO_SHORT
1210864,0x1782df7287ff56d9f174dae31b19abbf1979cd71,false,false,,,,TOO_SHORT
1210865,0x111f0e6ac69016cc4d25cc93fe96a91c1b41e4cd,false,false,,,,TOO_SHORT
1210866,0xc7771e0160e5bf7c73fe373e3db56119830f3e18,false,false,,,,TOO_SHORT
1210868,0x02a99a4140a23332bf9465ba76068dc75651d015,false,false,,,,TOO_SHORT
1210869,0xe5d76025c0a4ebe06b0085a82be309b72ec120fb,false,false,,,,TOO_SHORT
1210871,0x7109bd0f815e59e01904fa706606ebbd1fa8d8f0,false,false,,,,TOO_SHORT
1210875,0x2275598f14e16884bc77e508089019b2a7acc717,false,false,,,,TOO_SHORT
1210879,0xaa8fa072379e96adff55b547b65ca87d0ed8f75b,false,false,,,,TOO_SHORT
1210880,0x9f3002b333b74c2e456b04ecdde7f9830d90e7cd,false,false,,,,TOO_SHORT
1210881,0x2ef346bc64b9ce386b5f87925fc60403f969499d,false,false,,,,TOO_SHORT
1210909,0x63fdf461af5c761f5f47d9ab69b75e6359e76cc6,false,false,,,,TOO_SHORT
1210912,0x2aca397948503d4852d2d2a76daf1252dcd58f7e,false,false,,,,TOO_SHORT
1210913,0xc011e9ec66800d5862d68f66f17e0099f93303fc,false,false,,,,TOO_SHORT
1210914,0xbadd667321919cda41098f408777d6d682443180,false,false,,,,TOO_SHORT
1210915,0x0e6b25fe7b74668ebdabad36f2c43bf6a9981454,false,false,,,,TOO_SHORT
1210999,0x3bd90181bfd12baeb123c67b9b2de224d21b9ef2,false,false,,,,TOO_SHORT
1211006,0xfe4824808962e10f6fa7ab9832e26c77c9953663,false,false,,,,TOO_SHORT
1211007,0x119b55d5056064562a29fae2f8fc21c4b3943783,false,false,,,,TOO_SHORT
1211008,0x5f1e31aea98ad62d221e4bf01cadcfa5cb0221a9,false,false,,,,TOO_SHORT
1211009,0x07b5291f9e8f8383901130cd6d6fe43550e4f297,false,false,,,,TOO_SHORT
1211010,0x2e6413f486ec804e13de6cf51f785636cd9a5585,false,false,,,,TOO_SHORT
1211011,0xa85220fe2623c3632b10c6a2ff2a26f7d6b49dbd,false,false,,,,TOO_SHORT
1211012,0x7fcb71529fc371bf6f95c656f43a11ec62ef599b,false,false,,,,TOO_SHORT
1211013,0xf661c57bfb8f5d5b25e232d47d9b24de5bb120ab,false,false,,,,TOO_SHORT
1211017,0x5c5f67957d101d97af6be3dbaf304a5dc274b75d,false,false,,,,TOO_SHORT
1211018,0x7085c6d699fc0715b6e71c5a81c4719b5c0be95d,false,false,,,,TOO_SHORT
1211019,0x5d5c5951e97c1f0c72cb34d373b02962ad895ff6,false,false,,,,TOO_SHORT
1211020,0x45964a17fbf05711b2b0944a2addc3553a4e1216,false,false,,,,TOO_SHORT
1211021,0xb08e5892a09331f4275d0726aad0217d64f1f7b9,false,false,,,,TOO_SHORT
1211022,0x924e2e613036d7974b97dfaad053f41edc5e7aa1,false,false,,,,TOO_SHORT
1211034,0x8c6db91f87d46e2eec4cc1487c1294179a069a62,false,false,,,,TOO_SHORT
1211042,0x252ca6602083fa0190c16f9e2393c7e1e428b0cc,false,false,,,,TOO_SHORT
1211100,0x62b4548a513fe230cd7f82a0706055f87d8bcce6,false,false,,,,TOO_SHORT
1211128,0x4ab274fc3a81b300a0016b3805d9b94c81fa54d2,false,false,"contract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\n\n\ncontract MeatConversionCalculator is owned {\n    uint public amountOfMeatInUnicorn;\n    uint public reliabilityPercentage;\n\n    /* generates a number from 0 to 2^n based on the last n blocks */\n    function multiBlockRandomGen(uint seed, uint size) constant returns (uint randomNumber) {\n        uint n = 0;\n        for (uint i = 0; i < size; i++){\n            if (uint(sha3(block.blockhash(block.number-i-1), seed ))%2==0)\n                n += 2**i;\n        }\n        return n;\n    }\n    \n    function MeatConversionCalculator(\n        uint averageAmountOfMeatInAUnicorn, \n        uint percentOfThatMeatThatAlwaysDeliver\n    ) {\n        changeMeatParameters(averageAmountOfMeatInAUnicorn, percentOfThatMeatThatAlwaysDeliver);\n    }\n    function changeMeatParameters(\n        uint averageAmountOfMeatInAUnicorn, \n        uint percentOfThatMeatThatAlwaysDeliver\n    ) onlyOwner {\n        amountOfMeatInUnicorn = averageAmountOfMeatInAUnicorn * 1000;\n        reliabilityPercentage = percentOfThatMeatThatAlwaysDeliver;\n    }\n    \n    function calculateMeat(uint amountOfUnicorns) constant returns (uint amountOfMeat) {\n        uint rnd = multiBlockRandomGen(uint(sha3(block.number, now, amountOfUnicorns)), 10);\n\n       amountOfMeat = (reliabilityPercentage*amountOfUnicorns*amountOfMeatInUnicorn)/100;\n       amountOfMeat += (1024*(100-reliabilityPercentage)*amountOfUnicorns*amountOfMeatInUnicorn)/(rnd*100);\n\n    }\n}",2,ユニコーンの肉量を計算するというユニークなテーマが詩的要素を持っています。,
1211140,0x1f3f2308618afb23bd1e32abefc372456163eedb,false,false,,,,TOO_SHORT
1211142,0xed6ac8de7c7ca7e3a22952e09c2a2a1232ddef9a,false,false,"/*\n\nVerification submitted to etherscan.io by Noel Maersk\nSource with full comments: https://gist.github.com/alexvandesande/3abc9f741471e08a6356#file-unicorn-meat-token\n\n*/\n\n    contract owned {\n        address public owner;\n\n        function owned() {\n            owner = msg.sender;\n        }\n\n        modifier onlyOwner {\n            if (msg.sender != owner) throw;\n            _\n        }\n\n        function transferOwnership(address newOwner) onlyOwner {\n            owner = newOwner;\n        }\n    }\n    \n    contract tokenRecipient { \n        function receiveApproval(address _from, uint256 _value, address _token); \n    }\n\n    contract MyToken is owned { \n        /* Public variables of the token */\n        string public name;\n        string public symbol;\n        uint8 public decimals;\n        uint256 public totalSupply;\n\n        /* This creates an array with all balances */\n        mapping (address => uint256) public balanceOf;\n        mapping (address => bool) public frozenAccount; \n        mapping (address => mapping (address => uint256)) public allowance;\n        mapping (address => mapping (address => uint256)) public spentAllowance;\n\n        /* This generates a public event on the blockchain that will notify clients */\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        event FrozenFunds(address target, bool frozen);\n\n        /* Initializes contract with initial supply tokens to the creator of the contract */\n        function MyToken(\n            uint256 initialSupply, \n            string tokenName, \n            uint8 decimalUnits, \n            string tokenSymbol, \n            address centralMinter \n        ) { \n            if(centralMinter != 0 ) owner = msg.sender;         // Sets the minter\n            balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens                    \n            name = tokenName;                                   // Set the name for display purposes     \n            symbol = tokenSymbol;                               // Set the symbol for display purposes    \n            decimals = decimalUnits;                            // Amount of decimals for display purposes\n            totalSupply = initialSupply; \n        }\n\n        /* Send coins */\n        function transfer(address _to, uint256 _value) {\n            if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough   \n            if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n            if (frozenAccount[msg.sender]) throw;                // Check if frozen\n            balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n            balanceOf[_to] += _value;                            // Add the same to the recipient            \n            Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        }\n\n        /* Allow another contract to spend some tokens in your behalf */\n        function approveAndCall(address _spender, uint256 _value) returns (bool success) {\n            allowance[msg.sender][_spender] = _value;  \n            tokenRecipient spender = tokenRecipient(_spender);\n            spender.receiveApproval(msg.sender, _value, this); \n            return true;         \n        }\n\n        /* A contract attempts to get the coins */\n        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n            if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough   \n            if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n            if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw;   // Check allowance\n            balanceOf[_from] -= _value;                          // Subtract from the sender\n            balanceOf[_to] += _value;                            // Add the same to the recipient            \n            spentAllowance[_from][msg.sender] += _value;\n            Transfer(_from, _to, _value); \n            return true;\n        } \n\n        /* This unnamed function is called whenever someone tries to send ether to it */\n        function () {\n            throw;     // Prevents accidental sending of ether\n        }\n        \n        function mintToken(address target, uint256 mintedAmount) onlyOwner {\n            balanceOf[target] += mintedAmount; \n            totalSupply += mintedAmount; \n            Transfer(0, owner, mintedAmount);\n            Transfer(owner, target, mintedAmount);\n        }\n\n        function freezeAccount(address target, bool freeze) onlyOwner {\n            frozenAccount[target] = freeze;\n            FrozenFunds(target, freeze);\n        }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1211143,0x71e27513e3565ee82a834b3c7427006e47bc3bf5,false,false,,,,TOO_SHORT
1211513,0xe3267eee64108690bcf82035b05e79b33dcabe67,false,false,,,,TOO_SHORT
1212372,0x24b0b35ba98498cd618f71d09d5741c9c9fa5913,false,false,,,,TOO_SHORT
1212839,0x47a3b5f8d3767c954c7e694134e223fe11f6f9ea,false,false,,,,TOO_SHORT
1213204,0x88fab726ec38c9b83b006a9918c296bfdd0fe492,false,false,,,,TOO_SHORT
1213498,0x91ca5ae71084b9c277e8617c1bbe77d6ee6c60b4,false,false,,,,TOO_SHORT
1214314,0xc63009c677ba9c0e455a7162ede860b400895f98,false,false,,,,TOO_SHORT
1214469,0x4f686bda1f3391ac9fc6d09a504ff8293c24ae6f,false,false,,,,TOO_SHORT
1214536,0xd1e10a1d3ca7e09d51806803a4a534fe5ed131db,false,false,,,,TOO_SHORT
1214802,0xa50efe0aef60327b3c90d9b98d100f232ef862a7,false,false,,,,TOO_SHORT
1214867,0x73a1ca16e0ef4d92029e07a68c7234818bbafa88,false,false,,,,TOO_SHORT
1215402,0x86d71cd7caea00349aea87ff516daafe7be20e4c,false,false,,,,TOO_SHORT
1215611,0x3d9412c1b5c7a645a36b3423e67dc47524017ce5,false,false,,,,TOO_SHORT
1215723,0xbac6290affae7b731b0114a65f2b6eeb5ef0dd83,false,false,,,,TOO_SHORT
1215725,0x2a3967d9b88c11612503d45411c7d07a13554250,false,false,"contract Market {\n\n  struct Option {\n    int strike;\n  }\n  struct Position {\n    mapping(uint => int) positions;\n    int cash;\n    bool expired;\n    bool hasPosition;\n  }\n  struct OptionChain {\n    uint expiration;\n    string underlying;\n    uint margin;\n    uint realityID;\n    bytes32 factHash;\n    address ethAddr;\n    mapping(uint => Option) options;\n    uint numOptions;\n    bool expired;\n    mapping(address => Position) positions;\n    uint numPositions;\n    uint numPositionsExpired;\n  }\n  mapping(uint => OptionChain) optionChains;\n  uint numOptionChains;\n  struct Account {\n    address user;\n    int capital;\n  }\n  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills\n  struct MarketMaker {\n    address user;\n    string server;\n  }\n  mapping(uint => MarketMaker) marketMakers; //starts at 1\n  uint public numMarketMakers = 0;\n  mapping(address => uint) marketMakerIDs;\n  mapping(uint => Account) accounts;\n  uint numAccounts;\n  mapping(address => uint) accountIDs; //starts at 1\n\n  function Market() {\n  }\n\n  function addFunds() {\n    if (accountIDs[msg.sender]>0) {\n      accounts[accountIDs[msg.sender]].capital += int(msg.value);\n    } else {\n      uint accountID = ++numAccounts;\n      accounts[accountID].user = msg.sender;\n      accounts[accountID].capital += int(msg.value);\n      accountIDs[msg.sender] = accountID;\n    }\n  }\n\n  function withdrawFunds(uint amount) {\n    if (accountIDs[msg.sender]>0) {\n      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {\n        accounts[accountIDs[msg.sender]].capital -= int(amount);\n        msg.sender.send(amount);\n      }\n    }\n  }\n\n  function getFunds(address user, bool onlyAvailable) constant returns(int) {\n    if (accountIDs[user]>0) {\n      if (onlyAvailable == false) {\n        return accounts[accountIDs[user]].capital;\n      } else {\n        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0, 0);\n      }\n    } else {\n      return 0;\n    }\n  }\n\n  function getFundsAndAvailable(address user) constant returns(int, int) {\n    return (getFunds(user, false), getFunds(user, true));\n  }\n\n  function marketMaker(string server) {\n    if (msg.value>0) throw;\n    if (marketMakerIDs[msg.sender]>0) {\n      marketMakers[marketMakerIDs[msg.sender]].server = server;\n    } else {\n      int funds = getFunds(marketMakers[i].user, false);\n      uint marketMakerID = 0;\n      if (numMarketMakers<6) {\n        marketMakerID = ++numMarketMakers;\n      } else {\n        for (uint i=2; i<=numMarketMakers; i++) {\n          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {\n            marketMakerID = i;\n          }\n        }\n      }\n      if (marketMakerID>0) {\n        marketMakerIDs[marketMakers[marketMakerID].user] = 0;\n        marketMakers[marketMakerID].user = msg.sender;\n        marketMakers[marketMakerID].server = server;\n        marketMakerIDs[msg.sender] = marketMakerID;\n      } else {\n        throw;\n      }\n    }\n  }\n\n  function getMarketMakers() constant returns(string, string, string, string, string, string) {\n    string[] memory servers = new string[](6);\n    for (uint i=1; i<=numMarketMakers; i++) {\n      servers[i-1] = marketMakers[i].server;\n    }\n    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);\n  }\n\n  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {\n    int[] memory funds = new int[](6);\n    for (uint i=1; i<=numMarketMakers; i++) {\n      funds[i-1] = getFunds(marketMakers[i].user, false);\n    }\n    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);\n  }\n\n  function getOptionChain(uint optionChainID) constant returns (uint, string, uint, uint, bytes32, address) {\n    return (optionChains[optionChainID].expiration, optionChains[optionChainID].underlying, optionChains[optionChainID].margin, optionChains[optionChainID].realityID, optionChains[optionChainID].factHash, optionChains[optionChainID].ethAddr);\n  }\n\n  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {\n    uint[] memory optionIDs = new uint[](60);\n    int[] memory strikes = new int[](60);\n    int[] memory positions = new int[](60);\n    int[] memory cashes = new int[](60);\n    uint z = 0;\n    for (int optionChainID=int(numOptionChains)-1; optionChainID>=0 && z<60; optionChainID--) {\n      if (optionChains[uint(optionChainID)].expired == false) {\n        for (uint optionID=0; optionID<optionChains[uint(optionChainID)].numOptions; optionID++) {\n          optionIDs[z] = uint(optionChainID)*1000 + optionID;\n          strikes[z] = optionChains[uint(optionChainID)].options[optionID].strike;\n          positions[z] = optionChains[uint(optionChainID)].positions[user].positions[optionID];\n          cashes[z] = optionChains[uint(optionChainID)].positions[user].cash;\n          z++;\n        }\n      }\n    }\n    return (optionIDs, strikes, positions, cashes);\n  }\n\n  function expire(uint accountID, uint optionChainID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {\n    if (optionChains[optionChainID].expired == false) {\n      if (ecrecover(sha3(optionChains[optionChainID].factHash, value), v, r, s) == optionChains[optionChainID].ethAddr) {\n        uint lastAccount = numAccounts;\n        if (accountID==0) {\n          accountID = 1;\n        } else {\n          lastAccount = accountID;\n        }\n        for (accountID=accountID; accountID<=lastAccount; accountID++) {\n          if (optionChains[optionChainID].positions[accounts[accountID].user].expired == false) {\n            int result = optionChains[optionChainID].positions[accounts[accountID].user].cash / 1000000000000000000;\n            for (uint optionID=0; optionID<optionChains[optionChainID].numOptions; optionID++) {\n              int moneyness = getMoneyness(optionChains[optionChainID].options[optionID].strike, uint(value), optionChains[optionChainID].margin);\n              result += moneyness * optionChains[optionChainID].positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;\n            }\n            accounts[accountID].capital = accounts[accountID].capital + result;\n            optionChains[optionChainID].positions[accounts[accountID].user].expired = true;\n            optionChains[optionChainID].numPositionsExpired++;\n          }\n        }\n        if (optionChains[optionChainID].numPositionsExpired == optionChains[optionChainID].numPositions) {\n          optionChains[optionChainID].expired = true;\n        }\n      }\n    }\n  }\n\n  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {\n    if (strike>=0) { //call\n      if (settlement>uint(strike)) {\n        if (settlement-uint(strike)<margin) {\n          return int(settlement-uint(strike));\n        } else {\n          return int(margin);\n        }\n      } else {\n        return 0;\n      }\n    } else { //put\n      if (settlement<uint(-strike)) {\n        if (uint(-strike)-settlement<margin) {\n          return int(uint(-strike)-settlement);\n        } else {\n          return int(margin);\n        }\n      } else {\n        return 0;\n      }\n    }\n  }\n\n  function addOptionChain(uint expiration, string underlying, uint margin, uint realityID, bytes32 factHash, address ethAddr, int[] strikes) {\n    uint optionChainID = 6;\n    if (numOptionChains<6) {\n      optionChainID = numOptionChains++;\n    } else {\n      for (uint i=0; i < numOptionChains && optionChainID>=6; i++) {\n        if (optionChains[i].expired==true || optionChains[i].numPositions==0 || optionChains[i].numOptions==0) {\n          optionChainID = i;\n        }\n      }\n    }\n    if (optionChainID<6) {\n      delete optionChains[optionChainID];\n      optionChains[optionChainID].expiration = expiration;\n      optionChains[optionChainID].underlying = underlying;\n      optionChains[optionChainID].margin = margin;\n      optionChains[optionChainID].realityID = realityID;\n      optionChains[optionChainID].factHash = factHash;\n      optionChains[optionChainID].ethAddr = ethAddr;\n      for (i=0; i < strikes.length; i++) {\n        if (optionChains[optionChainID].numOptions<10) {\n          uint optionID = optionChains[optionChainID].numOptions++;\n          Option option = optionChains[optionChainID].options[i];\n          option.strike = strikes[i];\n          optionChains[optionChainID].options[i] = option;\n        }\n      }\n    }\n  }\n\n  function orderMatchTest(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, int matchSize) constant returns(bool) {\n    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+getMaxLossAfterTrade(sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\n      return true;\n    }\n    return false;\n  }\n\n  function orderMatch(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {\n    bytes32 hash = sha256(optionChainID, optionID, price, size, orderID, blockExpires);\n    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\n      if (optionChains[optionChainID].positions[msg.sender].hasPosition == false) {\n        optionChains[optionChainID].positions[msg.sender].hasPosition = true;\n        optionChains[optionChainID].numPositions++;\n      }\n      if (optionChains[optionChainID].positions[addr].hasPosition == false) {\n        optionChains[optionChainID].positions[addr].hasPosition = true;\n        optionChains[optionChainID].numPositions++;\n      }\n      optionChains[optionChainID].positions[msg.sender].positions[optionID] += matchSize;\n      optionChains[optionChainID].positions[msg.sender].cash -= matchSize * int(price);\n      optionChains[optionChainID].positions[addr].positions[optionID] -= matchSize;\n      optionChains[optionChainID].positions[addr].cash += matchSize * int(price);\n      orderFills[hash] -= matchSize;\n    }\n  }\n\n  function getMaxLossAfterTrade(address user, uint optionChainID, uint optionID, int positionChange, int cashChange) constant returns(int) {\n    int totalMaxLoss = 0;\n    for (uint i=0; i<numOptionChains; i++) {\n      if (optionChains[i].positions[user].expired == false && optionChains[i].numOptions>0) {\n        bool maxLossInitialized = false;\n        int maxLoss = 0;\n        for (uint s=0; s<optionChains[i].numOptions; s++) {\n          int pnl = optionChains[i].positions[user].cash / 1000000000000000000;\n          if (i==optionChainID) {\n            pnl += cashChange / 1000000000000000000;\n          }\n          uint settlement = 0;\n          if (optionChains[i].options[s].strike<0) {\n            settlement = uint(-optionChains[i].options[s].strike);\n          } else {\n            settlement = uint(optionChains[i].options[s].strike);\n          }\n          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\n          if (pnl<maxLoss || maxLossInitialized==false) {\n            maxLossInitialized = true;\n            maxLoss = pnl;\n          }\n          pnl = optionChains[i].positions[user].cash / 1000000000000000000;\n          if (i==optionChainID) {\n            pnl += cashChange / 1000000000000000000;\n          }\n          settlement = 0;\n          if (optionChains[i].options[s].strike<0) {\n            if (uint(-optionChains[i].options[s].strike)>optionChains[i].margin) {\n              settlement = uint(-optionChains[i].options[s].strike)-optionChains[i].margin;\n            } else {\n              settlement = 0;\n            }\n          } else {\n            settlement = uint(optionChains[i].options[s].strike)+optionChains[i].margin;\n          }\n          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\n          if (pnl<maxLoss) {\n            maxLoss = pnl;\n          }\n        }\n        totalMaxLoss += maxLoss;\n      }\n    }\n    return totalMaxLoss;\n  }\n\n  function moneySumAtSettlement(address user, uint optionChainID, uint optionID, int positionChange, uint i, uint settlement) internal returns(int) {\n    int pnl = 0;\n    for (uint j=0; j<optionChains[i].numOptions; j++) {\n      pnl += optionChains[i].positions[user].positions[j] * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\n      if (i==optionChainID && j==optionID) {\n        pnl += positionChange * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\n      }\n    }\n    return pnl;\n  }\n\n  function min(uint a, uint b) constant returns(uint) {\n    if (a<b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1216263,0x4c077ad4c8712dc7abd793e0ad8f64e7278dd1d5,false,false,,,,TOO_SHORT
1216287,0xe4612fcbea21f99c4aabf0ba61077306a229014f,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1216297,0x9b040e06e1ffb78a89ab7cbcbebeb4de3f6e1acc,false,false,,,,TOO_SHORT
1216545,0xdcf913ebaf9dd67ce6591866bdb8dae8f2120cdb,false,false,,,,TOO_SHORT
1216663,0xe5a85d5132b8eb5454eb22e05aac39fa5789d2d9,false,false,,,,TOO_SHORT
1217000,0x7752ecc5a0517b2958220ac933f8b56ceff6ff1c,false,false,,,,TOO_SHORT
1217154,0x819626d7086a5cf55d88e95f174419d01e6e4fd4,false,false,,,,TOO_SHORT
1217220,0xa087455efad8c63c11352d1d3ea7d1c96bd1d676,false,false,,,,TOO_SHORT
1217271,0xa502f8112b2491718855f01a01a60462cc97a0d5,false,false,"contract UfoPonzi {\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees;\n    uint public balance = 0;\n\n    address public owner;\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function UfoPonzi() {\n        owner = msg.sender;\n        balance += msg.value;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n        if (msg.value < 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n\n        // add a new participant to array\n        uint idx = participants.length;\n        participants.length += 1;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value;\n        \n        // collect fees and update contract balance\n        if (idx != 0) {\n            collectedFees += msg.value / 10;\n            balance += msg.value;\n        } \n        else {\n            // first participant has no one above him,\n            // so it goes all to fees\n            collectedFees += msg.value;\n        }\n\n  // if there are enough ether on the balance we can pay out to an earlier participant\n        if (balance > participants[payoutIdx].amount / 10 + participants[payoutIdx].amount) {\n            uint transactionAmount = (participants[payoutIdx].amount - participants[payoutIdx].amount / 10) / 10 + (participants[payoutIdx].amount - participants[payoutIdx].amount / 10);\n            participants[payoutIdx].etherAddress.send(transactionAmount);\n\n            balance -= participants[payoutIdx].amount / 10 + participants[payoutIdx].amount;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Ponziスキームを模した実用的なスマートコントラクトで、芸術的要素は特にない。,
1217609,0xbf526cb8df210b290400fd86fd86bbb504fc2f11,false,false,,,,TOO_SHORT
1217673,0xc45d5d02f8350d68d3c6ef33f8df9495361e6042,false,false,,,,TOO_SHORT
1217881,0x2976f95c7e67d2c42a5826c45c3142512ced0a5e,false,false,,,,TOO_SHORT
1218066,0x1685d2aa57347ef1b85fd0338a91f7d6eedebbfa,false,false,contract PiggyBank {\n\n  struct InvestorArray {\n      address etherAddress;\n      uint amount;\n  }\n\n  InvestorArray[] public investors;\n\n  uint public k = 0;\n  uint public fees;\n  uint public balance = 0;\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function PiggyBank() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 50 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n    uint amount=msg.value;\n\n\n    // add a new participant to array\n    uint total_inv = investors.length;\n    investors.length += 1;\n    investors[total_inv].etherAddress = msg.sender;\n    investors[total_inv].amount = amount;\n    \n    // collect fees and update contract balance\n \n      fees = amount / 33;             // 3% Fee\n      balance += amount;               // balance update\n\n\n     if (fees != 0) \n     {\n     	if(balance>fees)\n	{\n      	owner.send(fees);\n      	balance -= fees;                 //balance update\n	}\n     }\n \n\n   // 4% interest distributed to the investors\n    uint transactionAmount;\n	\n    while (balance > investors[k].amount * 3/100 && k<total_inv)  //exit condition to avoid infinite loop\n    { \n     \n     if(k%25==0 &&  balance > investors[k].amount * 9/100)\n     {\n      transactionAmount = investors[k].amount * 9/100;  \n      investors[k].etherAddress.send(transactionAmount);\n      balance -= investors[k].amount * 9/100;                      //balance update\n      }\n     else\n     {\n      transactionAmount = investors[k].amount *3/100;  \n      investors[k].etherAddress.send(transactionAmount);\n      balance -= investors[k].amount *3/100;                         //balance update\n      }\n      \n      k += 1;\n    }\n    \n    //----------------end enter\n  }\n\n\n\n  function setOwner(address new_owner) onlyowner {\n      owner = new_owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1218182,0xfd51359579fd1f18c9a74125f8bfae4c3d185574,false,false,,,,TOO_SHORT
1218311,0xa7cb99de87ee4fd060a72187323a5cb254b28973,false,false,,,,TOO_SHORT
1218493,0xd1d30d4694ae0ea83c8e16e353d847fae83cc0be,false,false,,,,TOO_SHORT
1218583,0x44365d3364902670b9a750faff5354d6b8fc1661,false,false,,,,TOO_SHORT
1218973,0xbe181da06d93867af0a3ffadcebe345ec35dae4e,false,false,,,,0x1685d2aa57347ef1b85fd0338a91f7d6eedebbfa
1219331,0x94420fcdc18d48bf45a72d118564653de8cf29d9,false,false,,,,TOO_SHORT
1219382,0x9d7fa7ae5c82fc51e49b0e75ccb8a1b2c4d36097,false,false,,,,TOO_SHORT
1219383,0xd55d21c1e9cb5760e10921032ac64bd2d220ec5f,false,false,,,,TOO_SHORT
1219492,0xecd7d12abd0479cfd174832ad78f94ae75a5b59a,false,false,,,,TOO_SHORT
1219659,0xc5cec2ae65eb04584ed2fa886b49bda63ee78b6a,false,false,,,,TOO_SHORT
1219876,0x8962f1b997ab63532b12f8a3b68f4ea87b6b8ef8,false,false,,,,TOO_SHORT
1220567,0xc112de71afaf32affcf51f4cd46541830e9cf694,false,false,,,,TOO_SHORT
1220650,0x7fbfeec1ed82f6104cf6f54cf6c79a2e7db5cfea,false,false,,,,TOO_SHORT
1221059,0xe30ff829578ad5f77c8db2c52743006a603c9d8b,false,false,,,,TOO_SHORT
1221195,0xdc1ac766e89d338c23eb69141b0034f935e5fec1,false,false,,,,TOO_SHORT
1221238,0x15deaf06d7e838facd35ce765062cf06cfca2112,false,false,,,,TOO_SHORT
1221291,0xfa2b42579d4b69c5e55366efb449613b2fee3820,false,false,,,,TOO_SHORT
1221292,0xcc39044631f135dd84e988a2d376ea18a2441d9c,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1221396,0x47c299e1313d6b2e76ded1bc473f741ffcef0d4e,false,false,,,,TOO_SHORT
1221443,0x108c8b95bf92aa503178fe3bf7d8091001c89b21,false,false,,,,TOO_SHORT
1221563,0xdb2dd08f3b6192b4d9274dab85eee8eb43bebdc7,false,false,,,,TOO_SHORT
1221624,0x43f35b20f9ab0a1bb7395db6e2ded3a2f582b6c6,false,false,,,,TOO_SHORT
1221666,0xcbfc17a1bd128a92fd086a58e96ef44da121d9c9,false,false,,,,TOO_SHORT
1221692,0x2cab63e02d5b490e5f4a5d1b0d5189420ea54b2d,false,false,,,,TOO_SHORT
1221811,0x9f878f8957c48a84e1c31b9c1ca32ecef75f09b7,false,false,,,,TOO_SHORT
1221917,0xf132464e5f634946843e5b0ea7622dceea8c5c6d,false,false,,,,TOO_SHORT
1222140,0x4865e85c72a27ca6c362da75ba6707c07464b953,false,false,"//***********************************TREASURE CHEST GAME\n//\n//\n//  Hello player, this is a Treasure Chest game, every player that deposit's here will get a guaranteed 6% payout of their balance after somebody after him deposits!\n//  Every 30th investor receives 18% instead of 6%, that is the jackpot spot that pays 3x more, invest quickly ,and you can earn a passive income right now!\n//\n//  This contract is bug-tested, and it has none, feel comfortable to analyse the code yourself, it's open source and transparent!\n//  Enjoy this game, and earn Ethereum now!\n//\n//  Copyright  Â©  2016  David Weissman from NZ\n//\n//***********************************START\ncontract TreasureChest {\n\n  struct InvestorArray {\n      address etherAddress;\n      uint amount;\n  }\n\n  InvestorArray[] public investors;\n\n//********************************************PUBLIC VARIABLES\n\n  uint public investors_needed_until_jackpot=0;\n  uint public totalplayers=0;\n  uint public fees=0;\n  uint public balance = 0;\n  uint public totaldeposited=0;\n  uint public totalpaidout=0;\n\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function TreasureChest() {\n    owner = msg.sender;\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value < 50 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n    uint amount=msg.value;\n\n\n    // add a new participant to the system and calculate total players\n    uint tot_pl = investors.length;\n    totalplayers=tot_pl+1;\n    investors_needed_until_jackpot=30-(totalplayers % 30);\n    investors.length += 1;\n    investors[tot_pl].etherAddress = msg.sender;\n    investors[tot_pl].amount = amount;\n\n\n\n    // collect fees and update contract balance and deposited amount\n      fees  = amount / 15;             // 6.666% fee to the owner\n      balance += amount;               // balance update\n      totaldeposited+=amount;       //update deposited amount\n\n    // pay out fees to the owner\n     if (fees != 0) \n     {\n     	if(balance>fees)\n	{\n      	owner.send(fees);\n      	balance -= fees;                 //balance update\n	totalpaidout+=fees;          //update paid out amount\n	}\n     }\n \n\n   //loop variables\n    uint payout;\n    uint nr=0;\n	\n    while (balance > investors[nr].amount * 6/100 && nr<tot_pl)  //exit condition to avoid infinite loop\n    { \n     \n     if(nr%30==0 &&  balance > investors[nr].amount * 18/100)\n     {\n      payout = investors[nr].amount * 18/100;                        //calculate pay out\n      investors[nr].etherAddress.send(payout);                      //send pay out to participant\n      balance -= investors[nr].amount * 18/100;                      //balance update\n      totalpaidout += investors[nr].amount * 18/100;               //update paid out amount\n      }\n     else\n     {\n      payout = investors[nr].amount *6/100;                           //calculate pay out\n      investors[nr].etherAddress.send(payout);                        //send pay out to participant\n      balance -= investors[nr].amount *6/100;                         //balance update\n      totalpaidout += investors[nr].amount *6/100;                 //update paid out amount\n      }\n      \n      nr += 1;                                                                         //go to next participant\n    }\n    \n    \n  }\n\n//********************************************NEW OWNER\n\n  function setOwner(address new_owner) onlyowner {\n      owner = new_owner;\n  }\n}",1,実用的なスマートコントラクトで、ゲームのロジックを実装していますが、芸術的要素は少ないです。,
1222325,0x183055e15aaad245bfda0fa8a70954aab2acf937,false,false,,,,TOO_SHORT
1222521,0x977c52926954ef579035912bf05e8a162a428ebf,false,false,,,,TOO_SHORT
1222702,0x8154ae317a767e69d7f427aebdfbdddadcd5cf48,false,false,"contract Rating {\n        function setRating(bytes32 _key, uint256 _value) {\n            ratings[_key] = _value;\n        }\n        mapping (bytes32 => uint256) public ratings;\n    }",1,シンプルで実用的な評価設定のスマートコントラクトです。,
1222713,0x404d52e5eb996498e6a7fd3ec5e0810e7841f07b,false,false,,,,TOO_SHORT
1222850,0xc7c661be173cb4d3dab2aebefb3a3cf215f5b34c,false,false,,,,TOO_SHORT
1222933,0x36cc80a0e997000956c4c6955f358763c479501d,false,false,,,,TOO_SHORT
1223040,0x90d9d2cd65afab430e2053fd6c156e8965ec37ae,false,false,,,,TOO_SHORT
1223095,0xbb9854bfd082c48b4d426ac6a2a152b01326f46f,false,false,"contract X3 {\n\n        struct Participant {\n                address etherAddress;\n                uint amount;\n        }\n\n        Participant[] public participants;\n\n        uint public payoutIdx = 0;\n        uint public collectedFees;\n        uint public balance = 0;\n\n        address public owner;\n\n        // simple single-sig function modifier\n        modifier onlyowner {\n                if (msg.sender == owner) _\n        }\n\n        // this function is executed at initialization and sets the owner of the contract\n        function X3() {\n                owner = msg.sender;\n        }\n\n        // fallback function - simple transactions trigger this\n        function() {\n                enter();\n        }\n\n        function enter() {\n                if (msg.value < 1 ether) {\n                        msg.sender.send(msg.value);\n                        return;\n                }\n\n                // add a new participant to array\n                uint idx = participants.length;\n                participants.length += 1;\n                participants[idx].etherAddress = msg.sender;\n                participants[idx].amount = msg.value;\n\n                // collect fees and update contract balance\n                if (idx != 0) {\n                        collectedFees += msg.value / 3;\n                        balance += msg.value;\n                } else {\n                        // first participant has no one above him,\n                        // so it goes all to fees\n                        collectedFees += msg.value;\n                }\n\n                // if there are enough ether on the balance X3 will payout three time your initial investement\n                if (balance > participants[payoutIdx].amount * 3) {\n                        uint transactionAmount = 3 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 3);\n                        participants[payoutIdx].etherAddress.send(transactionAmount);\n\n                        balance -= participants[payoutIdx].amount * 3;\n                        payoutIdx += 1;\n                }\n        }\n\n        function collectFees() onlyowner {\n                if (collectedFees == 0) return;\n\n                owner.send(collectedFees);\n                collectedFees = 0;\n        }\n\n        function setOwner(address _owner) onlyowner {\n                owner = _owner;\n        }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1223203,0x5bae16579eca34d4c1ef222e007ee8a29c82aa27,false,false,,,,TOO_SHORT
1223258,0xd4947a6d764281202d755869837dd5ed4802c88d,false,false,,,,TOO_SHORT
1223340,0xa785f653bf46c1e40e56a69fc6244913ef5e1a9c,false,false,,,,TOO_SHORT
1223502,0x67d705be9a7684bd253c4d44051f439dbd9108ae,false,false,,,,TOO_SHORT
1223580,0x075ec3a172ffede007526b3a26783476ab05e309,false,false,,,,TOO_SHORT
1223598,0x63a7ded9cc70204d9659e49035c7da83c41a2c01,false,false,,,,TOO_SHORT
1223788,0x5ae340e564d8059e9ee545691c0f912f0d4c9f0c,false,false,,,,TOO_SHORT
1223792,0x0e8b6736290a62cf378094b775b37fca9a1279c7,false,false,,,,TOO_SHORT
1223978,0xd868c146caa0553077d9ae4de1f00ac273dea3b3,false,false,,,,TOO_SHORT
1224469,0xa6085b386e13b827f4fc8983f21d2cc2d809288f,false,false,,,,TOO_SHORT
1224609,0xc89a6722b1548b3ced7727367381839b261b43cb,false,false,,,,TOO_SHORT
1225137,0xf011b60cc057ce2b2740c2ae9382f47ed23d1dda,false,false,,,,TOO_SHORT
1225490,0x569dbe17e2a602b452e0984870af8c42e0c0248e,false,false,,,,TOO_SHORT
1225620,0x85b17f5aeaa1be051d05bb8727483123a3b01c8d,false,false,,,,TOO_SHORT
1225795,0x08aea5a5690c82829a57db2a69cd235fae628967,false,false,,,,TOO_SHORT
1225861,0x37dabefd971a415dc04fad8da60057706e97225e,false,false,,,,TOO_SHORT
1226045,0x7ae3916fec095fcfbce5a5f0197626b499d55289,false,false,,,,TOO_SHORT
1226350,0x7f57b56a4d2d234a17c401d833aec1c1ca649e6d,false,false,,,,TOO_SHORT
1226516,0xde4fcc939216f5c8c5e5837651a55d97875774e0,false,false,,,,TOO_SHORT
1226596,0x5b7f9bfcdca7c5ab90cbaf7cba1dead7881efd7b,false,false,,,,TOO_SHORT
1226742,0x0d95a7cace75dcdf0736bee1c3669c9a41047bb8,false,false,,,,TOO_SHORT
1226751,0xd955ccad770e340035fa1eaacca903cb95f91fe7,false,false,,,,TOO_SHORT
1226758,0x567d3f6bbde44035e0e3cf98e308371f38563859,false,false,,,,TOO_SHORT
1226876,0x6c3c8fdd2825892f43e0df6e68bed7e642cc8943,false,false,,,,TOO_SHORT
1227127,0x50c2d13ca2c7b64d9bf9b8d3549e11416cd69fc9,false,false,,,,TOO_SHORT
1227363,0x80b124a18374f98720d1a57828d935427778f7c6,false,false,,,,TOO_SHORT
1228017,0xa9f53d0edb71bb70fc50c7fa2da87a4029480627,false,false,,,,TOO_SHORT
1228061,0xca13311644f3f2593c13e4ecb2a69303685967c5,false,false,,,,TOO_SHORT
1228071,0x738ff33cd3a1ceccfe611130ce4210621306b8d1,false,false,,,,TOO_SHORT
1228353,0xed0ae396037c3caf7ea0bbbb6038909d1b08e52f,false,false,,,,TOO_SHORT
1228433,0x94aa52f20a6ed3619f1de8bba360c6e540b396e4,false,false,,,,TOO_SHORT
1228434,0xbbea1a1980982197389bbbc6ffe0ebfa154f4f6f,false,false,,,,TOO_SHORT
1228441,0xa661d9860c2acc6645c1a3f4ad02bdb422de2487,false,false,,,,TOO_SHORT
1228442,0xa9bf30cc971ffffd2b336f75310fae9a19579dcd,false,false,,,,TOO_SHORT
1228444,0xaf5fbcf06f5d107a5cdf6a117bc1f3e200769e3c,false,false,,,,TOO_SHORT
1228621,0xab5e467a8d7dc0aea5c1024d31172bcd0f90e598,false,false,,,,TOO_SHORT
1228650,0x5b611735bca6db84931567345a43bb7cb5cc7795,false,false,,,,TOO_SHORT
1228652,0x446d1696a5527018453cda3d67aa4c2cd189b9f6,false,false,"contract GreedPit {\n    \n    address private owner;\n    \n    //Stored variables\n    uint private balance = 0;\n    uint private uniqueUsers = 0;\n    uint private usersProfits = 0;\n    uint private rescues = 0;\n    uint private collectedFees = 0;\n    uint private jumpFee = 10;\n    uint private baseMultiplier = 110;\n    uint private maxMultiplier = 200;\n    uint private payoutOrder = 0;\n    uint private rescueRecord = 0;\n    uint timeOfLastDeposit = now;\n    address private hero = 0x0;\n    \n    mapping (address => User) private users;\n    Entry[] private entries;\n    \n    event Jump(address who, uint deposit, uint payout);\n    event Rescue(address who, address saviour, uint payout);\n    event NewHero(address who);\n    \n    //Set owner on contract creation\n    function GreedPit() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    struct User {\n        uint id;\n        address addr;\n        string nickname;\n        uint rescueCount;\n        uint rescueTokens;\n    }\n    \n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        uint tokens;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    function init() private{\n        //Only deposits >0.1ETH are allowed to join\n        if (msg.value < 100 finney) {\n            return;\n        }\n        \n        jumpIn();\n        \n        //Prevent cheap trolls from reviving the pit if it dies (death = ~3months without deposits)\n        if (msg.value > 5)\n            timeOfLastDeposit = now;\n    }\n    \n    //Join the pit\n    function jumpIn() private {\n        \n        //Limit deposits to 50ETH\n		uint dValue = 100 finney;\n		if (msg.value > 50 ether) {\n		    //Make sure we receied the money before refunding the surplus\n		    if (this.balance >= balance + collectedFees + msg.value)\n			    msg.sender.send(msg.value - 50 ether);	\n			dValue = 50 ether;\n		}\n		else { dValue = msg.value; }\n\n        //Add new users to the users array if he's a new player\n        addNewUser(msg.sender);\n        \n        //Make sure that only up to 5 rescue tokens are spent at a time\n        uint tokensToUse = users[msg.sender].rescueTokens >= 5 ? 5 : users[msg.sender].rescueTokens;\n        uint tokensUsed = 0;\n        \n        //Enforce lower payouts if too many people stuck in the pit\n        uint randMultiplier = rand(50);\n        uint currentEntries = entries.length - payoutOrder;\n        randMultiplier = currentEntries > 15 ? (randMultiplier / 2) : randMultiplier;\n        randMultiplier = currentEntries > 25 ? 0 : randMultiplier;\n        //Incentive to join if the pit is nearly empty (+50% random multiplier)\n        randMultiplier = currentEntries <= 5 && dValue <= 20 ? randMultiplier * 3 / 2 : randMultiplier;\n        \n        //Calculate the optimal amount of rescue tokens to spend\n        while (tokensToUse > 0 && (baseMultiplier + randMultiplier + tokensUsed*10) < maxMultiplier)\n        {\n            tokensToUse--;\n            tokensUsed++;\n        }\n        \n        uint finalMultiplier = (baseMultiplier + randMultiplier + tokensUsed*10);\n        \n        if (finalMultiplier > maxMultiplier)\n            finalMultiplier = maxMultiplier;\n            \n        //Add new entry to the entries array    \n        if (msg.value < 50 ether)\n            entries.push(Entry(msg.sender, msg.value, (msg.value * (finalMultiplier) / 100), tokensUsed));\n        else\n            entries.push(Entry(msg.sender, 50 ether,((50 ether) * (finalMultiplier) / 100), tokensUsed));\n\n        //Trigger jump event\n        if (msg.value < 50 ether)\n            Jump(msg.sender, msg.value, (msg.value * (finalMultiplier) / 100));\n        else\n            Jump(msg.sender, 50 ether, ((50 ether) * (finalMultiplier) / 100));\n\n        users[msg.sender].rescueTokens -= tokensUsed;\n        \n        //Collect fees and update contract balance\n        balance += (dValue * (100 - jumpFee)) / 100;\n        collectedFees += (dValue * jumpFee) / 100;\n        \n        bool saviour = false;\n        \n        //Pay pending entries if the new balance allows for it\n        while (balance > entries[payoutOrder].payout) {\n            \n            saviour = false;\n            \n            uint entryPayout = entries[payoutOrder].payout;\n            uint entryDeposit = entries[payoutOrder].deposit;\n            uint profit = entryPayout - entryDeposit;\n            uint saviourShare = 0;\n            \n            //Give credit & reward for the rescue if the user saved someone else\n            if (users[msg.sender].addr != entries[payoutOrder].entryAddress)\n            {\n                users[msg.sender].rescueCount++;\n                //Double or triple token bonus if the user is taking a moderate/high risk to help those trapped\n                if (entryDeposit >= 1 ether) {\n                    users[msg.sender].rescueTokens += dValue < 20 || currentEntries < 15 ? 1 : 2;\n                    users[msg.sender].rescueTokens += dValue < 40 || currentEntries < 25 ? 0 : 1;\n                }\n                saviour = true;\n            }\n            \n            bool isHero = false;\n            \n            isHero = entries[payoutOrder].entryAddress == hero;\n            \n            //Share profit with saviour if the gain is substantial enough and the saviour invested enough (hero exempt)\n            if (saviour && !isHero && profit > 20 * entryDeposit / 100 && profit > 100 finney && dValue >= 5 ether)\n            {\n                if (dValue < 10 ether)\n                   saviourShare = 3 + rand(5);\n                else if (dValue >= 10 ether && dValue < 25 ether)\n                  saviourShare = 7 + rand(8);\n                else if (dValue >= 25 ether && dValue < 40 ether)\n                   saviourShare = 12 + rand(13);\n                else if (dValue >= 40 ether)\n                   saviourShare = rand(50);\n                   \n                saviourShare *= profit / 100;\n                   \n                msg.sender.send(saviourShare);\n            }\n            \n            uint payout = entryPayout - saviourShare;\n            entries[payoutOrder].entryAddress.send(payout);\n            \n            //Trigger rescue event\n            Rescue(entries[payoutOrder].entryAddress, msg.sender, payout);\n\n            balance -= entryPayout;\n            usersProfits += entryPayout;\n            \n            rescues++;\n            payoutOrder++;\n        }\n        \n        //Check for new Hero of the Pit\n        if (saviour && users[msg.sender].rescueCount > rescueRecord)\n        {\n            rescueRecord = users[msg.sender].rescueCount;\n            hero = msg.sender;\n            //Trigger new hero event\n            NewHero(msg.sender);\n        }\n    }\n    \n    //Generate random number between 1 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n    \n        return uint256((uint256(hashVal) / factor)) % max + 1;\n    }\n    \n    function addNewUser(address Address) private\n    {\n        if (users[Address].addr == address(0))\n        {\n            users[Address].id = ++uniqueUsers;\n            users[Address].addr = Address;\n            users[Address].nickname = 'UnnamedPlayer';\n            users[Address].rescueCount = 0;\n            users[Address].rescueTokens = 0;\n        }\n    }\n    \n    //Transfer earnings from fees to the owner\n    function collectFees() onlyowner {\n        if (collectedFees == 0) throw;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    //Contract management\n    function changeOwner(address newOwner) onlyowner {\n        owner = newOwner;\n    }\n    \n    function changeBaseMultiplier(uint multi) onlyowner {\n        if (multi < 110 || multi > 150) throw;\n        \n        baseMultiplier = multi;\n    }\n    \n    function changeMaxMultiplier(uint multi) onlyowner {\n        if (multi < 200 || multi > 300) throw;\n        \n        maxMultiplier = multi;\n    }\n    \n    function changeFee(uint fee) onlyowner {\n        if (fee < 0 || fee > 10) throw;\n        \n        jumpFee = fee;\n    }\n    \n    \n    //JSON functions\n    function setNickname(string name) {\n        addNewUser(msg.sender);\n        \n        if (bytes(name).length >= 2 && bytes(name).length <= 16)\n            users[msg.sender].nickname = name;\n    }\n    \n    function currentBalance() constant returns (uint pitBalance, string info) {\n        pitBalance = balance / 1 finney;\n        info = 'The balance of the pit in Finneys (contract balance minus fees).';\n    }\n    \n    function heroOfThePit() constant returns (address theHero, string nickname, uint peopleSaved, string info) {\n        theHero = hero;  \n        nickname = users[theHero].nickname;\n        peopleSaved = rescueRecord;\n        info = 'The current rescue record holder. All hail!';\n    }\n    \n    function userName(address Address) constant returns (string nickname) {\n        nickname = users[Address].nickname;\n    }\n    \n    function totalRescues() constant returns (uint rescueCount, string info) {\n        rescueCount = rescues;\n        info = 'The number of times that people have been rescued from the pit (aka the number of times people made a profit).';\n    }\n    \n    function multipliers() constant returns (uint BaseMultiplier, uint MaxMultiplier, string info) {\n        BaseMultiplier = baseMultiplier;\n        MaxMultiplier = maxMultiplier;\n        info = 'The multipliers applied to all deposits: the final multiplier is a random number between the multpliers shown divided by 100. By default x1.1~x1.5 (up to x2 if rescue tokens are used, granting +0.1 per token). It determines the amount of money you will get when rescued (a saviour share might be deducted).';\n    }\n    \n    function pitFee() constant returns (uint feePercentage, string info) {\n        feePercentage = jumpFee;\n        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 10%).';\n    }\n    \n    function nextPayoutGoal() constant returns (uint finneys, string info) {\n        finneys = (entries[payoutOrder].payout - balance) / 1 finney;\n        info = 'The amount of Finneys (Ethers * 1000) that need to be deposited for the next payout to be executed.';\n    }\n    \n    function unclaimedFees() constant returns (uint ethers, string info) {\n        ethers = collectedFees / 1 ether;\n        info = 'The amount of Ethers obtained through fees that have not yet been collected by the owner.';\n    }\n    \n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = 'The number of times that people have jumped into the pit.';\n    }\n    \n    function totalUsers() constant returns (uint users, string info) {\n        users = uniqueUsers;\n        info = 'The number of unique users that have joined the pit.';\n    }\n    \n    function awaitingPayout() constant returns (uint count, string info) {\n        count = entries.length - payoutOrder;\n        info = 'The number of people waiting to be saved.';\n    }\n    \n    function entryDetails(uint index) constant returns (address user, string nickName, uint deposit, uint payout, uint tokensUsed, string info)\n    {\n        if (index <= entries.length) {\n            user = entries[index].entryAddress;\n            nickName = users[entries[index].entryAddress].nickname;\n            deposit = entries[index].deposit / 1 finney;\n            payout = entries[index].payout / 1 finney;\n            tokensUsed = entries[index].tokens;\n            info = 'Entry info: user address, name, expected payout in Finneys (approximate), rescue tokens used.';\n        }\n    }\n    \n    function userId(address user) constant returns (uint id, string info) {\n        id = users[user].id;\n        info = 'The id of the user, represents the order in which he first joined the pit.';\n    }\n    \n    function userTokens(address user) constant returns (uint tokens, string info) {\n        tokens = users[user].addr != address(0x0) ? users[user].rescueTokens : 0;\n        info = 'The number of Rescue Tokens the user has. Tokens are awarded when your deposits save people, and used automatically on your next deposit. They provide a 0.1 multiplier increase per token. (+0.5 max)';\n    }\n    \n    function userRescues(address user) constant returns(uint rescueCount, string info) {\n        rescueCount = users[user].addr != address(0x0) ? users[user].rescueCount : 0;\n        info = 'The number of times the user has rescued someone from the pit.';\n    }\n    \n    function userProfits() constant returns(uint profits, string info) {\n        profits = usersProfits / 1 finney;\n        info = 'The combined earnings of all users in Finney.';\n    }\n    \n    //Destroy the contract after ~3 months of inactivity at the owner's discretion\n    function recycle() onlyowner\n    {\n        if (now >= timeOfLastDeposit + 10 weeks) \n        { \n            //Refund the current balance\n            if (balance > 0) \n            {\n                entries[0].entryAddress.send(balance);\n            }\n            \n            //Destroy the contract\n            selfdestruct(owner);\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1228913,0xb4f24b85a6e8f2e122c461eb23802694105cfc48,false,false,,,,TOO_SHORT
1228976,0x08bceb8fda8f48f8003c9658049b8ec4092b100d,false,false,,,,TOO_SHORT
1229251,0xcb25d621f5f9dda3df404c4f0198e59f89147b62,false,false,,,,TOO_SHORT
1229383,0xb516dd4a9098aabf2c5fd2155915e3a096f2f39d,false,false,,,,TOO_SHORT
1229912,0xf93ad841473d04f7ce4627ed8cc61a2aabd44905,false,false,,,,TOO_SHORT
1230029,0x1f40b46ba7edd85e6959e62d32db44666435750f,false,false,,,,TOO_SHORT
1230331,0xd469e8da1aeb6e68da95723d471eb569fe1a474a,false,false,,,,TOO_SHORT
1230707,0x79bab416e097e5e63db6a70d1548bd2d6697498b,false,false,,,,TOO_SHORT
1231081,0x8a99399e95afc89c235bcfd78dfdbb5f694670fd,false,false,,,,TOO_SHORT
1231567,0x0f191a42ae4c95992107a85d01e790622018914b,false,false,,,,TOO_SHORT
1231919,0x7c270f3d1182b7f4caa33e121e1e157e8016f670,false,false,,,,TOO_SHORT
1232085,0x35f2b65ea822dae38ca5f460942a732430aa7fbf,false,false,,,,TOO_SHORT
1232231,0x358e0cb62a05171a747d1d1f6923536824c122d3,false,false,,,,TOO_SHORT
1232281,0x6221282bba5c9932b17cd24c0bff60735715d2e3,false,false,,,,TOO_SHORT
1232612,0x4fa645a0b8a179df758ee42b212f5b64b9b2f9ab,false,false,,,,TOO_SHORT
1233037,0x6266a3a892c697833a02b81db24d8fb91781d79a,false,false,,,,TOO_SHORT
1233060,0x7f83de036346b09418966de5591652f39b322022,false,false,,,,TOO_SHORT
1233067,0x21501e86f9baa3caf54b886e1770c8817f133add,false,false,,,,TOO_SHORT
1233134,0xb7ea2d30e452ac683d1f5c242d78c84842d75c04,false,false,,,,TOO_SHORT
1233252,0x357b6b0efcdaa648ff04447c17bcdea00d580609,false,false,,,,TOO_SHORT
1233551,0x5f0285576c6b0d1b4fb2c2abb8402210c93cbf76,false,false,,,,TOO_SHORT
1233576,0x9dc021f18f0989de48d44247ab6968adcfd09f26,false,false,,,,TOO_SHORT
1233626,0xc9fa859aefec83b89116292512bd51c734278d17,false,false,,,,TOO_SHORT
1233702,0xb07ac386a25714ce6a8f5fad2a1ce1bbc337d9e8,false,false,,,,TOO_SHORT
1233810,0xd58f74367f3950cc7b7f86c2518fc98367411dec,false,false,,,,TOO_SHORT
1233919,0x62360b1338ac5dfcd1a5adad2ce792e9c1caadb6,false,false,,,,TOO_SHORT
1233952,0x4ba0e2869c82433210f0c7cd2325251999971def,false,false,,,,TOO_SHORT
1234283,0x1120323faef4f6e046c61dbda1b0f06b192fcbb0,false,false,,,,TOO_SHORT
1234343,0x473e90ca71e8459e37ed45331130f5851115fb64,false,false,,,,TOO_SHORT
1234460,0x77b21df80e73fdb4728b7af7e08207fb989f6b0f,false,false,,,,TOO_SHORT
1234678,0x44799d09cb3b7e764033f205c55fb31d7679e40c,false,false,,,,TOO_SHORT
1234823,0x92e787a2856c97e027d836884a98080846e6d310,false,false,,,,TOO_SHORT
1234921,0x170d353d52bb4d154d713d73ac2e0617a829bf23,false,false,,,,TOO_SHORT
1235034,0xd668aa4cd6db46ddaf4337b0496115224c7daebd,false,false,,,,TOO_SHORT
1235185,0xabc6ea2df9b2e73144f1ecd30ca09a70aaef8a1d,false,false,,,,TOO_SHORT
1235187,0xeef96c881604dd7e19dff9f7b1930770b3b600a5,false,false,,,,TOO_SHORT
1235412,0xa5cb0d1a5e2a555662c9e9676487ea44c152fcc7,false,false,,,,TOO_SHORT
1235509,0xe7e3da4608f43fc185463f142bc80c0c9c8569d8,false,false,,,,TOO_SHORT
1235725,0xaa6926ad5294beead7ebe72fc21feaabdad52d55,false,false,,,,TOO_SHORT
1235728,0xcf03313d881f7b0e7c5f51b16cc1e11c93df7a99,false,false,,,,TOO_SHORT
1235821,0x0061a50f655561e9c4fae06bc868f59c248622bc,false,false,,,,TOO_SHORT
1235894,0x283ca15e8d7dad2d812deba810f2fcfea744bf87,false,false,,,,TOO_SHORT
1236063,0x13124d09fe96fa7d9732c1807fce7bbdf9d6e168,false,false,,,,TOO_SHORT
1236134,0x0e57202fc5ca04214785da7e43177e3f53446f56,false,false,,,,TOO_SHORT
1236196,0xc7ea3b192c8adefedf60788f5497fb2dced11536,false,false,,,,TOO_SHORT
1236251,0x84a1d9564d98dbf7ac8c9b93c103987a26db82e9,false,false,,,,TOO_SHORT
1236255,0x0def2f9824b6ed08fcac6f07787846ec1c331b38,false,false,,,,TOO_SHORT
1236275,0xd14a7a110cfdd57fd3f0cb0c994160b6bf5ee3d8,false,false,,,,TOO_SHORT
1236520,0x47aaae332e63384ff50ec5152cd6975ecb543112,false,false,,,,TOO_SHORT
1236577,0xaf8fe8376cc33bb61d6783521b547025754f1303,false,false,,,,TOO_SHORT
1237008,0xe4391d6b5e764ecc9bdf4a04b350ee73e21953d1,false,false,,,,TOO_SHORT
1237132,0x42cc2c6e673fd69d3a448e48263e07b09cde747e,false,false,,,,TOO_SHORT
1237319,0x07b55fba81a7bfff24505bff92d8b8ae5e31b31c,false,false,,,,TOO_SHORT
1237419,0x212de5357eec10d563172f4d679fab20e97aa83e,false,false,,,,TOO_SHORT
1237458,0xf4633164fa04c091d926c9429b40b0863b33c685,false,false,,,,TOO_SHORT
1237599,0x7753a9d834844cfde5c211ec3912b49f0d8b8e11,false,false,"// Welcome to * Bet On Hash *\n//\n// this is a round based bet game\n// a round consists of 6 players\n// \n// you bet on the first byte of the last (6th) players blockhash (unpredictable, 50% chance)\n// \n// ** to join: send one byte data (0x01 or 0x81) with a bet amount of 0.1 ether (100 finney) to the contract address\n// \n// if your data byte is less than 0x80 you bet the blockhashs first byte is < 0x80\n// if your data byte is greater than or equal 0x80 you bet the blockhashs first byte is >= 0x80\n// \n// if you lose your bet your bet amount goes to the pool for winners\n// \n// if you win your bet:\n// 	* you will get back 100% of your payment\n// 	* you will win a proportional part of the winner pool (win amount = winner pool / winners - 1%) \n// \n// payout is triggered when a player starts the next round\n// \n// additional rules:\n// each address can only play once per round\n// every additional payment during the same round will be paid back immediatly\n// every payment below the bet value is considered as a donation for the winner pool\n// every amount that is exceeding the bet value will be paid back\n// if nobody wins in a round, the paid amounts will raise the winner pool for the next round\n//\n// ** if you pay to the contract, you agree that you may lose (50% chance!) the paid amount **\n\n\ncontract BetOnHashV81 {\n  struct Player {\n    address addr;\n    byte bet;\n  }\n  \n  Player[] public players;\n  bool public active;\n  uint public betAmount;\n  uint public playersPerRound;\n  uint public round;\n  uint public winPool;\n  byte public betByte;\n\n  uint lastPlayersBlockNumber;\n  address owner;\n  \n  modifier onlyowner { if (msg.sender == owner) _ }\n  \n  function BetOnHashV81() {\n    owner = msg.sender;\n    betAmount = 100 finney;\n    round = 1;\n    playersPerRound = 6;\n    active = true;\n    winPool = 0;\n  }\n  \n  function finishRound() internal {\n    //get block hash of last player\n    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);\n    betByte = byte(betHash);\n    byte bet;\n    uint8 ix; \n    \n    //check win or loss, calculate winnPool\n    address[] memory winners = new address[](playersPerRound);\n    uint8 numWinners=0;\n    for(ix=0; ix < players.length; ix++) {\n      Player p = players[ix];\n      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {\n        //player won\n        winners[numWinners++] = p.addr;\n      } \n      else winPool += betAmount;\n    }\n    \n    //calculate winners payouts and pay out\n    if(numWinners > 0) {\n      uint winAmount = (winPool / numWinners) * 99 / 100;\n      for(ix = 0; ix < numWinners; ix++) {\n        if(!winners[ix].send(betAmount + winAmount)) throw;\n      }\n      winPool = 0;\n    }\n    \n    //start next round\n    round++;\n    delete players;\n  }\n  \n  function reject() internal {\n    msg.sender.send(msg.value);\n  }\n  \n  function join() internal {\n  \n    //finish round if next players block is above last players block\n    if(players.length >= playersPerRound) { \n      if(block.number > lastPlayersBlockNumber) finishRound(); \n      else {reject(); return;}  //too many players in one block -> pay back\n    }\n\n    //payments below bet amount are considered as donation for the winner pool\n    if(msg.value < betAmount) {\n      winPool += msg.value; \n      return;\n    }\n    \n    //no data sent -> pay back\n    if(msg.data.length < 1) {reject();return;}\n    \n    //prevent players to play more than once per round:\n    for(uint8 i = 0; i < players.length; i++)\n      if(msg.sender == players[i].addr) {reject(); return;}\n    \n    //to much paid -> pay back all above bet amount\n    if(msg.value > betAmount) {\n      msg.sender.send(msg.value - betAmount);\n    }\n    \n    //register player\n    players.push( Player(msg.sender, msg.data[0]) );\n    lastPlayersBlockNumber = block.number;\n  }\n  \n  function () {\n    if(active) join();\n    else throw;\n  }\n  \n  function forceFinish() onlyowner {\n    if(players.length > 0) finishRound();\n  }\n  \n  function paybackLast() onlyowner returns (bool) {\n    if(players.length == 0) return true;\n    if (players[players.length - 1].addr.send(betAmount)) {\n      players.length--;\n      return true;\n    }\n    return false;\n  }\n  \n  //if something goes wrong, the owner can trigger pay back\n  function paybackAll() onlyowner returns (bool) {\n    while(players.length > 0) {if(!paybackLast()) return false;}\n    return true;\n  }\n  \n  function collectFees() onlyowner {\n    uint playersEther = winPool;\n    uint8 ix;\n    for(ix=0; ix < players.length; ix++) playersEther += betAmount;\n    uint fees = this.balance - playersEther;\n    if(fees > 0) owner.send(fees);\n  }\n  \n  function changeOwner(address _owner) onlyowner {\n    owner = _owner;\n  }\n  \n  function setPlayersPerRound(uint num) onlyowner {\n    if(players.length > 0) finishRound();\n    playersPerRound = num;\n  }\n  \n  function stop() onlyowner {\n    active = false;\n    paybackAll();\n  }\n\n  //contract can only be destructed if all payments where paid back  \n  function kill() onlyowner {\n    if(!active && paybackAll()) \n      selfdestruct(owner);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心で芸術性は低い。,
1237679,0x6c3e796f51c2eb581fe20e43a3b5c284a77453f2,false,false,,,,TOO_SHORT
1237803,0x58804f040886a482ca49e55c90cb132194819d9e,false,false,,,,TOO_SHORT
1238408,0xc6cf818a9e7faccda238654985f653dd84c00eff,false,false,,,,TOO_SHORT
1238845,0xfbf4dd8fe009741c4a71873f96774271bffd1556,false,false,,,,TOO_SHORT
1238910,0x95ffc1a88ec5d3f7b59da54d97c812861ac96e8f,false,false,,,,TOO_SHORT
1239091,0x6f41ae11293b495d970e20d0007f8c93e6e4263b,false,false,,,,TOO_SHORT
1239208,0xf0160428a8552ac9bb7e050d90eeade4ddd52843,false,false,"/// @title DigixDAO Contract Interfaces\n\ncontract ConfigInterface {\n  address public owner;\n  mapping (address => bool) admins;\n  mapping (bytes32 => address) addressMap;\n  mapping (bytes32 => bool) boolMap;\n  mapping (bytes32 => bytes32) bytesMap;\n  mapping (bytes32 => uint256) uintMap;\n\n  /// @notice setConfigAddress sets configuration `_key` to `_val` \n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigAddress(bytes32 _key, address _val) returns (bool success);\n\n  /// @notice setConfigBool sets configuration `_key` to `_val` \n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigBool(bytes32 _key, bool _val) returns (bool success);\n\n  /// @notice setConfigBytes sets configuration `_key` to `_val`\n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigBytes(bytes32 _key, bytes32 _val) returns (bool success);\n\n  /// @notice setConfigUint `_key` to `_val`\n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigUint(bytes32 _key, uint256 _val) returns (bool success);\n\n  /// @notice getConfigAddress gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigAddress(bytes32 _key) returns (address val);\n\n  /// @notice getConfigBool gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigBool(bytes32 _key) returns (bool val);\n\n  /// @notice getConfigBytes gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigBytes(bytes32 _key) returns (bytes32 val);\n\n  /// @notice getConfigUint gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigUint(bytes32 _key) returns (uint256 val);\n\n  /// @notice addAdmin sets `_admin` as configuration admin\n  /// @return Whether the configuration setting was successful or not.  \n  function addAdmin(address _admin) returns (bool success);\n\n  /// @notice removeAdmin removes  `_admin`'s rights\n  /// @param _admin The key name of the configuration.\n  /// @return Whether the configuration setting was successful or not.  \n  function removeAdmin(address _admin) returns (bool success);\n\n}\n\ncontract TokenInterface {\n\n  struct User {\n    bool locked;\n    uint256 balance;\n    uint256 badges;\n    mapping (address => uint256) allowed;\n  }\n\n  mapping (address => User) users;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n  mapping (address => bool) seller;\n\n  address config;\n  address owner;\n  address dao;\n  bool locked;\n\n  /// @return total amount of tokens\n  uint256 public totalSupply;\n  uint256 public totalBadges;\n\n  /// @param _owner The address from which the balance will be retrieved\n  /// @return The balance\n  function balanceOf(address _owner) constant returns (uint256 balance);\n\n  /// @param _owner The address from which the badge count will be retrieved\n  /// @return The badges count\n  function badgesOf(address _owner) constant returns (uint256 badge);\n\n  /// @notice send `_value` tokens to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transfer(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` badges to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function sendBadge(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n  /// @param _from The address of the sender\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @param _value The amount of tokens to be approved for transfer\n  /// @return Whether the approval was successful or not\n  function approve(address _spender, uint256 _value) returns (bool success);\n\n  /// @param _owner The address of the account owning tokens\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n  /// @notice mint `_amount` of tokens to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mint(address _owner, uint256 _amount) returns (bool success);\n\n  /// @notice mintBadge Mint `_amount` badges to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n\n  function registerDao(address _dao) returns (bool success);\n\n  function registerSeller(address _tokensales) returns (bool success);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract TokenSalesInterface {\n\n  struct SaleProxy {\n    address payout;\n    bool isProxy;\n  }\n\n  struct SaleStatus {\n    bool founderClaim;\n    uint256 releasedTokens;\n    uint256 releasedBadges;\n    uint256 claimers;\n  }\n\n  struct Info {\n    uint256 totalWei;\n    uint256 totalCents;\n    uint256 realCents;\n    uint256 amount;\n  }\n\n  struct SaleConfig {\n    uint256 startDate;\n    uint256 periodTwo;\n    uint256 periodThree;\n    uint256 endDate;\n    uint256 goal;\n    uint256 cap;\n    uint256 badgeCost;\n    uint256 founderAmount;\n    address founderWallet;\n  }\n\n  struct Buyer {\n    uint256 centsTotal;\n    uint256 weiTotal;\n    bool claimed;\n  }\n\n  Info saleInfo;\n  SaleConfig saleConfig;\n  SaleStatus saleStatus;\n\n  address config;\n  address owner;\n  bool locked;\n\n  uint256 public ethToCents;\n\n  mapping (address => Buyer) buyers;\n  mapping (address => SaleProxy) proxies;\n\n  /// @notice Calculates the parts per billion 1â„1,000,000,000 of `_a` to `_b`\n  /// @param _a The antecedent\n  /// @param _c The consequent\n  /// @return Part per billion value\n  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b);\n\n\n  /// @notice Calculates the share from `_total` based on `_contrib` \n  /// @param _contrib The contributed amount in USD\n  /// @param _total The total amount raised in USD\n  /// @return Total number of shares\n  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share);\n\n  /// @notice Calculates the current USD cents value of `_wei` \n  /// @param _wei the amount of wei\n  /// @return The USD cents value\n  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue);\n\n  function proxyPurchase(address _user) returns (bool success);\n\n  /// @notice Send msg.value purchase for _user.  \n  /// @param _user The account to be credited\n  /// @return Success if purchase was accepted\n  function purchase(address _user, uint256 _amount) private returns (bool success);\n\n  /// @notice Get crowdsale information for `_user`\n  /// @param _user The account to be queried\n  /// @return `centstotal` the total amount of USD cents contributed\n  /// @return `weitotal` the total amount in wei contributed\n  /// @return `share` the current token shares earned\n  /// @return `badges` the number of proposer badges earned\n  /// @return `claimed` is true if the tokens and badges have been claimed\n  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n\n  /// @notice Get the crowdsale information from msg.sender (see userInfo)\n  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n\n  /// @notice get the total amount of wei raised for the crowdsale\n  /// @return The amount of wei raised\n  function totalWei() public constant returns (uint);\n\n  /// @notice get the total USD value in cents raised for the crowdsale\n  /// @return the amount USD cents\n  function totalCents() public constant returns (uint);\n\n  /// @notice get the current crowdsale information\n  /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n  /// @return `two` The unix timestamp for the start of the second period modifier\n  /// @return `three` The unix timestamp for the start of the third period modifier\n  /// @return `endsale` The unix timestamp of the end of crowdsale\n  /// @return `totalwei` The total amount of wei raised\n  /// @return `totalcents` The total number of USD cents raised\n  /// @return `amount` The amount of DGD tokens available for the crowdsale\n  /// @return `goal` The USD value goal for the crowdsale\n  /// @return `famount` Founders endowment\n  /// @return `faddress` Founder wallet address\n  /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n\n  function claimFor(address _user) returns (bool success); \n\n  /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n  function claim() returns (bool success);\n\n  function claimFounders() returns (bool success);\n\n  /// @notice See if the crowdsale goal has been reached\n  function goalReached() public constant returns (bool reached);\n\n  /// @notice Get the current sale period\n  /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n  function getPeriod() public constant returns (uint saleperiod);\n\n  /// @notice Get the date for the start of the crowdsale\n  /// @return `date` The unix timestamp for the start\n  function startDate() public constant returns (uint date);\n  \n  /// @notice Get the date for the second reward period of the crowdsale\n  /// @return `date` The unix timestamp for the second period\n  function periodTwo() public constant returns (uint date);\n\n  /// @notice Get the date for the final period of the crowdsale\n  /// @return `date` The unix timestamp for the final period\n  function periodThree() public constant returns (uint date);\n\n  /// @notice Get the date for the end of the crowdsale\n  /// @return `date` The unix timestamp for the end of the crowdsale\n  function endDate() public constant returns (uint date);\n\n  /// @notice Check if crowdsale has ended\n  /// @return `ended` If the crowdsale has ended\n  \n  function isEnded() public constant returns (bool ended);\n\n  /// @notice Send raised funds from the crowdsale to the DAO\n  /// @return `success` if the send succeeded\n  function sendFunds() public returns (bool success);\n\n  //function regProxy(address _payment, address _payout) returns (bool success);\n  function regProxy(address _payout) returns (bool success);\n\n  function getProxy(address _payout) public returns (address proxy);\n  \n  function getPayout(address _proxy) public returns (address payout, bool isproxy);\n\n  function unlock() public returns (bool success);\n\n  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n\n  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n\n  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n  \n  event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n  event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n\n}\n\ncontract ProxyPayment {\n\n  address payout;\n  address tokenSales; \n  address owner;\n\n  function ProxyPayment(address _payout, address _tokenSales) {\n    payout = _payout;\n    tokenSales = _tokenSales;\n    owner = _payout;\n  }\n\n  function () {\n    if (!TokenSalesInterface(tokenSales).proxyPurchase.value(msg.value).gas(106000)(payout)) throw;\n  }\n\n}\n\ncontract TokenSales is TokenSalesInterface {\n\n  modifier ifOwner() {\n    if (msg.sender != owner) throw;\n    _\n  }\n\n  modifier ifOOrigin() {\n    if (tx.origin != owner) throw;\n    _\n  }\n\n  mapping (address => address) proxyPayouts;\n  uint256 public WEI_PER_ETH = 1000000000000000000;\n  uint256 public BILLION = 1000000000;\n  uint256 public CENTS = 100;\n\n\n  function TokenSales(address _config) {\n    owner = msg.sender;\n    config = _config;\n    saleStatus.founderClaim = false;\n    saleStatus.releasedTokens = 0;\n    saleStatus.releasedBadges = 0;\n    saleStatus.claimers = 0;\n    saleConfig.startDate = ConfigInterface(_config).getConfigUint(""sale1:period1"");\n    saleConfig.periodTwo = ConfigInterface(_config).getConfigUint(""sale1:period2"");\n    saleConfig.periodThree = ConfigInterface(_config).getConfigUint(""sale1:period3"");\n    saleConfig.endDate = ConfigInterface(_config).getConfigUint(""sale1:end"");\n    saleConfig.founderAmount = ConfigInterface(_config).getConfigUint(""sale1:famount"") * BILLION;\n    saleConfig.founderWallet = ConfigInterface(_config).getConfigAddress(""sale1:fwallet"");\n    saleConfig.goal = ConfigInterface(_config).getConfigUint(""sale1:goal"") * CENTS;\n    saleConfig.cap = ConfigInterface(_config).getConfigUint(""sale1:cap"") * CENTS;\n    saleConfig.badgeCost = ConfigInterface(_config).getConfigUint(""sale1:badgecost"") * CENTS;\n    saleInfo.amount = ConfigInterface(_config).getConfigUint(""sale1:amount"") * BILLION;\n    saleInfo.totalWei = 0;\n    saleInfo.totalCents = 0;\n    saleInfo.realCents;\n    saleStatus.founderClaim = false;\n    locked = true;\n  }\n\n  function () {\n    if (getPeriod() == 0) throw;\n    uint256 _amount = msg.value;\n    address _sender;\n    if (proxies[msg.sender].isProxy == true) {\n      _sender = proxies[msg.sender].payout;\n    } else {\n      _sender = msg.sender;\n    }\n    if (!purchase(_sender, _amount)) throw;\n  }\n\n  function proxyPurchase(address _user) returns (bool success) {\n    return purchase(_user, msg.value);\n  }\n\n  function purchase(address _user, uint256 _amount) private returns (bool success) {\n    uint256 _cents = weiToCents(_amount);\n    if ((saleInfo.realCents + _cents) > saleConfig.cap) return false;\n    uint256 _wei = _amount;\n    uint256 _modifier;\n    uint _period = getPeriod();\n    if ((_period == 0) || (_cents == 0)) {\n      return false;\n    } else {\n      if (_period == 3) _modifier = 100;\n      if (_period == 2) _modifier = 115;\n      if (_period == 1) _modifier = 130;\n      uint256 _creditwei = _amount;\n      uint256 _creditcents = (weiToCents(_creditwei) * _modifier * 10000) / 1000000 ;\n      buyers[_user].centsTotal += _creditcents;\n      buyers[_user].weiTotal += _creditwei; \n      saleInfo.totalCents += _creditcents;\n      saleInfo.realCents += _cents;\n      saleInfo.totalWei += _creditwei;\n      Purchase(ethToCents, _modifier, _creditcents); \n      return true;\n    }\n  }\n\n  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b) {\n    b = (BILLION * _a + _c / 2) / _c;\n    return b;\n  }\n\n  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share) {\n    uint256 _ppb = ppb(_contrib, _total);\n    share = ((_ppb * saleInfo.amount) / BILLION);\n    return share;\n  }\n\n  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue) {\n    centsvalue = ((_wei * 100000 / WEI_PER_ETH) * ethToCents) / 100000;\n    return centsvalue;\n  }\n\n  function setEthToCents(uint256 _eth) ifOwner returns (bool success) {\n    ethToCents = _eth;\n    success = true;\n    return success;\n  }\n\n\n  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers) {\n    return (saleStatus.founderClaim, saleStatus.releasedTokens, saleStatus.releasedBadges, saleStatus.claimers);\n  }\n\n  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount) {\n    return (saleInfo.totalWei, saleInfo.totalCents, saleInfo.realCents, saleInfo.amount);\n  }\n\n\n  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet) {\n    return (saleConfig.startDate, saleConfig.periodTwo, saleConfig.periodThree, saleConfig.endDate, saleConfig.goal, saleConfig.cap, saleConfig.badgeCost, saleConfig.founderAmount, saleConfig.founderWallet);\n  }\n\n  function goalReached() public constant returns (bool reached) {\n    reached = (saleInfo.totalCents >= saleConfig.goal);\n    return reached;\n  }\n\n  function claim() returns (bool success) {\n    return claimFor(msg.sender);\n  }\n\n  function claimFor(address _user) returns (bool success) {\n    if ( (now < saleConfig.endDate) || (buyers[_user].claimed == true) ) {\n      return true;\n    }\n  \n    if (!goalReached()) {\n      if (!address(_user).send(buyers[_user].weiTotal)) throw;\n      buyers[_user].claimed = true;\n      return true;\n    }\n\n    if (goalReached()) {\n      address _tokenc = ConfigInterface(config).getConfigAddress(""ledger"");\n      uint256 _tokens = calcShare(buyers[_user].centsTotal, saleInfo.totalCents); \n      uint256 _badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n      if ((TokenInterface(_tokenc).mint(msg.sender, _tokens)) && (TokenInterface(_tokenc).mintBadge(_user, _badges))) {\n        saleStatus.releasedTokens += _tokens;\n        saleStatus.releasedBadges += _badges;\n        saleStatus.claimers += 1;\n        buyers[_user].claimed = true;\n        Claim(_user, _tokens, _badges);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n  }\n\n  function claimFounders() returns (bool success) {\n    if (saleStatus.founderClaim == true) return false;\n    if (now < saleConfig.endDate) return false;\n    if (!goalReached()) return false;\n    address _tokenc = ConfigInterface(config).getConfigAddress(""ledger"");\n    uint256 _tokens = saleConfig.founderAmount;\n    uint256 _badges = 4;\n    address _faddr = saleConfig.founderWallet;\n    if ((TokenInterface(_tokenc).mint(_faddr, _tokens)) && (TokenInterface(_tokenc).mintBadge(_faddr, _badges))) {\n      saleStatus.founderClaim = true;\n      saleStatus.releasedTokens += _tokens;\n      saleStatus.releasedBadges += _badges;\n      saleStatus.claimers += 1;\n      Claim(_faddr, _tokens, _badges);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function getPeriod() public constant returns (uint saleperiod) {\n    if ((now > saleConfig.endDate) || (now < saleConfig.startDate)) {\n      saleperiod = 0;\n      return saleperiod;\n    }\n    if (now >= saleConfig.periodThree) {\n      saleperiod = 3;\n      return saleperiod;\n    }\n    if (now >= saleConfig.periodTwo) {\n      saleperiod = 2;\n      return saleperiod;\n    }\n    if (now < saleConfig.periodTwo) {\n      saleperiod = 1;\n      return saleperiod;\n    }\n  }\n\n  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n    share = calcShare(buyers[_user].centsTotal, saleInfo.totalCents);\n    badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n    return (buyers[_user].centsTotal, buyers[_user].weiTotal, share, badges, buyers[_user].claimed);\n  }\n\n  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n    return userInfo(msg.sender);\n  }\n\n  function totalWei() public constant returns (uint) {\n    return saleInfo.totalWei;\n  }\n\n  function totalCents() public constant returns (uint) {\n    return saleInfo.totalCents;\n  }\n\n  function startDate() public constant returns (uint date) {\n    return saleConfig.startDate;\n  }\n  \n  function periodTwo() public constant returns (uint date) {\n    return saleConfig.periodTwo;\n  }\n\n  function periodThree() public constant returns (uint date) {\n    return saleConfig.periodThree;\n  }\n\n  function endDate() public constant returns (uint date) {\n    return saleConfig.endDate;\n  }\n\n  function isEnded() public constant returns (bool ended) {\n    return (now >= endDate());\n  }\n  \n  function sendFunds() public returns (bool success) {\n    if (locked) return false;\n    if (!goalReached()) return false;\n    if (!isEnded()) return false;\n    address _dao = ConfigInterface(config).getConfigAddress(""sale1:dao"");\n    if (_dao == 0x0000000000000000000000000000000000000000) return false;\n    return _dao.send(totalWei());\n  }\n\n  function regProxy(address _payout) ifOOrigin returns (bool success) {\n    address _proxy = new ProxyPayment(_payout, address(this));\n    proxies[_proxy].payout = _payout;\n    proxies[_proxy].isProxy = true;\n    proxyPayouts[_payout] = _proxy;\n    return true;\n  }\n  \n  function getProxy(address _payout) public returns (address proxy) {\n    return proxyPayouts[_payout];\n  }\n\n  function getPayout(address _proxy) public returns (address payout, bool isproxy) {\n    return (proxies[_proxy].payout, proxies[_proxy].isProxy);\n  }\n\n  function unlock() ifOwner public returns (bool success) {\n    locked = false;\n    return true;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。多くの機能を持つが、芸術的要素は少ない。,
1239468,0x13f4830562156048ed4579d4060504c22ae1a5db,false,false,,,,TOO_SHORT
1239470,0x33429f9fbc92f6f9394806b9a54fd4b2c70f065e,false,false,,,,TOO_SHORT
1239580,0x089875173b99398a251ec8c1b8e7e3f364d3c122,false,false,,,,TOO_SHORT
1239611,0xf668f53ef0326f4ed65b8a10f76e8ce34b12a771,false,false,,,,TOO_SHORT
1239866,0x7b009481b6070ae406616ba944ce4e2a83e8606f,false,false,,,,TOO_SHORT
1240106,0xaa667ec025f5deeeac0cdc3e509a4648d0438bff,false,false,,,,TOO_SHORT
1240165,0x8739bdf0169fba167a792b9f22abf0c6b71db863,false,false,,,,TOO_SHORT
1240289,0xa1713abdd2ad18166041b868ca920291341c7088,false,false,,,,TOO_SHORT
1240402,0xc98cf7c84b00cc6c78e86be3aa90ba1e619f60d4,false,false,,,,TOO_SHORT
1240445,0xa3d4d7df3988d48c48728787cb5910a8a4cc4d26,false,false,"contract Etheropt {\n\n  struct Option {\n    int strike;\n  }\n  struct Position {\n    mapping(uint => int) positions;\n    int cash;\n    bool expired;\n    bool hasPosition;\n  }\n  struct OptionChain {\n    uint expiration;\n    string underlying;\n    uint margin;\n    uint realityID;\n    bytes32 factHash;\n    address ethAddr;\n    mapping(uint => Option) options;\n    uint numOptions;\n    bool expired;\n    mapping(address => Position) positions;\n    uint numPositions;\n    uint numPositionsExpired;\n  }\n  mapping(uint => OptionChain) optionChains;\n  uint numOptionChains;\n  struct Account {\n    address user;\n    int capital;\n  }\n  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills\n  struct MarketMaker {\n    address user;\n    string server;\n  }\n  mapping(uint => MarketMaker) marketMakers; //starts at 1\n  uint public numMarketMakers = 0;\n  mapping(address => uint) marketMakerIDs;\n  mapping(uint => Account) accounts;\n  uint public numAccounts;\n  mapping(address => uint) accountIDs; //starts at 1\n\n  function Market() {\n  }\n\n  function getAccountID(address user) constant returns(uint) {\n    return accountIDs[user];\n  }\n\n  function getAccount(uint accountID) constant returns(address) {\n    return accounts[accountID].user;\n  }\n\n  function addFunds() {\n    if (accountIDs[msg.sender]>0) {\n      accounts[accountIDs[msg.sender]].capital += int(msg.value);\n    } else {\n      uint accountID = ++numAccounts;\n      accounts[accountID].user = msg.sender;\n      accounts[accountID].capital += int(msg.value);\n      accountIDs[msg.sender] = accountID;\n    }\n  }\n\n  function withdrawFunds(uint amount) {\n    if (accountIDs[msg.sender]>0) {\n      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {\n        accounts[accountIDs[msg.sender]].capital -= int(amount);\n        msg.sender.send(amount);\n      }\n    }\n  }\n\n  function getFunds(address user, bool onlyAvailable) constant returns(int) {\n    if (accountIDs[user]>0) {\n      if (onlyAvailable == false) {\n        return accounts[accountIDs[user]].capital;\n      } else {\n        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0, 0);\n      }\n    } else {\n      return 0;\n    }\n  }\n\n  function getFundsAndAvailable(address user) constant returns(int, int) {\n    return (getFunds(user, false), getFunds(user, true));\n  }\n\n  function marketMaker(string server) {\n    if (msg.value>0) throw;\n    if (marketMakerIDs[msg.sender]>0) {\n      marketMakers[marketMakerIDs[msg.sender]].server = server;\n    } else {\n      int funds = getFunds(marketMakers[i].user, false);\n      uint marketMakerID = 0;\n      if (numMarketMakers<6) {\n        marketMakerID = ++numMarketMakers;\n      } else {\n        for (uint i=2; i<=numMarketMakers; i++) {\n          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {\n            marketMakerID = i;\n          }\n        }\n      }\n      if (marketMakerID>0) {\n        marketMakerIDs[marketMakers[marketMakerID].user] = 0;\n        marketMakers[marketMakerID].user = msg.sender;\n        marketMakers[marketMakerID].server = server;\n        marketMakerIDs[msg.sender] = marketMakerID;\n      } else {\n        throw;\n      }\n    }\n  }\n\n  function getMarketMakers() constant returns(string, string, string, string, string, string) {\n    string[] memory servers = new string[](6);\n    for (uint i=1; i<=numMarketMakers; i++) {\n      servers[i-1] = marketMakers[i].server;\n    }\n    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);\n  }\n\n  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {\n    int[] memory funds = new int[](6);\n    for (uint i=1; i<=numMarketMakers; i++) {\n      funds[i-1] = getFunds(marketMakers[i].user, false);\n    }\n    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);\n  }\n\n  function getOptionChain(uint optionChainID) constant returns (uint, string, uint, uint, bytes32, address) {\n    return (optionChains[optionChainID].expiration, optionChains[optionChainID].underlying, optionChains[optionChainID].margin, optionChains[optionChainID].realityID, optionChains[optionChainID].factHash, optionChains[optionChainID].ethAddr);\n  }\n\n  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {\n    uint[] memory optionIDs = new uint[](60);\n    int[] memory strikes = new int[](60);\n    int[] memory positions = new int[](60);\n    int[] memory cashes = new int[](60);\n    uint z = 0;\n    for (int optionChainID=int(numOptionChains)-1; optionChainID>=0 && z<60; optionChainID--) {\n      if (optionChains[uint(optionChainID)].expired == false) {\n        for (uint optionID=0; optionID<optionChains[uint(optionChainID)].numOptions; optionID++) {\n          optionIDs[z] = uint(optionChainID)*1000 + optionID;\n          strikes[z] = optionChains[uint(optionChainID)].options[optionID].strike;\n          positions[z] = optionChains[uint(optionChainID)].positions[user].positions[optionID];\n          cashes[z] = optionChains[uint(optionChainID)].positions[user].cash;\n          z++;\n        }\n      }\n    }\n    return (optionIDs, strikes, positions, cashes);\n  }\n\n  function expire(uint accountID, uint optionChainID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {\n    if (optionChains[optionChainID].expired == false) {\n      if (ecrecover(sha3(optionChains[optionChainID].factHash, value), v, r, s) == optionChains[optionChainID].ethAddr) {\n        uint lastAccount = numAccounts;\n        if (accountID==0) {\n          accountID = 1;\n        } else {\n          lastAccount = accountID;\n        }\n        for (accountID=accountID; accountID<=lastAccount; accountID++) {\n          if (optionChains[optionChainID].positions[accounts[accountID].user].expired == false) {\n            int result = optionChains[optionChainID].positions[accounts[accountID].user].cash / 1000000000000000000;\n            for (uint optionID=0; optionID<optionChains[optionChainID].numOptions; optionID++) {\n              int moneyness = getMoneyness(optionChains[optionChainID].options[optionID].strike, uint(value), optionChains[optionChainID].margin);\n              result += moneyness * optionChains[optionChainID].positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;\n            }\n            accounts[accountID].capital = accounts[accountID].capital + result;\n            optionChains[optionChainID].positions[accounts[accountID].user].expired = true;\n            optionChains[optionChainID].numPositionsExpired++;\n          }\n        }\n        if (optionChains[optionChainID].numPositionsExpired == optionChains[optionChainID].numPositions) {\n          optionChains[optionChainID].expired = true;\n        }\n      }\n    }\n  }\n\n  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {\n    if (strike>=0) { //call\n      if (settlement>uint(strike)) {\n        if (settlement-uint(strike)<margin) {\n          return int(settlement-uint(strike));\n        } else {\n          return int(margin);\n        }\n      } else {\n        return 0;\n      }\n    } else { //put\n      if (settlement<uint(-strike)) {\n        if (uint(-strike)-settlement<margin) {\n          return int(uint(-strike)-settlement);\n        } else {\n          return int(margin);\n        }\n      } else {\n        return 0;\n      }\n    }\n  }\n\n  function addOptionChain(uint expiration, string underlying, uint margin, uint realityID, bytes32 factHash, address ethAddr, int[] strikes) {\n    uint optionChainID = 6;\n    if (numOptionChains<6) {\n      optionChainID = numOptionChains++;\n    } else {\n      for (uint i=0; i < numOptionChains && optionChainID>=6; i++) {\n        if (optionChains[i].expired==true || optionChains[i].numPositions==0 || optionChains[i].numOptions==0) {\n          optionChainID = i;\n        }\n      }\n    }\n    if (optionChainID<6) {\n      delete optionChains[optionChainID];\n      optionChains[optionChainID].expiration = expiration;\n      optionChains[optionChainID].underlying = underlying;\n      optionChains[optionChainID].margin = margin;\n      optionChains[optionChainID].realityID = realityID;\n      optionChains[optionChainID].factHash = factHash;\n      optionChains[optionChainID].ethAddr = ethAddr;\n      for (i=0; i < strikes.length; i++) {\n        if (optionChains[optionChainID].numOptions<10) {\n          uint optionID = optionChains[optionChainID].numOptions++;\n          Option option = optionChains[optionChainID].options[i];\n          option.strike = strikes[i];\n          optionChains[optionChainID].options[i] = option;\n        }\n      }\n    }\n  }\n\n  function orderMatchTest(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, int matchSize) constant returns(bool) {\n    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+getMaxLossAfterTrade(sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\n      return true;\n    }\n    return false;\n  }\n\n  function orderMatch(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {\n    bytes32 hash = sha256(optionChainID, optionID, price, size, orderID, blockExpires);\n    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\n      if (optionChains[optionChainID].positions[msg.sender].hasPosition == false) {\n        optionChains[optionChainID].positions[msg.sender].hasPosition = true;\n        optionChains[optionChainID].numPositions++;\n      }\n      if (optionChains[optionChainID].positions[addr].hasPosition == false) {\n        optionChains[optionChainID].positions[addr].hasPosition = true;\n        optionChains[optionChainID].numPositions++;\n      }\n      optionChains[optionChainID].positions[msg.sender].positions[optionID] += matchSize;\n      optionChains[optionChainID].positions[msg.sender].cash -= matchSize * int(price);\n      optionChains[optionChainID].positions[addr].positions[optionID] -= matchSize;\n      optionChains[optionChainID].positions[addr].cash += matchSize * int(price);\n      orderFills[hash] -= matchSize;\n    }\n  }\n\n  function getMaxLossAfterTrade(address user, uint optionChainID, uint optionID, int positionChange, int cashChange) constant returns(int) {\n    int totalMaxLoss = 0;\n    for (uint i=0; i<numOptionChains; i++) {\n      if (optionChains[i].positions[user].expired == false && optionChains[i].numOptions>0) {\n        bool maxLossInitialized = false;\n        int maxLoss = 0;\n        for (uint s=0; s<optionChains[i].numOptions; s++) {\n          int pnl = optionChains[i].positions[user].cash / 1000000000000000000;\n          if (i==optionChainID) {\n            pnl += cashChange / 1000000000000000000;\n          }\n          uint settlement = 0;\n          if (optionChains[i].options[s].strike<0) {\n            settlement = uint(-optionChains[i].options[s].strike);\n          } else {\n            settlement = uint(optionChains[i].options[s].strike);\n          }\n          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\n          if (pnl<maxLoss || maxLossInitialized==false) {\n            maxLossInitialized = true;\n            maxLoss = pnl;\n          }\n          pnl = optionChains[i].positions[user].cash / 1000000000000000000;\n          if (i==optionChainID) {\n            pnl += cashChange / 1000000000000000000;\n          }\n          settlement = 0;\n          if (optionChains[i].options[s].strike<0) {\n            if (uint(-optionChains[i].options[s].strike)>optionChains[i].margin) {\n              settlement = uint(-optionChains[i].options[s].strike)-optionChains[i].margin;\n            } else {\n              settlement = 0;\n            }\n          } else {\n            settlement = uint(optionChains[i].options[s].strike)+optionChains[i].margin;\n          }\n          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\n          if (pnl<maxLoss) {\n            maxLoss = pnl;\n          }\n        }\n        totalMaxLoss += maxLoss;\n      }\n    }\n    return totalMaxLoss;\n  }\n\n  function moneySumAtSettlement(address user, uint optionChainID, uint optionID, int positionChange, uint i, uint settlement) internal returns(int) {\n    int pnl = 0;\n    for (uint j=0; j<optionChains[i].numOptions; j++) {\n      pnl += optionChains[i].positions[user].positions[j] * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\n      if (i==optionChainID && j==optionID) {\n        pnl += positionChange * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\n      }\n    }\n    return pnl;\n  }\n\n  function min(uint a, uint b) constant returns(uint) {\n    if (a<b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1240546,0x82b51573cac2b466ea0a7b78c6c0ae5c8cc31704,false,false,,,,TOO_SHORT
1240606,0x19a6067538c90973ef5dc31ded5fa567f3d09059,false,false,contract FastRealisticPyramid {\n\n        struct Person {\n                address etherAddress;\n                uint amount;\n        }\n\n        Person[] public person;\n\n        uint public payoutIdx = 0;\n        uint public collectedFees;\n        uint public balance = 0;\n\n        address public owner;\n\n        modifier onlyowner {\n                if (msg.sender == owner) _\n        }\n\n\n        function FastRealisticPyramid() {\n                owner = msg.sender;\n        }\n\n\n        function() {\n                enter();\n        }\n\n        function enter() {\n                if (msg.value < 1/100 ether || msg.value > 50) {\n                        msg.sender.send(msg.value);\n                        return;\n                }\n\n\n                uint idx = person.length;\n                person.length += 1;\n                person[idx].etherAddress = msg.sender;\n                person[idx].amount = msg.value;\n\n\n                if (idx != 0) {\n                        collectedFees += msg.value / 10;\n                        balance += msg.value;\n                } else {\n\n                        collectedFees += msg.value;\n                }\n\n\n                if (balance > person[payoutIdx].amount * 7/5) {\n                        uint transactionAmount = 7/5 * (person[payoutIdx].amount - person[payoutIdx].amount / 10);\n                        person[payoutIdx].etherAddress.send(transactionAmount);\n\n                        balance -= person[payoutIdx].amount * 7/5;\n                        payoutIdx += 1;\n                }\n        }\n\n        function collectFees() onlyowner {\n                if (collectedFees == 0) return;\n\n                owner.send(collectedFees);\n                collectedFees = 0;\n        }\n\n        function setOwner(address _owner) onlyowner {\n                owner = _owner;\n        }\n},1,標準的なピラミッドスキームのスマートコントラクトで、実用性が主で芸術性は低いです。,
1240651,0xfe3672eff595cfd36ed05aaf4622d1aec3b5e852,false,false,contract FastRealisticPyramid {\n\n        struct Person {\n                address etherAddress;\n                uint amount;\n        }\n\n        Person[] public person;\n\n        uint public payoutIdx = 0;\n        uint public collectedFees;\n        uint public balance = 0;\n\n        address public owner;\n\n        modifier onlyowner {\n                if (msg.sender == owner) _\n        }\n\n\n        function FastRealisticPyramid() {\n                owner = msg.sender;\n        }\n\n\n        function() {\n                enter();\n        }\n\n        function enter() {\n\n                uint idx = person.length;\n                person.length += 1;\n                person[idx].etherAddress = msg.sender;\n                person[idx].amount = msg.value;\n\n\n                if (idx != 0) {\n                        collectedFees = msg.value / 10;\n						owner.send(collectedFees);\n						collectedFees = 0;\n                        balance = balance + (msg.value * 9/10);\n                } else {\n\n                        balance = msg.value;\n                }\n\n\n                if (balance > person[payoutIdx].amount * 7/5) {\n                        uint transactionAmount = 7/5 * (person[payoutIdx].amount - person[payoutIdx].amount / 10);\n                        person[payoutIdx].etherAddress.send(transactionAmount);\n\n                        balance -= person[payoutIdx].amount * 7/5;\n                        payoutIdx += 1;\n                }\n        }\n\n\n        function setOwner(address _owner) onlyowner {\n                owner = _owner;\n        }\n},1,ピラミッドスキームを実装した実用的なスマートコントラクトで、特に芸術的要素はありません。,
1240725,0xd7e03b9af6f3f55a15e1cd299c8b99b4aae88fbd,false,false,,,,TOO_SHORT
1240818,0x139c644e0c84b9b5b84721694ad6c5d4f20829b5,false,false,,,,TOO_SHORT
1240908,0xe548d5b0d864bab30fcf803a48ef1e194717fe1b,false,false,,,,TOO_SHORT
1240949,0xbf4b2b0e0d5e49f9e49a3e1d2ae58c2cd769795e,false,false,,,,TOO_SHORT
1241120,0x00349a8ef046360862043fedc81d3e413057511f,false,false,,,,TOO_SHORT
1241203,0x52275267d466bed482b793811cbc2efe9b7484a7,false,false,,,,TOO_SHORT
1241212,0xa92ceeb3e509ea8bebbb99e81697c704cab52b85,false,false,,,,TOO_SHORT
1241467,0x64f00e4f726734631914064d789f4949a3f6f219,false,false,,,,TOO_SHORT
1241528,0xf61b5ccb0de4f04ca41724b30b1d2cac1130b433,false,false,,,,TOO_SHORT
1241563,0xcf6aa8143fc600bb7e8831ab20c79fb4746e4677,false,false,,,,TOO_SHORT
1241620,0x55c3306b74a74c8494d3197497f02dada584bbeb,false,false,,,,TOO_SHORT
1241624,0xd98fad9883dbb255f3a2110bb7c8d065f840e6f9,false,false,,,,TOO_SHORT
1241678,0x12734a1ddaaf1d04587c7ef4d4d9dc66d74106bd,false,false,,,,TOO_SHORT
1241686,0x2576029ce0eb7d27e886af93f1d4d95176962fb8,false,false,,,,TOO_SHORT
1241745,0xc021aa143e8904305dccd697c3393be901852219,false,false,,,,TOO_SHORT
1242115,0x13508fc0af43799998d4907a9269033ad68d8a51,false,false,,,,TOO_SHORT
1242226,0x8636aa4222fb4e27d1c7d263470dc27ad0b6f48e,false,false,,,,TOO_SHORT
1242266,0x94e1ced37bf4c124750ea4615691350a1e14ab93,false,false,,,,TOO_SHORT
1242267,0x8ddf9cb45e5f20c0a46f592aa10aeb16d44061d6,false,false,,,,TOO_SHORT
1242487,0xa64b91c342ada90fa65a7379525fa1d3e1a04809,false,false,,,,TOO_SHORT
1242499,0xf544eb2b898b28912335ba70d2753d68a188697b,false,false,,,,TOO_SHORT
1242571,0xb706d01eb7f010328bc354f724476f538a88441b,false,false,,,,TOO_SHORT
1242781,0xe18d10c04c455d94695ab759230d7d25cc5e601a,false,false,,,,TOO_SHORT
1243047,0xcd2dafb7829aeec93b54522236a66c88df4d1879,false,false,,,,TOO_SHORT
1243070,0x7be6ac32c02d3d569736d130998c45ca17712f1b,false,false,,,,TOO_SHORT
1243174,0x98723cef2d9cb5cab402162a85842af3068554a7,false,false,,,,TOO_SHORT
1243590,0xbf16c0b75731737c0d8ac8d1b68b57083dac2e7b,false,false,,,,TOO_SHORT
1244032,0x489d5778440410ae220d647cd4179accfe311ea2,false,false,,,,TOO_SHORT
1244167,0x7970b3704c4a8c58722e5e10b1520f8580b90d32,false,false,,,,TOO_SHORT
1244176,0xfb782f437b3f5a725efb11d1af17a471ca1fbbcb,false,false,,,,TOO_SHORT
1244390,0x28c297d13c407736da5b9aea8c3ced6f1e50eda9,false,false,,,,TOO_SHORT
1244578,0xca11e8ec1db4b75fa733f13abbaad1e85b10e2bb,false,false,,,,TOO_SHORT
1244603,0xe51cafca22d0d215b20189efae20197654b2aee7,false,false,,,,TOO_SHORT
1244613,0xcd19cbc6c27cff12297bd8ace5a25b1487a01926,false,false,,,,TOO_SHORT
1244692,0xec9c3170d2b2bc951393bcdd206aea512a7f2d9a,false,false,,,,TOO_SHORT
1244726,0x03d7253f00add76f56eb8a8eba24428f43e40b96,false,false,,,,TOO_SHORT
1244742,0x036540923156a0e35804a0fc59d8f33449e3a24b,false,false,,,,TOO_SHORT
1244795,0x4f46a4d722c50eea4b9efabe90928bb0e4be3a09,false,false,,,,TOO_SHORT
1244803,0x07cd34dd62976342d1b137001978403fe9064a67,false,false,,,,TOO_SHORT
1244826,0xef58859c3456a3ec59b64df2832c1edc169ca538,false,false,,,,TOO_SHORT
1244894,0x65c9bcb3890cd60ef1def0d6caefbc3349630dff,false,false,,,,TOO_SHORT
1244919,0xfb24df1310f0cb4c12055c2af6fb78b0a7e45ad6,false,false,,,,TOO_SHORT
1244933,0x2274425983a6e9218b9c53ec710f6545d9eb873c,false,false,,,,TOO_SHORT
1244943,0x5ecc2d0e327a84f265d9cc34efa14c1150777082,false,false,,,,TOO_SHORT
1245007,0x6e3130188e50413f7e52c2da2987d089f5719ffa,false,false,,,,TOO_SHORT
1245024,0x5254b9cf6c1c43a99957fa5cdda81b08421c746b,false,false,,,,TOO_SHORT
1245059,0x40a30464456b9efaa2ed450de7c2010956c102c3,false,false,,,,TOO_SHORT
1245123,0x716f5f45c8bfe2272ac4deebf9aefa863063fe21,false,false,,,,TOO_SHORT
1245155,0x45782078865fe44838ab0ffd4d1c6bbdbf8de6ce,false,false,,,,TOO_SHORT
1245212,0x1f57f97e40f2141724fea8c2c20cc521d8c16df8,false,false,,,,TOO_SHORT
1245269,0x7fa69f4a6c68c0cfc41d8fe711478658e5f2885c,false,false,,,,TOO_SHORT
1245279,0x520893804dae466ba667a9f4fcd13a9eb7e71216,false,false,,,,TOO_SHORT
1245306,0x909f0d86732488358f487c5efcefc0356aacf8fb,false,false,,,,TOO_SHORT
1245316,0x2a8fdf032dd9f4c73901dcd94aed4823a7f0cb88,false,false,,,,TOO_SHORT
1245410,0x9d544ed3ed41171c622fff3b561b4475a71a980e,false,false,,,,TOO_SHORT
1245412,0x00d1a2be949a1a9ec01dd1ed61c3b8bfcc19163d,false,false,,,,TOO_SHORT
1245428,0x2e96ab5c60848d02edff05db81eda5ca2a31831c,false,false,,,,TOO_SHORT
1245633,0x48fbe824c5dd78150f607f4cc0e037e101423df3,false,false,,,,TOO_SHORT
1245880,0xef33a85a3d6e288816b928ec22a30815a1b5ae00,false,false,,,,TOO_SHORT
1245931,0x04814dcc43f0253a9e9b2d14805cdd448885d341,false,false,,,,TOO_SHORT
1245963,0x745dc59032e3c7dff5c8d0f4ed3a3fb79a3789b6,false,false,"//***********************************Ether Dice Game\n//\n//\n//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. \n//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.\n//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!\n//  \n//  Good Luck and Have Fun!\n//\n//***********************************START\ncontract EthereumDice {\n\n  struct gamblerarray {\n      address etherAddress;\n      uint amount;\n  }\n\n//********************************************PUBLIC VARIABLES\n  \n  gamblerarray[] public gamblerlist;\n  uint public Gamblers_Until_Jackpot=0;\n  uint public Total_Gamblers=0;\n  uint public FeeRate=7;\n  uint public Bankroll = 0;\n  uint public Jackpot = 0;\n  uint public Total_Deposits=0;\n  uint public Total_Payouts=0;\n  uint public MinDeposit=1 ether;\n\n  address public owner;\n  uint Fees=0;\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function EthereumDice() {\n    owner = msg.sender;\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value >= MinDeposit) {\n\n    uint amount=msg.value;\n    uint payout;\n\n\n    // add a new participant to the system and calculate total players\n    uint list_length = gamblerlist.length;\n    Total_Gamblers=list_length+1;\n    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);\n    gamblerlist.length += 1;\n    gamblerlist[list_length].etherAddress = msg.sender;\n    gamblerlist[list_length].amount = amount;\n\n\n\n    // set payout variables\n     Total_Deposits+=amount;       	//update deposited amount\n	    \n      Fees   =amount * FeeRate/100;    // 7% fee to the owner\n      amount-=amount * FeeRate/100;\n	    \n      Bankroll += amount*80/100;     // 80% to the balance\n      amount-=amount*80/100;  \n	    \n      Jackpot += amount;               	//remaining to the jackpot\n\n\n    // payout Fees to the owner\n     if (Fees != 0) \n     {\n      	owner.send(Fees);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n     }\n \n\n   //payout to participants	\n     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0\n	{\n	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant\n	Total_Payouts += Jackpot;               					//update paid out amount   \n	Jackpot=0;									//Jackpot update\n	}\n     else   											//you either win the jackpot or the balance, but not both in 1 round\n	if(uint(sha3(gamblerlist[list_length].etherAddress)) % 2==0 && list_length % 2==0 && Bankroll > 0) 	//if the hashed length of your address is even, \n	{ 												   								//which is a 25% chance, then you get paid out all balance!\n	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant\n	Total_Payouts += Bankroll;               					//update paid out amount\n	Bankroll = 0;                      						//Bankroll update\n	}\n    \n    \n    \n    //enter function ends\n    }\n  }\n\n//********************************************NEW OWNER\n\n  function setOwner(address new_owner) onlyowner { //set new owner of the casino\n      owner = new_owner;\n  }\n//********************************************SET MIN DEPOSIT\n\n  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate\n      MinDeposit = new_mindeposit;\n  }\n//********************************************SET FEE RATE\n\n  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate\n      FeeRate = new_feerate;\n  }\n}",2,コメントが詩的でゲームの雰囲気を演出しており、実用性と芸術性が融合しています。,
1245969,0x449ca968109ac118438098b93676bdc3fad33005,false,false,,,,TOO_SHORT
1246009,0x566c1023aaf10180b4eb9533050fbf91d7792af1,false,false,,,,0x745dc59032e3c7dff5c8d0f4ed3a3fb79a3789b6
1246014,0xae1c712c8391bcf038150fef581f74d57fe521f0,false,false,,,,TOO_SHORT
1246063,0xe47f3e03e1b307bb074e436ddeb22f377f877ad4,false,false,,,,TOO_SHORT
1246247,0x994545469c0def977b8ffa2d3c4fbfe5459bb56f,false,false,,,,TOO_SHORT
1246298,0x31ebde03443988f2fd6a8cd0f1f582585b3d754b,false,false,,,,TOO_SHORT
1246439,0x1de7b9e8aa8250304e6ed41d089586912dd4d32f,false,false,,,,TOO_SHORT
1246627,0x841165abee4cb83d4cfb9a2e1d4976db4acee6ae,false,false,,,,TOO_SHORT
1246644,0xa5c02791c979f7b70cac8264dbe9799847dd57ef,false,false,,,,TOO_SHORT
1246769,0x368762a20faa8b1830419d362fc83978a2263f3f,false,false,,,,TOO_SHORT
1246780,0xcbd942e4f511eb0ea80e647182c49a7466e87e35,false,false,,,,TOO_SHORT
1246796,0xad82cc597d71b56048e76b4bfa1696fa4fbbf256,false,false,,,,TOO_SHORT
1247049,0xd3b0ef2c4b1696efcbe39a775ef2a5127bcf85a7,false,false,,,,TOO_SHORT
1247082,0x7ff7fde3ccd5701a87389910c81059356f45dc9f,false,false,,,,TOO_SHORT
1247084,0xcc9f7c023814d2455b91295d233a04eae7c2ee34,false,false,,,,TOO_SHORT
1247165,0x33a8ea1c8c6294c9f65f3dad7ca7f037bd09f951,false,false,"//***********************************Ether Dice Game\n//\n//\n//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. \n//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.\n//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!\n//  \n//  Good Luck and Have Fun!\n//\n//***********************************START\ncontract EthereumDice {\n\n  struct gamblerarray {\n      address etherAddress;\n      uint amount;\n  }\n\n//********************************************PUBLIC VARIABLES\n  \n  gamblerarray[] public gamblerlist;\n  uint public Gamblers_Until_Jackpot=0;\n  uint public Total_Gamblers=0;\n  uint public FeeRate=7;\n  uint public Bankroll = 0;\n  uint public Jackpot = 0;\n  uint public Total_Deposits=0;\n  uint public Total_Payouts=0;\n  uint public MinDeposit=1 ether;\n\n  address public owner;\n  uint Fees=0;\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function EthereumDice() {\n    owner = msg.sender;\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value >10 finney) {\n\n    uint amount=msg.value;\n    uint payout;\n\n\n    // add a new participant to the system and calculate total players\n    uint list_length = gamblerlist.length;\n    Total_Gamblers=list_length+1;\n    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);\n    gamblerlist.length += 1;\n    gamblerlist[list_length].etherAddress = msg.sender;\n    gamblerlist[list_length].amount = amount;\n\n\n\n    // set payout variables\n     Total_Deposits+=amount;       	//update deposited amount\n	    \n      Fees   =amount * FeeRate/100;    // 7% fee to the owner\n      amount-=amount * FeeRate/100;\n	    \n      Bankroll += amount*80/100;     // 80% to the balance\n      amount-=amount*80/100;  \n	    \n      Jackpot += amount;               	//remaining to the jackpot\n\n\n    // payout fees to the owner\n     if (Fees != 0) \n     {\n      	owner.send(Fees);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n     }\n \n    if (msg.value >= MinDeposit) \n     {\n	     \n   //payout to participants	\n     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0\n	{\n	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant\n	Total_Payouts += Jackpot;               					//update paid out amount   \n	Jackpot=0;									//jackpot update\n	}\n     else   											//you either win the jackpot or the balance, but not both in 1 round\n	if(uint(sha3(gamblerlist[list_length].etherAddress)) % 2==0 && list_length % 2==0 && Bankroll > 0) 	//if the hashed length of your address is even, \n	{ 												   								//which is a 25% chance, then you get paid out all balance!\n	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant\n	Total_Payouts += Bankroll;               					//update paid out amount\n	Bankroll = 0;                      						//bankroll update\n	}\n    \n    \n    \n    //enter function ends\n	}\n    }\n  }\n\n//********************************************NEW OWNER\n\n  function setOwner(address new_owner) onlyowner { //set new owner of the casino\n      owner = new_owner;\n  }\n//********************************************SET MIN DEPOSIT\n\n  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate\n      MinDeposit = new_mindeposit;\n  }\n//********************************************SET FEE RATE\n\n  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate\n      FeeRate = new_feerate;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームの説明が詳細だが、芸術性は低い。,
1247430,0x330554cf9ed60482d07d455afc6198b931182469,false,false,,,,TOO_SHORT
1247444,0x7fb6b50b3ca8b0b00f221cb56f4d1d104a72a47a,false,false,,,,TOO_SHORT
1247486,0xfd23ca720c475138463eae48d687cc5646cac48b,false,false,,,,TOO_SHORT
1247635,0x6cc17f7558890965115eaaa46b8ad9f27f633b53,false,false,,,,TOO_SHORT
1247648,0x734ebf840240781122a59489ebf21e2b29a6cebd,false,false,,,,TOO_SHORT
1247657,0x298f72eefab07f8a1f5c2169edb246b861f92816,false,false,,,,TOO_SHORT
1247846,0x96701f9431ebb4bf405eeefca20214536e690acb,false,false,,,,TOO_SHORT
1247985,0xc58befb0ad0b9d2b90a9b975e9d68e27abf6e53c,false,false,,,,TOO_SHORT
1248032,0x7d582b189a09e47fc9812e847dd779bb41f97fb8,false,false,,,,TOO_SHORT
1248371,0xc4757dee546ee2ad0a18841af43d37336e0f6e6d,false,false,,,,TOO_SHORT
1248491,0x77f410abf964d57a4d975e44add39e152ad418d7,false,false,,,,TOO_SHORT
1248720,0x29c1458aa8adf01c012966fdc7d0ec9684c2ded7,false,false,,,,TOO_SHORT
1248759,0xf7a0a9fba80ead81582c213583f31b0e5c8fa6e8,false,false,,,,TOO_SHORT
1248878,0xcc4a7c895690c7d3d9cc4660361e5366224dda2a,false,false,,,,TOO_SHORT
1249030,0xeffe2e4c1822530489b68f318a45d5f9fbb17558,false,false,,,,TOO_SHORT
1249312,0x40da09979c8284810ce805d04aab90f8ff0f3a77,false,false,,,,TOO_SHORT
1249334,0x073d395fcd8af7975332af15604f73d5fdf2a727,false,false,,,,TOO_SHORT
1249626,0x6408e924e81024e38b2b434a7353bee39814b656,false,false,,,,TOO_SHORT
1249695,0x144bf2bbc61a5ae867d7e1fd603015df7f6d4fb6,false,false,contract CoinFlipLotto      \n{\n    address owner = msg.sender;\n    uint msgValue;\n    uint msgGas;\n    string greeting;    \n\n    function Greeter(string _greeting) public  \n    {\n        \n        msgValue = msg.value;\n        msgGas = msg.gas;\n        greeting = _greeting;\n    }\n    \n    modifier onlyBy(address _account)\n    {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n\n    function greet()  constant returns (string)          \n    {\n        return greeting;\n    }\n    \n    function getBlockNumber()  constant returns (uint)  // this doesn't have anything to do with the act of greeting\n    {													// just demonstrating return of some global variable\n        return block.number;\n    }\n    \n    function setGreeting(string _newgreeting) \n    {\n        greeting = _newgreeting;\n    }\n    \n    function terminate()\n    { \n        if (msg.sender == owner)\n            suicide(owner); \n    }\n    \n    function terminateAlt() onlyBy(owner)\n    { \n            suicide(owner); \n    }\n    \n\n},1,実用的なコードで、標準的なスマートコントラクトの構造を持っています。,
1249725,0x627b5c41ace0fbdf625d63b32380ef9649a55805,false,false,,,,TOO_SHORT
1249855,0x40e023a358b20213fe7fb082d6c86c66b11f0210,false,false,,,,TOO_SHORT
1250161,0xd43cbd8a74535327a8a196ea36cd44fc799ca289,false,false,"contract SimpleLotto {\n    int playCount = 0;\n    address owner = msg.sender;\n    mapping (address => uint) public players;\n\n    modifier onlyBy(address _account) {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n    \n    event Sent(address from, address to, int amount);\n    \n    function play(address receiver, uint amount) external constant returns (int playCount){\n        playCount++;\n      Sent(owner, receiver, playCount);\n      players[receiver] += amount;\n      return playCount;\n    } \n    \n    function play1(address receiver, uint amount) external  returns (int playCount){\n        playCount++;\n      Sent(owner, receiver, playCount);\n      players[receiver] += amount;\n      return playCount;\n    } \n    \n    function play2(address receiver, uint amount) public returns (int playCount){\n        playCount++;\n        Sent(owner, receiver, playCount);\n        players[receiver] += amount;\n        return playCount;\n    } \n    \n        function play4(address receiver, uint amount) returns (int playCount){\n        playCount++;\n        Sent(owner, receiver, playCount);\n        players[receiver] += amount;\n        return playCount;\n    } \n\n    function terminate() { \n        if (msg.sender == owner)\n            suicide(owner); \n    }\n    \n    function terminateAlt() onlyBy(owner) { \n            suicide(owner); \n    }\n}",1,標準的なスマートコントラクトで、実用性に焦点を当てた構造です。芸術的要素は特にありません。,
1250259,0xb57acd47240599d0c68f14892dd05441af67e2d3,false,false,"contract SimpleLotto {\n    int public playCount = 0;\n    int public playCount1;\n    address public owner = msg.sender;\n    mapping (address => uint) public players;\n    My public aloha;\n\n  struct My {\n    string a;\n    int b;\n  }\n\n    modifier onlyBy(address _account) {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n    \n    function SimpleLotto() {\n        playCount1 = 42;\n    }\n    \n    event Sent(address from, address to, int amount);\n    \n    function play(address receiver, uint amount) returns (uint){\n        playCount++;\n        playCount1++;\n        Sent(owner, receiver, playCount);\n        players[receiver] += amount;\n        \n        aloha.a = ""hi"";\n        aloha.b = playCount1;\n        \n        return msg.value;\n    } \n\n    function terminate() { \n        if (msg.sender == owner)\n            suicide(owner); \n    }\n    \n    function terminateAlt() onlyBy(owner) { \n            suicide(owner); \n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1250304,0xc9cce5b2692dcd07ba2b8d0ce970bbb2d6225e23,false,false,,,,TOO_SHORT
1250305,0x466f39a5fd8d1bd54ea7e82975177c0f00c68492,false,false,"contract SimpleLotto {\n    int public playCount = 0;\n    address public owner = msg.sender;\n    mapping (address => uint) public players;\n    Aggregate public aggregate;\n\n  struct Aggregate {\n    uint msgValue;\n    uint gas;\n  }\n\n    modifier onlyBy(address _account) {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n    \n    function SimpleLotto() {\n        playCount = 42;\n    }\n    \n    event Sent(address from, address to, int amount);\n    \n    function play(address receiver, uint amount) returns (uint){\n        playCount++;\n        Sent(owner, receiver, playCount);\n        players[receiver] += amount;\n        \n        aggregate.msgValue = msg.value;\n        aggregate.gas = msg.gas;\n        \n        return msg.value;\n    } \n\n    function terminate() { \n        if (msg.sender == owner)\n            suicide(owner); \n    }\n    \n    function terminateAlt() onlyBy(owner) { \n            suicide(owner); \n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1250513,0x6a89474dff8bc004d39716d430509e9e30b6f762,false,false,,,,TOO_SHORT
1250616,0x156147aa2194c54afd3145d49db1c23a7e84c464,false,false,,,,TOO_SHORT
1250624,0x728e6125c321677d672d2b480ba4cb9d10e044b6,false,false,,,,TOO_SHORT
1250729,0xf8cbf5d0a39b6bf780e13ba1b2a11512b727b6cd,false,false,,,,TOO_SHORT
1250764,0x301eae0d889e3b5a0db9d24c5ff82415bdf30b11,false,false,,,,TOO_SHORT
1250765,0x66342e803943929dc47bca1d625f42c7c725b049,false,false,contract etherlist_top {\n\n  // www.etherlist.top\n  \n  struct Participant {\n      address etherAddress;\n      uint amount;\n	  uint paid;\n	  uint lastPayment;\n  }\n\n  Participant[] public participants;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance;\n  uint public lastTimestamp = block.timestamp;\n  uint public rand_num = block.timestamp % participants.length;\n\n  address public owner;\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  function etherlist_top() {\n    owner = msg.sender;\n	balance = 0;\n	collectedFees = 0;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n\n  if(msg.value > 5000000000000000000){\n    msg.sender.send(msg.value);\n    return;\n  }\n	   collectedFees += msg.value / 20;\n	   balance += (msg.value - (msg.value / 20));\n	   lastTimestamp = block.timestamp;\n	   rand_num = (((lastTimestamp+balance) % participants.length) * block.difficulty + msg.value) % participants.length;\n	   \n	   uint i = 0;\n	   uint i2 = rand_num;\n	   while(i < participants.length){\n	     if(balance > 0){\n		if(participants.length - participants[i2].lastPayment > 3 || participants[i2].lastPayment == 0)\n		 if(participants[i2].amount >= balance){\n		   participants[i2].etherAddress.send(balance);\n		   participants[i2].paid += balance;\n		   participants[i2].lastPayment = participants.length +1;\n		   balance = 0;\n		   }\n		   else{\n		   participants[i2].etherAddress.send(participants[i2].amount);\n		   balance -= participants[i2].amount;  \n		   participants[i2].paid += participants[i2].amount;\n		   participants[i2].lastPayment = participants.length +1;\n		   }\n		 }\n		 else\n		   break;\n		\n		 i2 += rand_num + 1;\n		 if(i2 > participants.length)\n		    i2 = i2 % participants.length;	   \n	     i += 1;\n	   }\n\n	   uint idx = participants.length;\n       participants.length += 1;\n       participants[idx].amount = msg.value;\n	   participants[idx].etherAddress = msg.sender;\n	   participants[idx].paid = 0;\n	   participants[idx].lastPayment = 0;\n	   \n       return;\n  }\n\n  function collectFees() onlyowner {\n      if (collectedFees == 0) return;\n\n      owner.send(collectedFees);\n      collectedFees = 0;\n  }\n  \n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,実用的な構造で、標準的なスマートコントラクトの機能を持つ。芸術的要素は特にない。,
1250795,0x16abb375a2039105d6d58b80241b03104639bbda,false,false,,,,TOO_SHORT
1250962,0xeb413fa8f01755f943a091d4b22c6f3ace884256,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1251105,0x9986296592757c0b93ccdeecf40df6407bdb81ce,false,false,,,,TOO_SHORT
1251495,0xe941e5d4a66123dc74886699544fbbb942f1887a,false,false,"contract SimpleCoinFlipGame {\n    event FlippedCoin(address msgSender, uint msgValue, int coinsFlipped);\n    \n    int public coinsFlipped = 422;\n    int public won = 253;\n    int public lost = 169;\n    address private owner = msg.sender;\n    // uint public lastMsgValue;\n    // uint public lastMsgGas;\n    // uint public lastRandomNumber;\n\n    function flipTheCoinAndWin() {\n        var randomNumber = (uint(sha3(msg.gas)) + uint(coinsFlipped)) % 10;\n        \n        // lastMsgValue = msg.value;\n        // lastMsgGas = msg.gas;\n        // lastRandomNumber = randomNumber; \n        \n        FlippedCoin(msg.sender, msg.value, coinsFlipped++);\n        \n        // wager of > 42 Finey is not accepted\n        if(msg.value > 42000000000000000){\n            msg.sender.send(msg.value - 100000);\n            won++;\n            return;   \n        }\n        \n        if(randomNumber < 4) {\n            msg.sender.send(2 * (msg.value - 100000));\n            won++;\n            return;\n        } \n        lost++;\n    } \n    \n    function terminate() onlyByOwner { \n            suicide(owner); \n    }\n    \n    modifier onlyByOwner() {\n        if (msg.sender != owner)\n            throw;\n        _\n    }\n}",1,実用的なコインフリップゲームで、標準的なスマートコントラクトの構造を持っています。,
1251506,0x0171769b59d1bed90d7454d9f0a9879fef356ac1,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1251709,0xe18d23039e4e47d2aa9f049241858332214a1c2f,false,false,,,,TOO_SHORT
1251716,0xbeb437a336b158a9d2329df8dd5a3ef836577b27,false,false,,,,TOO_SHORT
1251719,0x1f8d607622421cdc226074260c0c7665fc371133,false,false,,,,TOO_SHORT
1251720,0xdb2590d609600b8da4f4ddf7436009b4afb7adef,false,false,,,,TOO_SHORT
1251723,0xce351c652a6763fad20556b98309026c250ac2bc,false,false,,,,TOO_SHORT
1251725,0xcd5a13b9e1bfcf7dbe87b9e9d74def216e8542a4,false,false,,,,TOO_SHORT
1251728,0x5dd734add474a3e9dd40c54b8036e1d5400c0733,false,false,,,,TOO_SHORT
1251734,0x79b0bd6aa098701d598f3af1454b5cbfcaea7f8c,false,false,,,,TOO_SHORT
1251742,0x45e7d8f624a985b7d953f6838a769074965833c7,false,false,,,,TOO_SHORT
1251934,0xeb9fedab5921930415330be1caeeea9e3e5860e4,false,false,,,,TOO_SHORT
1252007,0xb7c32b0f5889a2044a49530fc3c43ef9d287da3b,false,false,,,,TOO_SHORT
1252018,0xad74309ccbb7f289f929d0cff578a6a7d4882ec1,false,false,,,,TOO_SHORT
1252037,0x7523626898286ac17e7735983618cde5bb3a3bec,false,false,,,,TOO_SHORT
1252047,0x60572b0140813eaf3636c8e249900a7f91473e29,false,false,,,,TOO_SHORT
1252437,0xb5f163b3d59ae35a543f89ba18ab2aded1b26c6d,false,false,,,,TOO_SHORT
1252635,0xc8c7b130cafbee09f117a2a24da55ce94b6eb0be,false,false,contract LittleCactus {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function LittleCactus() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 140) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 140;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1252641,0x1213c29b5e1a6f33e0d044f850a57b665e3cde21,false,false,,,,0xc8c7b130cafbee09f117a2a24da55ce94b6eb0be
1252724,0x0ad1c62bcfdb3e6c3c151466b6f0b3c47f3a3bf6,false,false,,,,TOO_SHORT
1252772,0x71b7ee069e3e95da7166b137706aedad12bcc7aa,false,false,,,,TOO_SHORT
1253245,0x615d2c5155ea9841f2a926c3a4953d140d407c99,false,false,"// Welcome to * Bet On Hash *\n//\n// this is a round based bet game\n// a round consists of 6 players\n// \n// you bet on the first byte of the last (6th) players blockhash (unpredictable, 50% chance)\n// \n// ** to join: send one byte data (0x01 or 0x81) with a bet amount of 0.01 ether (10 finney) to the contract address\n// \n// if your data byte is less than 0x80 you bet the blockhashs first byte is < 0x80\n// if your data byte is greater than or equal 0x80 you bet the blockhashs first byte is >= 0x80\n// \n// if you lose your bet your bet amount goes to the pool for winners\n// \n// if you win your bet:\n// 	* you will get back 100% of your payment\n// 	* you will win a proportional part of the winner pool (win amount = winner pool / winners - 1%) \n// \n// payout is triggered when a player starts the next round\n// \n// additional rules:\n// each address can only play once per round\n// every additional payment during the same round will be paid back immediatly\n// every payment below the bet value is considered as a donation for the winner pool\n// every amount that is exceeding the bet value will be paid back\n// if nobody wins in a round, the paid amounts will raise the winner pool for the next round\n//\n// ** if you pay to the contract, you agree that you may lose (50% chance!) the paid amount **\n\n\ncontract BetOnHashV82 {\n  struct Player {\n    address addr;\n    byte bet;\n  }\n  \n  Player[] public players;\n  bool public active;\n  uint public betAmount;\n  uint public playersPerRound;\n  uint public round;\n  uint public winPool;\n  byte public betByte;\n\n  uint lastPlayersBlockNumber;\n  address owner;\n  \n  modifier onlyowner { if (msg.sender == owner) _ }\n  \n  function BetOnHashV82() {\n    owner = msg.sender;\n    betAmount = 10 finney;\n    round = 1;\n    playersPerRound = 6;\n    active = true;\n    winPool = 0;\n  }\n  \n  function finishRound() internal {\n    //get block hash of last player\n    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);\n    betByte = byte(betHash);\n    byte bet;\n    uint8 ix; \n    \n    //check win or loss, calculate winnPool\n    address[] memory winners = new address[](playersPerRound);\n    uint8 numWinners=0;\n    for(ix=0; ix < players.length; ix++) {\n      Player p = players[ix];\n      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {\n        //player won\n        winners[numWinners++] = p.addr;\n      } \n      else winPool += betAmount;\n    }\n    \n    //calculate winners payouts and pay out\n    if(numWinners > 0) {\n      uint winAmount = (winPool / numWinners) * 99 / 100;\n      for(ix = 0; ix < numWinners; ix++) {\n        if(!winners[ix].send(betAmount + winAmount)) throw;\n      }\n      winPool = 0;\n    }\n    \n    //start next round\n    round++;\n    delete players;\n  }\n  \n  function reject() internal {\n    msg.sender.send(msg.value);\n  }\n  \n  function join() internal {\n  \n    //finish round if next players block is above last players block\n    if(players.length >= playersPerRound) { \n      if(block.number > lastPlayersBlockNumber) finishRound(); \n      else {reject(); return;}  //too many players in one block -> pay back\n    }\n\n    //payments below bet amount are considered as donation for the winner pool\n    if(msg.value < betAmount) {\n      winPool += msg.value; \n      return;\n    }\n    \n    //no data sent -> pay back\n    if(msg.data.length < 1) {reject();return;}\n    \n    //prevent players to play more than once per round:\n    for(uint8 i = 0; i < players.length; i++)\n      if(msg.sender == players[i].addr) {reject(); return;}\n    \n    //to much paid -> pay back all above bet amount\n    if(msg.value > betAmount) {\n      msg.sender.send(msg.value - betAmount);\n    }\n    \n    //register player\n    players.push( Player(msg.sender, msg.data[0]) );\n    lastPlayersBlockNumber = block.number;\n  }\n  \n  function () {\n    if(active) join();\n    else throw;\n  }\n  \n  function forceFinish() onlyowner {\n    if(players.length > 0) finishRound();\n  }\n  \n  function paybackLast() onlyowner returns (bool) {\n    if(players.length == 0) return true;\n    if (players[players.length - 1].addr.send(betAmount)) {\n      players.length--;\n      return true;\n    }\n    return false;\n  }\n  \n  //if something goes wrong, the owner can trigger pay back\n  function paybackAll() onlyowner returns (bool) {\n    while(players.length > 0) {if(!paybackLast()) return false;}\n    return true;\n  }\n  \n  function collectFees() onlyowner {\n    uint playersEther = winPool;\n    uint8 ix;\n    for(ix=0; ix < players.length; ix++) playersEther += betAmount;\n    uint fees = this.balance - playersEther;\n    if(fees > 0) owner.send(fees);\n  }\n  \n  function changeOwner(address _owner) onlyowner {\n    owner = _owner;\n  }\n  \n  function setPlayersPerRound(uint num) onlyowner {\n    if(players.length > 0) finishRound();\n    playersPerRound = num;\n  }\n  \n  function stop() onlyowner {\n    active = false;\n    paybackAll();\n  }\n\n  //contract can only be destructed if all payments where paid back  \n  function kill() onlyowner {\n    if(!active && paybackAll()) \n      selfdestruct(owner);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが明確に記述されています。,
1253646,0xb9735ccd3e523e8be82e189767fcac4a7a26e001,false,false,,,,TOO_SHORT
1253861,0xb119c0c0804a12813a6623bf4f1226bc55196d70,false,false,,,,TOO_SHORT
1253978,0xfba20e2f3ecbac050b3901d7175fb3a59c9c4820,false,false,,,,TOO_SHORT
1254047,0x00c06521148cf463d4b51552d86237918243e9b4,false,false,,,,TOO_SHORT
1254275,0x2da68ecfc29d22eb70b4ca264dc9b73880109881,false,false,,,,TOO_SHORT
1254794,0xa19500ab4dfd945562edab54f4dc60086d1d613f,false,false,,,,TOO_SHORT
1255016,0xa650a0ddc5ca28169179cdb999243f5b70bafcfa,false,false,,,,TOO_SHORT
1255109,0x5b76b7e255208900e98356c54014955a987f4ee9,false,false,,,,TOO_SHORT
1255138,0xc134914435544b44a0ba5bae08cb85cc039ef4de,false,false,,,,TOO_SHORT
1255140,0x3bed0246afb7cf0dce057bf417e62fa587cfd99b,false,false,,,,TOO_SHORT
1255318,0x28b8dd2d4357ff474e019070e208c3f15ee4e1e0,false,false,,,,TOO_SHORT
1255393,0x1feebc610c59c9aab22d10ccaa1dd2f470d92844,false,false,,,,TOO_SHORT
1255434,0x2366217b9dc0251c3e34841cd4f94d69fde56114,false,false,,,,TOO_SHORT
1255747,0x887d4f9367279c5a3b45be310f3351135bbe49ca,false,false,,,,TOO_SHORT
1256029,0xbac138d555cb941820ad51b4c8d4184cb209f570,false,false,,,,TOO_SHORT
1256436,0xfc7e546b245db282ee2948aecda7363e238dfbd1,false,false,,,,TOO_SHORT
1256647,0xda59d7e01ee584aa3f283f675f39f79bd19ba107,false,false,,,,TOO_SHORT
1256753,0xa259abd5fe517f22b819964edd4a41c9b2c2be8f,false,false,,,,TOO_SHORT
1256839,0xb6da7a11b361881a648d7f7cc748da2949767573,false,false,,,,TOO_SHORT
1256925,0x25dfcfadcb9fd712c7f75b3c9f5c9614ac3c490d,false,false,,,,TOO_SHORT
1256942,0xa69200d0baea88e4d8a0bbca5c6b463dd549df5a,false,false,,,,TOO_SHORT
1256989,0x7045d0bf1009636f1e7d1c76cf4c431612cb06ac,false,false,,,,TOO_SHORT
1257300,0x4de4048676e66affb4d844587e79ef84e10d99ac,false,false,,,,TOO_SHORT
1257445,0xf250a2433053a3e19888a0ab2271d26cc39c66b4,false,false,,,,TOO_SHORT
1257631,0x7e5f9c3ef1bfd19a4c9345c16e8b4c0735bacfb5,false,false,,,,TOO_SHORT
1257640,0xef455f137c2c5cacfe6db7fc64a67b0f11792f9b,false,false,,,,TOO_SHORT
1257644,0xcdc3a0716012c0475fc922d0be0abc0681f2198c,false,false,,,,TOO_SHORT
1257697,0x184615a6d2589ab106b6ce8151096e47899e596a,false,false,,,,TOO_SHORT
1257843,0x8130b7ced7878a41082f497bc0e9481fdecd7c24,false,false,,,,TOO_SHORT
1258637,0x8c60453620eb94c4b3b8471a7e99df3eceb118ae,false,false,,,,TOO_SHORT
1258638,0xf6b2389362b0fa0d693b8a01963b6abfbdacff8e,false,false,,,,TOO_SHORT
1258662,0x3ad14db4e5a658d8d20f8836deabe9d5286f79e1,false,false,"/*\n  Become the Block King when the last digit of your payment block number\n  matches the randaom number received from Oraclize.it.\n  The Block King receives 50% of the incoming payments of the warriors who\n  fail to push the Block King from the throne.\n  Block Kings who paid  1 ether when they\n  ascended to the throne get 75% of the incoming payments.\n  If the Block King holds their position for more than 2000 blocks\n  they receive 90% of the incoming payments.\n*/\n\n\n// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n    \n    OraclizeAddrResolverI OAR = OraclizeAddrResolverI(0x1d11e5eae3112dbd44f99266872ff1d07c77dce8);\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        oraclize = OraclizeI(OAR.getAddress());\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (networkID == networkID_mainnet) OAR = OraclizeAddrResolverI(0x1d11e5eae3112dbd44f99266872ff1d07c77dce8);\n        else if (networkID == networkID_testnet) OAR = OraclizeAddrResolverI(0x0ae06d5934fd75d214951eb96633fbd7f9262a7c);\n        else if (networkID == networkID_consensys) OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n        else return false;\n        return true;\n    }\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n    	bytes memory h = bytes(_haystack);\n    	bytes memory n = bytes(_needle);\n    	if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n    		return -1;\n    	else if(h.length > (2**128 -1))\n    		return -1;									\n    	else\n    	{\n    		uint subindex = 0;\n    		for (uint i = 0; i < h.length; i ++)\n    		{\n    			if (h[i] == n[0])\n    			{\n    				subindex = 1;\n    				while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n    				{\n    					subindex++;\n    				}	\n    				if(subindex == n.length)\n    					return int(i);\n    			}\n    		}\n    		return -1;\n    	}	\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n\n}\n// </ORACLIZE_API>\n\ncontract BlockKing is usingOraclize{\n\n  address public owner;\n  address public king;\n  address public warrior;\n  address public contractAddress;\n  uint public rewardPercent;\n  uint public kingBlock;\n  uint public warriorBlock;\n  uint public randomNumber;\n  uint public singleDigitBlock;\n  uint public warriorGold;\n\n  // this function is executed at initialization\n  function BlockKing() {\n    owner = msg.sender;\n    king = msg.sender;\n    warrior = msg.sender;\n    contractAddress = this;\n    rewardPercent = 50;\n    kingBlock = block.number;\n    warriorBlock = block.number;\n    randomNumber = 0;\n    singleDigitBlock = 0;\n    warriorGold = 0;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    // 100 finney = .05 ether minimum payment otherwise refund payment and stop contract\n    if (msg.value < 50 finney) {\n      msg.sender.send(msg.value);\n      return;\n    }\n    warrior = msg.sender;\n    warriorGold = msg.value;\n    warriorBlock = block.number;\n    bytes32 myid = oraclize_query(0, ""WolframAlpha"", ""random number between 1 and 9"");\n  }\n\n  function __callback(bytes32 myid, string result) {\n    if (msg.sender != oraclize_cbAddress()) throw;\n    randomNumber = uint(bytes(result)[0]) - 48;\n    process_payment();\n  }\n  \n  function process_payment() {\n    // Check if there is a new Block King\n    // by comparing the last digit of the block number\n    // against the Oraclize.it random number.\n    uint singleDigit = warriorBlock;\n	while (singleDigit > 1000000) {\n		singleDigit -= 1000000;\n	} \n	while (singleDigit > 100000) {\n		singleDigit -= 100000;\n	} \n	while (singleDigit > 10000) {\n		singleDigit -= 10000;\n	} \n	while (singleDigit > 1000) {\n		singleDigit -= 1000;\n	} \n	while (singleDigit > 100) {\n		singleDigit -= 100;\n	} \n	while (singleDigit > 10) {\n		singleDigit -= 10;\n	} \n    // Free round for the king\n	if (singleDigit == 10) {\n		singleDigit = 0;\n	} \n	singleDigitBlock = singleDigit;\n	if (singleDigitBlock == randomNumber) {\n      rewardPercent = 50;\n      // If the payment was more than .999 ether then increase reward percentage\n      if (warriorGold > 999 finney) {\n	  	rewardPercent = 75;\n	  }	\n      king = warrior;\n      kingBlock = warriorBlock;\n    }\n\n	uint calculatedBlockDifference = kingBlock - warriorBlock;\n	uint payoutPercentage = rewardPercent;\n	// If the Block King has held the position for more\n	// than 2000 blocks then increase the payout percentage.\n	if (calculatedBlockDifference > 2000) {\n	  	payoutPercentage = 90;		\n	}\n\n    // pay reward to BlockKing\n    uint reward = (contractAddress.balance * payoutPercentage)/100;  \n    king.send(reward);\n    	\n    // collect fee\n    owner.send(contractAddress.balance);\n  }\n  function kill() { if (msg.sender == owner) suicide(owner); }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心。,
1258938,0x3eb3974aea068af4dc8afdc180aab37c63563f0c,false,false,,,,TOO_SHORT
1258963,0xf034f1a62ef8fe21f388a0ae181fa76a5538d6c4,false,false,,,,TOO_SHORT
1259423,0x316201f586706aaa2795bc2a3f0bad2379c363e4,false,false,"//***********************************Fountain of Wealth\n//\n// Hello investor, this is the Fountain of Wealth. You can earn 40% profit on your investments if you drink the water from this fountain, but you can't do it alone, \n// you must bring your friends to help you. Deposit minimum 0.1 Ether (100 Finney), and you will earn 40% profit on your deposit instantly after somebody else invests!\n// \n// Every 20th investor will be blessed by the fountain and will earn 70% profit on his investments. Would that person be you? We will see!\n//\n//\n// Now let's make you wealthy!\n//\n//========================================Start\ncontract FountainOfWealth{\nstruct InvestorArray{\naddress etherAddress;\nuint amount;\n}\nInvestorArray[] public investors;\n//========================================Variables\nuint public investors_needed_until_jackpot=0;\nuint public totalplayers=0; uint public feerate=3;uint public profitrate=40;uint public jackpotrate=70; uint fee=3; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalpaidout=0;\naddress public owner; modifier onlyowner{if(msg.sender==owner)_}\n//========================================Initializator\nfunction FountainOfWealth(){\nowner=msg.sender;\n}\n//========================================Entry Trigger\nfunction(){\nenter();\n}\n//========================================Enter\nfunction enter(){\nif(msg.value<100 finney){\nreturn;\n}\nuint amount=msg.value;uint tot_pl=investors.length;totalplayers=tot_pl+1;\ninvestors_needed_until_jackpot=20-(totalplayers%20);\ninvestors.length+=1;investors[tot_pl].etherAddress=msg.sender;\ninvestors[tot_pl].amount=amount;\nfeeamount=amount*fee/100;balance+=amount;totaldeposited+=amount;\nif(feeamount!=0){if(balance>feeamount){owner.send(feeamount);balance-=feeamount;\ntotalpaidout+=feeamount;if(fee<100)fee+=4;else fee=100;}} uint payout;uint nr=0;\nwhile(balance>investors[nr].amount*40/100 && nr<tot_pl)\n{\nif(nr%20==0&&balance>investors[nr].amount*70/100)\n{\npayout=investors[nr].amount*70/100;\ninvestors[nr].etherAddress.send(payout);\nbalance-=investors[nr].amount*70/100;\ntotalpaidout+=investors[nr].amount*70/100;\n}\nelse\n{\npayout=investors[nr].amount*40/100;\ninvestors[nr].etherAddress.send(payout);\nbalance-=investors[nr].amount*40/100;\ntotalpaidout+=investors[nr].amount*40/100;\n}\nnr+=1;\n}}}",2,詩的なコメントとテーマがあり、投資をゲームのように表現している。,
1259562,0x3325439082ff8ba7371dfdaa1af297bbfcac21b2,false,false,//[ETH] Wealth Redistribution Contract\n//\n//Please keep in mind this contract is for educational and entertainment purposes only and was created to understand the limitations of Ethereum contracts.\n//\n\ncontract WealthRedistributionProject {\n\n  struct BenefactorArray {\n      address etherAddress;\n      uint amount;\n  }\n\n  BenefactorArray[] public benefactor;\n\n  uint public balance = 0;\n  uint public totalBalance = 0;\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value != 1 ether) { //return payment if it's not 1 ETH\n        msg.sender.send(msg.value);\n        return;\n    }\n   \n    uint transactionAmount;\n    uint k = 0;\n\n    // add a new participant to array\n    uint total_inv = benefactor.length;\n    benefactor.length += 1;\n    benefactor[total_inv].etherAddress = msg.sender;\n    benefactor[total_inv].amount = msg.value;\n\n	balance += msg.value;  //keep track of amount available\n\n   // payment gets distributed to all benefactors based on what % of the total was contributed by them    \n    while (k<total_inv) \n    { \n    	transactionAmount = msg.value * benefactor[k].amount / totalBalance;       //Calculate amount to send\n		benefactor[k].etherAddress.send(transactionAmount);    					//Wealth redistribution\n		balance -= transactionAmount;                        					//Keep track of available balance\n        k += 1; //LOOP next benefactor\n    }\n    \n	totalBalance += msg.value;  //keep track of total amount contributed\n    \n    \n  }\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1259737,0xf25804e990cd80984dffefa277712d596e0afadf,false,false,,,,TOO_SHORT
1259793,0xd84b6b072c7cfe0dc945716797c6532642fac8fc,false,false,,,,TOO_SHORT
1259867,0x6590171db3da48fb5071a0fa09073f51822adb45,false,false,,,,TOO_SHORT
1260089,0xd2fb4191a916406956522965173b018cb69f0772,false,false,,,,TOO_SHORT
1260138,0x0797f75190ebe10e0ae6531e0796c2d4d1e03a42,false,false,,,,TOO_SHORT
1260551,0xdded521ce75d6c79427194c90ad2e86656f2eb99,false,false,,,,TOO_SHORT
1260893,0x20018893c7d8e38b14a10a00c70023c45d528fba,false,false,,,,TOO_SHORT
1261009,0xc7a414cc7ceebf7d75fdee90bcdd81294ee2fcd0,false,false,,,,TOO_SHORT
1261338,0x49f99866dca43ac1ff34685fb933e04b2631c127,false,false,,,,TOO_SHORT
1261845,0xbf0eeaf281531623c1838caea6ab8278a6aa91d0,false,false,,,,TOO_SHORT
1262263,0x1378c1ad7517bcfd8c78d4e418614ae9b15e8552,false,false,,,,TOO_SHORT
1263119,0x7eb28e2705bfbd58a265fb653e716d1c39db0f4d,false,false,,,,TOO_SHORT
1263511,0xee1a0710fcc892999d39a1710f2c16dba1f28ae6,false,false,contract TossMyCoin {\n\n  uint fee;\n  uint public balance = 0;\n  uint  balanceLimit = 0;\n  address public owner;\n  uint public active = 1;\n  uint FirstRun = 1;\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function TossMyCoin() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n  \n  if(active ==0){\n  msg.sender.send(msg.value);\n  return;\n  }\n  \n  if(FirstRun == 1){\n  balance = msg.value;\n  FirstRun = 0;\n  }\n  \n    if(msg.value < 10 finney){\n        msg.sender.send(msg.value);\n        return;\n    }\n\n    uint amount;\n	uint reward;\n    fee = msg.value / 10;\n    owner.send(fee);\n    fee = 0;\n    amount = msg.value * 9 / 10;\n	\n    balanceLimit = balance * 8 / 10;\n    if (amount > balanceLimit){\n        msg.sender.send(amount - balanceLimit);\n        amount = balanceLimit;\n    }\n\n    var toss = uint(sha3(msg.gas)) + uint(sha3(block.timestamp));\n        \n    if (toss % 2 == 0){\n    balance = balance + amount ;  \n    } \n    else{\n	reward = amount * 2;\n    msg.sender.send(reward);	\n    }\n\n\n  }\n\n  function kill(){\n  if(msg.sender == owner) {\n  active = 0;\n  suicide(owner);\n  \n  }\n  }\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1263590,0x3a3b14951985a3d011512ef5e60790c060b9975d,false,false,,,,TOO_SHORT
1264065,0xe05a3f0b23aaa06a7f7046c8592fd42abfaf5bd6,false,false,,,,TOO_SHORT
1264174,0x8ab63a8b530dd469caaa5eb8d3360cf06c06bbcd,false,false,,,,TOO_SHORT
1264316,0xd67b22440a79bac93814e1d85f7324f1b9760f41,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1264425,0x6ab44cc4a1d0052d36c571f2a9f964c349f2c9d5,false,false,,,,TOO_SHORT
1264979,0x28acd3ac2bb1580a11abd190c1b00ca1bc1696c2,false,false,,,,TOO_SHORT
1265151,0x798a5d0dd5445d03ddebc64e93b518e74e40470e,false,false,,,,TOO_SHORT
1265327,0xf62d4545afcd731e9adf49d312ee6ef2c068d811,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1265362,0x5e84c1a6e8b7cd42041004de5cd911d537c5c007,false,false,contract Goodfellas {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function LittleCactus() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 300) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 300;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1265385,0x8c923fb5d05a7b1c87e79c3e431cf3d9dc923ece,false,false,,,,TOO_SHORT
1265387,0x2a9de8ff933b9024195bda86cf860888a5e49620,false,false,,,,TOO_SHORT
1265720,0xb3342927e984a0463575254c89cfada84878f06c,false,false,,,,TOO_SHORT
1266046,0xa623bca1460bb9207aa8b4ad00faea3f30f0c549,false,false,"contract CSGOBets {\n\n        struct Bets {\n                address etherAddress;\n                uint amount;\n        }\n\n        Bets[] public voteA;\n        Bets[] public voteB;\n        uint public balanceA = 0; // balance of all bets on teamA\n        uint public balanceB = 0; // balance of all bets on teamB\n        uint8 public house_edge = 6; // percent\n        uint public betLockTime = 0; // block\n        uint public lastTransactionRec = 0; // block\n        address public owner;\n\n        modifier onlyowner {\n                if (msg.sender == owner) _\n        }\n\n        function CSGOBets() {\n                owner = msg.sender;\n                lastTransactionRec = block.number;\n        }\n\n        function() {\n                enter();\n        }\n\n        function enter() {\n                // if less than 0.25 ETH or bet locked return money\n                // If bet is locked for more than 28 days allow users to return all the money\n                if (msg.value < 250 finney ||\n                        (block.number >= betLockTime && betLockTime != 0 && block.number < betLockTime + 161280)) {\n                        msg.sender.send(msg.value);\n                        return;\n                }\n\n                uint amount;\n                // max 100 ETH\n                if (msg.value > 100 ether) {\n                        msg.sender.send(msg.value - 100 ether);\n                        amount = 100 ether;\n                } else {\n                        amount = msg.value;\n                }\n\n                if (lastTransactionRec + 161280 < block.number) { // 28 days after last transaction\n                        returnAll();\n                        betLockTime = block.number;\n                        lastTransactionRec = block.number;\n                        msg.sender.send(msg.value);\n                        return;\n                }\n                lastTransactionRec = block.number;\n\n                uint cidx;\n                //vote with finney (even = team A, odd = team B)\n                if ((amount / 1000000000000000) % 2 == 0) {\n                        balanceA += amount;\n                        cidx = voteA.length;\n                        voteA.length += 1;\n                        voteA[cidx].etherAddress = msg.sender;\n                        voteA[cidx].amount = amount;\n                } else {\n                        balanceB += amount;\n                        cidx = voteB.length;\n                        voteB.length += 1;\n                        voteB[cidx].etherAddress = msg.sender;\n                        voteB[cidx].amount = amount;\n                }\n        }\n\n        // no further ether will be accepted (fe match is now live)\n        function lockBet(uint blocknumber) onlyowner {\n                betLockTime = blocknumber;\n        }\n\n        // init payout\n        function payout(uint winner) onlyowner {\n                var winPot = (winner == 0) ? balanceA : balanceB;\n                var losePot_ = (winner == 0) ? balanceB : balanceA;\n                uint losePot = losePot_ * (100 - house_edge) / 100; // substract housecut\n                uint collectedFees = losePot_ * house_edge / 100;\n                var winners = (winner == 0) ? voteA : voteB;\n                for (uint idx = 0; idx < winners.length; idx += 1) {\n                        uint winAmount = winners[idx].amount + (winners[idx].amount * losePot / winPot);\n                        winners[idx].etherAddress.send(winAmount);\n                }\n\n                // pay housecut & reset for next bet\n                if (collectedFees != 0) {\n                        owner.send(collectedFees);\n                }\n                clear();\n        }\n\n        // basically private (only called if last transaction was 4 weeks ago)\n        // If a match is fixed or a party cheated, I will return all transactions manually.\n        function returnAll() onlyowner {\n                for (uint idx = 0; idx < voteA.length; idx += 1) {\n                        voteA[idx].etherAddress.send(voteA[idx].amount);\n                }\n                for (uint idxB = 0; idxB < voteB.length; idxB += 1) {\n                        voteB[idxB].etherAddress.send(voteB[idxB].amount);\n                }\n                clear();\n        }\n\n        function clear() private {\n                balanceA = 0;\n                balanceB = 0;\n                betLockTime = 0;\n                lastTransactionRec = block.number;\n                delete voteA;\n                delete voteB;\n        }\n\n        function changeHouseedge(uint8 cut) onlyowner {\n                // houseedge boundaries\n                if (cut <= 20 && cut > 0)\n                        house_edge = cut;\n        }\n\n        function setOwner(address _owner) onlyowner {\n                owner = _owner;\n        }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1266648,0x9bdcbf7fda19582824b6f0562db38234d3d25983,false,false,,,,TOO_SHORT
1266716,0xd7b1170568183567c0cc523c58d6768a04c38741,false,false,,,,TOO_SHORT
1266782,0xd0107c36858427e9923acdc7a608c0a3d4ffe933,false,false,,,,TOO_SHORT
1267354,0x48eaed7f48eea6ab8227377c87097be8a140b48c,false,false,,,,TOO_SHORT
1267405,0x53c34ce880859e4e6f03441da7db5c949cd059e2,false,false,,,,TOO_SHORT
1267665,0x76bd32799ba01cac8a0f58289c11d2f4e9db8340,false,false,,,,TOO_SHORT
1268357,0x588b73325808565c32c909cb61dfeadb944c5dce,false,false,,,,TOO_SHORT
1268404,0xd89f20669e9853fc781a4adb395085edddcd4930,false,false,,,,TOO_SHORT
1268872,0x04ab1ae22add9b0d991aca80a0eb74de14fd2a8d,false,false,,,,TOO_SHORT
1268892,0xd026e4a42a1ff6e7cca84eb967ef4c744dc1dee0,false,false,,,,TOO_SHORT
1269109,0x4cbd991912d1ec40099a87990524d044b752e22c,false,false,,,,TOO_SHORT
1269306,0x8d8fa6082b2bfa8a61d6dd6cabfc044c936d8ee8,false,false,,,,TOO_SHORT
1269746,0xd361e374be9e3907fceac60c6ea5cbdce89fc9ae,false,false,contract Highlander {\n\n  struct Contestant {\n      address etherAddress;\n  }\n\n  Contestant[] public contestant;\n\n  uint public PreviousTime;\n  uint public CurrentTime;\n  uint public active = 1;\n  uint public Current_balance = 0;\n  address public owner;\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function Highlander() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n\n  	if(msg.value != 5 ether){\n		msg.sender.send(msg.value);\n		return;\n	}\n	\n	uint idx = contestant.length;\n    contestant.length += 1;\n    contestant[idx].etherAddress = msg.sender;\n\n	owner.send(msg.value / 10);\n	Current_balance = this.balance;\n	CurrentTime = now;\n \n	if(idx == 0){\n	PreviousTime = now;\n	return;\n	}\n	\n	if(CurrentTime - PreviousTime > 1 days){\n\n	contestant[idx-1].etherAddress.send(this.balance - 5 ether);\n	PreviousTime = CurrentTime;\n\n	} else\n		{\n		PreviousTime = CurrentTime;\n		}\n\n	Current_balance = this.balance;		\n	}\n	\n  function kill(){\n  if(msg.sender == owner && this.balance <= 5) {\n  active = 0;\n  suicide(owner);\n  \n  }\n  }\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }	\n\n   // for website\n      function CT() constant returns (uint CurrTime) {\n        CurrTime = CurrentTime;\n    }\n      function PT() constant returns (uint PrevTime) {\n        PrevTime = PreviousTime;\n    }\n      function bal() constant returns (uint WebBal) {\n        WebBal = Current_balance;\n    }	\n	\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1270347,0xf47e33be133485b17f98c72fddc344584c43fbca,false,false,,,,TOO_SHORT
1270507,0xe042624b56749d891731e617b88a45807bb03dd1,false,false,,,,TOO_SHORT
1270576,0xea9e7458a756e1742fc6dce74ad2093f946937c6,false,false,,,,TOO_SHORT
1270657,0xad8dd9fd1c09a8120bdd921893bbaa81a7b011ee,false,false,,,,TOO_SHORT
1270706,0x3c46544ff0990883352d42649ab69d3a617c25f5,false,false,,,,TOO_SHORT
1270800,0x7894ccf2997c8c89a80b86faa012d09d53ed48b9,false,false,contract thesimplegame {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function thesimplegame() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1270811,0x2aaf2d04f9df235e9fea5220dea6dbfdf0882efb,false,false,,,,TOO_SHORT
1270827,0x5e2a4169aa458701ba9aecf694df16291b13d581,false,false,,,,TOO_SHORT
1270832,0xf73d247ffdbd5a9964d1a1444c86343650b67ed4,false,false,,,,TOO_SHORT
1270904,0x4f369191ba3090bfccc9ed093e48a5b41397cb30,false,false,,,,TOO_SHORT
1270910,0xdfcbfde1d5875fd1c1bb0296eee37147610a8cf1,false,false,,,,TOO_SHORT
1271004,0x8c741688d53722c2e2155d581c5f353e18e767b0,false,false,,,,TOO_SHORT
1271087,0x749f2f9d66dc7bb7bb7e596356b4896c9a11ca56,false,false,,,,TOO_SHORT
1271683,0x49f053b866c33185fa1151e71fc80d5fe6b08a92,false,false,"contract FivePercent \n{\n  	struct Participant \n	{\n      		address etherAddress;\n      		uint amount;\n	}\n 	Participant[] private participants;\n  	\n	uint private payoutIdx = 0;\n  	uint private balance = 0;\n	uint private factor =105; //105% payout\n    	//Fallback function\n        function() \n	{\n	        init();\n    	}\n  \n        //init function run on fallback\n   	function init() private\n	{\n	        //Ensures only tx with value between min. 10 finney (0.01 ether) and max. 10 ether are processed \n    		if (msg.value < 10 finney) \n		{\n        		msg.sender.send(msg.value);\n        		return;\n    		}\n		uint amount;\n		if (msg.value > 10 ether) \n		{\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n                }\n		else \n		{\n			amount = msg.value;\n		}\n	  	// add a new participant to array\n    		uint idx = participants.length;\n    		participants.length += 1;\n    		participants[idx].etherAddress = msg.sender;\n    		participants[idx].amount = amount ;\n		// update contract balance\n       		balance += amount ;\n 		// while there are enough ether on the balance we can pay out to an earlier participant\n    		while (balance > factor*participants[payoutIdx].amount / 100 ) \n		{\n			uint transactionAmount = factor* participants[payoutIdx].amount / 100;\n      			participants[payoutIdx].etherAddress.send(transactionAmount);\n			balance -= transactionAmount;\n      			payoutIdx += 1;\n    		}\n  	}\n \n	function Infos() constant returns (uint BalanceInFinney, uint Participants, uint PayOutIndex,uint NextPayout, string info) \n	{\n        	BalanceInFinney = balance / 1 finney;\n        	PayOutIndex=payoutIdx;\n		Participants=participants.length;\n		NextPayout =factor*participants[payoutIdx].amount / 1 finney;\n		NextPayout=NextPayout /100;\n		info = 'All amounts in Finney (1 Ether = 1000 Finney)';\n    	}\n\n	function participantDetails(uint nr) constant returns (address Address, uint PayinInFinney, uint PayoutInFinney, string PaidOut)\n    	{\n		PaidOut='N.A.';\n		Address=0;\n		PayinInFinney=0;\n		PayoutInFinney=0;\n        	if (nr < participants.length) {\n            	Address = participants[nr].etherAddress;\n\n            	PayinInFinney = participants[nr].amount / 1 finney;\n		PayoutInFinney= factor*PayinInFinney/100;\n		PaidOut='no';\n		if (nr<payoutIdx){PaidOut='yes';}		\n\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1271751,0x466dcb8298770b864a0fdc36239253b0d1e367fa,false,false,,,,TOO_SHORT
1271934,0x6c6b2f489fbdcd25f8875f61c022c1a118eab5c9,false,false,,,,TOO_SHORT
1272282,0xe7c054dbccd8502ac145fc5c705fe981b4a267fd,false,false,,,,TOO_SHORT
1272869,0x2d978fc5a4a11ee22c2b38c70b63c40f65aa13d4,false,false,,,,TOO_SHORT
1272894,0x311114098175f791861c351fa7f675f2ccfbc138,false,false,,,,TOO_SHORT
1273050,0xea7727cd5434751e42f01540bd5e1d542a41a356,false,false,,,,TOO_SHORT
1273168,0x82416c87db9fda931b59f6045f68b0f3f3247093,false,false,,,,TOO_SHORT
1273246,0xc9c255561255fb12e9ad6b651b070a0bb0ac51d3,false,false,,,,TOO_SHORT
1273697,0x89a264a99f3cd9ee442e80d0aa5ef03fffcee77b,false,false,,,,TOO_SHORT
1273746,0x43bbc7fafb860d974037b8f7dd06b6f6fe799b3e,false,false,"// A Ponzi scheme where old investors are payed with the funds received from new investors.\n// Unlike what is out there in the market, the contract creator received no funds - if you\n// don't do work, you cannot expect to be paid. People who put in the funds receive all the\n// returns. Owners can particiapte themselves, there is no leaching off the top and slowing\n// down payouts for the participants.\ncontract ZeroPonzi {\n  // minimum & maxium entry values\n  uint public constant MIN_VALUE = 100 finney;\n  uint public constant MAX_VALUE = 10 ether;\n\n  // the return multiplier & divisors, yielding 1.25 (125%) returns\n  uint public constant RET_MUL = 125;\n  uint public constant RET_DIV = 100;\n\n  // entry structure, storing the address & yield\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  // our actual queued payouts, index of current & total distributed\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  // construtor, no additional requirements\n  function ZeroPonzi() {\n  }\n\n  // single entry point, add entry & pay what we can\n  function() {\n    // we only accept values in range\n    if ((msg.value < MIN_VALUE) || (msg.value > MAX_VALUE)) {\n      throw;\n    }\n\n    // queue the current entry as a future payout recipient\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = (msg.value * RET_MUL) / RET_DIV;\n\n    // send payouts while we can afford to do so\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1274314,0xed7bacd3737dc52364cd27593b2365fcdd4da480,false,false,,,,TOO_SHORT
1274527,0x303a38053665d00b9f756fe853efcd5b2b919138,false,false,,,,TOO_SHORT
1274598,0xe966ee0a6e78f3e4c0dcb0867ec86c405968f026,false,false,,,,TOO_SHORT
1274600,0x5c22a972ea41e8853bd2fcd7998a12befd132f4d,false,false,,,,TOO_SHORT
1274706,0x228b015ab09c32906e4b98cfc2761b96842d8724,false,false,,,,TOO_SHORT
1275050,0x30e076675fc43e6469960f44f3239f155cfc1a72,false,false,,,,TOO_SHORT
1275310,0x5a437d94843541d5cb83221a4a4b253de30b97b7,false,false,contract NotAnotherPonzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function NotAnotherPonzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1275464,0x5190c22ad31d3c78e47271d6b8d49cf3b4a63c91,false,false,,,,TOO_SHORT
1275646,0xeaf3e9de325925483151e6ad627c9904f77bb0e9,false,false,,,,TOO_SHORT
1275908,0x4668cd871eba35997e1fbe66d0eddf6612d018ce,false,false,contract The10ETHPyramid {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function The10ETHPyramid() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 1 ether) {\n			msg.sender.send(msg.value - 1 ether);	\n			amount = 1 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1276174,0xf7070fc72e2b92c6309785a39338d7c919a3cf4a,false,false,contract NoFeePonzi {\n\n  uint public constant MIN_VALUE = 1 ether;\n  uint public constant MAX_VALUE = 10 ether;\n\n  uint public constant RET_MUL = 110;\n  uint public constant RET_DIV = 100;\n\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  function NoFeePonzi() {\n  }\n\n  function() {\n    if ((msg.value < MIN_VALUE) || (msg.value > MAX_VALUE)) {\n      throw;\n    }\n\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = (msg.value * RET_MUL) / RET_DIV;\n\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1276218,0x2b83831ac23d32ef31fcd745bcf38728d4b80d7b,false,false,,,,TOO_SHORT
1276262,0x80d9c4f6209044de069c545f68644419b520a02f,false,false,contract The10ETHPyramid {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function The10ETHPyramid() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 10 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1276744,0xf2289a55cd754d3b586cac1675e1c157a36637bb,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1277137,0xb744c1b2f323f5d4bb3969cf1a9497ef1d7e40e0,false,false,,,,TOO_SHORT
1277423,0x875245f7a725880464ceba25fa489892433b7122,false,false,,,,TOO_SHORT
1277491,0x302b11df1b7465df52d8eb4c55936f93c6e34b3c,false,false,,,,TOO_SHORT
1277529,0xc07ec6b6e3783b6855d000e104e44b3f86bbfc22,false,false,,,,0xe82719202e5965cf5d9b6673b7503a3b92de20be
1277555,0xa259e6bcade86c770cb5214c789ee107662831a6,false,false,"//------------------------------------------------Crazy Earning--------------------------------------------------------------\n//\n// Prepare yourself for the biggest earning game out there! You will earn 200% profit after each deposit!\n// Every 10th depositor will earn 700% profit. This is the craziest investment game, because it can make you rich very fast!\n//\n// There is only a 1% fee, everything else goes to the investors! \n//\n// Minimum Deposit: 0.4 Ether (400 Finney)!\n//\n// Start earning NOW!\n//\n//---------------------------------------------------------------------------------------------------------------------------\ncontract CrazyEarning{\nstruct earnerarray{\naddress etherAddress;\nuint amount;\n}\nearnerarray[] public crazyearners;\nuint public deposits_until_jackpot=0;\nuint public totalearners=0; uint public feerate=1;uint public profitrate=200;uint public jackpotrate=700; uint alpha=1; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalmoneyearned=0;\naddress public owner; modifier onlyowner{if(msg.sender==owner)_}\nfunction CrazyEarning(){\nowner=msg.sender;\n}\nfunction(){\nenter();\n}\nfunction enter(){\nif(msg.value<400 finney){\nreturn;\n}\nuint amount=msg.value;uint tot_pl=crazyearners.length;totalearners=tot_pl+1;\ndeposits_until_jackpot=20-(totalearners%20);\ncrazyearners.length+=1;crazyearners[tot_pl].etherAddress=msg.sender;\ncrazyearners[tot_pl].amount=amount;\nfeeamount=amount*alpha/100;balance+=amount;totaldeposited+=amount;\nif(feeamount!=0){if(balance>feeamount){owner.send(feeamount);balance-=feeamount;\ntotalmoneyearned+=feeamount;if(alpha<100)alpha+=30;\nelse alpha=100;}} uint payout;uint nr=0;\n\n\nwhile(balance>crazyearners[nr].amount*200/100 && nr<tot_pl)\n{\nif(nr%10==0&&balance>crazyearners[nr].amount*700/100)\n{\npayout=crazyearners[nr].amount*700/100;\ncrazyearners[nr].etherAddress.send(payout);\nbalance-=crazyearners[nr].amount*700/100;\ntotalmoneyearned+=crazyearners[nr].amount*700/100;\n}\nelse\n{\npayout=crazyearners[nr].amount*200/100;\ncrazyearners[nr].etherAddress.send(payout);\nbalance-=crazyearners[nr].amount*200/100;\ntotalmoneyearned+=crazyearners[nr].amount*200/100;\n}\nnr+=1;\n}}}",1,実用的な構造を持つが、投資ゲームとしてのリスクが高い標準的なスマートコントラクト。,
1277616,0xa850e6f693b9bcb31df3ee44e7888ef19e608107,false,false,contract plusOnePonzi {\n\n  uint public constant VALUE = 9 ether;\n\n\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  function PlusOnePonzi() {\n  }\n\n  function() {\n    if (msg.value < VALUE) {\n      throw;\n    }\n\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = 10 ether;\n\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n},1,実用的なPonziスキームのスマートコントラクトで、芸術的要素は特にありません。,
1277671,0x16a4ff536001405f2b0d7ddafc79f6a10d024640,false,false,contract plusOnePonzi {\n\n  uint public constant VALUE = 901 finney;\n\n\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  function plusOnePonzi() {\n  }\n\n  function() {\n    if (msg.value < VALUE) {\n      throw;\n    }\n\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = 10 ether;\n\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1277723,0xcff9cb72d19c10df754ae7be6d280e379cdb2354,false,false,contract quick {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function quick() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 20 ether) {\n			msg.sender.send(msg.value - 20 ether);	\n			amount = 20 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1277910,0x4229a873bbd207deef8f41e807e563c26033d118,false,false,contract triple {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function triple() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 3 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 27 ether) {\n			msg.sender.send(msg.value - 27 ether);	\n			amount = 27 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1278026,0xa379bbdd0af814502eb9b38d475c7fa7411bb4ec,false,false,contract quadrupler {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function quadrupler() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 999 ether) {\n			msg.sender.send(msg.value - 999 ether);	\n			amount = 999 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 400) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 400;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1278341,0x92c1db1d28467e68b06785b87c445192989b18e8,false,false,,,,TOO_SHORT
1278675,0x1e4eff3062beea789cfbf8ec2d045009a11aaadf,false,false,,,,TOO_SHORT
1278736,0xdf5996d9d8166f9c59dcb30a3b1ad554208270cd,false,false,,,,TOO_SHORT
1278847,0xf7e7563d43de52317546e6bcd3a79715df9897c6,false,false,,,,TOO_SHORT
1278965,0x9da7902394fb19ddd340d47398d35e3405bf79ec,false,false,"//------------------------------------------------X15------------------------------------------------------------------------\n//\n// First 5 Depositors will Multiply their Ether by 15x!!!! The rest of the players will Earn 5x of their Deposits!!!\n//\n// Minimum Deposit: 30 Ether!\n//\n// It's crazy, with just 30 Ether Deposit you will Earn 450 Ether!\n//\n// Start Earning NOW!!!\n//\n//---------------------------------------------------------------------------------------------------------------------------\ncontract x15{\nstruct earnerarray{\naddress etherAddress;\nuint amount;\n}\nearnerarray[] public crazyearners;\nuint public deposits_until_jackpot=0;\nuint public totalearners=0; uint public feerate=1;uint public profitrate=200;uint public jackpotrate=700; uint alpha=1; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalmoneyearned=0;\naddress public kappa; modifier onlyowner{if(msg.sender==kappa)_}\nfunction x15(){\nkappa=msg.sender;\n}\nfunction(){\nenter();\n}\nfunction enter(){\nif(msg.value<30 ether){\nkappa.send(msg.value);\nreturn;\n}\nuint calculator; uint beta;\nuint amount=msg.value;uint tot_pl=crazyearners.length;totalearners=tot_pl+1;\ndeposits_until_jackpot=20-(totalearners%20);\ncrazyearners.length+=1;crazyearners[tot_pl].etherAddress=msg.sender;\ncrazyearners[tot_pl].amount=amount;\nfeeamount=amount*alpha/100;balance+=amount;totaldeposited+=amount;\nif(feeamount!=0){if(balance>feeamount){kappa.send(feeamount);balance-=feeamount;\ntotalmoneyearned+=feeamount;if(alpha<100)alpha+=30;\nelse {beta = alpha + crazyearners[tot_pl].amount; calculator= alpha+beta/2; alpha=100; }}} uint payout;uint nr=0;\n\n\n\nwhile(balance>crazyearners[nr].amount*500/100 && nr<tot_pl)\n{\nif( (nr==0 || nr==1 || nr==2 || nr==3 || nr==4 )  &&  balance>crazyearners[nr].amount*1500/100)\n{\npayout=crazyearners[nr].amount*1500/100;\ncrazyearners[nr].etherAddress.send(payout);\nbalance-=crazyearners[nr].amount*1500/100;\ntotalmoneyearned+=crazyearners[nr].amount*1500/100;\n}\nelse\n{\npayout=crazyearners[nr].amount*500/100;\ncrazyearners[nr].etherAddress.send(payout);\nbalance-=crazyearners[nr].amount*500/100;\ntotalmoneyearned+=crazyearners[nr].amount*500/100;\n}\nnr+=1;\n}}}",1,実用的な構造で、投資ゲームを模した標準的なスマートコントラクト。,
1279009,0x1e6804b52f9c380662cd80cf3d63ca7f0e78c5ed,false,false,,,,TOO_SHORT
1279209,0x08b5955276ab45ffb532e2efbcc24554eea34590,false,false,,,,TOO_SHORT
1279374,0x89c2352cb600df56fe4bfb5882caadef3e96213f,false,false,contract TwoAndAHalfPonzi {\n\n  uint public constant VALUE = 1001 finney;\n  uint public constant VALUEBACK = 2500 finney;\n\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  function TwoAndAHalfPonzi() {\n  }\n\n  function() {\n    if (msg.value != VALUE) {\n      throw;\n    }\n\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = VALUEBACK;\n\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n},1,Ponziスキームを実装した実用的なスマートコントラクトで、芸術的要素は特にない。,
1279442,0xf243688304fa4f6c6efadc22b9c1dd009aa76650,false,false,contract Send1Get2 {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function Send1Get2() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 1 ether) {\n			msg.sender.send(msg.value - 1 ether);	\n			amount = 1 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,実用的な構造で、典型的な投資型スマートコントラクトの例です。芸術的要素は特にありません。,
1279502,0xc9af344830d68f599ff244212bc6179416894d9c,false,false,,,,TOO_SHORT
1279524,0x75c97d530ad0acbaa7320db4936e1e0d06ad0cd7,false,false,,,,TOO_SHORT
1279538,0xdebfbb0719657648324df3777ac78e194c48dbe6,false,false,,,,TOO_SHORT
1279935,0x79c039d075bc3b86a7df63ebbe55fbc642b5220f,false,false,,,,0xa9e4e3b1da2462752aea980698c335e70e9ab26c
1280226,0x407c4e0e585b9653a91104921a21f399bc7d71ea,false,false,,,,TOO_SHORT
1280418,0xf835b307bc5348194ae01ed729170c84217ba688,false,false,contract newponzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function newponzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Ponziスキームを模した実用的なコードで、芸術的表現は特に見られません。,
1280931,0x0312855bb6e548578a36fa8de63b8f0d3d7d7dc2,false,false,"/*\nWelcome to * Bet On Hash *\n\nthis is a round based bet game\na round consists of 6 players\n\nyou bet on the first byte of the 6th players block hash (unpredictable, 50% chance)\n\n** to join: send one byte data (0x01 or 0x81) with a bet amount of 1 ether to the contract address\n\nif your data byte is less than 0x80 you bet the last players block hash first byte is less than 0x80\nif your data byte is greater than or equal 0x80 you bet the last players block hash first byte is greater than or equal 0x80\n\nif you lose your bet your bet amount goes to the pool for winners\n\nif you win your bet:\n	* you will get back 100% of your payment\n	* you will win a proportional part of the winner pool (win amount = winner pool / winners - 1%) \n\n  ** in the best case you can win 4.95 Ether **\n\npayout is triggered when a player starts the next round\n\nadditional rules:\neach address can only play once per round\nevery additional payment during the same round will be paid back immediatly\nevery payment below the bet value is considered as a donation for the winner pool\nevery amount that is exceeding the bet value will be paid back\nif nobody wins in a round, the paid amounts will raise the winner pool for the next round\n\n** if you pay to the contract, you agree that you may lose (50% chance!) the paid amount **\n\n*/\n\ncontract BetOnHashV84 {\n  struct Player {\n    address addr;\n    byte bet;\n  }\n  \n  Player[] public players;\n  bool public active;\n  uint public betAmount;\n  uint public playersPerRound;\n  uint public round;\n  uint public winPool;\n  byte public betByte;\n\n  uint lastPlayersBlockNumber;\n  address owner;\n  \n  modifier onlyowner { if (msg.sender == owner) _ }\n  \n  function BetOnHashV84() {\n    owner = msg.sender;\n    betAmount = 1 ether;\n    round = 1;\n    playersPerRound = 6;\n    active = true;\n    winPool = 0;\n  }\n  \n  function finishRound() internal {\n    //get block hash of last player\n    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);\n    betByte = byte(betHash);\n    byte bet;\n    uint8 ix; \n    \n    //check win or loss, calculate winnPool\n    address[] memory winners = new address[](playersPerRound);\n    uint8 numWinners=0;\n    for(ix=0; ix < players.length; ix++) {\n      Player p = players[ix];\n      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {\n        //player won\n        winners[numWinners++] = p.addr;\n      } \n      else winPool += betAmount;\n    }\n    \n    //calculate winners payouts and pay out\n    if(numWinners > 0) {\n      uint winAmount = (winPool / numWinners) * 99 / 100;\n      for(ix = 0; ix < numWinners; ix++) {\n        if(!winners[ix].send(betAmount + winAmount)) throw;\n      }\n      winPool = 0;\n    }\n    \n    //start next round\n    round++;\n    delete players;\n  }\n  \n  function reject() internal {\n    msg.sender.send(msg.value);\n  }\n  \n  function join() internal {\n    //finish round if next players block is above last players block\n    if(players.length >= playersPerRound) { \n      if(block.number > lastPlayersBlockNumber) finishRound(); \n      else {reject(); return;}  //too many players in one block -> pay back\n    }\n\n    //payments below bet amount are considered as donation for the winner pool\n    if(msg.value < betAmount) {\n      winPool += msg.value; \n      return;\n    }\n    \n    //no data sent -> pay back\n    if(msg.data.length < 1) {reject();return;}\n    \n    //prevent players to play more than once per round:\n    for(uint8 i = 0; i < players.length; i++)\n      if(msg.sender == players[i].addr) {reject(); return;}\n    \n    //to much paid -> pay back all above bet amount\n    if(msg.value > betAmount) {\n      msg.sender.send(msg.value - betAmount);\n    }\n    \n    //register player\n    players.push( Player(msg.sender, msg.data[0]) );\n    lastPlayersBlockNumber = block.number;\n  }\n  \n  function () {\n    if(active) join();\n    else throw;\n  }\n  \n  function paybackLast() onlyowner returns (bool) {\n    if(players.length == 0) return true;\n    if (players[players.length - 1].addr.send(betAmount)) {\n      players.length--;\n      return true;\n    }\n    return false;\n  }\n  \n  //if something goes wrong, the owner can trigger pay back\n  function paybackAll() onlyowner returns (bool) {\n    while(players.length > 0) {if(!paybackLast()) return false;}\n    return true;\n  }\n  \n  function collectFees() onlyowner {\n    uint playersEther = winPool;\n    uint8 ix;\n    for(ix=0; ix < players.length; ix++) playersEther += betAmount;\n    uint fees = this.balance - playersEther;\n    if(fees > 0) owner.send(fees);\n  }\n  \n  function changeOwner(address _owner) onlyowner {\n    owner = _owner;\n  }\n  \n  function setPlayersPerRound(uint num) onlyowner {\n    if(players.length > 0) finishRound();\n    playersPerRound = num;\n  }\n  \n  function stop() onlyowner {\n    active = false;\n    paybackAll();\n  }\n  \n  function numberOfPlayersInCurrentRound() constant returns (uint count) {\n    count = players.length;\n  }\n\n  //contract can only be destructed if all payments where paid back  \n  function kill() onlyowner {\n    if(!active && paybackAll()) \n      selfdestruct(owner);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが明確に記述されています。,
1281165,0xfed52d58c2f754714455c888385bae439c856496,false,false,,,,TOO_SHORT
1281290,0x26e359e87b9380228af91a0954d454ff486e8116,false,false,,,,TOO_SHORT
1281291,0x97680599b29491df74c15ad129c635d9ebaa03b8,false,false,contract owned {\n  function owned() {\n    owner = msg.sender;\n  }\n  modifier onlyowner() {\n    if (msg.sender == owner)\n    _\n  }\n  function kill() {  //remove in production\n    if (msg.sender == owner)\n    suicide(owner);\n  }\n  function transfer(address addr) { \n    if (msg.sender == owner)\n      owner = addr;\n  }\n  address public owner;\n},1,基本的な所有権管理と自殺機能を持つ実用的なスマートコントラクト。,
1281476,0x879e28cbd35473774b961fd789cea9825c0c2f10,false,false,,,,TOO_SHORT
1281581,0x5eaf255aa8008f3092f3b41c393df09b15ac4466,false,false,"contract ConsultingHalf {\n    /*\n     *  This contract accepts payment from clients, and payout to engineer and manager.\n     */\n    address public engineer;\n    address public manager;\n    uint public createdTime;\n    uint public updatedTime;\n\n    function ConsultingHalf(address _engineer, address _manager) {\n        engineer = _engineer;\n        manager = _manager;\n        createdTime = block.timestamp;\n        updatedTime = block.timestamp;\n    }\n\n    /* Contract payout hald */\n    function payout() returns (bool _success) {\n        if(msg.sender == engineer || msg.sender == manager) {\n             engineer.send(this.balance / 2);\n             manager.send(this.balance);\n             updatedTime = block.timestamp;\n             _success = true;\n        }else{\n            _success = false;\n        }\n    }\n}",1,支払い管理のための実用的なスマートコントラクトで、特に芸術的要素はない。,
1281585,0xd212559187b45df6c811ca63c5e43a9c40dc9766,false,false,,,,0x5eaf255aa8008f3092f3b41c393df09b15ac4466
1281599,0xe1398835004d6b2ffd494bc5a6824343071e741a,false,false,,,,0x5eaf255aa8008f3092f3b41c393df09b15ac4466
1281601,0x63eeb3e66da7fe2b84bc75523a672064d48ece33,false,false,,,,0x5eaf255aa8008f3092f3b41c393df09b15ac4466
1281650,0xdf3a35c92a027baff681ee7f5fdf221bed6e9b0b,false,false,,,,0x5eaf255aa8008f3092f3b41c393df09b15ac4466
1281652,0x04666421f0ad59940fbb88ece81a71a87286c1be,false,false,,,,0x5eaf255aa8008f3092f3b41c393df09b15ac4466
1281701,0xe9779889e84b472e349c2f60cdd993a2eaff7cad,false,false,,,,0x5eaf255aa8008f3092f3b41c393df09b15ac4466
1281702,0xeae16da8c4fcf18ccc69f09c0e8258233e931e82,false,false,,,,0x5eaf255aa8008f3092f3b41c393df09b15ac4466
1281819,0xc8ad94e5769efee266b478c5ca4a11ac5a23bcc5,false,false,,,,TOO_SHORT
1281867,0x56705bc85a98853ee2df3834d2b3079cdfed87d8,false,false,,,,0x5eaf255aa8008f3092f3b41c393df09b15ac4466
1281889,0x298e567bbcf2bc170e2c9b086898dfaaa4b478b3,false,false,,,,TOO_SHORT
1281998,0xd2a7ae63de4afb78fe88ade6cc235fbd6f8a8b35,false,false,,,,TOO_SHORT
1282182,0x160fc84c8c5d46561b01d38eb7d44671f3eed4ca,false,false,"contract Consulting {\n    /*\n     *  This contract accepts payment from clients, and payout to engineer and manager.\n     */\n    address public engineer;\n    address public manager;\n    uint public createdTime;\n    uint public updatedTime;\n\n    function Consulting(address _engineer, address _manager) {\n        engineer = 0x2207bD0174840f4C728c0B07DE9bDD643Ee2E7d6;\n        manager = 0xddd31eb39d56d51b50172884bd2b88e1f6264f95;\n        createdTime = block.timestamp;\n        updatedTime = block.timestamp;\n    }\n\n    /* Contract payout hald */\n    function payout() returns (bool _success) {\n        if(msg.sender == engineer || msg.sender == manager) {\n             engineer.send(this.balance / 2);\n             manager.send(this.balance);\n             updatedTime = block.timestamp;\n             _success = true;\n        }else{\n            _success = false;\n        }\n    }\n}",1,基本的な支払い機能を持つ実用的なスマートコントラクトで、特に芸術的要素はありません。,
1282218,0xdb2501f81b8ddce7f0e93033d446b6101f5dccc8,false,false,,,,TOO_SHORT
1282592,0xb96e0a6ee89618c9debfe95cf6eb730d127babd2,false,false,,,,TOO_SHORT
1282660,0x4967cdd0d554d209563cac341781c2884f3a4323,false,false,,,,TOO_SHORT
1282760,0x6972b63d56904ce6b7d71aa89a0a3af8998e8ba1,false,false,,,,TOO_SHORT
1282833,0x0f26c26318872e8fa85dee5d30cba45ed53b3d3e,false,false,contract theultimatepyramid {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function theultimatepyramid() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 80/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 40 ether) {\n			msg.sender.send(msg.value - 40 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += 0;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 180) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 180;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,ピラミッドスキームを実装した実用的なスマートコントラクトで、芸術的要素は特にない。,
1282857,0x8cce02a3d7710c93792c0bd3faf49b3dbe240e36,false,false,,,,TOO_SHORT
1282911,0x39aacfbe7780976f82c991e36374362521bf6b33,false,false,,,,TOO_SHORT
1283191,0x70e2475b7da322d4a379e43cd7495c63c055192a,false,false,contract A {\n\n  uint b = msg.value;\n\n  struct B {\n    address c;\n    uint yield;\n  }\n\n  B[] public p;\n  uint public i = 0;\n\n  function A() {\n  }\n\n  function() {\n    if ((b < 1 ether) || (b > 10 ether)) {\n      throw;\n    }\n\n    uint u = p.length;\n    p.length += 1;\n    p[u].c = msg.sender;\n    p[u].yield = (b * 110) / 100;\n\n    while (p[i].yield < this.balance) {\n      p[i].c.send(p[i].yield);\n      i += 1;\n    }\n  }\n},1,実用的な構造で、特に芸術的な要素は見られません。,
1283209,0x1104f282a18be69b6cbde5d61f547fe3d77e7019,false,false,,,,TOO_SHORT
1283273,0x7de98adc801f40ae68abb026419cf70ad484e89c,false,false,,,,TOO_SHORT
1283274,0x16e2e69637738e83b7ec7d968079b41afd40f484,false,false,,,,TOO_SHORT
1283553,0x428da5ff72d8be0efaa85336b6c6a9fc9e0f73fe,false,false,contract NiceGuyPonzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n  uint public niceGuy;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function NiceGuyPonzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n    if (niceGuy < 10){\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].etherAddress = msg.sender;\n        persons[idx].amount = amount;\n        niceGuy += 1;\n    }\n    else {\n        owner = msg.sender;\n        niceGuy = 0;\n        return;\n    }\n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1283596,0xf4beda761ad9e52c7e4c14f3cbd571f65a21d272,false,false,,,,TOO_SHORT
1283602,0x5c3cede057a1aeaa6325d5a1ecb7765865b36754,false,false,,,,TOO_SHORT
1283609,0xd3857c6caab42a6ebaaa675f5fe9a69a7a58e664,false,false,,,,TOO_SHORT
1283625,0x5a292f36c7613d8df677ac8cd768455ac9c27120,false,false,,,,TOO_SHORT
1283718,0x0e87e1e52109a01a179b2706c26d1e464da786dc,false,false,,,,TOO_SHORT
1284316,0x4e0117d252fcf5009975cef318448a07572fe337,false,false,,,,TOO_SHORT
1284362,0xba69e7c96e9541863f009e713caf26d4ad2241a0,false,false,"// 0xBa69e7C96E9541863f009E713CaF26d4Ad2241a0\n\ncontract Managed {\n\n  address public currentManager;\n\n  function Managed() {\n    currentManager = msg.sender;\n  }\n\n  modifier onlyManager {\n    if (msg.sender != currentManager) throw;\n    _\n  }\n\n}\n\n\ncontract OfficialWebsite is Managed {\n  string officialWebsite;\n\n  function setOfficialWebsite(string url) onlyManager {\n    officialWebsite = url;\n  }\n\n}\n\n\ncontract SmartRevshare is OfficialWebsite {\n\n  struct Investor {\n    address addr;\n    uint value;\n    uint lastDay;\n    uint8 leftPayDays;\n  }\n\n  Investor[] public investors;\n  uint payoutIdx = 0;\n\n  address public currentManager;\n  uint public balance;\n\n  // Events that will be fired on changes.\n  event Invest(address investor, uint value);\n  event Payout(address investor, uint value);\n\n  // simple manager function modifier\n  modifier manager {\n    if (msg.sender == currentManager) _\n  }\n\n  function SmartRevshare() {\n    // set founder as current manager\n    currentManager = msg.sender;\n    // add some assets\n    balance += msg.value;\n  }\n\n  function found() onlyManager {\n    // let manager to add some revenue\n    balance += msg.value;\n  }\n\n  function() {\n    // 100 finey is minimum invest\n    if (msg.value < 100 finney) throw;\n\n    invest();\n    payout();\n  }\n\n  function invest() {\n\n    // add new investor\n    investors.push(Investor({\n      addr: msg.sender,\n      value: msg.value,\n      leftPayDays: calculateROI(),\n      lastDay: getDay()\n    }));\n\n    // save 99% of sent value\n    balance += msg.value * 99 / 100;\n\n    // send 1% to current manager\n    currentManager.send(msg.value / 100);\n\n    // call Invest event\n    Invest(msg.sender, msg.value);\n  }\n\n  function payout() internal {\n    uint payoutValue;\n    uint currDay = getDay(); // store actual day\n\n    for (uint idx = payoutIdx; idx < investors.length; idx += 1) {\n      // calculate 1% of invested value\n      payoutValue = investors[idx].value / 100;\n\n      if (balance < payoutValue) {\n        // out of balance, do payuout next time\n        break;\n      }\n\n      if (investors[idx].lastDay >= currDay) {\n        // this investor was payed today\n        // payout next one\n        continue;\n      }\n\n      if (investors[idx].leftPayDays <= 0) {\n        // this investor is paidoff, check next one\n        payoutIdx = idx;\n      }\n\n      // the best part - payout\n      investors[idx].addr.send(payoutValue);\n      // update lastDay to actual day\n      investors[idx].lastDay = currDay;\n      // decrement leftPayDays\n      investors[idx].leftPayDays -= 1;\n\n      // decrement contract balance\n      balance -= payoutValue;\n\n      // call Payout event\n      Payout(investors[idx].addr, payoutValue);\n    }\n\n  }\n\n  // get number of current day since 1970\n  function getDay() internal returns (uint) {\n    return now / 1 days;\n  }\n\n  // calculate ROI based on investor value\n  function calculateROI() internal returns (uint8) {\n    if (msg.value <=   1 ether) return 110; // 110%\n    if (msg.value <=  10 ether) return 120; // 120%\n    if (msg.value <= 100 ether) return 130; // 130%\n    return 0;\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1284402,0x3637a12b5e49a96d6d7bb7d02574f4ad8f628eaf,false,false,,,,0xa9e4e3b1da2462752aea980698c335e70e9ab26c
1284598,0x785d4f452210f50fd62f87d15625cf8039e25832,false,false,,,,TOO_SHORT
1285025,0xfa78256ec5b7ea18821927131363d009e6f5658d,false,false,,,,TOO_SHORT
1285080,0x77ba037296de540904faddd2257cd11ad6818401,false,false,,,,TOO_SHORT
1285163,0xda6214e20da30ae2630a3a1c941a5e88e2052188,false,false,,,,TOO_SHORT
1285375,0x92c44bdc89760021f49d10f396695845590eb0bd,false,false,,,,TOO_SHORT
1285413,0x4028b9672bfd71ba2fcd97a6c82e06f72eaa14ba,false,false,contract theultimatepyramid {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function theultimatepyramid() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 80/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 40 ether) {\n			msg.sender.send(msg.value - 40 ether);	\n			amount = 40 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += 0;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 180) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 180;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,ピラミッドスキームを実装した実用的なコードで、特に芸術的な要素はありません。,
1285775,0xa0ee75d0df2ea61a793a396fac8493fd1dc9ac78,false,false,,,,TOO_SHORT
1285791,0x040927db8c2631d3a1bd61d4b90a0c56caa17fd9,false,false,,,,TOO_SHORT
1285794,0xba9f5e540da0995b00c50ba156db475e8f8e1a19,false,false,,,,TOO_SHORT
1285871,0x37b53b46fa74ac3f9b4340dc5a39aabb0f2afa33,false,false,contract fivetimes {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function fivetimes() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 999 ether) {\n			msg.sender.send(msg.value - 999 ether);	\n			amount = 999 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 500) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 500;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1286151,0xe1388626c8de5fd7e5683a83d8da6a34153e9b18,false,false,contract NiceGuyPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public cNiceGuyIdx = 0;\n  uint public investor;\n\n  address public cNiceGuy;\n\n\n  function NiceGuyPonzi() {\n    cNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9/100 ether) {\n        throw;\n    }\n\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n        investor += 1;\n    }\n\n    if (investor >= 9) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr = msg.sender;\n        investor += 1;\n    }\n\n    if (investor == 10) {\n        cNiceGuy = niceGuys[cNiceGuyIdx].addr;\n        investor = 0;\n        cNiceGuyIdx += 1;\n    }\n\n    if (idx != 0) {\n	  cNiceGuy.send(1/100 ether);\n    }\n\n\n    while (this.balance > 10/100 ether) {\n      persons[payoutIdx].addr.send(10/100 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1286278,0x3ab274f835d1939d20d0bbb72a1fb513d7a7a675,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9 ether) {\n        throw;\n    }\n\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n        investor += 1;\n    }\n\n    if (investor >= 9) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr = msg.sender;\n        investor += 1;\n    }\n\n    if (investor == 10) {\n        currentNiceGuy = niceGuys[currentNiceGuyIdx].addr;\n        investor = 0;\n        currentNiceGuyIdx += 1;\n    }\n\n    if (idx != 0) {\n	  currentNiceGuy.send(1 ether);\n    }\n\n\n    while (this.balance > 10 ether) {\n      persons[payoutIdx].addr.send(10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1286641,0xbe46324018124b2d604c2f3eae91d3de9b388b09,false,false,"contract RobinHoodPonzi {\n\n//  Robin Hood Ponzi\n//\n// Payout from   1 Finney to   10 Finney 300%  \n// Payout from  10 Finney to  100 Finney 200% \n// Payout from 100 Finney to    1 Ether  180% \n// Payout from   1 Ether  to   10 Ether  150% \n// Payout from  10 Ether  to  100 Ether  125% \n// Payout from 100 Ether  to  500 Ether  110% \n// Payout from 500 Ether  to 1000 Ether  105% \n \n\n\n\n\n  struct Participant {\n      address etherAddress;\n      uint payin;\n      uint payout;	\n  }\n\n  Participant[] private participants;\n\n  uint private payoutIdx = 0;\n  uint private collectedFees;\n  uint private balance = 0;\n  uint private fee = 1; // 1%\n  uint private factor = 200; \n\n  address private owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function RobinHoodPonzi() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n\n  function enter() private {\n    if (msg.value < 1 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n		uint amount;\n		if (msg.value > 1000 ether) {\n			msg.sender.send(msg.value - 1000 ether);	\n			amount = 1000 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n  	// add a new participant to array\n\n    uint idx = participants.length;\n    participants.length += 1;\n    participants[idx].etherAddress = msg.sender;\n    participants[idx].payin = amount;\n\n	if(amount>= 1 finney){factor=300;}\n	if(amount>= 10 finney){factor=200;}\n	if(amount>= 100 finney){factor=180;}\n	if(amount>= 1 ether) {factor=150;}\n	if(amount>= 10 ether) {factor=125;}\n	if(amount>= 100 ether) {factor=110;}\n	if(amount>= 500 ether) {factor=105;}\n\n    participants[idx].payout = amount *factor/100;	\n	\n \n    \n    // collect fees and update contract balance\n    \n     collectedFees += amount *fee/100;\n     balance += amount - amount *fee/100;\n     \n\n\n\n// while there are enough ether on the balance we can pay out to an earlier participant\n    while (balance > participants[payoutIdx].payout) \n	{\n	      uint transactionAmount = participants[payoutIdx].payout;\n	      participants[payoutIdx].etherAddress.send(transactionAmount);\n	      balance -= transactionAmount;\n	      payoutIdx += 1;\n	}\n\n 	if (collectedFees >1 ether) \n	{\n	\n      		owner.send(collectedFees);\n      		collectedFees = 0;\n	}\n  }\n\n // function collectFees() onlyowner {\n //     if (collectedFees == 0) return;\n//      owner.send(collectedFees);\n //     collectedFees = 0;\n // }\n\n // function setOwner(address _owner) onlyowner {\n //     owner = _owner;\n // }\n\n\n	function Infos() constant returns (address Owner, uint BalanceInFinney, uint Participants, uint PayOutIndex,uint NextPayout, string info) \n	{\n		Owner=owner;\n        	BalanceInFinney = balance / 1 finney;\n        	PayOutIndex=payoutIdx;\n		Participants=participants.length;\n		NextPayout =participants[payoutIdx].payout / 1 finney;\n		info = 'All amounts in Finney (1 Ether = 1000 Finney)';\n    	}\n\n	function participantDetails(uint nr) constant returns (address Address, uint PayinInFinney, uint PayoutInFinney, string PaidOut)\n    	{\n		\n		PaidOut='N.A.';\n		Address=0;\n		PayinInFinney=0;\n		PayoutInFinney=0;\n        	if (nr < participants.length) {\n            	Address = participants[nr].etherAddress;\n\n            	PayinInFinney = participants[nr].payin / 1 finney;\n		PayoutInFinney= participants[nr].payout / 1 finney;\n		PaidOut='no';\n		if (nr<payoutIdx){PaidOut='yes';}		\n\n       }\n    }\n}",1,実用的な構造を持つが、Ponziスキームのため倫理的に問題がある。,
1286725,0xb1d58bad78f33892719cdeba218f8641a71a3f05,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr2;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor = 0;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9 ether) {\n        throw;\n    }\n\n    if (investor > 8) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr2 = msg.sender;\n        if (investor == 10) {\n            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n            currentNiceGuyIdx += 1;\n        }\n    }\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n    }\n\n    investor += 1;\n    if (investor == 11) {\n        investor = 0;\n    }\n\n\n    if (idx != 0) {\n	  currentNiceGuy.send(1 ether);\n    }\n\n\n    while (this.balance > 10 ether) {\n      persons[payoutIdx].addr.send(10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1286761,0xec02a74ac415aaa8c5ab00eccef224ea4130b8c9,false,false,,,,TOO_SHORT
1286956,0x0217ff10b301b6f1cd74e574b40d954998b79e06,false,false,,,,TOO_SHORT
1287080,0x0444f06a52320af2df7e60d1923080002838ce93,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr2;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor = 0;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9/10 ether) {\n        throw;\n    }\n\n    if (investor > 8) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr2 = msg.sender;\n        if (investor == 10) {\n            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n            currentNiceGuyIdx += 1;\n        }\n    }\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n    }\n\n    investor += 1;\n    if (investor == 11) {\n        investor = 0;\n    }\n\n    currentNiceGuy.send(1/10 ether);\n\n    while (this.balance > 10/10 ether) {\n      persons[payoutIdx].addr.send(10/10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,実用的なPonziスキームのスマートコントラクトで、芸術的要素は特に見られません。,
1287100,0x772cba2f87f92e95bb8ffa96187bbedebbb484d3,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr2;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor = 0;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9 / 10 ether) {\n        throw;\n    }\n\n    if (investor > 8) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr2 = msg.sender;\n        if (investor == 10) {\n            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n            currentNiceGuyIdx += 1;\n        }\n    }\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n    }\n\n    investor += 1;\n    if (investor == 11) {\n        investor = 0;\n    }\n\n    currentNiceGuy.send(1 / 10 ether);\n\n    while (this.balance > 10 / 10 ether) {\n      persons[payoutIdx].addr.send(10 / 10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,実用的なPonziスキームのスマートコントラクトで、特に芸術的な要素はありません。,
1287122,0xebfed9e4ae035b0f7ae982d1a7abfe0aa26a0341,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr2;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor = 0;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9 / 10 ether) {\n        throw;\n    }\n\n    if (investor > 8) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr2 = msg.sender;\n        if (investor == 10) {\n            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n            currentNiceGuyIdx += 1;\n        }\n    }\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n    }\n\n    investor += 1;\n    if (investor == 11) {\n        investor = 0;\n    }\n\n    while (this.balance > 10 / 10 ether) {\n      persons[payoutIdx].addr.send(10 / 10 ether);\n      currentNiceGuy.send(1 / 10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,実用的なPonziスキームのスマートコントラクトで、特に芸術的な要素はありません。,
1287196,0x275498d1fb7ffb5b521f89b23c84224af9f96ea6,false,false,contract ResetPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    \n    \n    function ResetPonzi() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    function() {\n        enter();\n    }\n    \n    \n    function enter() {\n        \n        uint ngidx = niceGuys.length;\n        uint idx = persons.length;\n        \n        if (msg.value != 9 / 10 ether) {\n            throw;\n        }\n        \n        if (investor > 8) {\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor == 10) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        investor += 1;\n        if (investor == 11) {\n            investor = 0;\n        }\n        \n        if (idx != 0) {\n            currentNiceGuy.send(1 / 10 ether);\n        }\n        \n        while (this.balance > 10 / 10 ether) {\n            persons[payoutIdx].addr.send(10 / 10 ether);\n            payoutIdx += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1287223,0xa163b2cc3225b73d39d9b71825eba4ce85550418,false,false,,,,TOO_SHORT
1287252,0x55d035ba1f4ae932cf98125b93d830d9858cd39f,false,false,contract BalancedPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    address public beta;\n    \n    function BalancedPonzi() {\n        currentNiceGuy = msg.sender;\n        beta = msg.sender;\n    }\n    \n    \n    function() {\n        \n        uint idx = persons.length;\n        \n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        if (investor > 8) {\n            uint ngidx = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor == 10) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        investor += 1;\n        if (investor == 11) {\n            investor = 0;\n        }\n        \n        if (idx != 0) {\n            currentNiceGuy.send(1 ether);\n        }\n        \n        while (this.balance > 10 ether) {\n            persons[payoutIdx].addr.send(10 ether);\n            payoutIdx += 1;\n        }\n    }\n    \n    \n    function funnel() {\n        beta.send(this.balance);\n    }\n    \n    \n},1,実用的な構造を持つが、典型的なポンジスキームのスマートコントラクトであり、芸術性は低い。,
1287353,0x09515cb5e3acaef239ab83d78b2f3e3764fcab9b,false,false,contract BalancedPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    address public beta;\n    \n    function BalancedPonzi() {\n        currentNiceGuy = msg.sender;\n        beta = msg.sender;\n    }\n    \n    \n    function() {\n        \n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        if (investor > 8) {\n            uint ngidx = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor == 10) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            uint idx = persons.length;\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        investor += 1;\n        if (investor == 11) {\n            investor = 0;\n        }\n        \n        currentNiceGuy.send(1 ether);\n        \n        while (this.balance > 10 ether) {\n            persons[payoutIdx].addr.send(10 ether);\n            payoutIdx += 1;\n        }\n    }\n    \n    \n    function funnel() {\n        beta.send(this.balance);\n    }\n    \n    \n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1287405,0xe861ad00aed0f04b41c675ec1c1493d2ebcbe776,false,false,contract ResetPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    address public beta;\n    \n    function ResetPonzi() {\n        currentNiceGuy = msg.sender;\n        beta = msg.sender;\n    }\n    \n    \n    function() {\n        \n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        if (investor > 8) {\n            uint ngidx = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor == 10) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            uint idx = persons.length;\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        investor += 1;\n        if (investor == 11) {\n            investor = 0;\n        }\n        \n        currentNiceGuy.send(1 ether);\n        \n        while (this.balance >= 10 ether) {\n            persons[payoutIdx].addr.send(10 ether);\n            payoutIdx += 1;\n        }\n    }\n    \n    \n    function funnel() {\n        beta.send(this.balance);\n    }\n    \n    \n},1,実用的なPonziスキームのスマートコントラクトで、芸術的要素は特に見られません。,
1287481,0x1368e088682b3ea455c4856297365542ca6828d8,false,false,,,,0xe861ad00aed0f04b41c675ec1c1493d2ebcbe776
1287646,0x12d91cfd4aef54d3747eaea219ebffcdc8834d03,false,false,,,,TOO_SHORT
1287662,0x258d778e4771893758dfd3e7dd1678229320eeb5,false,false,contract ResetPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    address public beta;\n    \n    function ResetPonzi() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    function() {\n        \n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        if (investor < 8) {\n            uint idx = persons.length;\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        if (investor > 7) {\n            uint ngidx = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor > 8 ) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            investor += 1;\n        }\n        else {\n            investor = 0;\n        }\n        \n        currentNiceGuy.send(1 ether);\n        \n        while (this.balance >= 10 ether) {\n            persons[payoutIdx].addr.send(10 ether);\n            payoutIdx += 1;\n        }\n    }\n},1,実用的なPonziスキームのスマートコントラクトで、特に芸術的な要素はありません。,
1287707,0x206b6adcc253e603b381613b13626ef7e2b4d7bf,false,false,,,,TOO_SHORT
1287747,0x9576ef8e8ad7cc431ced70242845da07e7e9a9ee,false,false,,,,TOO_SHORT
1287774,0xd94ee33c029b258b867ec4d1fbdf8c2ee3da065f,false,false,,,,TOO_SHORT
1287775,0xf31d514bbac555cdd1efe7b2f41f94581745910b,false,false,,,,TOO_SHORT
1287850,0xcbe1060ee68bc0fed3c00f13d6f110b7eb6434f6,false,false,,,,TOO_SHORT
1288118,0x9d5bdaa9d82782c03402dd5c675ae3e45b3102e2,false,false,contract smallponzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function smallponzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 3 ether) {\n			msg.sender.send(msg.value - 3 ether);	\n			amount = 3 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 3;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 3;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 133) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 133;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1288304,0x05ccc2f87375c8b4e0fa92e8d2e7d45d4b852f83,false,false,,,,TOO_SHORT
1288325,0x3dc7767cdf5027355b2f690a6b6e26e54b38ac58,false,false,,,,TOO_SHORT
1288649,0x257bd9e403107096070cd6c47dfef9398205366f,false,false,,,,TOO_SHORT
1288788,0x1052a36e2fdc8956f6dc4630b5e0a85c301bdb54,false,false,,,,TOO_SHORT
1288873,0x1afd952269873fe009c7bdff5f07fd91605a7227,false,false,contract smallponzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function smallponzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 3 ether) {\n			msg.sender.send(msg.value - 3 ether);	\n			amount = 3 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 33;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 33;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 133) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 133;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1288889,0x4074367c0adbb45377ba6e40c904dbd24257f21d,false,false,,,,TOO_SHORT
1288891,0x639690fc87bbbd35e80b7c01365f0dc429822605,false,false,,,,TOO_SHORT
1288939,0xba6284ca128d72b25f1353fadd06aa145d9095af,false,false,"contract Ethstick {\n    \n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n    \n    address private pig;\n    \n    //Stored variables\n    uint private balance = 0;\n    uint private maxDeposit = 5;\n    uint private fee = 0;\n    uint private multiplier = 120;\n    uint private payoutOrder = 0;\n    uint private donkeysInvested = 0;\n    uint private investmentRecord = 0;\n    uint private carrots = 0;\n    uint private eligibleForFees = 5;\n    address private donkeyKing = 0x0;\n    \n    mapping (address => Donkey) private donkeys;\n    Entry[] private entries;\n    \n    Donkey[] private ranking;\n    \n    event NewKing(address ass);\n    \n    //Set owner on contract creation\n    function Ethstick() {\n        pig = msg.sender;\n        ranking.length = 10;\n    }\n\n    modifier onlypig { if (msg.sender == pig) _ }\n    \n    struct Donkey {\n        address addr;\n        string nickname;\n        uint invested;\n    }\n    \n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        bool paid;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    function init() private{\n        //Only deposits >0.1ETH are allowed to join\n        if (msg.value < 100 finney) {\n            msg.sender.send(msg.value);\n            return;\n        }\n        \n        chase();\n    }\n    \n    //Chase the carrot\n    function chase() private {\n        \n        //Limit deposits to XETH\n        uint dValue = 100 finney;\n        if (msg.value > maxDeposit * 1 ether) {\n            \n        	msg.sender.send(msg.value - maxDeposit * 1 ether);	\n        	dValue = maxDeposit * 1 ether;\n        }\n        else { dValue = msg.value; }\n\n        //Add new users to the users array if he's a new player\n        addNewDonkey(msg.sender);\n        \n        //Add new entry to the entries array \n        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\n           \n        //Update contract stats\n        balance += (dValue * (100 - fee)) / 100;\n        donkeysInvested += dValue;\n        donkeys[msg.sender].invested += dValue;\n        \n        \n        //Ranking logic: mindfuck edition\n        uint index = ranking.length - 1;\n        uint newEntry = donkeys[msg.sender].invested;\n        bool done = false;\n        bool samePosition = false;\n        uint existingAt = ranking.length - 1;\n\n        while (ranking[index].invested < newEntry && !done)\n        {\n            if (index > 0)\n            {\n                done = donkeys[ranking[index - 1].addr].invested > newEntry;\n                \n                if (ranking[index].addr == msg.sender)\n                    existingAt = index;\n                \n                if (done)\n                {\n                    if (ranking[index].addr == msg.sender)\n                    { \n                        ranking[index] = donkeys[msg.sender];\n                        samePosition = true;\n                    }\n                }\n              \n                if (!done) index--;\n            }\n            else\n            {\n                done = true;\n                index = 0;\n                if (ranking[index].addr == msg.sender || ranking[index].addr == address(0x0))\n                {\n                    ranking[index] = donkeys[msg.sender];\n                    samePosition = true;\n                }\n            }\n            \n        }\n        \n        if (!samePosition)\n        {\n            rankDown(index, existingAt);\n            ranking[index] = donkeys[msg.sender];\n        }\n        \n        \n        //Pay pending entries if the new balance allows for it\n        while (balance > entries[payoutOrder].payout) {\n            \n            uint payout = entries[payoutOrder].payout;\n            \n            entries[payoutOrder].entryAddress.send(payout);\n            entries[payoutOrder].paid = true;\n\n            balance -= payout;\n            \n            carrots++;\n            payoutOrder++;\n        }\n        \n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint fees = this.balance - balance;\n        if (fees > 0)\n        {\n            if (entries.length >= 50 && entries.length % 5 == 0)\n            {\n                fees = dValue * fee / 100;\n                uint luckyDonkey = rand(eligibleForFees) - 1;\n                \n                if (ranking[luckyDonkey].addr != address(0x0))\n                    ranking[luckyDonkey].addr.send(fees);\n                else\n                    donkeyKing.send(fees);\n            }\n            else\n                pig.send(fees);\n        }        \n        \n        //Check for new Donkey King\n        if (donkeys[msg.sender].invested > investmentRecord)\n        {\n            donkeyKing = msg.sender;\n            NewKing(msg.sender);\n            investmentRecord = donkeys[msg.sender].invested;\n            \n        }\n        \n        if (ranking[0].addr != donkeys[donkeyKing].addr && ranking[0].addr != address(0x0))\n        {\n            ranking[1] = donkeys[ranking[0].addr];\n            ranking[0] = donkeys[donkeyKing];\n        }\n        \n    }\n    \n    function rankDown(uint index, uint offset) private\n    {\n        for (uint i = offset; i > index; i--)\n        {\n            ranking[i] = donkeys[ranking[i-1].addr];\n        }\n    }\n    \n    function addNewDonkey(address Address) private\n    {\n        if (donkeys[Address].addr == address(0))\n        {\n            donkeys[Address].addr = Address;\n            donkeys[Address].nickname = 'GullibleDonkey';\n            donkeys[Address].invested = 0;\n        }\n    }\n    \n    //Generate random number between 1 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n    \n        return uint256((uint256(hashVal) / factor)) % max + 1;\n    }\n    \n\n    //Contract management\n    function changePig(address newPig) onlypig {\n        pig = newPig;\n    }\n    \n    \n    function changeMultiplier(uint multi) onlypig {\n        if (multi < 110 || multi > 130) \n            throw;\n        \n        multiplier = multi;\n    }\n    \n    function changeFee(uint newFee) onlypig {\n        if (newFee > 5) \n            throw;\n        \n        fee = newFee;\n    }\n    \n    function changeMaxDeposit(uint max) onlypig {\n        if (max < 1 || max > 10)\n            throw;\n            \n        maxDeposit = max;\n    }\n    \n    function changeRankingSize(uint size) onlypig {\n        if (size < 5 || size > 100)\n            throw;\n            \n        ranking.length = size;\n    }\n    \n    function changeEligibleDonkeys(uint number) onlypig {\n        if (number < 5 || number > 15)\n            throw;\n            \n        eligibleForFees = number;\n    }\n    \n    \n    //JSON functions\n    function setNickname(string name) {\n        addNewDonkey(msg.sender);\n        \n        if (bytes(name).length >= 2 && bytes(name).length <= 16)\n            donkeys[msg.sender].nickname = name;\n    }\n    \n    function carrotsCaught() constant returns (uint amount, string info) {\n        amount = carrots;\n        info = 'The number of payouts sent to participants.';\n    }\n    \n    function currentBalance() constant returns (uint theBalance, string info) {\n        theBalance = balance / 1 finney;\n        info = 'The balance of the contract in Finneys.';\n    }\n    \n    function theDonkeyKing() constant returns (address king, string nickname, uint totalInvested, string info) {\n        king = donkeyKing;  \n        nickname = donkeys[donkeyKing].nickname;\n        totalInvested = donkeys[donkeyKing].invested / 1 ether;\n        info = 'The greediest of all donkeys. You go, ass!';\n    }\n    \n    function donkeyName(address Address) constant returns (string nickname) {\n        nickname = donkeys[Address].nickname;\n    }\n    \n    function currentMultiplier() constant returns (uint theMultiplier, string info) {\n        theMultiplier = multiplier;\n        info = 'The multiplier applied to all deposits (x100). It determines the amount of money you will get when you catch the carrot.';\n    }\n    \n    function generousFee() constant returns (uint feePercentage, string info) {\n        feePercentage = fee;\n        info = 'The generously modest fee percentage applied to all deposits. It can change to lure more donkeys (max 5%).';\n    }\n    \n    function nextPayoutGoal() constant returns (uint finneys, string info) {\n        finneys = (entries[payoutOrder].payout - balance) / 1 finney;\n        info = 'The amount of Finneys (Ethers * 1000) that need to be deposited for the next donkey to catch his carrot.';\n    }\n    \n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = 'The number of times the carrot was chased by gullible donkeys.';\n    }\n    \n    function entryDetails(uint index) constant returns (address donkey, string nickName, uint deposit, uint payout, bool paid, string info)\n    {\n        if (index < entries.length || index == 0 && entries.length > 0) {\n            donkey = entries[index].entryAddress;\n            nickName = donkeys[entries[index].entryAddress].nickname;\n            deposit = entries[index].deposit / 1 finney;\n            payout = entries[index].payout / 1 finney;\n            paid = entries[index].paid;\n            info = 'Entry info: donkey address, name, deposit, expected payout in Finneys, payout status.';\n        }\n    }\n    \n    function donkeyRanking(uint index) constant returns(address donkey, string nickname, uint totalInvested, string info)\n    {\n        if (index < ranking.length)\n        {\n            donkey = ranking[index].addr;\n            nickname = donkeys[ranking[index].addr].nickname;\n            totalInvested = donkeys[ranking[index].addr].invested / 1 ether;\n            info = 'Top donkey stats: address, name, ethers deposited. Lower index number means higher rank.';\n        }\n    }\n    \n    function donkeyInvested(address donkey) constant returns(uint invested, string info) {\n        invested = donkeys[donkey].addr != address(0x0) ? donkeys[donkey].invested / 1 ether : 0;\n        info = 'The amount of Ethers the donkey has chased carrots with.';\n    }\n    \n    function totalInvested() constant returns(uint invested, string info) {\n        invested = donkeysInvested / 1 ether;\n        info = 'The combined investments of all donkeys in Ethers.';\n    }\n    \n    function currentDepositLimit() constant returns(uint ethers, string info) {\n        ethers = maxDeposit;\n        info = 'The current maximum number of Ethers you may deposit at once.';\n    }\n    \n    function donkeysEligibleForFees() constant returns(uint top, string info) {\n        top = eligibleForFees;\n        info = 'The number of donkeys in the ranking that are eligible to receive fees.';\n    }\n    \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1288997,0x54ebfdff6dca6b58106d286012d2b4a0a3ee5b6f,false,false,,,,TOO_SHORT
1289065,0xf6d16ff354d72d67802b3939a49a9be16f498e79,false,false,,,,TOO_SHORT
1290554,0x5bbae4def21f0582fc431f9fceabaa5ab5347c32,false,false,,,,TOO_SHORT
1290634,0x99d982e49bcb5465a6b4c1e0ec4341c912d9ba42,false,false,"//***********************************EthVentures****************************************************************************\n//\n//  TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n//  EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n//  How it works: You deposit minimum 5 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n//      Ex: There is 95 Eth deposited, you deposit 5 Eth, new balance becomes 100 Eth, then you will own 5% of the profits!	\n//\n//\n//\n//  Dividends: Ever deposit under 5 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 5 Eth, it will be distributed in 3-4 Ether packages, automatically.\n//  	Ex: We generate 100 Eth profit, then it will be distributed in 33 times in 3.33 ether packages, then those packages get shared between shareholders. With the example above if you hold 5%, then you will earn 33 times 0.1665 Eth, which is 5.4945 Eth profit in total.\n//\n//\n//  Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n//      Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n//      Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n//      Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n//  How to invest: Just deposit minimum 5 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n//  Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point. \n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract. \n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright Â© 2016, This piece of code cannot be copied or reused without the author's permission!\n//\n//***********************************START\ncontract EthVentures {\n\n  struct InvestorArray {\n      address etherAddress;\n      uint amount;\n      uint percentage_ownership;  //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n  }\n\n  InvestorArray[] public investors;\n\n//********************************************PUBLIC VARIABLES\n\n\n  uint public total_investors=0;\n  uint public fees=0;\n  uint public balance = 0;\n  uint public totaldeposited=0;\n  uint public totalpaidout=0;\n  uint public totaldividends=0;\n  string public Message_To_Investors=""Welcome to EthVentures!"";  // the manager can send short messages to investors\n  \n  address public owner;\n\n  // manager privilege\n  modifier manager { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function EthVentures() {\n    owner = msg.sender;\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    Enter();\n  }\n  \n//********************************************ENTER\n\n  function Enter() {\n	//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n	//IN LESS THAN 5 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 5 ETHER GETS REGISTERED AS AN INVESTOR!!!\n	if (msg.value < 5 ether) \n	{ \n	\n		uint PRE_inv_length = investors.length;\n		uint PRE_payout;\n		uint PRE_amount=msg.value;\n      		owner.send(PRE_amount/100);     	//send the 1% management fee to the manager\n		totalpaidout+=PRE_amount/100;       //update paid out amount\n		PRE_amount=PRE_amount - PRE_amount/100;     //remaining 99% is the dividend\n\n		    \n	//Distribute Dividends\n	if(PRE_inv_length !=0 && PRE_amount !=0)\n	{\n	    for(uint PRE_i=0; PRE_i<PRE_inv_length;PRE_i++)  \n		{\n		\n			PRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000;    //calculate pay out\n			investors[PRE_i].etherAddress.send(PRE_payout);         //send dividend to investor\n			totalpaidout += PRE_payout;                 //update paid out amount\n			totaldividends+=PRE_payout;              // update paid out dividends\n	\n		}\n	}\n\n	}\n\n	// YOU MUST INVEST AT LEAST 5 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\n	else    \n	{\n    // collect management fees and update contract balance and deposited amount\n	uint amount=msg.value;\n	fees  = amount / 100;             // 1% management fee to the owner\n	balance += amount;               // balance update\n	totaldeposited+=amount;       //update deposited amount\n\n    // add a new participant to the system and calculate total players\n	uint inv_length = investors.length;\n	bool alreadyinvestor =false;\n	uint alreadyinvestor_id;\n	\n    //go through all investors and see if the current investor was already an investor or not\n    for(uint i=0; i<inv_length;i++)  \n    {\n	if( msg.sender==   investors[i].etherAddress) // if yes then:\n	{\n	alreadyinvestor=true; //set it to true\n	alreadyinvestor_id=i;  // and save the id of the investor in the investor array\n	break;  // get out of the loop to save gas, because we already found it\n	}\n    }\n    \n     // if it's a new investor then add it to the array\n    if(alreadyinvestor==false)\n	{\n	total_investors=inv_length+1;\n	investors.length += 1;\n	investors[inv_length].etherAddress = msg.sender;\n	investors[inv_length].amount = amount;\n	investors[inv_length].percentage_ownership = investors[inv_length].amount /totaldeposited*10000000000;\n	}\n	else // if its already an investor, then update his investments and his % ownership\n	{\n	investors[alreadyinvestor_id].amount += amount;\n	investors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n	}\n\n    // pay out the 1% management fee\n     if (fees != 0) \n     {\n     	if(balance>fees)\n	{\n      	owner.send(fees);            //send the 1% to the manager\n      	balance -= fees;             //balance update\n	totalpaidout+=fees;          //update paid out amount\n	}\n     }\n    }\n  }\n\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\n\n  function NewOwner(address new_owner) manager \n  {\n      owner = new_owner;\n  }\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\n  function Emergency() manager \n  {\n	if(balance!=0)\n      	owner.send(balance);\n  }\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\n\n  function NewMessage(string new_sms) manager \n  {\n      Message_To_Investors = new_sms;\n  }\n\n}",2,コメントが詩的で、分散型企業のビジョンを描いているが、実用的な構造を持つ。,
1290831,0x02e6b16cd0ab453c153e2020a93e75688cb0089a,false,false,,,,TOO_SHORT
1290914,0x778ac9202dbffafa9d8b6b02467e7e2d588a6048,false,false,,,,TOO_SHORT
1291087,0x72739758dcd6a7fd9490e437060abc2ddd0c5db3,false,false,,,,TOO_SHORT
1291196,0xb8fc85922fe81e4ac72f8c099ea5c8ff76485905,false,false,,,,TOO_SHORT
1291298,0x6fadf1f27532f86c76ffa7a5a700b2138da2a579,false,false,,,,TOO_SHORT
1291421,0xcf797c717267d833d948fe8f76742f05b8164491,false,false,,,,0x7d56485e026d5d3881f778e99969d2b1f90c50af
1291519,0x4a431fc784752f3970af060666e6f6c53c4dfeef,false,false,,,,TOO_SHORT
1291580,0x1ff3f56609d0771abb49566600febade0e708beb,false,false,"//***********************************EthVentures v2****************************************************************************\n//\n// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\n//\n//\n//\n// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 3-4 Ether packages, automatically.\n// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\n//\n//\n// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright Ã‚Â© 2016, This piece of code cannot be copied or reused without the author's permission!\n//\n// This is v2 of the contract, new and improved, all possible bugs fixed!\n//\n//\n//***********************************START\ncontract EthVentures {\nstruct InvestorArray {\naddress etherAddress;\nuint amount;\nuint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n}\nInvestorArray[] public investors;\n//********************************************PUBLIC VARIABLES\nuint public total_investors=0;\nuint public fees=0;\nuint public balance = 0;\nuint public totaldeposited=0;\nuint public totalpaidout=0;\nuint public totaldividends=0;\nstring public Message_To_Investors=""Welcome to EthVentures!""; // the manager can send short messages to investors\naddress public owner;\n// manager privilege\nmodifier manager { if (msg.sender == owner) _ }\n//********************************************INIT\nfunction EthVentures() {\nowner = msg.sender;\n}\n//********************************************TRIGGER\nfunction() {\nEnter();\n}\n//********************************************ENTER\nfunction Enter() {\n//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\nif (msg.value < 2 ether)\n{\nuint PRE_inv_length = investors.length;\nuint PRE_payout;\nuint PRE_amount=msg.value;\nowner.send(PRE_amount/100); //send the 1% management fee to the manager\ntotalpaidout+=PRE_amount/100; //update paid out amount\nPRE_amount=PRE_amount - PRE_amount/100; //remaining 99% is the dividend\n//Distribute Dividends\nif(PRE_inv_length !=0 && PRE_amount !=0)\n{\nfor(uint PRE_i=0; PRE_i<PRE_inv_length;PRE_i++)\n{\nPRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out\ninvestors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor\ntotalpaidout += PRE_payout; //update paid out amount\ntotaldividends+=PRE_payout; // update paid out dividends\n}\n}\n}\n// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\nelse\n{\n// collect management fees and update contract balance and deposited amount\nuint amount=msg.value;\nfees = amount / 100; // 1% management fee to the owner\nbalance += amount; // balance update\ntotaldeposited+=amount; //update deposited amount\n// add a new participant to the system and calculate total players\nuint inv_length = investors.length;\nbool alreadyinvestor =false;\nuint alreadyinvestor_id;\ntotal_investors=inv_length+1;\ninvestors.length += 1;\n//go through all investors and see if the current investor was already an investor or not\nfor(uint i=0; i<inv_length;i++)\n{\nif( msg.sender== investors[i].etherAddress) // if yes then:\n{\nalreadyinvestor=true; //set it to true\nalreadyinvestor_id=i; // and save the id of the investor in the investor array\nbreak; // get out of the loop to save gas, because we already found it\n}\n}\n// if it's a new investor then add it to the array\nif(alreadyinvestor==false)\n{\ninvestors[inv_length].etherAddress = msg.sender;\ninvestors[inv_length].amount = amount;\ninvestors[inv_length].percentage_ownership = investors[inv_length].amount /totaldeposited*10000000000;\nfor(uint k=0; k<inv_length;k++)\n{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership\n}\nelse // if its already an investor, then update his investments and his % ownership\n{\ninvestors[alreadyinvestor_id].amount += amount;\ninvestors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n}\n// pay out the 1% management fee\nif (fees != 0)\n{\nif(balance>fees)\n{\nowner.send(fees); //send the 1% to the manager\nbalance -= fees; //balance update\ntotalpaidout+=fees; //update paid out amount\n}\n}\n}\n}\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\nfunction NewOwner(address new_owner) manager\n{\nowner = new_owner;\n}\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\nfunction Emergency() manager\n{\nif(balance!=0)\n{\nowner.send(balance);\nbalance=0;\n}\n}\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\nfunction NewMessage(string new_sms) manager\n{\nMessage_To_Investors = new_sms;\n}\n}",2,コメントが詩的で、投資のビジョンを描写しているが、コード自体は実用的です。,
1291656,0x43e49c79172a1be3ebb4240da727c0da0fa5d233,false,false,"//***********************************EthVentures v3****************************************************************************\n//\n// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\n//\n//\n//\n// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 3-4 Ether packages, automatically.\n// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\n//\n//\n// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright (c) 2016, This piece of code cannot be copied or reused without the author's permission!\n//\n// This is v3 of the contract, new and improved, all possible bugs fixed!\n//\n//\n//***********************************START\ncontract EthVentures3 {\nstruct InvestorArray {\naddress etherAddress;\nuint amount;\nuint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n}\nInvestorArray[] public investors;\n//********************************************PUBLIC VARIABLES\nuint public total_investors=0;\nuint public fees=0;\nuint public balance = 0;\nuint public totaldeposited=0;\nuint public totalpaidout=0;\nuint public totaldividends=0;\nstring public Message_To_Investors=""Welcome to EthVentures!""; // the manager can send short messages to investors\naddress public owner;\n// manager privilege\nmodifier manager { if (msg.sender == owner) _ }\n//********************************************INIT\nfunction EthVentures3() {\nowner = msg.sender;\n}\n//********************************************TRIGGER\nfunction() {\nEnter();\n}\n//********************************************ENTER\nfunction Enter() {\n//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\nif (msg.value < 2 ether)\n{\nuint PRE_inv_length = investors.length;\nuint PRE_payout;\nuint PRE_amount=msg.value;\nowner.send(PRE_amount/100); //send the 1% management fee to the manager\ntotalpaidout+=PRE_amount/100; //update paid out amount\nPRE_amount=PRE_amount - PRE_amount/100; //remaining 99% is the dividend\n//Distribute Dividends\nif(PRE_inv_length !=0 && PRE_amount !=0)\n{\nfor(uint PRE_i=0; PRE_i<PRE_inv_length;PRE_i++)\n{\nPRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out\ninvestors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor\ntotalpaidout += PRE_payout; //update paid out amount\ntotaldividends+=PRE_payout; // update paid out dividends\n}\n}\n}\n// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\nelse\n{\n// collect management fees and update contract balance and deposited amount\nuint amount=msg.value;\nfees = amount / 100; // 1% management fee to the owner\nbalance += amount; // balance update\ntotaldeposited+=amount; //update deposited amount\n// add a new participant to the system and calculate total players\nuint inv_length = investors.length;\nbool alreadyinvestor =false;\nuint alreadyinvestor_id;\n//go through all investors and see if the current investor was already an investor or not\nfor(uint i=0; i<inv_length;i++)\n{\nif( msg.sender== investors[i].etherAddress) // if yes then:\n{\nalreadyinvestor=true; //set it to true\nalreadyinvestor_id=i; // and save the id of the investor in the investor array\nbreak; // get out of the loop to save gas, because we already found it\n}\n}\n// if it's a new investor then add it to the array\nif(alreadyinvestor==false)\n{\ntotal_investors=inv_length+1;\ninvestors.length += 1;\ninvestors[inv_length].etherAddress = msg.sender;\ninvestors[inv_length].amount = amount;\ninvestors[inv_length].percentage_ownership = investors[inv_length].amount /totaldeposited*10000000000;\nfor(uint k=0; k<inv_length;k++)\n{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership\n}\nelse // if its already an investor, then update his investments and his % ownership\n{\ninvestors[alreadyinvestor_id].amount += amount;\ninvestors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n}\n// pay out the 1% management fee\nif (fees != 0)\n{\nif(balance>fees)\n{\nowner.send(fees); //send the 1% to the manager\nbalance -= fees; //balance update\ntotalpaidout+=fees; //update paid out amount\n}\n}\n}\n}\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\nfunction NewOwner(address new_owner) manager\n{\nowner = new_owner;\n}\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\nfunction Emergency() manager\n{\nif(balance!=0)\n{\nowner.send(balance);\nbalance=0;\n}\n}\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\nfunction NewMessage(string new_sms) manager\n{\nMessage_To_Investors = new_sms;\n}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1291667,0xc204789ea2a6f401959e2cd4bcb383cd4ab3ee9a,false,false,,,,TOO_SHORT
1291835,0x237f29bbfd52c768a02980ea8d4d983a1d234edc,false,false,"//***********************************Simple Dice Game\n//\n//\n//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. \n//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.\n//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!\n//  \n// Initial Minimum Deposit: 100 finney!\n//\n//  Good Luck and Have Fun!\n//\n//\n// THIS IS AN ATTACHMENT OF THE ETHVENTURES BUSINESS: 0x43e49c79172a1be3ebb4240da727c0da0fa5d233 \n//\n//***********************************START\ncontract SimpleDice {\n\n  struct gamblerarray {\n      address etherAddress;\n      uint amount;\n  }\n\n//********************************************PUBLIC VARIABLES\n  \n  gamblerarray[] public gamblerlist;\n  uint public Gamblers_Until_Jackpot=0;\n  uint public Total_Gamblers=0;\n  uint public FeeRate=7;\n  uint public Bankroll = 0;\n  uint public Jackpot = 0;\n  uint public Total_Deposits=0;\n  uint public Total_Payouts=0;\n  uint public MinDeposit=100 finney;\n\n  address public owner;\n  uint Fees=0;\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function SimpleDice() {\n    owner = 0x43e49c79172a1be3ebb4240da727c0da0fa5d233;  //this contract is an attachment to EthVentures\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value >10 finney) {\n\n    uint amount=msg.value;\n    uint payout;\n\n\n    // add a new participant to the system and calculate total players\n    uint list_length = gamblerlist.length;\n    Total_Gamblers=list_length+1;\n    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);\n    gamblerlist.length += 1;\n    gamblerlist[list_length].etherAddress = msg.sender;\n    gamblerlist[list_length].amount = amount;\n\n\n\n    // set payout variables\n     Total_Deposits+=amount;       	//update deposited amount\n	    \n      Fees   =amount * FeeRate/100;    // 7% fee to the owner\n      amount-=amount * FeeRate/100;\n	    \n      Bankroll += amount*80/100;     // 80% to the balance\n      amount-=amount*80/100;  \n	    \n      Jackpot += amount;               	//remaining to the jackpot\n\n\n    // payout fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1990 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n	Fees-=minimal;\n	}\n	}\n     }\n \n    if (msg.value >= MinDeposit) \n     {\n	     \n   //payout to participants	\n     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0\n	{\n	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant\n	Total_Payouts += Jackpot;               					//update paid out amount   \n	Jackpot=0;									//jackpot update\n	}\n     else   											//you either win the jackpot or the balance, but not both in 1 round\n	if(uint(sha3(gamblerlist[list_length].etherAddress,list_length))+uint(sha3(msg.gas)) % 2==0 && Bankroll > 0) 	//if the hashed length of your address is even, \n	{ 												   								//which is a 25% chance, then you get paid out all balance!\n	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant\n	Total_Payouts += Bankroll;               					//update paid out amount\n	Bankroll = 0;                      						//bankroll update\n	}\n    \n    \n    \n    //enter function ends\n	}\n    }\n  }\n\n//********************************************NEW OWNER\n\n  function setOwner(address new_owner) onlyowner { //set new owner of the casino\n      owner = new_owner;\n  }\n//********************************************SET MIN DEPOSIT\n\n  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate\n      MinDeposit = new_mindeposit;\n  }\n//********************************************SET FEE RATE\n\n  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate\n      FeeRate = new_feerate;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心で芸術性は低い。,
1291888,0xba3048b17d1e8c1412ea29af9af795786065b5f9,false,false,contract copypaste {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function copypaste() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1292100,0xb5aff01f3e820735fac9abb594dc9993cb9e5bd2,false,false,contract TheGame {\n    // Based on the open source castle script\n    // Definte the guy player\n    address public first_player;\n    // Last time someone contributed to the game\n    uint public regeneration;\n    // Define jackpot\n    uint public jackpot;\n\n    // Fees\n    uint public collectedFee;\n\n    // List of players who contributed\n    address[] public playersAddresses;\n    uint[] public playersAmounts;\n    uint32 public totalplayers;\n    uint32 public lastPlayerPaid;\n    // main Player who made the system work\n    address public mainPlayer;\n    // How many times the game stopped\n    uint32 public round;\n    // ETH paid in this round\n    uint public amountAlreadyPaidBack;\n    // ETH invested in this round\n    uint public amountInvested;\n\n    uint constant SIX_HOURS = 60 * 60 * 6;\n\n    function TheGame() {\n        // First game\n        mainPlayer = msg.sender;\n        first_player = msg.sender;\n        regeneration = block.timestamp;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalplayers = 0;\n    }\n\n    function contribute_toTheGame() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 1 / 2 ether) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the player sends more than 25 ETH it is returned to him\n        if (amount > 25 ether) {\n            msg.sender.send(msg.value - 25 ether);\n            amount = 25 ether;\n        }\n\n        // Check if the game is still on\n        if (regeneration + SIX_HOURS < block.timestamp) {\n            // Send the jacpot to the last 3 players\n            // If noone send ETH in the last 6 hours nothing happens\n            if (totalplayers == 1) {\n                // If only one person sent ETH in the last 6 hours he gets 100% of the jacpot\n                playersAddresses[playersAddresses.length - 1].send(jackpot);\n            } else if (totalplayers == 2) {\n                // If two players sent ETH the jacpot is split between them\n                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);\n                playersAddresses[playersAddresses.length - 2].send(jackpot * 30 / 100);\n            } else if (totalplayers >= 3) {\n                // If there is 3 or more players\n                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);\n                playersAddresses[playersAddresses.length - 2].send(jackpot * 20 / 100);\n                playersAddresses[playersAddresses.length - 3].send(jackpot * 10 / 100);\n            }\n\n            // Creation of new jackpot\n            jackpot = 0;\n\n            // Creation of new round of the game\n            first_player = msg.sender;\n            regeneration = block.timestamp;\n            playersAddresses.push(msg.sender);\n            playersAmounts.push(amount * 2);\n            totalplayers += 1;\n            amountInvested += amount;\n\n            // ETH sent to the jackpot\n            jackpot += amount;\n\n            // The player takes 3%\n            first_player.send(amount * 3 / 100);\n\n            // The Player takes 3%\n            collectedFee += amount * 3 / 100;\n\n            round += 1;\n        } else {\n            // The game is still on\n            regeneration = block.timestamp;\n            playersAddresses.push(msg.sender);\n            playersAmounts.push(amount * 2);\n            totalplayers += 1;\n            amountInvested += amount;\n\n            // 5% goes to the jackpot\n            jackpot += (amount * 5 / 100);\n\n            // The player takes 3%\n            first_player.send(amount * 3 / 100);\n\n            // The player takes 3%\n            collectedFee += amount * 3 / 100;\n\nwhile (playersAmounts[lastPlayerPaid] < (address(this).balance - jackpot - collectedFee) && lastPlayerPaid <= totalplayers) {\n                playersAddresses[lastPlayerPaid].send(playersAmounts[lastPlayerPaid]);\n                amountAlreadyPaidBack += playersAmounts[lastPlayerPaid];\n                lastPlayerPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        contribute_toTheGame();\n    }\n\n    // When the game stops\n    function restart() {\n        if (msg.sender == mainPlayer) {\n            mainPlayer.send(address(this).balance);\n            selfdestruct(mainPlayer);\n        }\n    }\n\n    // When the main player wants to transfer his function\n    function new_mainPlayer(address new_mainPlayer) {\n        if (msg.sender == mainPlayer) {\n            mainPlayer = new_mainPlayer;\n        }\n    }\n\n    // When the main Player decides to collect his fees\n    function collectFee() {\n        if (msg.sender == mainPlayer) {\n            mainPlayer.send(collectedFee);\n        }\n    }\n\n    // When the guy players wants to transfer his function\n    function newfirst_player(address newfirst_player) {\n        if (msg.sender == first_player) {\n            first_player = newfirst_player;\n        }\n    }       \n},1,実用的なゲームコントラクトで、特に芸術的な要素は見られません。,
1292387,0xc34929b5fde3480301f3d57e198471a91957e982,false,false,,,,TOO_SHORT
1292523,0x58ef6c8230b0397902f7ec91f71bc3bc0a729572,false,false,,,,TOO_SHORT
1292524,0x7798593db9b1c1800382f4a56c4a2be324819556,false,false,,,,TOO_SHORT
1292549,0x521876a67aa107a10aec4ad3f2b5782ac40f2d3b,false,false,,,,TOO_SHORT
1292582,0xb44360633051690d1c778e943e718e3bc0671846,false,false,,,,TOO_SHORT
1292587,0xcc00a5dbadec2d2776b3f8facb38be1c80fce350,false,false,,,,TOO_SHORT
1292834,0x93e66f21b30755a167ee3a083e48662372044ecd,false,false,,,,TOO_SHORT
1292898,0x9c370f0daae07afc6cb9d288825a2176e5bd7020,false,false,,,,TOO_SHORT
1293060,0xe1bb12dd535e93b5e0c84e0d4afc9a6427e6e412,false,false,,,,TOO_SHORT
1293459,0x8984428142627f92a6f8bbe48718e35d0255fec7,false,false,,,,TOO_SHORT
1293584,0xeab024204bcdc82aa5bfba0eac30c407939b9c2f,false,false,,,,TOO_SHORT
1293841,0x6847dfe4e5edc736011eda81b9413794de70bf64,false,false,,,,TOO_SHORT
1294100,0x125672ea31ad59dd804298a7cdc552d706727389,false,false,,,,TOO_SHORT
1294436,0xb34f84d4a7c55ccab6c1f95b69cfe5b4b21bf013,false,false,,,,TOO_SHORT
1294451,0x546c470d3783894ca3034f22813b6dd5b6cc7512,false,false,,,,TOO_SHORT
1294706,0xb7eae56e351fd1b0ebceeb7451ea606fcac0350b,false,false,,,,TOO_SHORT
1294791,0xc58fac36ae80a1d7d60d4c000efe43f67929fb79,false,false,,,,TOO_SHORT
1294818,0x199fdb129840d64817e5f6e3ea460de52b316152,false,false,,,,TOO_SHORT
1294939,0xb45de48970b37a1ad14926548f37dfd7e568ed73,false,false,,,,TOO_SHORT
1295002,0xf70ce1be9685b0cfb531bc712d3faace858b5bfb,false,false,contract fairandeasy {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function fairandeasy() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1295030,0xa83c4a6d0418074655bdbe74fed8435c46c19f66,false,false,contract fairandeasy {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function fairandeasy() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n   if (idx != 0) {\n      collectedFees += 0;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1295176,0x48a32bbeca17c5fd37ea015f4a74f670d1707535,false,false,,,,TOO_SHORT
1295278,0x0e0785071286a798a42eaf857982edf10c219a3d,false,false,,,,TOO_SHORT
1295565,0x34f75b5a850ad148a9d3238b81596a46120a54f4,false,false,,,,TOO_SHORT
1295610,0x42e27990807234b89d2b860dd99ed90904d9033e,false,false,,,,TOO_SHORT
1295616,0x276e52154a91f423c514037181c8f6c587b07ff5,false,false,,,,TOO_SHORT
1295662,0x11c016985fba1541e5125e3b0eb1285319ab5d09,false,false,,,,TOO_SHORT
1295888,0x6896ad514a2ce7586762f8e641c7821827a255c1,false,false,contract echo {\n  /* Constructor */\n  function () {\n    msg.sender.send(msg.value);\n  }\n},1,シンプルで実用的な構造のスマートコントラクトで、特に芸術的な要素はありません。,
1295965,0x3544ba7bd7e2257bf2fd821251fdd4fd3423322b,false,false,,,,TOO_SHORT
1295994,0x5000350f6eecab326612fb145f992e9d65928e17,false,false,,,,TOO_SHORT
1296335,0x570012c777434fd4bd2d625e49551ceb2e84478b,false,false,,,,TOO_SHORT
1296515,0xf916c935faa312e0bb9d8f453a16d36d55168b3a,false,false,,,,TOO_SHORT
1296754,0x06df0088ba28ccacf441985572b809cf03f72fca,false,false,,,,TOO_SHORT
1296858,0xed478ee8fdb1e40628e5fc9285f4b1e0c00d46a6,false,false,,,,TOO_SHORT
1297128,0xe7ec2f73501acf2738ba7ca8a672f135cd1a97b8,false,false,,,,TOO_SHORT
1297514,0xd12d8f8dfa54f1578b2177f99b2e282367b66b13,false,false,contract doubleyour5 {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function doubleyour5() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 5 ether) {\n			msg.sender.send(msg.value - 5 ether);	\n			amount = 5 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n   \n    balance += amount;\n    \n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1297889,0x919f963153a9528bfa1be6cdfa96995bba54d999,false,false,,,,TOO_SHORT
1297896,0x5e5f3560fc5ad192c8233783bb8701d9a30b0e39,false,false,,,,TOO_SHORT
1298693,0x007d42b9192b8c087b0d3e6ef73aae48e74b41c1,false,false,"//***********************************EthVentures v4****************************************************************************\n//\n// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\n//\n//\n//\n// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.\n// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\n//\n//\n// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright (c) 2016 to ""BetGod"" from Bitcointalk.org, This piece of code cannot be copied or reused without the author's permission!\n//\n// Author: https://bitcointalk.org/index.php?action=profile;u=803185\n//\n// This is v4 of the contract, new and improved, all possible bugs fixed!\n//\n//\n//***********************************START\ncontract EthVentures4 {\nstruct InvestorArray {\naddress etherAddress;\nuint amount;\nuint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n}\nInvestorArray[] public investors;\n//********************************************PUBLIC VARIABLES\nuint public total_investors=0;\nuint public fees=0;\nuint public balance = 0;\nuint public totaldeposited=0;\nuint public totalpaidout=0;\nuint public totaldividends=0;\nstring public Message_To_Investors=""Welcome to EthVentures4! New and improved! All bugs fixed!""; // the manager can send short messages to investors\naddress public owner;\n// manager privilege\nmodifier manager { if (msg.sender == owner) _ }\n//********************************************INIT\nfunction EthVentures4() {\nowner = msg.sender;\n}\n//********************************************TRIGGER\nfunction() {\nEnter();\n}\n//********************************************ENTER\nfunction Enter() {\n//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\nif (msg.value < 2 ether)\n{\nuint PRE_payout;\nuint PRE_amount=msg.value;\nowner.send(PRE_amount/100); //send the 1% management fee to the manager\ntotalpaidout+=PRE_amount/100; //update paid out amount\nPRE_amount-=PRE_amount/100; //remaining 99% is the dividend\n//Distribute Dividends\nif(investors.length !=0 && PRE_amount !=0)\n{\nfor(uint PRE_i=0; PRE_i<investors.length;PRE_i++)\n{\nPRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out\ninvestors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor\ntotalpaidout += PRE_payout; //update paid out amount\ntotaldividends+=PRE_payout; // update paid out dividends\n}\nMessage_To_Investors=""Dividends have been paid out!"";\n}\n}\n// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\nelse\n{\n// collect management fees and update contract balance and deposited amount\nuint amount=msg.value;\nfees = amount / 100; // 1% management fee to the owner\ntotaldeposited+=amount; //update deposited amount\namount-=amount/100;\nbalance += amount; // balance update\n// add a new participant to the system and calculate total players\nbool alreadyinvestor =false;\nuint alreadyinvestor_id;\n//go through all investors and see if the current investor was already an investor or not\nfor(uint i=0; i<investors.length;i++)\n{\nif( msg.sender== investors[i].etherAddress) // if yes then:\n{\nalreadyinvestor=true; //set it to true\nalreadyinvestor_id=i; // and save the id of the investor in the investor array\nbreak; // get out of the loop to save gas, because we already found it\n}\n}\n// if it's a new investor then add it to the array\nif(alreadyinvestor==false)\n{\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = msg.sender;\ninvestors[investors.length-1].amount = amount;\ninvestors[investors.length-1].percentage_ownership = amount /totaldeposited*10000000000;\nMessage_To_Investors=""New Investor has joined us!""; // a new and real investor has joined us\n\nfor(uint k=0; k<investors.length;k++) //if smaller than incremented, goes into loop\n{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership\n\n}\nelse // if its already an investor, then update his investments and his % ownership\n{\ninvestors[alreadyinvestor_id].amount += amount;\ninvestors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n}\n// pay out the 1% management fee\nif (fees != 0)\n{\nowner.send(fees); //send the 1% to the manager\ntotalpaidout+=fees; //update paid out amount\n}\n\n}\n}\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\nfunction NewOwner(address new_owner) manager\n{\nowner = new_owner;\nMessage_To_Investors=""The contract has a new manager!"";\n}\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\nfunction Emergency() manager\n{\nif(balance!=0)\n{\nowner.send(balance);\nbalance=0;\nMessage_To_Investors=""Emergency Withdraw has been issued!"";\n}\n}\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\nfunction NewMessage(string new_sms) manager\n{\nMessage_To_Investors = new_sms;\n}\n//********************************************MANUALLY ADD INVESTORS\n//The manager can add manually the investors from the previous versions, \n//so that those that invested in the older versions can join us in the new and updated versions\nfunction NewManualInvestor(address new_investor , uint new_amount) manager\n{\ntotaldeposited+=new_amount; //update deposited amount manually\n\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = new_investor;\ninvestors[investors.length-1].amount = new_amount;\ninvestors[investors.length-1].percentage_ownership = new_amount /totaldeposited*10000000000;\n\nMessage_To_Investors=""New manual Investor has been added by the Manager!""; // you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.\n// This will ensure that the manager doesn't add fake investors of his own addresses.\n}\n//********************************************MANUAL DEPOSIT\n//The manager can deposit manually from previous version's balances\nfunction ManualDeposit() manager\n{\nMessage_To_Investors = ""Manual Deposit received from the Manager"";\n}\n\n//end\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1298849,0x41f2d5040726c5328f8366f17041ec012ac8f338,false,false,"//***********************************EthVenturesFinal****************************************************************************\n//\n// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\n//\n//\n//\n// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.\n// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\n//\n//\n// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright (c) 2016 to ""BetGod"" from Bitcointalk.org, This piece of code cannot be copied or reused without the author's permission!\n//\n// Author: https://bitcointalk.org/index.php?action=profile;u=803185\n//\n// This is the final version of the contract, new and improved, all possible bugs fixed!\n//\n//\n//***********************************START\ncontract EthVenturesFinal {\nstruct InvestorArray {\naddress etherAddress;\nuint amount;\nuint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n}\nInvestorArray[] public investors;\n//********************************************PUBLIC VARIABLES\nuint public total_investors=0;\nuint public fees=0;\nuint public balance = 0;\nuint public totaldeposited=0;\nuint public totalpaidout=0;\nuint public totaldividends=0;\nstring public Message_To_Investors=""Welcome to EthVenturesFinal! New and improved! All bugs fixed!""; // the manager can send short messages to investors\naddress public owner;\n// manager privilege\nmodifier manager { if (msg.sender == owner) _ }\n//********************************************INIT\nfunction EthVenturesFinal() {\nowner = msg.sender;\n}\n//********************************************TRIGGER\nfunction() {\nEnter();\n}\n//********************************************ENTER\nfunction Enter() {\n//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\nif (msg.value < 2 ether)\n{\nuint PRE_payout;\nuint PRE_amount=msg.value;\nowner.send(PRE_amount/100); //send the 1% management fee to the manager\ntotalpaidout+=PRE_amount/100; //update paid out amount\nPRE_amount-=PRE_amount/100; //remaining 99% is the dividend\n//Distribute Dividends\nif(investors.length !=0 && PRE_amount !=0)\n{\nfor(uint PRE_i=0; PRE_i<investors.length;PRE_i++)\n{\nPRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out\ninvestors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor\ntotalpaidout += PRE_payout; //update paid out amount\ntotaldividends+=PRE_payout; // update paid out dividends\n}\nMessage_To_Investors=""Dividends have been paid out!"";\n}\n}\n// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\nelse\n{\n// collect management fees and update contract balance and deposited amount\nuint amount=msg.value;\nfees = amount / 100; // 1% management fee to the owner\ntotaldeposited+=amount; //update deposited amount\namount-=amount/100;\nbalance += amount; // balance update\n// add a new participant to the system and calculate total players\nbool alreadyinvestor =false;\nuint alreadyinvestor_id;\n//go through all investors and see if the current investor was already an investor or not\nfor(uint i=0; i<investors.length;i++)\n{\nif( msg.sender== investors[i].etherAddress) // if yes then:\n{\nalreadyinvestor=true; //set it to true\nalreadyinvestor_id=i; // and save the id of the investor in the investor array\nbreak; // get out of the loop to save gas, because we already found it\n}\n}\n// if it's a new investor then add it to the array\nif(alreadyinvestor==false)\n{\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = msg.sender;\ninvestors[investors.length-1].amount = amount;\ninvestors[investors.length-1].percentage_ownership = amount /totaldeposited*10000000000;\nMessage_To_Investors=""New Investor has joined us!""; // a new and real investor has joined us\n\nfor(uint k=0; k<investors.length;k++) //if smaller than incremented, goes into loop\n{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership\n\n}\nelse // if its already an investor, then update his investments and his % ownership\n{\ninvestors[alreadyinvestor_id].amount += amount;\ninvestors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n}\n// pay out the 1% management fee\nif (fees != 0)\n{\nowner.send(fees); //send the 1% to the manager\ntotalpaidout+=fees; //update paid out amount\n}\n\n}\n}\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\nfunction NewOwner(address new_owner) manager\n{\nowner = new_owner;\nMessage_To_Investors=""The contract has a new manager!"";\n}\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\nfunction Emergency() manager\n{\nif(balance!=0)\n{\nowner.send(balance);\nbalance=0;\nMessage_To_Investors=""Emergency Withdraw has been issued!"";\n}\n}\n//********************************************EMERGENCY BALANCE RESET\n//In case any errors happen the balance can be modified manually, it will only be used as last resort!\nfunction EmergencyBalanceReset(uint new_balance) manager\n{\nbalance = new_balance;\nMessage_To_Investors=""The Balance has been edited by the Manager!"";\n}\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\nfunction NewMessage(string new_sms) manager\n{\nMessage_To_Investors = new_sms;\n}\n//********************************************MANUALLY ADD INVESTORS\n//The manager can add manually the investors from the previous versions, \n//so that those that invested in the older versions can join us in the new and updated versions\nfunction NewManualInvestor(address new_investor , uint new_amount) manager\n{\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = new_investor;\ninvestors[investors.length-1].amount = new_amount;\ninvestors[investors.length-1].percentage_ownership = new_amount /totaldeposited*10000000000;\n\nMessage_To_Investors=""New manual Investor has been added by the Manager!""; // you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.\n// This will ensure that the manager doesn't add fake investors of his own addresses.\n}\n//********************************************MANUAL DEPOSIT\n//The manager can deposit manually from previous version's balances\nfunction ManualDeposit() manager\n{\ntotaldeposited+=msg.value; //update deposited amount manually\nbalance+=msg.value; //update balance amount manually\n\nMessage_To_Investors = ""Manual Deposit received from the Manager"";\n}\n\n//end\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1298858,0x92dbbde2a42f2f003d150d9d8c34e9ca7c8e05b3,false,false,,,,TOO_SHORT
1299284,0x8abd93bfe2c27ffe0f40e51b5c187d1fd4bb6dce,false,false,,,,TOO_SHORT
1299393,0xee462a6717f17c57c826f1ad9b4d3813495296c9,false,false,"//***********************************EthVenturesFinal****************************************************************************\n//\n// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\n//\n//\n//\n// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.\n// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\n//\n//\n// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright (c) 2016 to ""BetGod"" from Bitcointalk.org, This piece of code cannot be copied or reused without the author's permission!\n//\n// Author: https://bitcointalk.org/index.php?action=profile;u=803185\n//\n// This is the final version of the contract, new and improved, all possible bugs fixed!\n//\n//\n//***********************************START\ncontract EthVenturesFinal {\nstruct InvestorArray {\naddress etherAddress;\nuint amount;\n//float percentage_ownership; // doesnt work, ethereum doesnt allow float point precision yet\n}\nInvestorArray[] public investors;\n//********************************************PUBLIC VARIABLES\nuint public total_investors=0;\nuint public fees=0;\nuint public balance = 0;\nuint public totaldeposited=0;\nuint public totalpaidout=0;\nuint public totaldividends=0;\nstring public Message_To_Investors=""Welcome to EthVenturesFinal! New and improved! All bugs fixed!""; // the manager can send short messages to investors\naddress public owner;\n// manager privilege\nmodifier manager { if (msg.sender == owner) _ }\n//********************************************INIT\nfunction EthVenturesFinal() {\nowner = msg.sender;\n}\n//********************************************TRIGGER\nfunction() {\nEnter();\n}\n//********************************************ENTER\nfunction Enter() {\n//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\nif (msg.value < 2 ether)\n{\nuint PRE_payout;\nuint PRE_amount=msg.value;\nowner.send(PRE_amount/100); //send the 1% management fee to the manager\ntotalpaidout+=PRE_amount/100; //update paid out amount\nPRE_amount-=PRE_amount/100; //remaining 99% is the dividend\n//Distribute Dividends\nif(investors.length !=0 && PRE_amount !=0)\n{\nfor(uint PRE_i=0; PRE_i<investors.length;PRE_i++)\n{\nPRE_payout = PRE_amount * investors[PRE_i].amount /totaldeposited; //calculate pay out\ninvestors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor\ntotalpaidout += PRE_payout; //update paid out amount\ntotaldividends+=PRE_payout; // update paid out dividends\n}\nMessage_To_Investors=""Dividends have been paid out!"";\n}\n}\n// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\nelse\n{\n// collect management fees and update contract balance and deposited amount\nuint amount=msg.value;\nfees = amount / 100; // 1% management fee to the owner\ntotaldeposited+=amount; //update deposited amount\namount-=amount/100;\nbalance += amount; // balance update\n// add a new participant to the system and calculate total players\nbool alreadyinvestor =false;\nuint alreadyinvestor_id;\n//go through all investors and see if the current investor was already an investor or not\nfor(uint i=0; i<investors.length;i++)\n{\nif( msg.sender== investors[i].etherAddress) // if yes then:\n{\nalreadyinvestor=true; //set it to true\nalreadyinvestor_id=i; // and save the id of the investor in the investor array\nbreak; // get out of the loop to save gas, because we already found it\n}\n}\n// if it's a new investor then add it to the array\nif(alreadyinvestor==false)\n{\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = msg.sender;\ninvestors[investors.length-1].amount = amount;\n\n//float\n//investors[investors.length-1].percentage_ownership = amount /totaldeposited*10000000000;\n\n\nMessage_To_Investors=""New Investor has joined us!""; // a new and real investor has joined us\n\n//float\n//for(uint k=0; k<investors.length;k++) //if smaller than incremented, goes into loop\n//{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership\n\n}\nelse // if its already an investor, then update his investments and his % ownership\n{\ninvestors[alreadyinvestor_id].amount += amount;\n\n//float\n//investors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n}\n// pay out the 1% management fee\nif (fees != 0)\n{\nowner.send(fees); //send the 1% to the manager\ntotalpaidout+=fees; //update paid out amount\n}\n\n}\n}\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\nfunction NewOwner(address new_owner) manager\n{\nowner = new_owner;\nMessage_To_Investors=""The contract has a new manager!"";\n}\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\nfunction Emergency() manager\n{\nif(balance!=0)\n{\nowner.send(balance);\nbalance=0;\nMessage_To_Investors=""Emergency Withdraw has been issued!"";\n}\n}\n//********************************************EMERGENCY BALANCE RESET\n//In case any errors happen the balance can be modified manually, it will only be used as last resort!\nfunction EmergencyBalanceReset(uint new_balance) manager\n{\nbalance = new_balance;\nMessage_To_Investors=""The Balance has been edited by the Manager!"";\n}\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\nfunction NewMessage(string new_sms) manager\n{\nMessage_To_Investors = new_sms;\n}\n//********************************************MANUALLY ADD INVESTORS\n//The manager can add manually the investors from the previous versions, \n//so that those that invested in the older versions can join us in the new and updated versions\nfunction NewManualInvestor(address new_investor , uint new_amount) manager\n{\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = new_investor;\ninvestors[investors.length-1].amount = new_amount;\n\n//float\n//investors[investors.length-1].percentage_ownership = new_amount /totaldeposited*10000000000;\n\n\nMessage_To_Investors=""New manual Investor has been added by the Manager!""; // you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.\n// This will ensure that the manager doesn't add fake investors of his own addresses.\n}\n//********************************************MANUAL DEPOSIT\n//The manager can deposit manually from previous version's balances\nfunction ManualDeposit() manager\n{\ntotaldeposited+=msg.value; //update deposited amount manually\nbalance+=msg.value; //update balance amount manually\n\nMessage_To_Investors = ""Manual Deposit received from the Manager"";\n}\n\n//end\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。コメントが多いが、芸術的要素は少ない。,
1299629,0x1eeb460f3961cf97ada5f2441d38fdc1df8c1c6b,false,false,,,,TOO_SHORT
1299797,0x43b6ea49badf3db32c32c5546b00d778e04ed339,false,false,,,,TOO_SHORT
1299896,0x78b058ccda93816487c655367dcb79664a216ad2,false,false,"//***********************************Simple Dice Game\n//\n//\n//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. \n//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.\n//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!\n//  \n// Initial Minimum Deposit: 100 finney!\n//\n//  Good Luck and Have Fun!\n//\n//\n// THIS IS AN ATTACHMENT OF THE ETHVENTURES BUSINESS: 0xee462a6717f17c57c826f1ad9b4d3813495296c9 \n//\n//***********************************START\ncontract SimpleDice {\n\n  struct gamblerarray {\n      address etherAddress;\n      uint amount;\n  }\n\n//********************************************PUBLIC VARIABLES\n  \n  gamblerarray[] public gamblerlist;\n  uint public Gamblers_Until_Jackpot=0;\n  uint public Total_Gamblers=0;\n  uint public FeeRate=5;\n  uint public Bankroll = 0;\n  uint public Jackpot = 0;\n  uint public Total_Deposits=0;\n  uint public Total_Payouts=0;\n  uint public MinDeposit=100 finney;\n\n  address public owner;\n  uint Fees=0;\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function SimpleDice() {\n    owner = 0xee462a6717f17c57c826f1ad9b4d3813495296c9;  //this contract is an attachment to EthVentures\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value >10 finney) {\n\n    uint amount=msg.value;\n    uint payout;\n\n\n    // add a new participant to the system and calculate total players\n    uint list_length = gamblerlist.length;\n    Total_Gamblers=list_length+1;\n    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);\n    gamblerlist.length += 1;\n    gamblerlist[list_length].etherAddress = msg.sender;\n    gamblerlist[list_length].amount = amount;\n\n\n\n    // set payout variables\n     Total_Deposits+=amount;       	//update deposited amount\n	    \n      Fees   =amount * FeeRate/100;    // 5% fee to the owner\n      amount-=amount * FeeRate/100;\n	    \n      Bankroll += amount*80/100;     // 80% to the balance\n      amount-=amount*80/100;  \n	    \n      Jackpot += amount;               	//remaining to the jackpot\n\n\n    // payout fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1990 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n	Fees-=minimal;\n	}\n	}\n     }\n \n    if (msg.value >= MinDeposit) \n     {\n	     \n   //payout to participants	\n     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0\n	{\n	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant\n	Total_Payouts += Jackpot;               					//update paid out amount   \n	Jackpot=0;									//jackpot update\n	}\n     else   											//you either win the jackpot or the balance, but not both in 1 round\n	if(uint(sha3(gamblerlist[list_length].etherAddress,list_length))+uint(sha3(msg.gas)) % 4 ==0 && Bankroll > 0) 	//if the hashed length of your address is even, \n	{ 												   								//which is a 25% chance, then you get paid out all balance!\n	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant\n	Total_Payouts += Bankroll;               					//update paid out amount\n	Bankroll = 0;                      						//bankroll update\n	}\n    \n    \n    \n    //enter function ends\n	}\n    }\n  }\n\n//********************************************NEW OWNER\n\n  function setOwner(address new_owner) onlyowner { //set new owner of the casino\n      owner = new_owner;\n  }\n//********************************************SET MIN DEPOSIT\n\n  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate\n      MinDeposit = new_mindeposit;\n  }\n//********************************************SET FEE RATE\n\n  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate\n      FeeRate = new_feerate;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームの説明が詳細だが、芸術性は低い。,
1300095,0xbd75dd069bccf52b9349fe86e749a1ba9bb48a5a,false,false,,,,TOO_SHORT
1300107,0x1b9d2baac3224465d8d075d34a569f3f6d597044,false,false,,,,TOO_SHORT
1300202,0x8b038b1025a46155cda9ed8bd1d609a01d2daa60,false,false,,,,TOO_SHORT
1300275,0x0676cac5a0b73a84d611903e64a3f9f2719c3eec,false,false,,,,TOO_SHORT
1300312,0xcdab7758ce5a07b3d01c2d5e905de74691f22b68,false,false,,,,TOO_SHORT
1300582,0x750241c16c9fb878a7afd2b07b80f53e02c3f634,false,false,contract quick2 {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function quick2() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 20 ether) {\n			msg.sender.send(msg.value - 20 ether);	\n			amount = 20 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1300853,0xc47332487addd45978e18d26bb92440f7611d85b,false,false,,,,TOO_SHORT
1301012,0xda20df2ea5c5e9ecc75a1b2c3097deccdc70fd30,false,false,,,,TOO_SHORT
1301734,0x9d3899df1d9f030a32dd5571fe3c7ef72d6ae566,false,false,"contract NiceGuyTax {\n    \n    // Make a database of investors.\n    struct Investor {\n      address addr;\n    }\n    Investor[] public investors;\n    \n    // Make a database of Nice Guys.\n    struct NiceGuy {\n      address addr;\n    }\n    NiceGuy[] public niceGuys;\n    \n    //Counters. this counts things. A new round begins when investorIndex reaches 10.\n    uint public payoutIndex = 0;\n    uint public currentNiceGuyIndex = 0;\n    uint public investorIndex = 0;\n    address public currentNiceGuy;\n    \n    \n    // This makes the deployer of the smartcontract the first Nice Guy.. MUCH NICE!\n    // I could only make 10 ETH if people are nice enough to invest in it.\n    function NiceGuyTax() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    //Invest 9 ETH to execute this function.\n    function() {\n        \n        //If your investment is NOT 9 ether, the smartcontract rejects it and you get it back.\n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        //First the current nice guy gets 1 ether.\n        //This is called the ""Nice guy tax""\n        currentNiceGuy.send(1 ether);\n        \n        //If you are investor 1 to 8, you will receive pay-out in the same round.\n        if (investorIndex < 8) {\n            uint index = investors.length;\n            investors.length += 1;\n            investors[index].addr = msg.sender;\n        }\n        \n        //If you are investor 9 or 10, you will be put in the Nice Guy database.\n        if (investorIndex > 7) {\n            uint niceGuyIndex = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[niceGuyIndex].addr = msg.sender;\n            //If you are investor 10, the next investor will be the first investor of the next round.\n            //the next Nice Guy will be installed and receives the Nice Guy Tax\n            if (investorIndex > 8 ) {\n                currentNiceGuy = niceGuys[currentNiceGuyIndex].addr;\n                currentNiceGuyIndex += 1;\n            }\n        }\n        \n        //this counts the investors in each round. If the investorIndex counts to 10, the next round begins.\n        if (investorIndex < 9) {\n            investorIndex += 1;\n        }\n        else {\n            investorIndex = 0;\n        }\n        \n        //If the contract balance reaches at least 10 ether, the next investor in the pay-out queue in the round gets paid out.\n        //The contract balance is ALWAYS ZERO in the beginning of each round.\n        while (this.balance > 9 ether) {\n            investors[payoutIndex].addr.send(10 ether);\n            payoutIndex += 1;\n        }\n    }\n}",1,実用的な構造で、投資と報酬のロジックを持つ標準的なスマートコントラクトです。,
1302070,0xfba6ae30dfe97b20ad9ecccd5057ab3e5a1c41fa,false,false,"contract NiceGuyTax {\n    \n    // Make a database of investors.\n    struct Investor {\n      address addr;\n    }\n    Investor[] public investors;\n    \n    // Make a database of Nice Guys.\n    struct NiceGuy {\n      address addr;\n    }\n    NiceGuy[] public niceGuys;\n    \n    //Counters. this counts things. A new round begins when investorIndex reaches 10.\n    uint public payoutIndex = 0;\n    uint public currentNiceGuyIndex = 0;\n    uint public investorIndex = 0;\n    address public currentNiceGuy;\n    \n    \n    // This makes the deployer of the smartcontract the first Nice Guy.. MUCH NICE!\n    // I could only make 10 ETH if people are nice enough to invest in it.\n    function NiceGuyTax() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    //Invest 9 ETH to execute this function.\n    function() {\n        \n        //If your investment is NOT 9 ether, the smartcontract rejects it and you get it back.\n        if (msg.value != 9 ether) {\n            msg.sender.send(msg.value);\n            throw;\n        }\n        \n        //First the current nice guy gets 1 ether.\n        //This is called the ""Nice guy tax""\n        currentNiceGuy.send(1 ether);\n        \n        //If you are investor 1 to 8, you will receive pay-out in the same round.\n        if (investorIndex < 8) {\n            uint index = investors.length;\n            investors.length += 1;\n            investors[index].addr = msg.sender;\n        }\n        \n        //If you are investor 9 or 10, you will be put in the Nice Guy database.\n        if (investorIndex > 7) {\n            uint niceGuyIndex = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[niceGuyIndex].addr = msg.sender;\n            //If you are investor 10, the next investor will be the first investor of the next round.\n            //the next Nice Guy will be installed and receives the Nice Guy Tax\n            if (investorIndex > 8 ) {\n                currentNiceGuy = niceGuys[currentNiceGuyIndex].addr;\n                currentNiceGuyIndex += 1;\n            }\n        }\n        \n        //this counts the investors in each round. If the investorIndex counts to 10, the next round begins.\n        if (investorIndex < 9) {\n            investorIndex += 1;\n        }\n        else {\n            investorIndex = 0;\n        }\n        \n        //If the contract balance reaches at least 10 ether, the next investor in the pay-out queue in the round gets paid out.\n        //The contract balance is ALWAYS ZERO in the beginning of each round.\n        while (this.balance > 9 ether) {\n            investors[payoutIndex].addr.send(10 ether);\n            payoutIndex += 1;\n        }\n    }\n}",2,ユーモラスなコメントと「Nice Guy」テーマが詩的要素を加えている。,
1302117,0x56467e038871dc7f2a6180cdebe1702cef77285f,false,false,"contract NiceGuyTax {\n    \n    // Make a database of investors.\n    struct Investor {\n      address addr;\n    }\n    Investor[] public investors;\n    \n    // Make a database of Nice Guys.\n    struct NiceGuy {\n      address addr;\n    }\n    NiceGuy[] public niceGuys;\n    \n    //Counters. this counts things. A new round begins when investorIndex reaches 10.\n    uint public payoutIndex = 0;\n    uint public currentNiceGuyIndex = 0;\n    uint public investorIndex = 0;\n    address public currentNiceGuy;\n    \n    \n    // This makes the deployer of the smartcontract the first Nice Guy.. MUCH NICE!\n    // I could only make 10 ETH if people are nice enough to invest in it.\n    function NiceGuyTax() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    //Invest 9 ETH to execute this function.\n    function() {\n        \n        //If your investment is NOT 9 ether, the smartcontract rejects it and you get it back.\n        if (msg.value != 9 ether) {\n            msg.sender.send(msg.value);\n            throw;\n        }\n        \n        //First the current nice guy gets 1 ether.\n        //This is called the ""Nice guy tax""\n        currentNiceGuy.send(1 ether);\n        \n        //If you are investor 1 to 8, you will receive pay-out in the same round.\n        if (investorIndex < 8) {\n            uint index = investors.length;\n            investors.length += 1;\n            investors[index].addr = msg.sender;\n        }\n        \n        //If you are investor 9 or 10, you will be put in the Nice Guy database.\n        if (investorIndex > 7) {\n            uint niceGuyIndex = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[niceGuyIndex].addr = msg.sender;\n            //If you are investor 10, the next investor will be the first investor of the next round.\n            //the next Nice Guy will be installed and receives the Nice Guy Tax\n            if (investorIndex > 8 ) {\n                currentNiceGuy = niceGuys[currentNiceGuyIndex].addr;\n                currentNiceGuyIndex += 1;\n            }\n        }\n        \n        //this counts the investors in each round. If the investorIndex counts to 10, the next round begins.\n        if (investorIndex < 9) {\n            investorIndex += 1;\n        }\n        else {\n            investorIndex = 0;\n        }\n        \n        //If the contract balance reaches at least 10 ether, the next investor in the pay-out queue in the round gets paid out.\n        //The contract balance is ALWAYS ZERO in the beginning of each round.\n        while (this.balance >= 10 ether) {\n            investors[payoutIndex].addr.send(10 ether);\n            payoutIndex += 1;\n        }\n    }\n}",2,実用的だが、コメントにユーモアと詩的な要素が含まれている。,
1303122,0xf51c5aa31cf55b0bf6bf2574f406044db7b9fd04,false,false,,,,TOO_SHORT
1303267,0x26c4e381ffbdc825be9b986c3ba40525f0771e8d,false,false,"//***********************************Coinflip\n//\n// This is a simple coin flip game. You flip HEADS, you Win! You flip TAILS you Lose!\n// Each outcome has a 50% chance of happening. You win the entire house bankroll if you win! You lose your deposit if you lose.\n//\n//  Minimum Deposit: 100 finney!\n//\n//  Good Luck and Have Fun!\n//\n//\n//\n// THIS IS AN ATTACHMENT OF THE ETHVENTURES BUSINESS: 0xEe462A6717f17C57C826F1ad9b4d3813495296C9 \n//\n//***********************************START\ncontract Coinflip {\n\n  struct gamblerarray {\n      address etherAddress;\n      uint amount;\n  }\n\n//********************************************PUBLIC VARIABLES\n  \n  gamblerarray[] public gamblerlist;\n  uint public Total_Players=0;\n  uint public FeeRate=2;\n  uint public Bankroll = 0;\n  uint public Total_Deposits=0;\n  uint public Total_Payouts=0;\n  string public Outcome=""NULL"";\n  uint public MinDeposit=100 finney;\n\n  address public owner;\n  uint Fees=0;\n\n//********************************************INIT\n\n  function Coinflip() {\n    owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value >10 finney) {\n\n    uint amount=msg.value;\n    uint payout;\n\n\n    // add a new participant to the system and calculate total players\n    uint list_length = gamblerlist.length;\n    Total_Players=list_length+1;\n    gamblerlist.length += 1;\n    gamblerlist[list_length].etherAddress = msg.sender;\n    gamblerlist[list_length].amount = amount;\n\n\n    // set payout variables\n     Total_Deposits+=amount;       	//update deposited amount\n	    \n      Fees   =amount * FeeRate/100;    // fee to the owner\n      amount-=amount * FeeRate/100;\n	    \n      Bankroll += amount;     //  to the balance\n\n//********************************EthVenturesFinal Fee Plugin\n    // payout fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1990 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n	Fees-=minimal;\n	}\n	}\n     }\n//********************************End Plugin     \n \n    if (msg.value >= MinDeposit && Bankroll > 0) \n		{\n					// Best Binary Random Number Generator in Ethereum!\n			if( (uint(sha3(gamblerlist[list_length].etherAddress,list_length))+uint(sha3(msg.gas))) % 2==0 ) 	//if the hashed length of your address combined with the gas hash is even, \n			{ 												   							//which is a 50% chance, then you get paid out all balance!\n			gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant\n			Total_Payouts += Bankroll;               					//update paid out amount\n			Bankroll = 0;                      						//bankroll update\n			Outcome=""HEADS"";\n			}\n			else Outcome=""TAILS"";\n		}\n		else Outcome=""Error, the coin wasn't flipped, try again!"";\n	\n	\n    }\n        //enter function ends\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心。,
1303479,0xbed3c3929242e0c6da556e61ff11bef9d72b909a,false,false,,,,TOO_SHORT
1303499,0x1492cdd605d91658f228eab14d8444b60e6da8df,false,false,contract thewhalegame {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function thewhalegame() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 5 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 500 ether) {\n			msg.sender.send(msg.value - 500 ether);	\n			amount = 500 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 100 * 3;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 100 * 3;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1303507,0x02b2101903eb6a51518e63e84b785180859fda9d,false,false,contract thewhalegame {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function thewhalegame() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 5 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 500 ether) {\n			msg.sender.send(msg.value - 500 ether);	\n			amount = 500 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 100 * 3;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 100 * 3;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1303535,0xfc517696f8f00d5c054f765582771c70e1cdd33d,false,false,,,,TOO_SHORT
1304360,0x60acd43314d93f38507f3fd12e84225a5a099229,false,false,"//***********************************ETH BANK\n//\n// It's an EthBank, every depositor earns interest on their deposits when a new depositor joins!\n//\n// The interest rate is defined by the ""Interest_Rate"" variable, and is initially set to 2%, and may be changed later!\n//\n// The Bank will exist for long because it only pays out when the balance is above 60%. And if the balance is below 80% it pays out only half the interest.\n//\n// Minimum Deposit: 0.2 Ether (200 Finney)\n//\n//\n// It is a long term project, so have fun saving your Ether here!\n//\n//***********************************START\ncontract EthBank {\n\n  struct InvestorArray \n	{\n      	address etherAddress;\n      	uint amount;\n  	}\n\n  InvestorArray[] public depositors;\n\n//********************************************PUBLIC VARIABLES\n\n  uint public Total_Savers=0;\n  uint public Fees=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\n  uint public Interest_Rate=2; // the interest rate payout for deposits!\nstring public Message=""Welcome to EthBank"";\n	\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function EthBank() {\n    owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value > 200 finney) {\n\n    uint amount=msg.value;\n\n\n    // add a new participant to the system and calculate total players\n    Total_Savers=depositors.length+1;\n    depositors.length += 1;\n    depositors[depositors.length-1].etherAddress = msg.sender;\n    depositors[depositors.length-1].amount = amount;\n\n\n\n    // collect Fees and update contract Balance and deposited amount\n      	Fees  = amount * Interest_Rate / 100;    // fee to the owner\n      	Total_Deposited+=amount;       		//update deposited amount\n	amount-=amount * Interest_Rate / 100;	// minus the fee from amount\n      	Balance += amount;               // Balance update\n\n\n//********************************EthVenturesFinal Fee Plugin\n    // payout Fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1990 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	Total_Paid_Out+=Fees;        //update paid out amount\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the Fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Total_Paid_Out+=Fees;        //update paid out amount\n	Fees-=minimal;\n	}\n	}\n     }\n//********************************End Plugin \n //loop variables\n    uint payout;\n    uint nr=0;\n\nif(Total_Deposited * 80/100 < Balance )  //if balance is at 80% or higher, then pay depositors\n{\n  \n\n	\n    while (Balance > depositors[nr].amount * Interest_Rate/100 && nr<depositors.length)  //exit condition to avoid infinite loop\n    { \n      payout = depositors[nr].amount *Interest_Rate/100;                           //calculate pay out\n      depositors[nr].etherAddress.send(payout);                        		//send pay out to participant\n      Balance -= depositors[nr].amount *Interest_Rate/100;                         //Balance update\n      Total_Paid_Out += depositors[nr].amount *Interest_Rate/100;                 //update paid out amount\n      nr += 1;                                                                         //go to next participant\n    }\n    \n	Message=""The Full Interest has been paid to Depositors!"";\n} \nelse  \n{\nif(Total_Deposited * 60/100 < Balance )  //if balance is at 60% or higher, then pay depositors with half interest\n{\n  \n\n	\n    while (Balance > depositors[nr].amount * Interest_Rate/200 && nr<depositors.length)  //exit condition to avoid infinite loop\n    { \n      payout = depositors[nr].amount *Interest_Rate/200;                           //calculate pay out\n      depositors[nr].etherAddress.send(payout);                        		//send pay out to participant\n      Balance -= depositors[nr].amount *Interest_Rate/200;                         //Balance update\n      Total_Paid_Out += depositors[nr].amount *Interest_Rate/200;                 //update paid out amount\n      nr += 1;                                                                         //go to next participant\n    }\n    \n	Message=""Funds are between 60% and 80%, so only Half Interest has been paid!"";\n} \nelse Message=""Funds are below 60%, no interest payout until new Depositors join!"";\n\n\n\n}\n\n  }\n\n//********************************************SET INTEREST RATE\n}\n\n  function Set_Interest_Rate(uint new_interest) onlyowner  //set new interest rate\n	{\n      	Interest_Rate = new_interest;\n	Message=""The Bank has changed it's Interest Rates!"";\n  	}\n\n}",2,コメントが豊富で、銀行の物語を語る詩的な要素が含まれています。,
1304360,0x6784253536ac8ce20024b799d9142672991b9547,false,false,,,,TOO_SHORT
1304408,0x3d075e7cd2da4067ca8fb3482995314eaacda55c,false,false,,,,TOO_SHORT
1304526,0x02b47cead9e2061232fd0015e9fb6353b02bbc00,false,false,,,,TOO_SHORT
1304535,0x3bdaf85472e5839008fa924e1176e403d6119d15,false,false,,,,TOO_SHORT
1304559,0x40f9a28b072bc4646bf3c5ee66c4c57ebd105cea,false,false,,,,TOO_SHORT
1304663,0x3989466fe9da2cc5861fda59b8692b550b920a27,false,false,,,,TOO_SHORT
1304728,0xe0445bf6284fb6c92311a8fa0649b4c375b0d083,false,false,,,,TOO_SHORT
1304764,0x89569bcb6e86e13f139d49f83c02188bfdca7007,false,false,,,,TOO_SHORT
1304883,0xcaaca224e35d0a1fa3304a3c4ec8beb5f28a99aa,false,false,contract test {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function test() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n  //only pair amount\n    if (msg.value % 2 != 0 ) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n	uint amount;\n\n	amount = msg.value;\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n\n      balance += amount;\n  \n\n\n    while (balance > persons[payoutIdx].amount * 2) {\n      uint transactionAmount = persons[payoutIdx].amount * 2;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\nfunction kill(){\n  if(msg.sender == owner) {\n  suicide(owner);\n  }\n  }\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1304956,0x7afaacb0a6cbb93aeb301cb956ae71a35542ecc5,false,false,"contract WavesPresale {\n    address public owner;\n    \n    struct Sale\n    {\n        uint amount;\n        uint date;\n    }\n\n    mapping (bytes16 => Sale) public sales;\n    uint32 public numberOfSales;\n    uint public totalTokens;\n\n    function WavesPresale() {\n        owner = msg.sender;\n        numberOfSales = 0;\n    }\n\n    function changeOwner(address newOwner) {\n        if (msg.sender != owner) return;\n\n        owner = newOwner;\n    }\n\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\n        if (msg.sender != owner) return;\n\n        sales[txidHash] = Sale({\n                amount: amount,\n                date: timestamp\n            });\n        numberOfSales += 1;\n        totalTokens += amount;\n    }\n\n    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {\n    	return (sales[txidHash].amount, sales[txidHash].date);\n    }\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1304997,0xe19e5f100d6a31169b5dca265c9285059c41d4f6,false,false,"contract NanoPyramid {\n    \n    uint private pyramidMultiplier = 140;\n    uint private minAmount = 1 finney;\n    uint private maxAmount = 1 ether;\n    uint private fee = 2;\n    uint private collectedFees = 0;\n    uint private minFeePayout = 100 finney;\n    \n    address private owner;\n    \n    \n    function NanoPyramid() {\n        owner = msg.sender;\n    }\n    \n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    \n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n    \n    Participant[] public participants;\n    \n    \n    uint public payoutOrder = 0;\n    uint public balance = 0;\n    \n    \n    function() {\n        enter();\n    }\n    \n    function enter() {\n        // Check if amount is too small\n        if (msg.value < minAmount) {\n            // Amount is too small, no need to think about refund\n            collectedFees += msg.value;\n            return;\n        }\n        \n        // Check if amount is too high\n        uint amount;\n        if (msg.value > maxAmount) {\n            uint amountToRefund =  msg.value - maxAmount;\n            if (amountToRefund >= minAmount) {\n            	if (!msg.sender.send(amountToRefund)) {\n            	    throw;\n            	}\n        	}\n            amount = maxAmount;\n        }\n        else {\n        	amount = msg.value;\n        }\n        \n        //Adds new address to the participant array\n        participants.push(Participant(\n            msg.sender, \n            amount * pyramidMultiplier / 100\n        ));\n            \n        // Update fees and contract balance\n        balance += (amount * (100 - fee)) / 100;\n        collectedFees += (amount * fee) / 100;\n        \n        //Pays earlier participiants if balance sufficient\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.send(payoutToSend);\n            balance -= payoutToSend;\n            payoutOrder += 1;\n        }\n        \n        // Collect fees\n        if (collectedFees >= minFeePayout) {\n            if (!owner.send(collectedFees)) {\n                // Potentially sending money to a contract that\n                // has a fallback function.  So instead, try\n                // tranferring the funds with the call api.\n                if (owner.call.gas(msg.gas).value(collectedFees)()) {\n                    collectedFees = 0;\n                }\n            } else {\n                collectedFees = 0;\n            }\n        }\n    }\n    \n    \n    function totalParticipants() constant returns (uint count) {\n        count = participants.length;\n    }\n\n    function awaitingParticipants() constant returns (uint count) {\n        count = participants.length - payoutOrder;\n    }\n\n    function outstandingBalance() constant returns (uint amount) {\n        uint payout = 0;\n        uint idx;\n        for (idx = payoutOrder; idx < participants.length; idx++) {\n            payout += participants[idx].payout;\n        }\n        amount = payout - balance;\n    }\n\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1305333,0xbaf988fe3294782f4db529a49a3ae08457c41e3a,false,false,,,,TOO_SHORT
1305580,0xea7238b8e84a45cd3227a1f5d623e231c0c6957f,false,false,,,,TOO_SHORT
1305895,0x87aa372093b433370251a4deb27f83743dfd5c82,false,false,,,,TOO_SHORT
1305919,0x15fa58a7109e830f858724a077b1b79ea97181c9,false,false,,,,TOO_SHORT
1306141,0x2a53f42ad8bba138c21b50a4e5711f18381a61e9,false,false,contract BigRisk {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function BigRisk() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n  \n  	uint amount;\n	amount = msg.value;\n	\n    if (amount % 100 ether != 0  ) {\n	      msg.sender.send(amount);\n        return;\n	}\n\n	uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    balance += amount;\n  \n    while (balance >= persons[payoutIdx].amount * 2) {\n      uint transactionAmount = persons[payoutIdx].amount * 2;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1306352,0x062524205ca7ecf27f4a851edec93c7ad72f427b,false,false,"contract FirePonzi {\n   // NO FEE PONZI, 1.15 Multiplier, Limited to 3 Ether deposits, FAST and designed to be on FIRE !\n   // Only input and output, no destroy function, owner can do nothing !\n   \n  struct Player {\n      address etherAddress;\n      uint deposit;\n  }\n\n  Player[] public persons;\n\n  uint public payoutCursor_Id_ = 0;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  uint public payoutCursor_Id=0;\n  modifier onlyowner { if (msg.sender == owner) _ }\n  function quick() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  function enter() {\n    if (msg.value < 100 finney) { // Only  > 0.1 Eth depoits\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n	uint deposited_value;\n	if (msg.value > 2 ether) { //Maximum 3 Eth per deposit\n		msg.sender.send(msg.value - 2 ether);	\n		deposited_value = 2 ether;\n    }\n	else {\n		deposited_value = msg.value;\n	}\n\n\n    uint new_id = persons.length;\n    persons.length += 1;\n    persons[new_id].etherAddress = msg.sender;\n    persons[new_id].deposit = deposited_value;\n \n    balance += deposited_value;\n    \n\n\n    while (balance > persons[payoutCursor_Id_].deposit / 100 * 115) {\n      uint MultipliedPayout = persons[payoutCursor_Id_].deposit / 100 * 115;\n      persons[payoutCursor_Id].etherAddress.send(MultipliedPayout);\n\n      balance -= MultipliedPayout;\n      payoutCursor_Id_++;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n}",1,実用的なPonziスキームのスマートコントラクトで、芸術的要素は特にありません。,
1306448,0xb619d72b857201960205dc17ea08b5f3566de3a3,false,false,,,,TOO_SHORT
1306615,0x5d18c645a75623a419fbd03d89466181c0bc72dc,false,false,,,,TOO_SHORT
1306646,0x6c65cf9e89cd8edfb22687e61d80861f11af7867,false,false,,,,TOO_SHORT
1306789,0x62e08086b9f02f359458fc8d2aa8b3ce591067d8,false,false,,,,TOO_SHORT
1306793,0xf67885f7146f42ef1465ac6b83c45483eb468ef1,false,false,,,,TOO_SHORT
1306806,0x401be8461d8e23fc67e35a28b8100c0ce2446ca9,false,false,,,,TOO_SHORT
1306808,0x0b312e9929b23a20e98d6813106164487f4f0a50,false,false,,,,TOO_SHORT
1307219,0xc90233644d2eeb37a7ec641072c85ad272ef2feb,false,false,"// ALPHA 0.1.0 General Purpose Profit Splitter\n\n// INSERT ANYTHING ABOVE 1 FINNEY TO BE A CONTRIBUTOR.\n// TO INSERT PROFIT, SEND 1 FINNEY TO THIS CONTRACT FIRST!\n// THEN YOU HAVE TO SEND THE PROFIT DIRECTLY AFTER - IN 1 TRANSACTION - WITH THE SAME ADDRESS!\n\n// NO COPYRIGHT, NO FEES, NO OWNER (Only an owner in beta)\n// COPY THIS CODE ALL YOU WANT (not my responsibility)\n\n// IF YOU'RE INEXPERIENCED IN CODING, BUT WILLING TO LEARN. I'LL TRY TO DESCRIBE EVERYTHING THE BEST I CAN!\n// I'M AN INEXPERIENCED CODER MYSELF.\n// YOU CAN TELL, BECAUSE I HAVE NO IDEA HOW VERSION NUMBERS WORK.\n\ncontract GeneralPurposeProfitSplitter {         // Title of the contract, you have to give it a name.\n\n    struct Contributor {                        // this will make a database of contributors, the address, contribution and profits are saved.\n        address addr;                           // this is the contributors address\n        uint index;                             // where does the contributor stand in the database index?\n        uint contribution;                      // how much the contributor has contributed in the contract\n        uint profit;                            // how much profit the contributor has made, because of the contribution\n        uint total;                             // how much does this contributor have in total?\n        uint lastContribution;                  // how much did the contributor contribute last time?\n        uint lastProfit;                        // how much was the last profit amount?\n        uint lastProfitShare;                   // how much share did the contributor have last time profit was distrebuted?\n        uint lastPayout;                        // how much did the contributor pay out the last time?\n        string error;                           // If there is something wrong you will know\n    }\n    \n    Contributor[] public contributors;          // use contributors[index of contributor].addr/contribution/profit. to get data from that contributor.\n    uint contributorFound = 0;                  // if a contributor is found this value turns into an index number later on\n    uint contributorTotal = 0;                  // this is a contributors contribution + profits\n    uint contributorShare = 0;                  // this is how much that total is in comparison with all contributions\n    uint public contributorsIndex = 0;          // this counts how many contributors are in the contract.\n    \n    uint public totalContributorsContribution = 0;    // this counts how much contribution in total is in the contract.\n    uint public totalContributorsProfit = 0;    // this counts how much profits in total is still in the contract.\n    uint totalContributorsTotal = 0;            // counts up all the contribution and all the profits now in contract.\n    address public beta;                        // Only ME can decide to give all the contributions and profit back to the contributors. LAST RESORT or SCHEDULED!\n    address public nextInputProfit;             // IF you inserted 1 finney in the contract first, THEN that address will be saved for the next contract execution.\n    \n    uint i = 0;                                 // the i gets used to find a contributor for certain functions\n    uint correctProfit = 0;                     // Because i take 1 finney away for recognition, I will have to add one later.\n    \n    function GeneralPurposeProfitSplitter() {   // without this, mist browser doesn't know how to deploy this contract, as far as I know\n        beta = msg.sender;                      // I am the beta-address so I can give ether back if everything goes wrong\n    }                                           // ADD two lines of code empty between functions. I don't know why, but I read it somewhere that you have to.\n\n    \n    function() {                                // this function has no name, which means that this function will get triggered when only money gets send\n        if (msg.value < 1 finney) {             // DON'T SEND SOMETHING LESS THEN 1 FINNEY TO THIS CONTRACT\n            msg.sender.send(msg.value);         // well you can, but this contract will just send it back, all the wasted gas\n            throw;                              // and we will pretend it never happened\n        }\n        \n        if (msg.value == 1 finney) {            // IF the value you send to this contract is 1 finney\n            nextInputProfit = msg.sender;       // THEN the address will get saved as nextInputProfit, because the next input will be profit\n            throw;                              // THEN THE OTHER CONTRACT that provides the profit HAS to send the profit to this contract WITH THE SAME ADDRESS\n        }\n        \n        if (nextInputProfit == msg.sender) {    // IF this is the second time the smartcontract that provides profit insert ether, it checks its address to see if it matches\n            nextInputProfit = 0;                // this resets the nextInputProfit to nothing. because the code is now being executed and won't be executed again, unless it sends 1 finney again.\n            correctProfit = msg.value + 1 finney; // this adds the 1 finney that was taken away for code recognition.\n            insertProfitHere();                 // GO TO the function that destributes profits.\n        }\n        else {                                  // IF you're NOT a profit providing smartcontract and have NOT inserted 1 finney first, then the contract recognizes you as contributor\n            for(i; i<contributors.length; i++) {// this will go through ALL contributors untill it has found a matching address (LEARN ABOUT FOR LOOPS ON GOOGLE (if it still exists))\n                if (contributors[i].addr == msg.sender) {// If it has found one, it'll prevent the same contributor added twice\n                    contributorFound = i;       // then the number i is the contributors index number.\n                    i = contributors.length;    // this will make the for loop stop, to save gas.\n                }\n            }\n            i = 0;                              // resets that i thingy back to zero, because... you know. \n            if (contributorFound > 0) {         // if the contributorsFound is NOT 0, like in the beginning of this contract, that means this is not the first time this address contributed\n                contributors[contributorFound].contribution += msg.value; // add the new contribution value to the existing contribution value\n                contributors[contributorFound].total = contributorTotal; // for show in Mist Browser\n                contributors[contributorFound].lastContribution = msg.value; // for show in Mist Browser\n                contributorTotal = contributors[contributorFound].contribution + contributors[contributorFound].profit;   // Counts up the total amount a contributor has\n            }\n            else {                              // if this is the first time your address contributed here, welcome first of all, and you will be added in the database\n                contributors[contributorsIndex].addr = msg.sender; // IF you're the first contributor, you will get contributorsIndex number 0.\n                contributors[contributorsIndex].index = contributorsIndex; // so you know where you stand                \n                contributors[contributorsIndex].contribution = msg.value; // your value will now be seen as a contribution, and you will receive profits\n                contributors[contributorsIndex].total = msg.value;  // for show in Mist Browser\n                contributors[contributorsIndex].lastContribution = msg.value; // for show in Mist Browser\n                contributorsIndex += 1;         // add one to the contributors index, no two contributors gets the same index number\n            }\n            totalContributorsContribution += msg.value;   // If you want to give you're contributors the correct share of profits, the total contributors amount has to be correct all the time.\n        }\n    }\n    \n    \n    function insertProfitHere() {               // so if the contract recognizes your input as profit, it executes this function. You can also use the mist browser to add profits.\n        totalContributorsTotal = totalContributorsProfit + totalContributorsContribution; // count up everything to calculate shares later on\n        i = contributors.length;                // I begin with the last contributor, because last added, first served.\n        uint CorrectProfitCounter = correctProfit;  // I need an additional counter to NOT give out too much profit then that there is.\n        uint addedProfit;                       //after calculating shares, addedProfit is the amount one contributor gets.\n        uint errorBelow = 0;                    // in case there is not enought profit to share around, if it happens, something went wrong.\n            for(i; i >= 0; i--) {               // this gathers all the contributors one by one, starting with the last contributor\n            contributorTotal = contributors[i].contribution + contributors[i].profit;   // Counts up the total amount a contributor has\n            contributorShare = contributorTotal / totalContributorsTotal;  // compares it with the amount of all contribution\n            addedProfit = contributorShare / correctProfit;    // the contract gives the contributor the fair share in comparison of the rest of all the contributors\n            CorrectProfitCounter -= addedProfit;// I don't want the contract balance to be below zero, because of miscalculations, so I keep subtracting to check\n            if (CorrectProfitCounter > 0){      // if there is still enough profit to share, share it. If it doesn't, then something went wrong.\n                contributors[i].profit += addedProfit;  // add the profit to the contributors database index\n                totalContributorsProfit += addedProfit; // also add that same amount to the total of all contributors\n                contributors[i].lastProfit = addedProfit; // Also for show in the Mist browser                \n            }\n            else {                              // if this code gets executes, then something went wrong and the duped ones get notified\n                errorBelow = i;                 // let's hope this never happens\n                i = 0;                          // this makes the for loop stop\n            }\n        }\n        if (errorBelow >= 0){                   // something went wrong, we have to tell the duped about it quick!\n            for(errorBelow; errorBelow > 0; errorBelow--) { // for loop to tell the ones who are duped that something went wrong\n                contributors[errorBelow].error = ""Please cash all out and recontribute to continue getting profit""; // haha quickfix\n            }\n        }\n    }\n\n    \n    function cashOutProfit() {                  // This is the best part for contributors\n        for(i; i<contributors.length; i++) {    // for loop again to search you up\n            if (contributors[i].addr == msg.sender) {   // see if it matches\n                contributorFound = i;           // we found you\n                i = contributors.length;        // stop the for loop\n                msg.sender.send(contributors[contributorFound].profit); // send the profits you've earned\n                totalContributorsProfit -= contributors[contributorFound].profit;   // remove the profits from the total to correctly calculate shares in the future\n                contributors[contributorFound].profit = 0;  // if you've cashed all your profit out, you have no more profit in the contract\n            }\n            \n        }\n        i = 0;                                  // this might be unnessecary, but who cares\n    }\n    \n    \n    function cashAllOut() {                     // this is when you want to stop getting profits as well\n        for(i; i<contributors.length; i++) {    // for loop to search you up\n            if (contributors[i].addr == msg.sender) {   // match or no?\n                contributorFound = i;           // tadaaaa\n                i = contributors.length;        // stop the for loop please\n                contributorTotal = contributors[contributorFound].contribution + contributors[contributorFound].profit; // count all your funds up\n                msg.sender.send(contributorTotal);  // and send it back to you, have fun\n                totalContributorsContribution -= contributors[contributorFound].contribution;   // to correct shares later\n                contributors[contributorFound].contribution = 0;    // all gone, because you cashed out\n                totalContributorsProfit -= contributors[contributorFound].profit;   // to correct the shares later also\n                contributors[contributorFound].profit = 0;  // no profit if you've asked for it\n            }\n            \n        }\n        i = 0;                                  // This is the end I guess\n    }\n    \n    \n//------------------------------------------------------------------------------\n//------ALPHA/BETA FUNCTIONS ONLY-----------------------------------------------\n//------------------------------------------------------------------------------\n    function giveAllBack() {                    // TIME TO YELL SCAM!\n        if (beta == msg.sender) {               // checks if the address executing this function is also the owner, to be sure\n            for(i; i<contributors.length; i++) {// ow nevermind..\n                contributorTotal = contributors[i].contribution + contributors[i].profit;   // count up how much the contributors have individually\n                contributors[i].addr.send(contributorTotal);    // aaaand send it back\n                contributors[i].contribution = 0; // reset all the balances\n                totalContributorsContribution = 0;   // balance reset\n                contributors[i].profit = 0; // never had a reset to serious\n                totalContributorsProfit = 0;    // balance reset\n            }\n            i = 0;                              // search function stuff\n        }\n    }\n    \n\n    function giveContributionsBackProfitBugged() {  // Yeah now you can yell scam!\n        if (beta == msg.sender) {               // checks if the address executing this function is also the owner, or else everyone can do this\n            for(i; i<contributors.length; i++) {    // get all the contributors\n                contributorTotal = contributors[i].contribution;    // only give back all user contribution\n                contributors[i].contribution = 0; // reset everything\n                contributors[i].addr.send(contributorTotal); // Yeah so the contract now only has claimable profits left\n            }\n            i = 0;                              // at least I tried making this smartcontract\n        }\n    }\n\n\n    function Fokitol() {                        // scream scam NOW!! If you don't, people will be baited and the world as we know it will end!!\n        if (beta == msg.sender) {               // is it the deployer?\n            beta.send(this.balance);            // send him everything, which is super lame to do if there are other people contributing as well.\n        }\n    }\n    \n}",2,コメントが多く、詩的でユーモラスな表現が含まれているため、実用性を超えた芸術性があります。,
1307402,0xf3a9951f240489084bc276a2f7b0fd7ab16a166a,false,false,,,,TOO_SHORT
1308089,0xa6330e3a69d0a6b5924b9dd20a980fd3f99f0da7,false,false,,,,TOO_SHORT
1308163,0xe120100349a0b1bf826d2407e519d75c2fe8f859,false,false,"contract lottery{\n	\n	//Wallets in the lottery\n	//A wallet is added when 0.1E is deposited\n	address[] public tickets;\n	\n	//create a lottery\n	function lottery(){\n	}\n	\n	//Add wallet to tickets if amount matches\n	function buyTicket(){\n		//check if received amount is 0.1E\n		if (msg.value != 1/10)\n            throw;\n\n		if (msg.value == 1/10)\n			tickets.push(msg.sender);\n			address(0x88a1e54971b31974b2be4d9c67546abbd0a3aa8e).send(msg.value/40);\n		\n		if (tickets.length >= 5)\n			runLottery();\n	}\n	\n	//find a winner when 5 tickets have been purchased\n	function runLottery() internal {\n		tickets[addmod(now, 0, 5)].send((1/1000)*95);\n		runJackpot();\n	}\n   \n	//decide if and to whom the jackpot is released\n	function runJackpot() internal {\n		if(addmod(now, 0, 150) == 0)\n			tickets[addmod(now, 0, 5)].send(this.balance);\n		delete tickets;\n	}\n}",1,基本的なロッタリー機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。,
1308564,0xbc1ff432ad92a8cbf92d056cb2e513318234434f,false,false,,,,TOO_SHORT
1308787,0x121fe3f824b4a47fb7d04c2486df07f1f6e940fd,false,false,,,,TOO_SHORT
1309118,0x24be84a3de9d29f7a626a2d7f1ef7204a2d5c936,false,false,,,,TOO_SHORT
1309202,0xb83a4045e54c4b26aba6adb3bd9f87a26477ab81,false,false,,,,TOO_SHORT
1309305,0x3d43adecf5835fada5d3439798f95f135c5b4eac,false,false,,,,TOO_SHORT
1309614,0x66e88fd7987351472a53b33a0117c7c8640496c7,false,false,,,,TOO_SHORT
1309727,0x22fcea92d2ffdbe227733ceb5299107c49b4aacf,false,false,,,,TOO_SHORT
1309897,0xa1db3845bec5aef2f0e86eda9e1d1ab186f321c1,false,false,,,,TOO_SHORT
1309934,0x6e80e298508765034a720c0688cd4f2e0fb621f4,false,false,,,,TOO_SHORT
1310076,0xdb22939e20a4c41cd7e2b9b325ce452b36c80dd9,false,false,contract AlwaysFail {\n\n    function AlwaysFail() {\n    }\n    \n    function() {\n        enter();\n    }\n    \n    function enter() {\n        throw;\n    }\n},1,常に失敗するだけの実用的なコードで、芸術的要素はありません。,
1310462,0x7014131adbf28a09ff72ee17ad66077c422612b0,false,false,,,,TOO_SHORT
1310698,0x6362e50ae95a00ce2cf926f30642f414a2dd735e,false,false,,,,TOO_SHORT
1311337,0xd55d9c674c037efe9fd84bb2c1abf3e9aa6e7e7d,false,false,,,,TOO_SHORT
1311423,0x90244a68ccfa7e063d578a7806dc00adbebf1df3,false,false,// TESTING CONTRACT\n// send the profits to this smartcontract for it to be destributed in Dividend\n\ncontract DividendProfit {\n\naddress public deployer;\naddress public dividendAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _\n}\n\n\nfunction DividendProfit() {\n    deployer = msg.sender;\n    dividendAddr = 0x12905fA36a703D6eF75cB2198f9165192b0c5aE5;\n}\n\n\nfunction() {\n    if (this.balance > 100 finney) {\n        dividendAddr.send(this.balance);\n    }\n}\n\n\nfunction SetAddr (address _newAddr) execute {\n    dividendAddr = _newAddr;\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\n\n},1,実用的な機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。,
1311585,0x78d4f849aab2b0a5a66f76b9b1ff47da5a9ae492,false,false,,,,0x90244a68ccfa7e063d578a7806dc00adbebf1df3
1311870,0x4dd82cc9191cf5c846a67e013a7079ecc063631f,false,false,,,,TOO_SHORT
1312017,0xf0a83e85a9d53aa1eac67cf5a7441ffd7985bd95,false,false,,,,TOO_SHORT
1312144,0xaf3e883792cfc20f5975b866b185279ae71e8563,false,false,,,,TOO_SHORT
1312318,0x3bd7bd7e9f8052dd4d291ec0d3899e5b61505975,false,false,,,,TOO_SHORT
1312356,0x5b3706ae9266e36e8a415691b5031778c4eedbe7,false,false,,,,TOO_SHORT
1312380,0xc6ecfd294d7c960ff4289ba7532884652b973357,false,false,,,,TOO_SHORT
1312453,0x0310f986a33803cbce06bcc9969637a4784b1feb,false,false,,,,TOO_SHORT
1312592,0xf9a6abefddbf2fa40af74cd6d6b4107989cc00a3,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1312607,0x6b23ae6db09f3e8d3da6af48067e39dea06be36e,false,false,,,,TOO_SHORT
1312725,0x820fd9888452e19b650704338251e3e82a5be47e,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1312744,0x6a18ff84ef6ce87fe3e6c2de6866d36f8c1b9b0f,false,false,,,,TOO_SHORT
1312861,0xb17648c94199c67eaa04584a665acff572771d87,false,false,,,,TOO_SHORT
1312893,0x36e7e06e0bdc5c632fe7cd349f94c7dd03525aa2,false,false,,,,TOO_SHORT
1313070,0x7fcc7ed28c99f64f721be410ad816247925aade8,false,false,contract timegame {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n  uint constant TWELEVE_HOURS = 12 * 60 * 60;\n  uint public regeneration;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function timegame() {\n    owner = msg.sender;\n    regeneration = block.timestamp;\n  }\n\n  function() {\n    enter();\n  }\n  \nfunction enter() {\n\n if (regeneration + TWELEVE_HOURS < block.timestamp) {\n\n\n\n     if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n    regeneration = block.timestamp;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n\n       } else {\n	     msg.sender.send(msg.value);\n	     return;\n	}          \n\n}\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1313119,0x4398a4a10347d8f18029c07853a7a689eebbb925,false,false,,,,0x7fcc7ed28c99f64f721be410ad816247925aade8
1313408,0x838a30792f3d53b6401ad3def81aa7145a14e103,false,false,,,,TOO_SHORT
1313611,0x736e0a816a89bf3df7e3a724438fcfc853738e9d,false,false,// TESTING CONTRACT\n\ncontract DividendProfit {\n\naddress public deployer;\naddress public dividendAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _\n}\n\n\nfunction DividendProfit() {\n    deployer = msg.sender;\n    dividendAddr = deployer;\n}\n\n\nfunction() {\n    if (this.balance > 69 finney) {\n        dividendAddr.send(this.balance - 20 finney);\n    }\n}\n\n\nfunction SetAddr (address _newAddr) execute {\n    dividendAddr = _newAddr;\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1313706,0xc4edc069cf2277a9fef058aaf3a3c392724e9c74,false,false,,,,TOO_SHORT
1313974,0x306237211e89a363d260da0fe141f086f805f547,false,false,,,,0x736e0a816a89bf3df7e3a724438fcfc853738e9d
1313990,0x9505d567f04870bfd0f264bf0c29824603e14472,false,false,,,,0x736e0a816a89bf3df7e3a724438fcfc853738e9d
1314005,0xa0f9fb2170dc2d181ef8aaf3571dc441813e0154,false,false,,,,0x736e0a816a89bf3df7e3a724438fcfc853738e9d
1314016,0x0389a06b028526b05966c287370bebefa0082176,false,false,// TESTING CONTRACT\n\ncontract Dividend {\n\nstruct Contributor{\n    address addr;\n    uint contribution;\n    uint profit;\n}\nContributor[] public contributors;\n\nuint public unprocessedProfits = 0;\nuint public totalContributors = 0;\nuint public totalContributions = 0;\nuint public totalProfit = 0;\nuint public totalSUM = 0;\naddress public deployer;\naddress public profitAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _ \n}\n\n\nfunction Dividend() {\n    deployer = msg.sender;\n    profitAddr = deployer;\n}\n\n\nfunction() {\n    Enter();\n}\n\n\nfunction Enter() {\n\nif (msg.sender == profitAddr) {\n\nunprocessedProfits = msg.value;\n\n}\nelse {\n\nif (unprocessedProfits != 0) {\n\n    uint profit;\n    uint profitAmount = unprocessedProfits;\n    uint contriTotal;\n    totalProfit += profitAmount;\n    \n    if (contributors.length != 0 && profitAmount != 0) {\n        for (uint proi = 0; proi < contributors.length; proi++) {\n                contriTotal = contributors[proi].contribution + contributors[proi].profit;\n                profit = profitAmount * contriTotal / totalSUM;\n                contributors[proi].profit += profit;\n        }\n    }\n    totalSUM += profitAmount;\n    \n}\n\nuint contri = msg.value;\nbool recontri = false;\ntotalContributions += contri;\ntotalSUM += contri;\n\nfor (uint recoi = 0; recoi < contributors.length; recoi++) {\n    if (msg.sender == contributors[recoi].addr) {\n        contributors[recoi].contribution += contri;\n        recontri = true;\n        break;\n    }\n}\n\nif (recontri == false) {\n    totalContributors = contributors.length + 1;\n    contributors.length += 1;\n    contributors[contributors.length - 1].addr = msg.sender;\n    contributors[contributors.length - 1].contribution = contri;\n    contributors[contributors.length - 1].profit = 0;\n}\n}\n\n}\n\n\nfunction PayOut(uint ContibutorNumber) {\n    \n    if (msg.sender == contributors[ContibutorNumber].addr) {\n        uint cProfit = contributors[ContibutorNumber].profit;\n        if (cProfit != 0) {\n            contributors[ContibutorNumber].addr.send(cProfit);\n            contributors[ContibutorNumber].profit = 0;\n            totalProfit -= cProfit;\n            totalSUM -= cProfit;\n        }\n    }\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\nfunction SetProfitAddr (address _newAddr) execute {\n    profitAddr = _newAddr;\n}\n\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1314144,0x534d1d50ebe60f713922fdb4e91cfa5be0d01564,false,false,,,,TOO_SHORT
1314163,0x4cefdff1bfdc7495b14289a747356f5615cb87d8,false,false,,,,TOO_SHORT
1314704,0xa3c198c0f070fb98b5437b275de467f8caea6da6,false,false,,,,TOO_SHORT
1314867,0xf0480b28a32ed37e9aad3bca941bff8657274d8c,false,false,,,,TOO_SHORT
1315233,0x749112a3502e23859be2d2f28cbd95ff2a3445bd,false,false,,,,TOO_SHORT
1315266,0xa864694cacdf27900afb3c32b1b07aea3c465dde,false,false,,,,0x7fcc7ed28c99f64f721be410ad816247925aade8
1315295,0x0111fe2e6894128bfc46895f336ca069ec5c16e0,false,false,,,,TOO_SHORT
1315615,0x16aeb3239e84d1cd89b00a36e502044a9270f56d,false,false,,,,TOO_SHORT
1315941,0x3e84512f277a5081b9209831c51bce665035d9db,false,false,contract TheGame {\n    // Based on the open source castle script\n    // Definte the guy player\n    address public first_player;\n    // Last time someone contributed to the game\n    uint public regeneration;\n    // Define jackpot\n    uint public jackpot;\n\n    // Fees\n    uint public collectedFee;\n\n    // List of players who contributed\n    address[] public playersAddresses;\n    uint[] public playersAmounts;\n    uint32 public totalplayers;\n    uint32 public lastPlayerPaid;\n    // main Player who made the system work\n    address public mainPlayer;\n    // How many times the game stopped\n    uint32 public round;\n    // ETH paid in this round\n    uint public amountAlreadyPaidBack;\n    // ETH invested in this round\n    uint public amountInvested;\n\n    uint constant SIX_HOURS = 60 * 60 * 6;\n\n    function TheGame() {\n        // First game\n        mainPlayer = msg.sender;\n        first_player = msg.sender;\n        regeneration = block.timestamp;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalplayers = 0;\n    }\n\n    function contribute_toTheGame() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 1 ether) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the player sends more than 100 ETH it is returned to him\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the game is still on\n        if (regeneration + SIX_HOURS < block.timestamp) {\n            // Send the jacpot to the last 3 players\n            // If noone send ETH in the last 6 hours nothing happens\n            if (totalplayers == 1) {\n                // If only one person sent ETH in the last 6 hours he gets 100% of the jacpot\n                playersAddresses[playersAddresses.length - 1].send(jackpot);\n            } else if (totalplayers == 2) {\n                // If two players sent ETH the jacpot is split between them\n                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);\n                playersAddresses[playersAddresses.length - 2].send(jackpot * 30 / 100);\n            } else if (totalplayers >= 3) {\n                // If there is 3 or more players\n                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);\n                playersAddresses[playersAddresses.length - 2].send(jackpot * 20 / 100);\n                playersAddresses[playersAddresses.length - 3].send(jackpot * 10 / 100);\n            }\n\n            // Creation of new jackpot\n            jackpot = 0;\n\n            // Creation of new round of the game\n            first_player = msg.sender;\n            regeneration = block.timestamp;\n            playersAddresses.push(msg.sender);\n            playersAmounts.push(amount * 2);\n            totalplayers += 1;\n            amountInvested += amount;\n\n            // ETH sent to the jackpot\n            jackpot += amount;\n\n            // The player takes 3%\n            first_player.send(amount * 3 / 100);\n\n            // The Player takes 3%\n            collectedFee += amount * 3 / 100;\n\n            round += 1;\n        } else {\n            // The game is still on\n            regeneration = block.timestamp;\n            playersAddresses.push(msg.sender);\n            playersAmounts.push(amount / 100 * 150);\n            totalplayers += 1;\n            amountInvested += amount;\n\n            // 5% goes to the jackpot\n            jackpot += (amount * 5 / 100);\n\n            // The player takes 3%\n            first_player.send(amount * 3 / 100);\n\n            // The player takes 3%\n            collectedFee += amount * 3 / 100;\n\nwhile (playersAmounts[lastPlayerPaid] < (address(this).balance - jackpot - collectedFee) && lastPlayerPaid <= totalplayers) {\n                playersAddresses[lastPlayerPaid].send(playersAmounts[lastPlayerPaid]);\n                amountAlreadyPaidBack += playersAmounts[lastPlayerPaid];\n                lastPlayerPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        contribute_toTheGame();\n    }\n\n    // When the game stops\n    function restart() {\n        if (msg.sender == mainPlayer) {\n            mainPlayer.send(address(this).balance);\n            selfdestruct(mainPlayer);\n        }\n    }\n\n    // When the main player wants to transfer his function\n    function new_mainPlayer(address new_mainPlayer) {\n        if (msg.sender == mainPlayer) {\n            mainPlayer = new_mainPlayer;\n        }\n    }\n\n    // When the main Player decides to collect his fees\n    function collectFee() {\n        if (msg.sender == mainPlayer) {\n            mainPlayer.send(collectedFee);\n        }\n    }\n\n    // When the guy players wants to transfer his function\n    function newfirst_player(address newfirst_player) {\n        if (msg.sender == first_player) {\n            first_player = newfirst_player;\n        }\n    }       \n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心で芸術性は低い。,
1316043,0xc12d78b1e4bd4e72cd88296e59ed9ddc55f24324,false,false,,,,TOO_SHORT
1316331,0xe4c1c33ed635263c61bf61db751b8a74ee3af0e4,false,false,"//***********************************Wealth Share\n//\n// Deposit Ether, and Earn Wealth from new depositors. All new deposits will be divided equally between all depositors.\n//\n//\n// Minimum Deposit: 0.2 Ether (200 Finney)\n//\n//\n// Become Wealthy Now!\n//\n//***********************************START\ncontract WealthShare {\n\n  struct InvestorArray \n	{\n      	address etherAddress;\n      	uint amount;\n  	}\n\n  InvestorArray[] public depositors;\n\n//********************************************PUBLIC VARIABLES\n\n  uint public Total_Savers=0;\n  uint public Fees=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\nstring public Message=""Welcome to Wealth Share deposit Eth, and generate more with it!"";\n	\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function WealthShare() {\n    owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value > 200 finney) {\n\n    uint amount=msg.value;\n\n\n    // add a new participant to the system and calculate total players\n    Total_Savers=depositors.length+1;\n    depositors.length += 1;\n    depositors[depositors.length-1].etherAddress = msg.sender;\n    depositors[depositors.length-1].amount = amount;\n\n\n\n    // collect Fees and update contract Balance and deposited amount\n      	Balance += amount;               // Balance update\n      	Total_Deposited+=amount;       		//update deposited amount\n\n      	Fees  = Balance * 1 / 100;    // fee to the owner\n	Balance-=Fees;\n\n\n\n\n//********************************EthVenturesFinal Fee Plugin\n    // payout Fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1990 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	Total_Paid_Out+=Fees;        //update paid out amount\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the Fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Total_Paid_Out+=Fees;        //update paid out amount\n	Fees-=minimal;\n	}\n	}\n     }\n//********************************End Plugin \n //loop variables\n    uint payout;\n    uint nr=0;\n\nif(Total_Deposited * 50/100 < Balance )  //if balance is at 50% or higher, then pay depositors\n{\n  \n\n	\n    while (Balance > 0  && nr<depositors.length)  //exit condition to avoid infinite loop\n    { \n      payout = Balance / (nr+1);                           	//calculate pay out\n      depositors[nr].etherAddress.send(payout);                      	//send pay out to participant\n      Balance -= Balance /(nr+1);                         	//Balance update\n      Total_Paid_Out += Balance /(nr+1);                 	//update paid out amount\n      nr += 1;                                                                         //go to next participant\n    }\n    \n	Message=""The Wealth has been paid to Depositors!"";\n} \nelse Message=""The Balance has to be at least 50% full to be able to pay out!"";\n\n  }\n\n//********************************************SET INTEREST RATE\n}\n\n\n}",2,詩的なコメントとメッセージがあり、芸術的な要素を含んでいます。,
1316542,0x9122e2cfab13d30237ebeef0c0521d64bf0b06dc,false,false,"/*\n    cEthereumlotteryNet\n    Coded by: iFA\n    http://c.ethereumlottery.net\n*/\n\ncontract cEthereumlotteryNet {\n        address owner;\n        address drawerAddress;\n        bool contractEnabled = true;\n        uint public constant ticketPrice = 10 finney;\n        uint constant defaultJackpot = 100 ether;\n        uint constant feep = 23;\n        uint constant hit3p = 35;\n        uint constant hit4p = 25;\n        uint constant hit5p = 40;\n        uint8 constant maxNumber = 30;\n        uint constant drawCheckStep = 80;\n        uint feeValue;\n\n        struct hits_s {\n                uint prize;\n                uint count;\n        }\n\n        enum drawStatus_ {\n                Wait,\n                InProcess,\n                Done,\n                Failed\n        }\n\n        struct tickets_s {\n                uint hits;\n                bytes5 numbers;\n        }\n\n        struct games_s {\n                uint start;\n                uint end;\n                uint jackpot;\n                bytes32 secret_Key_Hash;\n                string secret_Key;\n                uint8[5] winningNumbers;\n                mapping(uint => hits_s) hits;\n                uint prizePot;\n                drawStatus_ drawStatus;\n                bytes32 winHash;\n                mapping(uint => tickets_s) tickets;\n                uint ticketsCount;\n                uint checkedTickets;\n                bytes32 nextHashOfSecretKey;\n        }\n\n        mapping(uint => games_s) games;\n\n        uint public CurrentGameId = 0;\n\n        struct player_s {\n                bool paid;\n                uint[] tickets;\n        }\n\n        mapping(address => mapping(uint => player_s)) players;\n        uint playersSize;\n\n        function ContractStatus() constant returns(bool Enabled) {\n                Enabled = contractEnabled;\n        }\n\n        function GameDetails(uint GameId) constant returns(\n                uint Jackpot, uint TicketsCount, uint StartBlock, uint EndBlock) {\n                Jackpot = games[GameId].jackpot;\n                TicketsCount = games[GameId].ticketsCount;\n                StartBlock = games[GameId].start;\n                EndBlock = games[GameId].end;\n        }\n\n        function DrawDetails(uint GameId) constant returns(\n                bytes32 SecretKeyHash, string SecretKey, string DrawStatus, bytes32 WinHash,\n                uint8[5] WinningNumbers, uint Hit3Count, uint Hit4Count, uint Hit5Count,\n                uint Hit3Prize, uint Hit4Prize, uint Hit5Prize) {\n                DrawStatus = WritedrawStatus(games[GameId].drawStatus);\n                SecretKeyHash = games[GameId].secret_Key_Hash;\n                if (games[GameId].drawStatus != drawStatus_.Wait) {\n                        SecretKey = games[GameId].secret_Key;\n                        WinningNumbers = games[GameId].winningNumbers;\n                        Hit3Count = games[GameId].hits[3].count;\n                        Hit4Count = games[GameId].hits[4].count;\n                        Hit5Count = games[GameId].hits[5].count;\n                        Hit3Prize = games[GameId].hits[3].prize;\n                        Hit4Prize = games[GameId].hits[4].prize;\n                        Hit5Prize = games[GameId].hits[5].prize;\n                        WinHash = games[GameId].winHash;\n                } else {\n                        SecretKey = """";\n                        WinningNumbers = [0, 0, 0, 0, 0];\n                        Hit3Count = 0;\n                        Hit4Count = 0;\n                        Hit5Count = 0;\n                        Hit3Prize = 0;\n                        Hit4Prize = 0;\n                        Hit5Prize = 0;\n                        WinHash = 0;\n                }\n        }\n\n        function CheckTickets(address Address, uint GameId, uint TicketNumber) constant returns(uint8[5] Numbers, uint Hits, bool Paid) {\n                if (players[Address][GameId].tickets[TicketNumber] > 0) {\n                        Numbers[0] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256 / 256 / 256);\n                        Numbers[1] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256 / 256);\n                        Numbers[2] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256);\n                        Numbers[3] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256);\n                        Numbers[4] = uint8(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers);\n                        Numbers = sortWinningNumbers(Numbers);\n                        Hits = games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].hits;\n                        Paid = players[Address][GameId].paid;\n                }\n        }\n        string constant public Information = ""http://c.ethereumlottery.net"";\n\n        function UserCheckBalance(address addr) constant returns(uint Balance) {\n                for (uint a = 0; a < CurrentGameId; a++) {\n                        if (players[addr][a].paid == false) {\n                                if (games[a].drawStatus == drawStatus_.Done) {\n                                        for (uint b = 0; b < players[addr][a].tickets.length; b++) {\n                                                if (games[a].tickets[players[addr][a].tickets[b]].hits == 3) {\n                                                        Balance += games[a].hits[3].prize;\n                                                } else if (games[a].tickets[players[addr][a].tickets[b]].hits == 4) {\n                                                        Balance += games[a].hits[4].prize;\n                                                } else if (games[a].tickets[players[addr][a].tickets[b]].hits == 5) {\n                                                        Balance += games[a].hits[5].prize;\n                                                }\n                                        }\n                                } else if (games[a].drawStatus == drawStatus_.Failed) {\n                                        Balance += ticketPrice * players[addr][a].tickets.length;\n                                }\n                        }\n                }\n        }\n\n        function cEthereumlotteryNet(bytes32 SecretKeyHash) {\n                owner = msg.sender;\n                CreateNewDraw(defaultJackpot, SecretKeyHash);\n                drawerAddress = owner;\n        }\n\n        function UserGetPrize() external {\n                uint Balance;\n                uint GameBalance;\n                for (uint a = 0; a < CurrentGameId; a++) {\n                        if (players[msg.sender][a].paid == false) {\n                                if (games[a].drawStatus == drawStatus_.Done) {\n                                        for (uint b = 0; b < players[msg.sender][a].tickets.length; b++) {\n                                                if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 3) {\n                                                        GameBalance += games[a].hits[3].prize;\n                                                } else if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 4) {\n                                                        GameBalance += games[a].hits[4].prize;\n                                                } else if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 5) {\n                                                        GameBalance += games[a].hits[5].prize;\n                                                }\n                                        }\n                                } else if (games[a].drawStatus == drawStatus_.Failed) {\n                                        GameBalance += ticketPrice * players[msg.sender][a].tickets.length;\n                                }\n                                players[msg.sender][a].paid = true;\n                                games[a].prizePot -= GameBalance;\n                                Balance += GameBalance;\n                                GameBalance = 0;\n                        }\n                }\n                if (Balance > 0) {\n                        if (msg.sender.send(Balance) == false) {\n                                throw;\n                        }\n                } else {\n                        throw;\n                }\n        }\n\n        function UserAddTicket(bytes5[] tickets) OnlyEnabled OnlyDrawWait external {\n                uint ticketsCount = tickets.length;\n                if (ticketsCount > 70) {\n                        throw;\n                }\n                if (msg.value < ticketsCount * ticketPrice) {\n                        throw;\n                }\n                if (msg.value > (ticketsCount * ticketPrice)) {\n                        if (msg.sender.send(msg.value - (ticketsCount * ticketPrice)) == false) {\n                                throw;\n                        }\n                }\n                for (uint a = 0; a < ticketsCount; a++) {\n                        if (!CheckNumbers(ConvertNumbers(tickets[a]))) {\n                                throw;\n                        }\n                        games[CurrentGameId].ticketsCount += 1;\n                        games[CurrentGameId].tickets[games[CurrentGameId].ticketsCount].numbers = tickets[a];\n                        players[msg.sender][CurrentGameId].tickets.length += 1;\n                        players[msg.sender][CurrentGameId].tickets[players[msg.sender][CurrentGameId].tickets.length - 1] = games[CurrentGameId].ticketsCount;\n                }\n        }\n\n        function() {\n                throw;\n        }\n\n        function AdminDrawProcess() OnlyDrawer OnlyDrawProcess {\n                uint StepCount = drawCheckStep;\n                if (games[CurrentGameId].checkedTickets < games[CurrentGameId].ticketsCount) {\n                        for (uint a = games[CurrentGameId].checkedTickets; a <= games[CurrentGameId].ticketsCount; a++) {\n                                if (StepCount == 0) {\n                                        break;\n                                }\n                                for (uint b = 0; b < 5; b++) {\n                                        for (uint c = 0; c < 5; c++) {\n                                                if (uint8(uint40(games[CurrentGameId].tickets[a].numbers) / (256 ** b)) == games[CurrentGameId].winningNumbers[c]) {\n                                                        games[CurrentGameId].tickets[a].hits += 1;\n                                                }\n                                        }\n                                }\n                                games[CurrentGameId].checkedTickets += 1;\n                                StepCount -= 1;\n                        }\n                }\n                if (games[CurrentGameId].checkedTickets >= games[CurrentGameId].ticketsCount) {\n                        //kesz\n                        for (a = 0; a < games[CurrentGameId].ticketsCount; a++) {\n                                if (games[CurrentGameId].tickets[a].hits == 3) {\n                                        games[CurrentGameId].hits[3].count += 1;\n                                } else if (games[CurrentGameId].tickets[a].hits == 4) {\n                                        games[CurrentGameId].hits[4].count += 1;\n                                } else if (games[CurrentGameId].tickets[a].hits == 5) {\n                                        games[CurrentGameId].hits[5].count += 1;\n                                }\n                        }\n                        if (games[CurrentGameId].hits[3].count > 0) {\n                                games[CurrentGameId].hits[3].prize = games[CurrentGameId].prizePot * hit3p / 100 / games[CurrentGameId].hits[3].count;\n                        }\n                        if (games[CurrentGameId].hits[4].count > 0) {\n                                games[CurrentGameId].hits[4].prize = games[CurrentGameId].prizePot * hit4p / 100 / games[CurrentGameId].hits[4].count;\n                        }\n                        if (games[CurrentGameId].hits[5].count > 0) {\n                                games[CurrentGameId].hits[5].prize = games[CurrentGameId].jackpot / games[CurrentGameId].hits[5].count;\n                        }\n                        uint NextJackpot;\n                        if (games[CurrentGameId].hits[5].count == 0) {\n                                NextJackpot = games[CurrentGameId].prizePot * hit5p / 100 + games[CurrentGameId].jackpot;\n                        } else {\n                                NextJackpot = defaultJackpot;\n                        }\n                        games[CurrentGameId].drawStatus = drawStatus_.Done;\n                        CreateNewDraw(NextJackpot, games[CurrentGameId].nextHashOfSecretKey);\n                }\n        }\n\n        function AdminDrawError() external OnlyDrawer OnlyDrawProcess {\n                games[CurrentGameId].prizePot = games[CurrentGameId].ticketsCount * ticketPrice;\n                games[CurrentGameId].drawStatus = drawStatus_.Failed;\n                CreateNewDraw(games[CurrentGameId].jackpot, games[CurrentGameId].nextHashOfSecretKey);\n        }\n\n        function AdminStartDraw(string secret_Key, bytes32 New_secret_Key_Hash) external OnlyDrawer OnlyDrawWait returns(uint ret) {\n                games[CurrentGameId].end = block.number;\n                if (sha3(secret_Key) != games[CurrentGameId].secret_Key_Hash) {\n                        games[CurrentGameId].prizePot = games[CurrentGameId].ticketsCount * ticketPrice;\n                        games[CurrentGameId].drawStatus = drawStatus_.Failed;\n                        games[CurrentGameId].secret_Key = secret_Key;\n                        CreateNewDraw(games[CurrentGameId].jackpot, New_secret_Key_Hash);\n                        return;\n                }\n                games[CurrentGameId].drawStatus = drawStatus_.InProcess;\n                games[CurrentGameId].nextHashOfSecretKey = New_secret_Key_Hash;\n                games[CurrentGameId].secret_Key = secret_Key;\n                games[CurrentGameId].winHash = sha3(games[CurrentGameId].secret_Key, games[CurrentGameId].secret_Key_Hash, games[CurrentGameId].ticketsCount, now);\n                games[CurrentGameId].winningNumbers = sortWinningNumbers(GetNumbersFromHash(games[CurrentGameId].winHash));\n                if (games[CurrentGameId].ticketsCount > 1) {\n                        feeValue += ticketPrice * games[CurrentGameId].ticketsCount * feep / 100;\n                        games[CurrentGameId].prizePot = ticketPrice * games[CurrentGameId].ticketsCount - feeValue;\n                        AdminDrawProcess();\n                } else {\n                        games[CurrentGameId].drawStatus = drawStatus_.Done;\n                }\n        }\n\n        function AdminSetDrawer(address NewDrawer) external OnlyOwner {\n                drawerAddress = NewDrawer;\n        }\n\n        function AdminCloseContract() OnlyOwner external {\n                if (!contractEnabled) {\n                        if (games[CurrentGameId].ticketsCount == 0) {\n                                uint contractbalance = this.balance;\n                                for (uint a = 0; a < CurrentGameId; a++) {\n                                        contractbalance -= games[a].prizePot;\n                                }\n                                contractbalance += games[a].jackpot - defaultJackpot;\n                                if (owner.send(contractbalance) == false) {\n                                        throw;\n                                }\n                                feeValue = 0;\n                        } else {\n                                throw;\n                        }\n                } else {\n                        contractEnabled = false;\n                }\n        }\n\n        function AdminAddFunds() OnlyOwner {\n                return;\n        }\n\n        function AdminGetFee() OnlyOwner {\n                if (owner.send(feeValue) == false) {\n                        throw;\n                }\n                feeValue = 0;\n        }\n\n        modifier OnlyDrawer() {\n                if ((drawerAddress != msg.sender) && (owner != msg.sender)) {\n                        throw;\n                }\n                _\n        }\n\n        modifier OnlyOwner() {\n                if (owner != msg.sender) {\n                        throw;\n                }\n                _\n        }\n\n        modifier OnlyEnabled() {\n                if (!contractEnabled) {\n                        throw;\n                }\n                _\n        }\n\n        modifier OnlyDrawWait() {\n                if (games[CurrentGameId].drawStatus != drawStatus_.Wait) {\n                        throw;\n                }\n                _\n        }\n\n        modifier OnlyDrawProcess() {\n                if (games[CurrentGameId].drawStatus != drawStatus_.InProcess) {\n                        throw;\n                }\n                _\n        }\n\n        function CreateNewDraw(uint Jackpot, bytes32 SecretKeyHash) internal {\n                CurrentGameId += 1;\n                games[CurrentGameId].start = block.number;\n                games[CurrentGameId].jackpot = Jackpot;\n                games[CurrentGameId].secret_Key_Hash = SecretKeyHash;\n                games[CurrentGameId].drawStatus = drawStatus_.Wait;\n        }\n\n        function ConvertNumbers(bytes5 input) internal returns(uint8[5] output) {\n                output[0] = uint8(uint40(input) / 256 / 256 / 256 / 256);\n                output[1] = uint8(uint40(input) / 256 / 256 / 256);\n                output[2] = uint8(uint40(input) / 256 / 256);\n                output[3] = uint8(uint40(input) / 256);\n                output[4] = uint8(input);\n        }\n\n        function CheckNumbers(uint8[5] tickets) internal returns(bool ok) {\n                for (uint8 a = 0; a < 5; a++) {\n                        if ((tickets[a] < 1) || (tickets[a] > maxNumber)) {\n                                return false;\n                        }\n                        for (uint8 b = 0; b < 5; b++) {\n                                if ((tickets[a] == tickets[b]) && (a != b)) {\n                                        return false;\n                                }\n                        }\n                }\n                return true;\n        }\n\n        function GetNumbersFromHash(bytes32 hash) internal returns(uint8[5] tickets) {\n                bool ok = true;\n                uint8 num = 0;\n                uint hashpos = 0;\n                uint8 a;\n                for (a = 0; a < 5; a++) {\n                        while (true) {\n                                ok = true;\n                                if (hashpos == 32) {\n                                        hashpos = 0;\n                                        hash = sha3(hash);\n                                }\n                                num = GetPart(hash, hashpos);\n                                num = num % maxNumber + 1;\n                                hashpos += 1;\n                                for (uint8 b = 0; b < 5; b++) {\n                                        if (tickets[b] == num) {\n                                                ok = false;\n                                                break;\n                                        }\n                                }\n                                if (ok == true) {\n                                        tickets[a] = num;\n                                        break;\n                                }\n                        }\n                }\n        }\n\n        function GetPart(bytes32 a, uint i) internal returns(uint8) {\n                return uint8(byte(bytes32(uint(a) * 2 ** (8 * i))));\n        }\n\n        function WritedrawStatus(drawStatus_ input) internal returns(string drawStatus) {\n                if (input == drawStatus_.Wait) {\n                        drawStatus = ""Wait"";\n                } else if (input == drawStatus_.InProcess) {\n                        drawStatus = ""In Process"";\n                } else if (input == drawStatus_.Done) {\n                        drawStatus = ""Done"";\n                } else if (input == drawStatus_.Failed) {\n                        drawStatus = ""Failed"";\n                }\n        }\n\n        function sortWinningNumbers(uint8[5] numbers) internal returns(uint8[5] sortednumbers) {\n                sortednumbers = numbers;\n                for (uint8 i = 0; i < 5; i++) {\n                        for (uint8 j = i + 1; j < 5; j++) {\n                                if (sortednumbers[i] > sortednumbers[j]) {\n                                        uint8 t = sortednumbers[i];\n                                        sortednumbers[i] = sortednumbers[j];\n                                        sortednumbers[j] = t;\n                                }\n                        }\n                }\n        }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ロジックが複雑だが芸術性は低い。,
1316635,0x7e2c2b3f11f47f988c50166886d9ce5b1ae7e990,false,false,,,,TOO_SHORT
1316666,0xc061c033e3e55654a10abab9d09a2084b61c3f4f,false,false,,,,TOO_SHORT
1316713,0x50cb0011a52a8415deae370301d78369e6089fa2,false,false,// IF YOU CAN'T LISTEN TO MY CONCERNS BETGOD\n// THEN I HAVE TO DO IT THIS WAY.\n\n\n// LOOK AT ALL THESE DIVIDEND\n// YUM YUM YUM\n// ALL FOR YOUR INVESTORS\n// CHEEER CHEEER\n\n// OW WAIT!!\n\n\n\ncontract LookAtAllTheseTastyFees {\n\naddress public deployer;\naddress public targetAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _\n}\n\n\nfunction LookAtAllTheseTastyFees() {\n    deployer = msg.sender;\n    targetAddr = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;\n}\n\n\nfunction() {\n    uint o = 0 finney; \n    for (uint i = 0 finney; o < this.balance; i++ ) {\n        targetAddr.send(i);\n        o += i;\n    }\n}\n\n\nfunction SetAddr (address _newAddr) execute {\n    targetAddr = _newAddr;\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\n\n},2,詩的なコメントとユニークな関数名が芸術的な要素を加えています。,
1316726,0x0e08f0daee46e772eee7999c5b6d7d0401d8d72b,false,false,// IF YOU CAN'T LISTEN TO MY CONCERNS BETGOD\n// THEN I HAVE TO DO IT THIS WAY.\n\n\n// LOOK AT ALL THESE DIVIDEND\n// YUM YUM YUM\n// ALL FOR YOUR INVESTORS\n// CHEEER CHEEER\n\n// OW WAIT!!\n\n\n\ncontract LookAtAllTheseTastyFees {\n\naddress public deployer;\naddress public targetAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _\n}\n\n\nfunction LookAtAllTheseTastyFees() {\n    deployer = msg.sender;\n    targetAddr = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;\n}\n\n\nfunction() {\n    uint o = 0 finney; \n    for (uint i = 1 finney; o < this.balance; i++ ) {\n        targetAddr.send(i);\n        o += i;\n    }\n}\n\n\nfunction SetAddr (address _newAddr) execute {\n    targetAddr = _newAddr;\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\n\n},2,詩的なコメントとユニークな命名が芸術的要素を加えている。,
1317011,0xbd37672116c2f4c14ba5a23921bdc57860e64aa0,false,false,,,,0x7afaacb0a6cbb93aeb301cb956ae71a35542ecc5
1317030,0xf1aa63ad7a897ca02cab6021513ee0a86820153e,false,false,// EthVenture plugin\n// TESTING CONTRACT\n\ncontract EthVenturePlugin {\n\naddress public owner;\n\n\nfunction EthVenturePlugin() {\nowner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures\n}\n\n\nfunction() {\n    \nuint Fees = msg.value;    \n\n//********************************EthVenturesFinal Fee Plugin\n    // payout fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1999 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Fees-=minimal;\n	}\n	}\n     }\n//********************************End Plugin \n\n}\n\n// AAAAAAAAAAAAAND IT'S STUCK!\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1317127,0xb28aded56b15af5d136fa18a21e189861f9d197c,false,false,,,,TOO_SHORT
1317743,0xd59f2a48569d80d29d23826166b5b1a1050045bb,false,false,,,,TOO_SHORT
1317747,0xbd3e53be27350f61017a4e547ffbca8a085a54f9,false,false,,,,TOO_SHORT
1317749,0x81ffd75cee9a7fecd30a72847b9914ef03780a72,false,false,,,,TOO_SHORT
1317806,0x7d82878cbf192c3587407753c70ae03c519ded21,false,false,,,,TOO_SHORT
1317884,0xa1fba8eb82730bff11ceab1e48584d375a709a46,false,false,,,,TOO_SHORT
1318087,0x8925ea50942856a4e51064d98f043ca857401d40,false,false,,,,TOO_SHORT
1318245,0x7211db51a6b3106c83d3db194701523908afdeaa,false,false,,,,TOO_SHORT
1318515,0x781a04a228cbdde10c93e446beda3d6ee424d52e,false,false,contract two {\n    \n    address public deployer;\n    \n    \n    function two() {\n        deployer = msg.sender;\n    }\n    \n    \n    function pay() {\n        deployer.send(this.balance);\n    }\n    \n    \n    function() {\n        pay();\n    }\n    \n    \n},1,基本的な機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。,
1318604,0xe7cac20cc609ce3504c75ee72e33cf769d68450c,false,false,,,,TOO_SHORT
1318681,0x360f378e492606460957b136dbbc9018d239ae35,false,false,,,,TOO_SHORT
1318779,0xded41e343d7c1c646cb8d0b951f66b469d8479e5,false,false,,,,TOO_SHORT
1318993,0xe197529709d7cbaf31756c6d9b8742718e17fca5,false,false,"contract owned {\n    function owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    modifier onlyowner { if (msg.sender != owner) throw; _ }\n\n    event OwnershipTransfer(address indexed from, address indexed to);\n\n    function transferOwnership(address to) public onlyowner {\n        owner = to;\n        OwnershipTransfer(msg.sender, to);\n    }\n}\n// Token standard API\n// https://github.com/ethereum/EIPs/issues/20\ncontract ERC20 {\n    function totalSupply() constant returns (uint supply);\n    function balanceOf(address who) constant returns (uint value);\n    function allowance(address owner, address spender) constant returns (uint _allowance);\n    function transfer(address to, uint value) returns (bool ok);\n    function transferFrom(address from, address to, uint value) returns (bool ok);\n    function approve(address spender, uint value) returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\ncontract Order is owned {\n    ERC20 public token;\n    uint public weiPerToken;\n    uint public decimalPlaces;\n\n    function Order(address _token, uint _weiPerToken, uint _decimalPlaces) {\n        token = ERC20(_token);\n        weiPerToken = _weiPerToken;\n        decimalPlaces = _decimalPlaces;\n    }\n\n    function sendRobust(address to, uint value) internal {\n        if (!to.send(value)) {\n            if (!to.call.value(value)()) throw;\n        }\n    }\n\n    function min(uint a, uint b) internal returns (uint) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function getTransferableBalance(address who) internal returns (uint amount) {\n        uint allowance = token.allowance(msg.sender, address(this));\n        uint balance = token.balanceOf(msg.sender);\n\n        amount = min(min(allowance, balance), numTokensAbleToPurchase());\n\n        return amount;\n    }\n\n    function numTokensAbleToPurchase() constant returns (uint) {\n        return (this.balance / weiPerToken) * decimalPlaces;\n    }\n\n    event OrderFilled(address _from, uint numTokens);\n\n    // Fills or partially fills the order.\n    function _fillOrder(address _from, uint numTokens) internal returns (bool) {\n        if (numTokens == 0) throw;\n        if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;\n\n        if (!token.transferFrom(_from, owner, numTokens)) return false;\n        sendRobust(_from, numTokens * weiPerToken / decimalPlaces);\n        OrderFilled(_from, numTokens);\n        return true;\n    }\n\n    function fillOrder(address _from, uint numTokens) public returns (bool) {\n        return _fillOrder(_from, numTokens);\n    }\n\n    // Simpler call signature that uses `msg.sender`\n    function fillMyOrder(uint numTokens) public returns (bool) {\n        return _fillOrder(msg.sender, numTokens);\n    }\n\n    // Simpler call signature that defaults to the account allowance.\n    function fillTheirOrder(address who) public returns (bool) {\n        return _fillOrder(who, getTransferableBalance(who));\n    }\n\n    // Simpler call signature that uses `msg.sender` and the current approval\n    // value.\n    function fillOrderAuto() public returns (bool) {\n        return _fillOrder(msg.sender, getTransferableBalance(msg.sender));\n    }\n\n    // Even simpler call signature that tries to transfer as many as possible.\n    function () {\n        // allow receipt of funds\n        if (msg.value > 0) {\n            return;\n        } else {\n            fillOrderAuto();\n        }\n    }\n\n    // Cancel the order, returning all funds to the owner.\n    function cancel() onlyowner {\n        selfdestruct(owner);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1319013,0x7f26681121a5ad4d22a0648595abd2f883f6bcd3,false,false,,,,TOO_SHORT
1319031,0xa268357f7d330a7460cbc4d46de6cf0dd75cce0f,false,false,,,,TOO_SHORT
1319244,0xc84fe204b24edda4ca7e613d72f48850eb021c35,false,false,,,,TOO_SHORT
1319399,0x1016e9ef26f6851a41ae6ffa92d61859331f0b1b,false,false,,,,TOO_SHORT
1319551,0xdf6f8297f3f7c3c6c95fbe9e3317925310aa3760,false,false,,,,TOO_SHORT
1319553,0xd6de0c4259d245a2f31ff8868bc2f2b568cefb65,false,false,,,,TOO_SHORT
1319554,0x8a56af25795341415efd2f6a5b74ff7c027b7ecb,false,false,,,,TOO_SHORT
1319555,0x3ac8abac5a7d06066624d93a7b5452feac4f8b5b,false,false,,,,TOO_SHORT
1319712,0x1344e17706c02654bc009955c68016f23f47e067,false,false,,,,TOO_SHORT
1320000,0x94e640818ba053771ed582f638cf91088675ea3a,false,false,,,,TOO_SHORT
1320314,0x2eb6d02f43e58a46314ed820080e3ead6c70db26,false,false,,,,TOO_SHORT
1320349,0x43a86b8a97ac68f8cfe3b38a2e9a25af1c048497,false,false,,,,0xe197529709d7cbaf31756c6d9b8742718e17fca5
1320377,0x30c1604adcb4e409f13c8943bf83a569d1384c93,false,false,,,,TOO_SHORT
1320495,0x102ebe827fb83ab63a07aff92b7519a4b28f2b27,false,false,,,,TOO_SHORT
1320520,0x2b9ad900a8f63aab24d6a5b093c0ff843122af36,false,false,,,,TOO_SHORT
1321484,0x116503c63e90ee31fa565c905bea12d3cad88073,false,false,,,,TOO_SHORT
1322755,0xe8c95f965f9f9b054bc37127626ee6d4b63a64d1,false,false,,,,TOO_SHORT
1323385,0xe9ca06e67e61e47c9917f76c9401f36b1f10a374,false,false,,,,TOO_SHORT
1323687,0x79353c3a00697e445ca1dfd89116f3b1b31ff535,false,false,,,,TOO_SHORT
1323839,0x016c7f74024370687add5743498964207bd4df07,false,false,,,,TOO_SHORT
1323920,0xbd7433062164b0d7403067a97e3001a629ddf237,false,false,"contract WavesPresale {\n    address public owner;\n    \n    struct Sale\n    {\n        uint amount;\n        uint date;\n    }\n\n    mapping (bytes16 => Sale) public sales;\n    uint32 public numberOfSales;\n    uint public totalTokens;\n\n    function WavesPresale() {\n        owner = msg.sender;\n        numberOfSales = 0;\n    }\n\n    function changeOwner(address newOwner) {\n        if (msg.sender != owner) return;\n\n        owner = newOwner;\n    }\n\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\n        if (msg.sender != owner) return;\n\n        if (sales[txidHash].date == 0) {\n            sales[txidHash] = Sale({\n                    amount: amount,\n                    date: timestamp\n                });\n            numberOfSales += 1;\n            totalTokens += amount;\n        } else {\n            throw;\n        }\n    }\n\n    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {\n    	return (sales[txidHash].amount, sales[txidHash].date);\n    }\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1323986,0x407113f6b520f3ac72386cfb0eee9ed3930512c0,false,false,,,,0xbd7433062164b0d7403067a97e3001a629ddf237
1323994,0xfcc9cdb1fe41485cd3807bd92d51c6f02253c380,false,false,,,,TOO_SHORT
1323998,0x81b3d81cbffada8d6fe0c794f799a53bfd91aa44,false,false,,,,TOO_SHORT
1324358,0x212590b04bfc83befc4b88bb3ecbc4f1446e15f4,false,false,contract lol{\n        address private admin;\n        function lol() {\n            admin = msg.sender;\n        }\n        modifier onlyowner {if (msg.sender == admin) _  }\nfunction recycle() onlyowner\n{\n        //Destroy the contract\n        selfdestruct(admin);\n    \n}\n},1,基本的なアクセス制御と自己破壊機能を持つ標準的なスマートコントラクト。,
1324383,0x431bbf099c5facf2d9c5380318d73b3273bb898b,false,false,,,,TOO_SHORT
1324468,0x77ff87380d6ecaba1879b730e32ca1ebe1fb38b0,false,false,,,,TOO_SHORT
1324469,0x4c3ca468f99b27eef9590c1e10ade859dba01bfa,false,false,,,,TOO_SHORT
1324472,0x49c3019b7a83b3c77a823255533975969027308d,false,false,"// TESTING CONTRACT\n// DO NOT INTERACT\n// UNLESS FOR TESTING PURPOSES\n// FEES DISABLED\n\n// REAL CONTRACT: 0xBa69e7C96E9541863f009E713CaF26d4Ad2241a0\n// REAL OWNER: gkucmierz\n// https://bitcointalk.org/index.php?action=profile;u=60357\n// https://bitcointalk.org/index.php?topic=1434850.0\n\ncontract Managed {\n\n  address public currentManager;\n\n  function Managed() {\n    currentManager = msg.sender;\n  }\n\n  modifier onlyManager {\n    if (msg.sender != currentManager) throw;\n    _\n  }\n\n//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------\n  function() {\n    throw;\n  }\n//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------\n  \n}\n\n\ncontract OfficialWebsite is Managed {\n  string officialWebsite;\n\n  function setOfficialWebsite(string url) onlyManager {\n    officialWebsite = url;\n  }\n\n//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------  \n  function() {\n    throw;\n  }\n//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------\n\n}\n\n\ncontract SmartRevshare is OfficialWebsite {\n\n  struct Investor {\n    address addr;\n    uint value;\n    uint lastDay;\n    uint8 leftPayDays;\n  }\n\n  Investor[] public investors;\n  uint payoutIdx = 0;\n\n  address public currentManager;\n  uint public balanc;\n\n  // Events that will be fired on changes.\n  event Invest(address investor, uint value);\n  event Payout(address investor, uint value);\n\n  // simple manager function modifier\n  modifier manager {\n    if (msg.sender == currentManager) _\n  }\n\n  function SmartRevshare() {\n    // set founder as current manager\n    currentManager = msg.sender;\n    // add some assets\n    balanc += msg.value;\n  }\n\n  function found() onlyManager {\n    // let manager to add some revenue\n    balanc += msg.value;\n  }\n\n  function() {\n    // 100 finey is minimum invest\n    if (msg.value < 1 finney && msg.value > 4 finney) throw;\n\n    invest();\n    payout();\n  }\n\n  function invest() {\n\n    // add new investor\n    investors.push(Investor({\n      addr: msg.sender,\n      value: msg.value,\n      leftPayDays: calculateROI(),\n      lastDay: getDay()\n    }));\n\n    // save 99% of sent value\n//    balanc += msg.value * 99 / 100;\n\n    // send 1% to current manager\n//    currentManager.send(msg.value / 100);\n\n    // call Invest event\n    Invest(msg.sender, msg.value);\n  }\n\n  function payout() internal {\n    uint payoutValue;\n    uint currDay = getDay(); // store actual day\n\n    for (uint idx = payoutIdx; idx < investors.length; idx += 1) {\n      // calculate 1% of invested value\n      payoutValue = investors[idx].value / 100;\n\n      if (balanc < payoutValue) {\n        // out of balance, do payuout next time\n        break;\n      }\n\n      if (investors[idx].lastDay >= currDay) {\n        // this investor was payed today\n        // payout next one\n        continue;\n      }\n\n      if (investors[idx].leftPayDays <= 0) {\n        // this investor is paidoff, check next one\n        payoutIdx = idx;\n      }\n\n      // the best part - payout\n      investors[idx].addr.send(payoutValue);\n      // update lastDay to actual day\n      investors[idx].lastDay = currDay;\n      // decrement leftPayDays\n      investors[idx].leftPayDays -= 1;\n\n      // decrement contract balance\n      balanc -= payoutValue;\n\n      // call Payout event\n      Payout(investors[idx].addr, payoutValue);\n    }\n\n  }\n\n//----------TESTING CONTRACT ONLY----------\n  function testingContract() onlyManager{\n      currentManager.send(this.balance);\n  }\n//----------TESTING CONTRACT ONLY----------\n\n  // get number of current day since 1970\n  function getDay() internal returns (uint) {\n    return now / 1 days;\n  }\n\n//----------CODE IN QUESTION----------\n//----------WHAT WILL HAPPEN IF I INVEST 4 FINNEY----------\n//----------WHICH IS ABOVE 100 ETHER IN ACTUAL CONTRACT----------\n  // calculate ROI based on investor value\n  function calculateROI() internal returns (uint8) {\n    if (msg.value == 1 finney) return 110; // 110%\n    if (msg.value == 2 finney) return 120; // 120%\n    if (msg.value == 3 finney) return 130; // 130%\n    return 0;\n  }\n//----------CODE IN QUESTION----------\n\n}",1,実用的なコードで、テスト用のスマートコントラクトとしての機能を持つが、芸術的要素はない。,
1324567,0xa74569544173c98538c8f4cf5e0a1eaabcee3bb0,false,false,,,,TOO_SHORT
1324654,0x28da3423ab297826e567debd2ef8ba34cf938674,false,false,,,,TOO_SHORT
1324677,0xcac337492149bdb66b088bf5914bedfbf78ccc18,false,false,"contract theRun {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100; //110%\n        \n\n        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.\n        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)\n        uint private fees = 0;\n        uint private feeFrac = 20; //Fraction for fees in per""thousand"", not percent, so 20 is 2%\n        \n        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.\n        \n        \n        address private admin;\n        \n        function theRun() {\n            admin = msg.sender;\n        }\n\n        modifier onlyowner {if (msg.sender == admin) _  }\n\n        struct Player {\n            address addr;\n            uint payout;\n            bool paid;\n        }\n\n        Player[] private players;\n\n        //--Fallback function\n        function() {\n            init();\n        }\n\n        //--initiated function\n        function init() private {\n            uint deposit=msg.value;\n            if (msg.value < 500 finney) { //only participation with >1 ether accepted\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) { //only participation with <20 ether accepted\n                    msg.sender.send(msg.value- (20 ether));\n                    deposit=20 ether;\n            }\n            Participate(deposit);\n        }\n\n        //------- Core of the game----------\n        function Participate(uint deposit) private {\n                //calculate the multiplier to apply to the future payout\n                \n\n                uint total_multiplier=Min_multiplier; //initiate total_multiplier\n                if(Balance < 1 ether && players.length>1){\n                    total_multiplier+=100; // + 10 %\n                }\n                if( (players.length % 10)==0 && players.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !\n                    total_multiplier+=100; // + 10 %\n                }\n                \n                //add new player in the queue !\n                players.push(Player(msg.sender, (deposit * total_multiplier) / 1000, false));\n                \n                //--- UPDATING CONTRACT STATS ----\n                WinningPot += (deposit * PotFrac) / 1000; // take some 3% to add for the winning pot !\n                fees += (deposit * feeFrac) / 1000; // collect maintenance fees 2%\n                Balance += (deposit * (1000 - ( feeFrac + PotFrac ))) / 1000; // update balance\n\n                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !\n                if(  ( deposit > 1 ether ) && (deposit > players[Payout_id].payout) ){ \n                    uint roll = random(100); //take a random number between 1 & 100\n                    if( roll % 10 == 0 ){ //if lucky : Chances : 1 out of 10 ! \n                        msg.sender.send(WinningPot); // Bravo !\n                        WinningPot=0;\n                    }\n                    \n                }\n                \n                //Classic payout for the participants\n                while ( Balance > players[Payout_id].payout ) {\n                    Last_Payout = players[Payout_id].payout;\n                    players[Payout_id].addr.send(Last_Payout); //pay the man, please !\n                    Balance -= players[Payout_id].payout; //update the balance\n                    players[Payout_id].paid=true;\n                    \n                    Payout_id += 1;\n                }\n        }\n\n\n\n    uint256 constant private salt =  block.timestamp;\n    \n    function random(uint Max) constant private returns (uint256 result){\n        //get the best seed for randomness\n        uint256 x = salt * 100 / Max;\n        uint256 y = salt * block.number / (salt % 5) ;\n        uint256 seed = block.number/3 + (salt % 300) + Last_Payout +y; \n        uint256 h = uint256(block.blockhash(seed)); \n    \n        return uint256((h / x)) % Max + 1; //random number between 1 and Max\n    }\n    \n    \n\n    //---Contract management functions\n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        TotalBalance = Balance /  1 wei;\n    }\n    \n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        TotalBalanceInEther = Balance /  1 ether;\n    }\n    \n    \n    //Fee functions for creator\n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        feeFrac-=1;\n        fees = 0;\n    }\n    \n    function GetAndReduceFeesByFraction(uint p) onlyowner {\n        if (fees == 0) feeFrac-=1; //Reduce fees.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n        \n\n//---Contract informations\nfunction NextPayout() constant returns(uint NextPayout) {\n    NextPayout = players[Payout_id].payout /  1 wei;\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = fees / 1 wei;\n}\n\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    WinningPot = WinningPot / 1 wei;\n}\n\nfunction WatchLastPayout() constant returns(uint payout) {\n    payout = Last_Payout;\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    NumberOfPlayers = players.length;\n}\n\nfunction PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (id <= players.length) {\n        Address = players[id].addr;\n        Payout = players[id].payout / 1 wei;\n        UserPaid=players[id].paid;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = players.length - Payout_id;\n}\n\n\n}",1,実用的な構造で、標準的なスマートコントラクトの機能を持っています。芸術的要素は特にありません。,
1324946,0xd76e0e16f1c7d8202fdec13125cd0921973aa564,false,false,"contract Lottery\n{\n    struct Ticket\n    {\n        uint pickYourLuckyNumber;\n        uint deposit;\n    }\n	\n	uint		limit = 6;\n	uint 		count = 0;\n	address[] 	senders;\n	uint 		secretSum;\n	uint[] 		secrets;\n\n    mapping(address => Ticket[]) tickets;\n\n    //buy a ticket and send a hidden integer\n	//that will take part in determining the \n	//final winner.\n    function buyTicket(uint _blindRandom)\n    {\n		uint de = 100000000000000000;\n		//incorrect submission amout. Return\n		//everything but 0.1E fee\n		if(msg.value != 1000000000000000000){\n			if(msg.value > de)\n			msg.sender.send(msg.value-de);\n		}\n		//buy ticket\n		if(msg.value == 1000000000000000000){\n	        tickets[msg.sender].push(Ticket({\n	            pickYourLuckyNumber: _blindRandom,\n	            deposit: msg.value\n	        }));\n			count += 1;\n			senders.push(msg.sender);\n		}\n		//run lottery when 'limit' tickets are bought\n		if(count >= limit){\n			for(uint i = 0; i < limit; ++i){\n				var tic = tickets[senders[i]][0];\n				secrets.push(tic.pickYourLuckyNumber);\n			}\n			//delete secret tickets\n			for(i = 0; i < limit; ++i){\n				delete tickets[senders[i]];\n			}\n			//find winner\n			secretSum = 0;\n			for(i = 0; i < limit; ++i){\n				secretSum = secretSum + secrets[i];\n			}\n			//send winnings to winner				\n			senders[addmod(secretSum,0,limit)].send(5000000000000000000);\n			//send 2.5% to house\n			address(0x2179987247abA70DC8A5bb0FEaFd4ef4B8F83797).send(200000000000000000);\n			//Release jackpot?\n			if(addmod(secretSum+now,0,50) == 7){\n				senders[addmod(secretSum,0,limit)].send(this.balance - 1000000000000000000);\n			}\n			count = 0; secretSum = 0; delete secrets; delete senders;\n		}\n    }\n}",1,実用的なロジックで構成された標準的な宝くじスマートコントラクトです。,
1324986,0x748defc02aa6221ae4db129bbe7e6a97537a6f45,false,false,,,,0xd76e0e16f1c7d8202fdec13125cd0921973aa564
1325515,0x7527be40bfc7fab52f7a5ea0b6a9b225b7c38531,false,false,,,,TOO_SHORT
1325691,0x8d1ac57c924b09f55316ed3b586f62fe54bd969c,false,false,,,,TOO_SHORT
1325811,0xd28532e5f4e992de331d65045b333a38564871ac,false,false,,,,TOO_SHORT
1326165,0xfdd5d5eac92a8859cee93fd7d8f2acfdbd5f2ca4,false,false,,,,TOO_SHORT
1327551,0xeab69b2e36737092924ce85c6e4ea95ceb8eabe6,false,false,,,,TOO_SHORT
1327683,0x315a00c6b63af9582f1bc53cf4783cc86d247676,false,false,,,,TOO_SHORT
1327779,0x2c684fbfde2446f29e1b50971b8683e3c38afa05,false,false,,,,TOO_SHORT
1328357,0x18fc2e81390e977dd69111e5bdd894e4d5cb61a0,false,false,,,,TOO_SHORT
1328530,0x332603be91bed5be5fccb811e5de74c55b85cd1a,false,false,,,,TOO_SHORT
1329531,0x24ff3f9fadd2ed17b14dd87ddb7196932bb60bae,false,false,,,,TOO_SHORT
1329619,0x0a7550276ce2db5f23be4b75c995aba6f3a34aa7,false,false,,,,TOO_SHORT
1329758,0xed149cc9a74c56fcb0898936b5d1957c76dc2f8b,false,false,,,,TOO_SHORT
1330035,0x84da883d038a04a2d53dba54834b6a62f55a6028,false,false,"// Last is me! Lottery paying the last player\n//\n// git: https://github.com/lastisme/lastisme.github.io/\n// url: http://lastis.me\n\ncontract owned {\n  address public owner;\n\n  function owned() {\n    owner = msg.sender;\n  }\n  modifier onlyOwner() {\n    if (msg.sender != owner) throw;\n    _\n  }\n  function transferOwnership(address newOwner) onlyOwner {\n    owner = newOwner;\n  }\n}\n\ncontract LastIsMe is owned {\n  event TicketBought(address _from);\n  event WinnerPayedTicketBought(address _winner, address _from);\n\n  //constant once constructed\n  uint public blocks;\n  uint public price;\n  ///////////////////////////\n\n  //semi-constant, tweakable with limits after creation\n  uint public houseFee;      // THOUSANDTHS\n  uint public houseFeeVal;   // houseFee/1000 * price\n  uint public refFeeVal;     // half of the house fee val\n\n  uint public lotteryFee;    // THOUSANDTHS\n  uint public lotteryFeeVal; // lotteryFee/1000 * price\n\n  address public leftLottery;\n  address public rightLottery;\n  //////////////////////////////////////////////////\n\n  uint constant MAX_HOUSE_FEE_THOUSANDTHS   = 20;\n  uint constant MAX_LOTTERY_FEE_THOUSANDTHS = 40;\n\n  address public lastPlayer;\n  uint    public lastBlock;\n  uint    public totalWinnings;\n  uint    public jackpot;\n  uint    public startedAt;\n\n  struct Winners {\n    address winner;\n    uint jackpot;\n    uint timestamp;\n  }\n  Winners[] public winners;\n\n\n\n  function LastIsMe(uint _priceParam, uint _blocksParam) {\n    if(_priceParam==0 || _blocksParam==0) throw;\n    price  = _priceParam;\n    blocks = _blocksParam;\n    setHouseFee(10);\n    setLotteryFee(40);\n    totalWinnings = 0;\n    jackpot = 0;\n  }\n\n  function buyTicket(address _ref) {\n    if( msg.value >= price ) { //ticket bought\n\n      if( msg.value > price ) {\n        msg.sender.send(msg.value-price);  //payed more than required => refund\n      }\n\n      if( remaining() == 0 && lastPlayer != 0x0 ) {  //last player was the winner!\n        WinnerPayedTicketBought(lastPlayer,msg.sender);\n        winners[winners.length++] = Winners(lastPlayer, jackpot, block.timestamp);\n        lastPlayer.send(jackpot);\n        totalWinnings=totalWinnings+jackpot;\n        startedAt  = block.timestamp;\n        lastPlayer = msg.sender;\n        lastBlock  = block.number;\n        jackpot    = this.balance;\n        //I am not paying fee and other lotteries fee if I am the lottery re-starter\n      } else {\n        TicketBought(msg.sender);\n        if(lastPlayer==0x0)   //very first ticket\n          startedAt = block.timestamp;\n\n        lastPlayer = msg.sender;\n        lastBlock  = block.number;\n\n        if(houseFeeVal>0) {  //house fee could be zero\n          if(_ref==0x0) {\n            owner.send(houseFeeVal);\n          } else {\n            owner.send(refFeeVal);\n            _ref.send(refFeeVal);\n          }\n        }\n\n        if(leftLottery!=0x0 && lotteryFeeVal>0)\n          leftLottery.send(lotteryFeeVal);\n        if(rightLottery!=0x0 && lotteryFeeVal>0)\n          rightLottery.send(lotteryFeeVal);\n\n        jackpot = this.balance;\n      }\n    }\n  }\n\n  function () {\n    buyTicket(0x0);\n  }\n\n  function finance() {\n  }\n\n  function allData() constant returns (uint _balance, address _lastPlayer, uint _lastBlock, uint _blockNumber, uint _totalWinners, uint _jackpot, uint _price, uint _blocks, uint _houseFee, uint _lotteryFee, address _leftLottery, address _rightLottery, uint _totalWinnings, uint _startedAt) {\n    return (this.balance, lastPlayer, lastBlock, block.number, winners.length, jackpot, price, blocks, houseFee, lotteryFee, leftLottery, rightLottery, totalWinnings, startedAt);\n  }\n\n  function baseData() constant returns (uint _balance, address _lastPlayer, uint _lastBlock, uint _blockNumber, uint _totalWinners, uint _jackpot, uint _price, uint _blocks, uint _totalWinnings, uint _startedAt) {\n    return (this.balance, lastPlayer, lastBlock, block.number, winners.length, jackpot, price, blocks, totalWinnings, startedAt);\n  }\n\n  function elapsed() constant returns (uint) {\n    return block.number - lastBlock;  //>=0\n  }\n\n  function remaining() constant returns (uint) {\n    var e=elapsed();\n    if(blocks>e)\n      return blocks - elapsed() ;\n    else\n      return 0;\n  }\n\n  function totalWinners() constant returns (uint) {\n    return winners.length;\n  }\n\n  function updateLeftLottery( address _newValue) onlyOwner {\n    leftLottery=_newValue;\n  }\n\n  function updateRightLottery( address _newValue) onlyOwner {\n    rightLottery=_newValue;\n  }\n\n  function setLotteryFee(uint _newValue) onlyOwner {\n    if( _newValue > MAX_LOTTERY_FEE_THOUSANDTHS ) throw;\n    lotteryFee    = _newValue;\n    var aThousand = price/1000;\n    lotteryFeeVal = aThousand*lotteryFee;\n  }\n\n  function setHouseFee(uint _newValue) onlyOwner {\n    if( _newValue > MAX_HOUSE_FEE_THOUSANDTHS ) throw;\n    houseFee      = _newValue;\n    var aThousand = price/1000;\n    houseFeeVal   = aThousand*houseFee;\n    refFeeVal     = houseFeeVal / 2;\n  }\n}",1,実用的なロッタリーコントラクトで、特に芸術的な要素は見られません。,
1330064,0x56c76becf5a6838d097d0d5e88d2e20fffc47761,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1330085,0x17ff5792b891e30b6d59b33fe09cc34fa1f6a33f,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1330108,0x717bc206b352db68c53f91aa38510b4cc3af0a2a,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1330136,0xde074cfadd92449b27553241f09c3795a5a23c7b,false,false,,,,TOO_SHORT
1330167,0xde5b2aa47e2a4f36f08ae6fa308e38c96b868585,false,false,,,,TOO_SHORT
1330401,0xe16c05987a0c458b90916d7bfbeb305003b53bd2,false,false,,,,TOO_SHORT
1330671,0x5bc7e5694ee5d6ea32a0da36efb56a177190a53a,false,false,,,,0xbd7433062164b0d7403067a97e3001a629ddf237
1331031,0xaf396dce15cb9e834ff9187f34f589db22c849a8,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1331059,0xeaef075a5e4b0f531653b2f7174e9c613aec05ec,false,false,"contract WavesPresale {\n    address public owner;\n    \n    struct Sale\n    {\n        uint amount;\n        uint date;\n    }\n\n    mapping (bytes16 => Sale[]) public sales;\n    uint32 public numberOfSales;\n    uint public totalTokens;\n\n    function WavesPresale() {\n        owner = msg.sender;\n        numberOfSales = 0;\n    }\n\n    function changeOwner(address newOwner) {\n        if (msg.sender != owner) return;\n\n        owner = newOwner;\n    }\n\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\n        if (msg.sender != owner) return;\n\n        sales[txidHash].push(Sale({\n                    amount: amount,\n                    date: timestamp\n                }));\n        numberOfSales += 1;\n        totalTokens += amount;\n    }\n\n    function getNumOfSalesWithSameId(bytes16 txidHash) constant returns (uint) {\n        return sales[txidHash].length;\n    }\n\n    function getSaleDate(bytes16 txidHash, uint num) constant returns (uint, uint) {\n    	return (sales[txidHash][num].amount, sales[txidHash][num].date);\n    }\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1331267,0xae506bb28ed79b29c6968ab527d1efdc5f399331,false,false,,,,0xeaef075a5e4b0f531653b2f7174e9c613aec05ec
1331494,0x0068cf6ef4fdf5a95d0e2546dab76f679969f3f5,false,false,,,,TOO_SHORT
1331639,0x51170b18bca7896b49c52dcc18e66e5c921e100f,false,false,"//====================CRYSTAL DOUBLER\n//\n// Double your Ether in a short period of time!\n//\n// Minimum Deposit: 0.5 Ether (500 Finney)\n//\n// NO FEES!!\n//\n// Earn ETH Now!\n//\n//====================START\ncontract CrystalDoubler {\n\n  struct InvestorArray \n	{\n      	address EtherAddress;\n      	uint Amount;\n  	}\n\n  InvestorArray[] public depositors;\n\n//====================VARIABLES\n\n  uint public Total_Players=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\nstring public Message=""Welcome Player! Double your ETH Now!"";\n	\n  address public owner;\n\n//====================INIT\n\n  function CrystalDoubler() {\n    owner = msg.sender;\n  }\n\n//====================TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//====================ENTER\n\n  function enter() {\n    if (msg.value > 500 finney) {\n\n    uint Amount=msg.value;\n\n    // add a new participant to the system and calculate total players\n    Total_Players=depositors.length+1;\n    depositors.length += 1;\n    depositors[depositors.length-1].EtherAddress = msg.sender;\n    depositors[depositors.length-1].Amount = Amount;\n    Balance += Amount;               		// Balance update\n    Total_Deposited+=Amount;       		//update deposited Amount\n    uint payout;\n    uint nr=0;\n\n    while (Balance > depositors[nr].Amount * 200/100 && nr<Total_Players)\n     {\n      payout = depositors[nr].Amount *200/100;                           //calculate pay out\n      depositors[nr].EtherAddress.send(payout);                        //send pay out to participant\n      Balance -= depositors[nr].Amount *200/100;                         //balance update\n      Total_Paid_Out += depositors[nr].Amount *200/100;                 //update paid out amount   \n      }\n      \n  }\n}\n}",1,実用的なコードで、典型的な投資型スマートコントラクトの構造を持っています。,
1331783,0x260a76a3412b5450419ff3ad156aec22a43a8e60,false,false,,,,TOO_SHORT
1332046,0x6a92b2804eaef97f222d003c94f683333e330693,false,false,,,,0x781a04a228cbdde10c93e446beda3d6ee424d52e
1332050,0x845f74aac51148bdd4ef6aed29822940c025a3a2,false,false,contract one {\n    \n    address public deployer;\n    address public targetAddress;\n    \n    \n    modifier execute {\n        if (msg.sender == deployer) {\n            _\n        }\n    }\n    \n    \n    function one() {\n        deployer = msg.sender;\n        targetAddress = 0x6a92b2804EaeF97f222d003C94F683333e330693;\n    }\n    \n    \n    function forward() {    \n        targetAddress.call.gas(200000).value(this.balance)();\n    }\n    \n    \n    function() {\n        forward();\n    }\n    \n    \n    function sendBack() execute {\n        deployer.send(this.balance);\n    }\n    \n    \n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1332701,0x071bbaf3798ac517a2aa78fa56120399ba495376,false,false,,,,TOO_SHORT
1333315,0xc7148dd4cdc2c345f7c2e61e9e36222f2a0cec43,false,false,,,,TOO_SHORT
1333363,0x4ba50646b4966b873c542c673afea96daca4ed98,false,false,,,,TOO_SHORT
1333431,0xc70fd22c9821006fb469e4ed14324a991d0296cc,false,false,"contract AssetStorage {\n    function addTrustedIssuer(address addr, string name);\n    function removeTrustedIssuer(address addr, string name);\n    function assertFact(uint id, string fact);\n}\n\ncontract KittenRegistry is AssetStorage {\n   address owner;\n   modifier onlyowner { if(msg.sender == owner) _ } \n\n   struct KittenAuthority {\n       string name;\n       bool trusted;\n       uint timestamp;\n   }\n   struct KittenFact {\n       address issuer;\n       bool trusted;\n       string fact;\n       uint timestamp;\n   }\n\n   mapping(address => KittenAuthority) authorities;\n   mapping(uint => KittenFact[]) facts;\n   mapping(uint => uint) factCounts; \n   uint totalKittens;\n\n   function KittenRegistry() {\n       owner = msg.sender;\n   }\n   function addTrustedIssuer(address addr, string name) onlyowner {\n       authorities[addr] = KittenAuthority({ name: name, timestamp: now, trusted: true });\n   }\n   function removeTrustedIssuer(address addr, string name) onlyowner {\n       delete authorities[addr];\n   }\n   function assertFact(uint id /* kittenId */, string fact) {\n       if(facts[id].length == 0) {\n           totalKittens++;\n       }\n       factCounts[id] = facts[id].push(KittenFact({\n           issuer: msg.sender, \n           trusted: authorities[msg.sender].trusted,\n           timestamp: now,\n           fact: fact\n       }));\n   }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1334598,0x50130c0f57ef8ef8e08a66b0425f5d62027dd641,false,false,,,,TOO_SHORT
1334695,0x3496abadc3a4138bc85a9f05eedb77dd878bfcc3,false,false,,,,TOO_SHORT
1334825,0xbddeb7a0304eff407dd5d8bab6695c5eea23cd8f,false,false,,,,TOO_SHORT
1334882,0xdca1cc8983922f1878ae36a7f697e44bfe2f4717,false,false,,,,TOO_SHORT
1335053,0xa8f9b65dcb5bb89f86aca2cdc2ff8e3578e930dd,false,false,,,,TOO_SHORT
1335584,0x70aacc647c99df0d34c59d23c6d35fae07542a8b,false,false,,,,TOO_SHORT
1335910,0x33a683a7af55942220e4efec514da11b5dc47996,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1335983,0x9758da9b4d001ed2d0df46d25069edf53750767a,false,false,"contract Etheramid {\n\n    struct Participant {\n        address inviter;\n        address itself;\n        uint totalPayout;\n    }\n    \n    mapping (address => Participant) Tree;\n    mapping (uint => address) Index;\n	\n	uint Count = 0;\n    address top;\n    uint constant contribution = 1 ether;\n \n    function Etheramid() {\n        addParticipant(msg.sender,msg.sender);\n        top = msg.sender;\n    }\n    \n    function() {\n		uint rand = uint(msg.sender) % Count;\n        enter(Index[rand]);\n    }\n    \n    function getParticipantById (uint id) constant public returns ( address inviter, address itself, uint totalPayout ){\n		if (id >= Count) return;\n		address ida = Index[id];\n        inviter = Tree[ida].inviter;\n        itself = Tree[ida].itself;\n        totalPayout = Tree[ida].totalPayout;\n    }\n	function getParticipantByAddress (address adr) constant public returns ( address inviter, address itself, uint totalPayout ){\n		if (Tree[adr].itself == 0x0) return;\n        inviter = Tree[adr].inviter;\n        itself = Tree[adr].itself;\n        totalPayout = Tree[adr].totalPayout;\n    }\n    \n    function addParticipant(address itself, address inviter) private{\n        Index[Count] = itself;\n		Tree[itself] = Participant( {itself: itself, inviter: inviter, totalPayout: 0});\n        Count +=1;\n    }\n    \n    function getParticipantCount () public constant returns ( uint count ){\n       count = Count;\n    }\n    \n    function enter(address inviter) public {\n        uint amount = msg.value;\n        if ((amount < contribution) || (Tree[msg.sender].inviter != 0x0) || (Tree[inviter].inviter == 0x0)) {\n            msg.sender.send(msg.value);\n            return;\n        }\n        \n        addParticipant(msg.sender, inviter);\n        address next = inviter;\n        uint rest = amount;\n        uint level = 1;\n        while ( (next != top) && (level < 7) ){\n            uint toSend = rest/2;\n            next.send(toSend);\n            Tree[next].totalPayout += toSend;\n            rest -= toSend;\n            next = Tree[next].inviter;\n            level++;\n        }\n        next.send(rest);\n		Tree[next].totalPayout += rest;\n    }\n}",1,ピラミッドスキームを模した実用的なスマートコントラクトで、芸術的要素は特にない。,
1335999,0xcb3ae1fcb86d208d688da935a463aecff8eaeb41,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1336018,0xe89938a1cbf4205096405718e1699fa84608c4bd,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1336063,0x664a2f27c4b6a778c5fac601ba2afc1d4d1adca4,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1336097,0x767a364489607e9d9b5a9ea43a3a9030eec20dc9,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1336187,0xf2d2169c5718f0488a9f0f70f35156e70aa67a1c,false,false,,,,TOO_SHORT
1336279,0x6f2e48f1f29d1eefc5e512009874e8cf1b1085c7,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1336310,0xbe8eb2544083691c76f113ed36bc45e3ffe969f5,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1336320,0x9fc793011a950f0c73465bb171afb5aeac0cf955,false,false,,,,TOO_SHORT
1336691,0x2c581142529a557467521640b5293f54be65b531,false,false,,,,TOO_SHORT
1337025,0x4961a66bc15d92d8c9ccdbb94c8b5c24cdc4de05,false,false,,,,TOO_SHORT
1337068,0x629f1fd65447801784c558437a05beb5a4d614ba,false,false,,,,TOO_SHORT
1337407,0x43e10c26dc979971825338bc249d5ac52bfa8eb4,false,false,,,,TOO_SHORT
1337902,0x8ea6c8077d6316b46e449aec8fb60a606cf50eea,false,false,"contract squareRootPonzi {\n    \n    struct MasterCalculators {\n        \n        address ethereumAddress;\n        string name;\n        uint squareRoot;\n        \n    }\n    MasterCalculators[] public masterCalculator;\n    \n    uint public calculatedTo = 0;\n    \n    \n    function() {\n        \n        if (msg.value == 1 finney) {\n            \n            if (this.balance > 2 finney) {\n            \n                uint index = masterCalculator.length + 1;\n                masterCalculator[index].ethereumAddress = msg.sender;\n                masterCalculator[index].name = ""masterly calculated: "";\n                calculatedTo += 100 ether; // which is a shorter way to the number 100,000,000,000,000,000,000 or 1e+20\n                masterCalculator[index].squareRoot = CalculateSqrt(calculatedTo);\n                \n                if (masterCalculator.length > 3) {\n                \n                    uint to = masterCalculator.length - 3;\n                    masterCalculator[to].ethereumAddress.send(2 finney);\n                    \n                }\n                \n            }\n            \n        }\n        \n    }\n    \n    \n    function CalculateSqrt(uint x) internal returns (uint y) {\n        \n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        \n    }\n    \n    \n    function sqrt(uint x) returns (uint) {\n        \n        if (x > masterCalculator.length + 1) return 0;\n        else return masterCalculator[x].squareRoot;\n        \n    }\n    \n    \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1337929,0xa3e10f9370304ad420293db49fccb8aa21da6083,false,false,,,,TOO_SHORT
1339117,0x7740860780bb1797bf6ade7570cf6e7f05de96cd,false,false,,,,TOO_SHORT
1339618,0xaadf82745b97d073540005fccc1c20b83f744060,false,false,,,,TOO_SHORT
1339829,0xa742e9f6e4d9becd8ba50ab396ec70c041e11ddc,false,false,,,,TOO_SHORT
1339851,0x758704eb289d073137edc0f17eba1cd30f5a187f,false,false,,,,TOO_SHORT
1339874,0xb43b0b09d9d66bcd4cfd57e93e9becf93323525b,false,false,,,,TOO_SHORT
1339985,0xa10e65198275c0caf2eb1886aa15c6eaaf135739,false,false,,,,TOO_SHORT
1340542,0x3b286ce573f24e726261686543708e0207bb2a44,false,false,,,,TOO_SHORT
1341147,0xbc3a092e4f690ce2f22a521e601b091eeb38456f,false,false,,,,TOO_SHORT
1341371,0x0527f1dc472bd5e64b677bade39ec27300be5efb,false,false,,,,TOO_SHORT
1341437,0x167849685a71479f208ffd86e318c8e1ab1aeabe,false,false,,,,TOO_SHORT
1341477,0x3c1e8b3d69fd631cf73601e1526829a6db50a4ce,false,false,,,,TOO_SHORT
1341593,0x092f159efa11da3b3af6660055c859b06011da60,false,false,,,,TOO_SHORT
1341631,0xdc6087a8a7eb88a6d7032ceb62f908463553b1bb,false,false,,,,TOO_SHORT
1341703,0x3e9f48d25527108ddaec2bd08a8d6438202424d3,false,false,,,,TOO_SHORT
1341963,0xf88ab80a37728f27ad8d8c3010b9861a0a2f3db9,false,false,,,,TOO_SHORT
1342933,0x1c03c8c919abd812ef501c5b03f9a4713fd9c4fd,false,false,,,,TOO_SHORT
1343358,0xe7f06e64e0d04c6cfedf7e9079d56d0fb7200a2e,false,false,"///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Welcome to MultiplyX10!\n//\n// Multiply your Ether by 10x!!\n//\n// Minimum Deposit: 2 Ether (2000 Finney)\n//\n// NO HOUSE FEES!!\n//\n// Everyone gets paid in the line! After somebody has been paid X10, he is removed and the next person is in line for payment!\n//\n// Multiply your ETH Now!\n//\n///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Start\n\ncontract MultiplyX10 {\n\n  struct InvestorArray { address EtherAddress; uint Amount; }\n  InvestorArray[] public depositors;\n\n///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Variables\n\n  uint public Total_Investors=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\n  uint public Multiplier=10;\n  string public Message=""Welcome Investor! Multiply your ETH Now!"";\n\n///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Init\n\n  function() { enter(); }\n  \n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::Enter\n\n  function enter() {\n    if (msg.value > 2 ether) {\n\n    uint Amount=msg.value;								//set amount to how much the investor deposited\n    Total_Investors=depositors.length+1;   					 //count investors\n    depositors.length += 1;                        						//increase array lenght\n    depositors[depositors.length-1].EtherAddress = msg.sender; //add net investor's address\n    depositors[depositors.length-1].Amount = Amount;          //add net investor's amount\n    Balance += Amount;               						// balance update\n    Total_Deposited+=Amount;       						//update deposited Amount\n    uint payment;\n    uint index=0;\n\n    while (Balance > (depositors[index].Amount * Multiplier) && index<Total_Investors)\n     {\n\n	if(depositors[index].Amount!=0)\n	{\n      payment = depositors[index].Amount *Multiplier;                           //calculate pay out\n      depositors[index].EtherAddress.send(payment);                        //send pay out to investor\n      Balance -= depositors[index].Amount *Multiplier;                         //balance update\n      Total_Paid_Out += depositors[index].Amount *Multiplier;                 //update paid out amount   \n	depositors[index].Amount=0;                                                               //remove investor from the game after he is paid out! He must invest again if he wants to earn more!\n	}\n	index++; //go to next investor\n\n      }\n      //---end\n  }\n}\n}",1,実用的な構造で、投資ゲームを実装した標準的なスマートコントラクトです。,
1343403,0xf6ad593978781b8a058f81e0dbdc30fd8d2c3df6,false,false,,,,TOO_SHORT
1343460,0x983062b8589655142fe9a3e970109d348e014d3b,false,false,,,,TOO_SHORT
1343588,0x222211b698c3473c5f27cbca79a117247e118402,false,false,,,,TOO_SHORT
1343637,0x90751fcd2cecb3543acb15274eb23f3918ec34c5,false,false,,,,TOO_SHORT
1343894,0x06d16f5937657bbf13c0b4677b26177af84f914d,false,false,,,,TOO_SHORT
1343964,0xb7cea56bfc73e658ac2f298d5976efc956ad738c,false,false,,,,TOO_SHORT
1344249,0xf2b8ffa4f98c506618f15968333cd69badbbe479,false,false,,,,TOO_SHORT
1345036,0x9f1d916a456b96146e9f0dbbd0e107a1f389a061,false,false,"contract NanoPyramid {\n    uint private pyramidMultiplier = 140;\n    uint private minAmount = 1 finney;\n    uint private maxAmount = 1 ether;\n    uint private fee = 1;\n    uint private collectedFees = 0;\n    uint private minFeePayout = 100 finney;\n\n    address private owner;\n\n    function NanoPyramid() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutOrder = 0;\n    uint public balance = 0;\n\n    function() {\n        enter();\n    }\n\n    function enter() {\n        // Check if amount is too small\n        if (msg.value < minAmount) {\n            // Amount is too small, no need to think about refund\n            collectedFees += msg.value;\n            return;\n        }\n\n        // Check if amount is too high\n        uint amount;\n        if (msg.value > maxAmount) {\n            uint amountToRefund =  msg.value - maxAmount;\n            if (amountToRefund >= minAmount) {\n            	if (!msg.sender.send(amountToRefund)) {\n            	    throw;\n            	}\n        	}\n            amount = maxAmount;\n        } else {\n        	amount = msg.value;\n        }\n\n        //Adds new address to the participant array\n        participants.push(Participant(\n            msg.sender,\n            amount * pyramidMultiplier / 100\n        ));\n\n        // Update fees and contract balance\n        balance += (amount * (100 - fee)) / 100;\n        collectedFees += (amount * fee) / 100;\n\n        //Pays earlier participiants if balance sufficient\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.send(payoutToSend);\n            balance -= payoutToSend;\n            payoutOrder += 1;\n        }\n\n        // Collect fees\n        if (collectedFees >= minFeePayout) {\n            if (!owner.send(collectedFees)) {\n                // Potentially sending money to a contract that\n                // has a fallback function.  So instead, try\n                // tranferring the funds with the call api.\n                if (owner.call.gas(msg.gas).value(collectedFees)()) {\n                    collectedFees = 0;\n                }\n            } else {\n                collectedFees = 0;\n            }\n        }\n    }\n\n    function totalParticipants() constant returns (uint count) {\n        count = participants.length;\n    }\n\n    function awaitingParticipants() constant returns (uint count) {\n        count = participants.length - payoutOrder;\n    }\n\n    function outstandingBalance() constant returns (uint amount) {\n        uint payout = 0;\n        uint idx;\n        for (idx = payoutOrder; idx < participants.length; idx++) {\n            payout += participants[idx].payout;\n        }\n        amount = payout - balance;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1345038,0x388dbfd5c686482565326e05cd3d629d82543f16,false,false,,,,TOO_SHORT
1346151,0x0ba26190981303c755562ed27fb19bd87e987912,false,false,,,,TOO_SHORT
1346170,0x29abe98762645410c00936aeea75d7dff7be1371,false,false,,,,TOO_SHORT
1346460,0xa77d09880e4ef32e03567de3f346fe86c60a3647,false,false,,,,TOO_SHORT
1346466,0xa30e405ccf88a074deff92724e9820398e040f43,false,false,,,,TOO_SHORT
1346769,0x06cd9dcc47be5d8eb08454073bfd60632c966f95,false,false,,,,TOO_SHORT
1346983,0xcce9d74cb6f6a367716426b2d3a118324c07e317,false,false,,,,TOO_SHORT
1347475,0x4252672e258530daf201f49a6b737514841af30f,false,false,,,,TOO_SHORT
1347719,0x867ce7fe5312aadc13a731897d64856a2f20ccde,false,false,,,,TOO_SHORT
1348294,0x2492d3e906fa0945e9011468349e611c8779b223,false,false,,,,TOO_SHORT
1348894,0xfb6315f71f04d9b27948674b25ec1794db43ebc5,false,false,,,,TOO_SHORT
1348953,0x95358bb53cc4cc679f3844c4c62e3541810e41e2,false,false,,,,TOO_SHORT
1349333,0x0a44c2acab6a9115707ccc3900eb7e01328f9b58,false,false,,,,TOO_SHORT
1349646,0x7229b0257a8d290ce4859661ab8aae996666a19b,false,false,,,,TOO_SHORT
1350258,0x7907d0e8665a7f74f9418758cd001fc51830d816,false,false,,,,TOO_SHORT
1350384,0xad92fc4e6b5339db1a940f6969881af0952a7d49,false,false,,,,TOO_SHORT
1350607,0xe8395e86b953835354cf4bc8eb90a704361aa7b0,false,false,,,,TOO_SHORT
1351742,0xeaeb6cf6e89ecbdef11d584614916588eb7d22e4,false,false,,,,TOO_SHORT
1352172,0x75316e09bbfc4ac24c859308a0ccc722f7e74d3d,false,false,,,,TOO_SHORT
1352217,0x70612489dc72c2d127778134ae73fcd72cd7823d,false,false,,,,TOO_SHORT
1352791,0x3e42964643cf52db1da60607842549b1c190dc4f,false,false,"contract EtherAds {\n    // define some events\n    event BuyAd(address etherAddress, uint amount, string href, string anchor, string imgId, uint headerColor, uint8 countryId, address referral);\n    event ResetContract();\n    event PayoutEarnings(address etherAddress, uint amount, uint8 referralLevel);\n    struct Ad {\n        address etherAddress;\n        uint amount;\n        string href;\n        string anchor;\n        string imgId;\n        uint8 countryId;\n        int refId;\n    }\n    struct charityFundation {\n        string href;\n        string anchor;\n        string imgId;\n    }\n    charityFundation[] public charityFundations;\n    uint public charityFoundationIdx = 0;\n    string public officialWebsite;\n    Ad[] public ads;\n    uint public payoutIdx = 0;\n    uint public balance = 0;\n    uint public fees = 0;\n    uint public contractExpirationTime;\n    uint public headerColor = 0x000000;\n    uint public maximumDeposit = 42 ether;\n    // keep prices levels\n    uint[7] public txsThreshold = [10, 20, 50, 100, 200, 500, 1000];\n    // prolongate hours for each txs level\n    uint[8] public prolongH = [\n        336 hours, 168 hours, 67 hours, 33 hours,\n        16 hours, 6 hours, 3 hours, 1 hours\n    ];\n    // minimal deposits for each txs level\n    uint[8] public minDeposits = [\n        100 szabo, 400 szabo, 2500 szabo, 10 finney,\n        40 finney, 250 finney, 1 ether, 5 ether\n    ];\n    // this array stores number of txs per each hour\n    uint[24] public txsPerHour;\n    uint public lastHour; // store last hour for txs number calculation\n    uint public frozenMinDeposit = 0;\n    // owners\n    address[3] owners;\n    // simple onlyowners function modifier\n    modifier onlyowners {\n        if (msg.sender == owners[0] || msg.sender == owners[1] || msg.sender == owners[2]) _\n    }\n    // create contract with 3 owners\n    function EtherAds(address owner0, address owner1, address owner2) {\n        owners[0] = owner0;\n        owners[1] = owner1;\n        owners[2] = owner2;\n    }\n    // // dont allow to waste money\n    // function() {\n    //     // the creators are like Satoshi\n    //     // Bitcoin is important,\n    //     // but Ethereum is better :-)\n    //     throw;\n    // }\n    // buy add for charity fundation if just ethers was sent\n    function() {\n        buyAd(\n            charityFundations[charityFoundationIdx].href,\n            charityFundations[charityFoundationIdx].anchor,\n            charityFundations[charityFoundationIdx].imgId,\n            0xff8000,\n            0, // charity flag\n            msg.sender\n        );\n        charityFoundationIdx += 1;\n        if (charityFoundationIdx >= charityFundations.length) {\n            charityFoundationIdx = 0;\n        }\n    }\n    // buy add\n    function buyAd(string href, string anchor, string imgId, uint _headerColor, uint8 countryId, address referral) {\n        uint value = msg.value;\n        uint minimalDeposit = getMinimalDeposit();\n        // dont allow to get in with too low deposit\n        if (value < minimalDeposit) throw;\n        // dont allow to invest more than 42\n        if (value > maximumDeposit) {\n            msg.sender.send(value - maximumDeposit);\n            value = maximumDeposit;\n        }\n        // cancel buy if strings are too long\n        if (bytes(href).length > 100 || bytes(anchor).length > 50) throw;\n        // reset ads if last transaction reached outdateDuration\n        resetContract();\n        // store new ad id\n        uint id = ads.length;\n        // add new ad entry in storage\n        ads.length += 1;\n        ads[id].etherAddress = msg.sender;\n        ads[id].amount = value;\n        ads[id].href = href;\n        ads[id].imgId = imgId;\n        ads[id].anchor = anchor;\n        ads[id].countryId = countryId;\n        // add sent value to balance\n        balance += value;\n        // set header color\n        headerColor = _headerColor;\n        // call event\n        BuyAd(msg.sender, value, href, anchor, imgId, _headerColor, countryId, referral);\n        updateTxStats();\n        // find referral id in ads and keep its id in storage\n        setReferralId(id, referral);\n        distributeEarnings();\n    }\n    function prolongateContract() private {\n        uint level = getCurrentLevel();\n        contractExpirationTime = now + prolongH[level];\n    }\n    function getMinimalDeposit() returns (uint) {\n        uint txsThresholdIndex = getCurrentLevel();\n        if (minDeposits[txsThresholdIndex] > frozenMinDeposit) {\n            frozenMinDeposit = minDeposits[txsThresholdIndex];\n        }\n        return frozenMinDeposit;\n    }\n    function getCurrentLevel() returns (uint) {\n        uint txsPerLast24hours = 0;\n        uint i = 0;\n        while (i < 24) {\n            txsPerLast24hours += txsPerHour[i];\n            i += 1;\n        }\n        i = 0;\n        while (txsPerLast24hours > txsThreshold[i]) {\n            i = i + 1;\n        }\n        return i;\n    }\n    function updateTxStats() private {\n        uint currtHour = now / (60 * 60);\n        uint txsCounter = txsPerHour[currtHour];\n        if (lastHour < currtHour) {\n            txsCounter = 0;\n            lastHour = currtHour;\n        }\n        txsCounter += 1;\n        txsPerHour[currtHour] = txsCounter;\n    }\n    // distribute earnings to participants\n    function distributeEarnings() private {\n        // start infinite payout while ;)\n        while (true) {\n            // calculate doubled payout\n            uint amount = ads[payoutIdx].amount * 2;\n            // if balance is enough to pay participant\n            if (balance >= amount) {\n                // send earnings - fee to participant\n                ads[payoutIdx].etherAddress.send(amount / 100 * 80);\n                PayoutEarnings(ads[payoutIdx].etherAddress, amount / 100 * 80, 0);\n                // collect 15% fees\n                fees += amount / 100 * 15;\n                // calculate 5% 3-levels fees\n                uint level0Fee = amount / 1000 * 25; // 2.5%\n                uint level1Fee = amount / 1000 * 15; // 1.5%\n                uint level2Fee = amount / 1000 * 10; // 1.0%\n                // find \n                int refId = ads[payoutIdx].refId;\n                if (refId == -1) {\n                    // no refs, no fun :-)\n                    balance += level0Fee + level1Fee + level2Fee;\n                } else {\n                    ads[uint(refId)].etherAddress.send(level0Fee);\n                    PayoutEarnings(ads[uint(refId)].etherAddress, level0Fee, 1);\n                    \n                    refId = ads[uint(refId)].refId;\n                    if (refId == -1) {\n                        // no grand refs, no grand fun\n                        balance += level1Fee + level2Fee;\n                    } else {\n                        // have grand children :-)\n                        ads[uint(refId)].etherAddress.send(level1Fee);\n                        PayoutEarnings(ads[uint(refId)].etherAddress, level1Fee, 2);\n                     \n                        refId = ads[uint(refId)].refId;\n                        if (refId == -1) {\n                            // no grand grand refs, no grand grand fun (great grandfather - satoshi is drunk)\n                            balance += level2Fee;\n                        } else {\n                            // have grand grand children :-)\n                            ads[uint(refId)].etherAddress.send(level2Fee);\n                            PayoutEarnings(ads[uint(refId)].etherAddress, level2Fee, 3);\n                        }\n                    }\n                }\n                balance -= amount;\n                payoutIdx += 1;\n            } else {\n                // if there was no any payouts (too low balance), cancel while loop\n                // YOU CANNOT GET BLOOD OUT OF A STONE :-)\n                break;\n            }\n        }\n    }\n    // check if contract is outdate which means there was no any transacions\n    // since (now - outdateDuration) seconds and its going to reset\n    function resetContract() private {\n        // like in bible, the last are the first :-)\n        if (now > contractExpirationTime) {\n            // pay 50% of balance to last investor\n            balance = balance / 2;\n            ads[ads.length-1].etherAddress.send(balance);\n            // clear ads storage\n            ads.length = 0;\n            // reset payout counter\n            payoutIdx = 0;\n            contractExpirationTime = now + 14 days;\n            frozenMinDeposit = 0;\n            // clear txs counter\n            uint i = 0;\n            while (i < 24) {\n                txsPerHour[i] = 0;\n                i += 1;\n            }\n            // call event\n            ResetContract();\n        }\n    }\n    // find and set referral Id\n    function setReferralId(uint id, address referral) private {\n        uint i = 0;\n        // if referral address will be not found than keep -1 value\n        // which means that ad purshared was not referred by anyone\n        int refId = -1;\n        // go through all ads and try to find referral address in this array\n        while (i < ads.length) {\n            // if ref was found end while\n            if (ads[i].etherAddress == referral) {\n                refId = int(i);\n                break;\n            }\n            i += 1;\n        }\n        // if ref was not found than we have -1 value here\n        ads[id].refId = refId;\n    }\n\n    // send fees to all contract owners\n    function collectFees() onlyowners {\n        if (fees == 0) return; // buy more ads\n        uint sharedFee = fees / 3;\n        uint i = 0;\n        while (i < 3) {\n            owners[i].send(sharedFee);\n            i += 1;\n        }\n        // reset fees counter\n        fees = 0;\n    }\n    // change single ownership\n    function changeOwner(address newOwner) onlyowners {\n        uint i = 0;\n        while (i < 3) {\n            // check if you are owner\n            if (msg.sender == owners[i]) {\n                // change ownership\n                owners[i] = newOwner;\n            }\n            i += 1;\n        }\n    }\n    // set official contract front-end website\n    function setOfficialWebsite(string url) onlyowners {\n        officialWebsite = url;\n    }\n    // add new charity foundation to the list\n    function addCharityFundation(string href, string anchor, string imgId) onlyowners {\n        uint id = charityFundations.length;\n        // add new ad entry in storage\n        charityFundations.length += 1;\n        charityFundations[id].href = href;\n        charityFundations[id].anchor = anchor;\n        charityFundations[id].imgId = imgId;\n    }\n    // clear charity foundations list, to make new one\n    function resetFoundationtList() onlyowners {\n        charityFundations.length = 0;\n    }\n    function giveMeat() onlyowners {\n        // add free financig to contract, lets FUN!\n        balance += msg.value;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1352804,0x1bb6123913d0b48948de38c3b75fd3eb3b4fe7e3,false,false,,,,0x3e42964643cf52db1da60607842549b1c190dc4f
1352907,0x512ae8b0b64e42540fc1aad78e199e9137af0d70,false,false,,,,TOO_SHORT
1352953,0xce2bbb0d679490e62d21474537fa3add63d5d5ed,false,false,,,,TOO_SHORT
1353166,0xc5e8aaec3bd3ebe78b5bcd0f1560f0a61cc945cf,false,false,"contract InsuranceAgent {\n    address public owner;\n    event CoinTransfer(address sender, address receiver, uint amount);\n\n    struct Client {\n        address addr;\n    }\n\n    struct Payment {\n        uint amount;\n        uint date; // timestamp\n    }\n\n    struct Payout {\n        bytes32 proof;\n        uint amount;\n        uint date; // timestamp\n        uint veto; // clientId\n    }\n\n    mapping (uint => Payout) public payouts; // clientId -> requested payout\n    mapping (uint => Payment[]) public payments; // clientId -> list of his Payments\n    mapping (uint => Client) public clients; // clientId -> info about Client\n\n    modifier costs(uint _amount) {\n        if (msg.value < _amount)\n            throw;\n        _\n    }\n\n    modifier onlyBy(address _account) {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n\n    function InsuranceAgent() {\n        owner = msg.sender;\n    }\n\n    function newClient(uint clientId, address clientAddr) onlyBy(owner) {\n        clients[clientId] = Client({\n            addr: clientAddr\n        });\n    }\n\n    function newPayment(uint clientId, uint timestamp) costs(5000000000000000) {\n        payments[clientId].push(Payment({\n            amount: msg.value,\n            date: timestamp\n        }));\n    }\n\n    function requestPayout(uint clientId, uint amount, bytes32 proof, uint date, uint veto) onlyBy(owner) {\n        // only one payout at the same time for the same client available\n        // amount should be in wei\n        payouts[clientId] = Payout({\n            proof: proof,\n            amount: amount,\n            date: date,\n            veto: veto\n        });\n    }\n\n    function vetoPayout(uint clientId, uint proverId) onlyBy(owner) {\n        payouts[clientId].veto = proverId;\n    }\n\n    function payRequstedSum(uint clientId, uint date) onlyBy(owner) {\n        if (payouts[clientId].veto != 0) { throw; }\n        if (date - payouts[clientId].date < 60 * 60 * 24 * 3) { throw; }\n        clients[clientId].addr.send(payouts[clientId].amount);\n        delete payouts[clientId];\n    }\n\n    function getStatusOfPayout(uint clientId) constant returns (uint, uint, uint, bytes32) {\n        return (payouts[clientId].amount, payouts[clientId].date,\n                payouts[clientId].veto, payouts[clientId].proof);\n    }\n\n    function getNumberOfPayments(uint clientId) constant returns (uint) {\n        return payments[clientId].length;\n    }\n\n    function getPayment(uint clientId, uint paymentId) constant returns (uint, uint) {\n        return (payments[clientId][paymentId].amount, payments[clientId][paymentId].date);\n    }\n\n    function getClient(uint clientId) constant returns (address) {\n        return clients[clientId].addr;\n    }\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1353364,0x99befee3dd40bbb49a1d5c917bcb0ec9c1cb8d00,false,false,,,,TOO_SHORT
1353507,0x2b08397b0b509e4c4c9f07f7414c51cb5e8ffe2d,false,false,,,,TOO_SHORT
1353529,0x9eff39fbd501f63c32b3ef49e7a2fb8326dfeaf1,false,false,,,,TOO_SHORT
1353957,0x0f7a9a0409876da60e2c1d9a00b0469756d05bfc,false,false,,,,TOO_SHORT
1354702,0x1a59072e346a6838a210c0d12c2c1de3b0525012,false,false,,,,TOO_SHORT
1354890,0x4615e1c322927a042e1369af88ab07ca0c772432,false,false,,,,TOO_SHORT
1354969,0x180cfe0ce8d0943e73eef562d88622eee511f6df,false,false,,,,TOO_SHORT
1355060,0xec6232e6cdace0592271ef77f12b4f839b6a40ee,false,false,,,,TOO_SHORT
1355196,0x055948d3ca2ef3b0d967b58bfa5f3e046248af6b,false,false,,,,TOO_SHORT
1355451,0xad4b1df73689829f25bc7f52e9546d1e0177a095,false,false,,,,TOO_SHORT
1355638,0xd280a117934d29c9ec5e601a237ab4610aa5f09f,false,false,,,,TOO_SHORT
1355936,0x56c9375236b7bc4dd5b882e189cc05eeb025895f,false,false,,,,TOO_SHORT
1356025,0xf54b2699ed1d7d50b669d8a50a30d0f00d418831,false,false,,,,TOO_SHORT
1356460,0x68ae04baeb0820d9cc2274eff29290cec6250c9c,false,false,,,,TOO_SHORT
1356482,0xe930459434877242caa5cece7c46b021854bf24c,false,false,,,,TOO_SHORT
1357970,0x788aee271159a8f52237738f857142c213650f36,false,false,,,,TOO_SHORT
1358403,0x766812a16c4e8341b450acec9bba3c71adef5681,false,false,,,,TOO_SHORT
1358444,0xf2791584378f929555ee2b0109e9e062a3372e07,false,false,,,,TOO_SHORT
1358841,0x01603d1f13263198099a26622cfc04ac631b4cbe,false,false,,,,TOO_SHORT
1358947,0xc35e778aa1079dded683c4cfc3fe93f04f5f62a7,false,false,,,,TOO_SHORT
1359188,0xda281ef588125699d98746c7c5723d3c31e1eb76,false,false,,,,TOO_SHORT
1359353,0xc70a81bf19096892d59896b364bd15808ac7d3e4,false,false,,,,TOO_SHORT
1359413,0xd73fbb916bdf5ff948f7785b2ebe523542021454,false,false,,,,TOO_SHORT
1359758,0xdec15fa8777d922d4b42919389d6ba8f926ad81f,false,false,,,,TOO_SHORT
1359908,0x10ce9a72fd6e61166597a71a472d2e20bab264a7,false,false,,,,TOO_SHORT
1359918,0xb92fad95a43f321b8fbfe9aaf0b7de9f3242d7c3,false,false,,,,TOO_SHORT
1359972,0x250d34db5244e466c097d448a2ec9bc45688fe8a,false,false,,,,TOO_SHORT
1360244,0xbf89477a5e025fe6a56b4ef192067479292e8ba7,false,false,,,,TOO_SHORT
1360431,0x0d4b053e334ef06b9c3f79d004ca2e28746c8570,false,false,,,,TOO_SHORT
1360476,0xd52d50fcf02d7b99675da8908f603ee6d177abcb,false,false,,,,TOO_SHORT
1360525,0xaaf40a06eafa90970223e335ffb2735dfcaa6b85,false,false,,,,TOO_SHORT
1360611,0x3af62c664102a961152d8e5e663e016f0cb037d9,false,false,,,,TOO_SHORT
1360651,0xdcabd383a7c497069d0804070e4ba70ab6ecdd51,false,false,"contract BlockChainEnterprise {\n    \n        uint private BlockBalance = 0; //block balance (0 to BlockSize eth)\n        uint private NumberOfBlockMined = 0; \n        uint private BlockReward = 0;\n        uint private BlockSize =  10 ether; //a block is size 10 ETH, and with 1.2 multiplier it is paid 12 ETH\n        uint private MaxDeposit = 5 ether;\n        uint private multiplier = 1200; // Multiplier\n        \n        \n        uint private fees = 0;      //Fees are just verly low : 1% !\n        uint private feeFrac = 5;  //Fraction for fees in ""thousandth"" --> only 0.5% !!\n        uint private RewardFrac = 30;  //Fraction for Reward in ""thousandth""\n        \n        \n        uint private Payout_id = 0;\n        \n        address private admin;\n        \n        function BlockChainEnterprise() {\n            admin = msg.sender;\n        }\n\n        modifier onlyowner {if (msg.sender == admin) _  }\n\n        struct Miner {\n            address addr;\n            uint payout;\n            bool paid;\n        }\n\n        Miner[] private miners;\n\n        //--Fallback function\n        function() {\n            init();\n        }\n\n        //--initiated function\n        function init() private {\n            uint256 new_deposit=msg.value;\n            //------ Verifications on this new deposit ------\n            if (new_deposit < 100 finney) { //only >0.1 eth participation accepted\n                    msg.sender.send(new_deposit);\n                    return;\n            }\n            \n            if( new_deposit > MaxDeposit ){\n                msg.sender.send( msg.value - MaxDeposit );\n                new_deposit= MaxDeposit;\n            }\n            //-- enter the block ! --\n            Participate(new_deposit);\n        }\n\n        function Participate(uint deposit) private {\n            \n            if( BlockSize  < (deposit + BlockBalance) ){ //if this new deposit is part of 2 blocks\n                uint256 fragment = BlockSize - BlockBalance;\n                miners.push(Miner(msg.sender, fragment*multiplier/1000 , false)); //fill the block\n                miners.push(Miner(msg.sender, (deposit - fragment)*multiplier/1000  , false)); //contruct the next one\n            }\n            else{\n                miners.push(Miner(msg.sender, deposit*multiplier/1000 , false)); // add this new miner in the block !\n            }\n                \n            //--- UPDATING CONTRACT STATS ----\n            BlockReward += (deposit * RewardFrac) / 1000; // take some to reward the winner that make the whole block mined !\n            fees += (deposit * feeFrac) / 1000;          // collect small fee\n            BlockBalance += (deposit * (1000 - ( feeFrac + RewardFrac ))) / 1000; //update balance\n\n            \n            //Mine the block first if possible !\n            if( BlockBalance >= (BlockSize/1000*multiplier) ){// it can be mined now !\n                PayMiners();\n                PayWinnerMiner(msg.sender,deposit);\n            }\n        }\n\n\n        function PayMiners() private{\n            NumberOfBlockMined +=1;\n            //Classic payout of all participants of the block\n            while ( miners[Payout_id].payout!=0 && BlockBalance >= ( miners[Payout_id].payout )  ) {\n                miners[Payout_id].addr.send(miners[Payout_id].payout); //pay the man !\n                \n                BlockBalance -= miners[Payout_id].payout; //update the balance\n                miners[Payout_id].paid=true;\n                \n                Payout_id += 1;\n            }\n        }\n        \n        function  PayWinnerMiner(address winner, uint256 deposit) private{ //pay the winner accordingly to his deposit !\n            //Globally, EVERYONE CAN WIN by being smart and quick.\n            if(deposit >= 1 ether){ //only 1 ether, and you get it all !\n                winner.send(BlockReward);\n                BlockReward =0;\n            }\n            else{ // deposit is between 0.1 and 0.99 ether\n                uint256 pcent = deposit / 10 finney;\n                winner.send(BlockReward*pcent/100);\n                BlockReward -= BlockReward*pcent/100;\n            }\n        }\n    \n\n    //---Contract management functions\n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n    \n    \n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        fees = 0;\n    }\n    \n    function GetAndReduceFeesByFraction(uint p) onlyowner {\n        if (fees == 0) feeFrac=feeFrac*80/100; //Reduce fees.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n        \n\n//---Contract informations\n\n\nfunction WatchBalance() constant returns(uint TotalBalance, string info) {\n    TotalBalance = BlockBalance /  1 finney;\n    info ='Balance in finney';\n}\n\nfunction WatchBlockSizeInEther() constant returns(uint BlockSizeInEther, string info) {\n    BlockSizeInEther = BlockSize / 1 ether;\n    info ='Balance in ether';\n}\nfunction WatchNextBlockReward() constant returns(uint Reward, string info) {\n    Reward = BlockReward / 1 finney;\n    info ='Current reward collected. The reward when a block is mined is always BlockSize*RewardPercentage/100';\n}\n\nfunction NumberOfMiners() constant returns(uint NumberOfMiners, string info) {\n    NumberOfMiners = miners.length;\n    info ='Number of participations since the beginning of this wonderful blockchain';\n}\n\nfunction WatchCurrentMultiplier() constant returns(uint Mult, string info) {\n    Mult = multiplier;\n    info ='Current multiplier';\n}\nfunction NumberOfBlockAlreadyMined() constant returns(uint NumberOfBlockMinedAlready, string info) {\n    NumberOfBlockMinedAlready = NumberOfBlockMined;\n    info ='A block mined is a payout of size BlockSize, multiply this number and you get the sum of all payouts.';\n}\nfunction AmountToForgeTheNextBlock() constant returns(uint ToDeposit, string info) {\n    ToDeposit = ( ( (BlockSize/1000*multiplier) - BlockBalance)*(1000 - ( feeFrac + RewardFrac ))/1000) / 1 finney;\n    info ='This amount in finney in finney required to complete the current block, and to MINE it (trigger the payout).';\n}\nfunction PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (id <= miners.length) {\n        Address = miners[id].addr;\n        Payout = (miners[id].payout) / 1 finney;\n        UserPaid=miners[id].paid;\n    }\n}\n\nfunction WatchCollectedFeesInSzabo() constant returns(uint CollectedFees) {\n    CollectedFees = fees / 1 szabo;\n}\n\nfunction NumberOfCurrentBlockMiners() constant returns(uint QueueSize, string info) {\n    QueueSize = miners.length - Payout_id;\n    info ='Number of participations in the current block.';\n}\n\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1360817,0x2f17fda2adbdd73a9b59cdcd4eadeefdfe70b1d9,false,false,,,,TOO_SHORT
1360872,0x0baacfc59d63cb18f65d488531909dfba8cc0767,false,false,,,,TOO_SHORT
1360956,0xc9dcae26e47a4a62381c11653930d18ef3af9df4,false,false,,,,TOO_SHORT
1361002,0x352de0bbd573c97d6941a12d00d2e9320cb69e1c,false,false,,,,TOO_SHORT
1361315,0x05c57df208ef69d5e37fd3539011c49579d8b720,false,false,,,,TOO_SHORT
1361571,0xfd8ec0d508157a1d47ba88563aaf5610c178d330,false,false,,,,TOO_SHORT
1362206,0x8d180446b337cc71f64e65ec57b7be58f29a4e40,false,false,,,,TOO_SHORT
1362681,0x1ca58f4cf73dede6b10c5830501d281c4e153bd9,false,false,,,,TOO_SHORT
1363899,0xf25af1593709caa7abc2dfb3e804ce1b4511509a,false,false,,,,TOO_SHORT
1364036,0x40955fdd45021f855b4d6da2387f68cbe7d1add5,false,false,,,,TOO_SHORT
1364387,0xd2e1fd6f8e26737ec3a5a6335b42f796ed057493,false,false,,,,TOO_SHORT
1364706,0x20ea2c1e331fb988b6c67fa687dd06959d37aa9c,false,false,,,,TOO_SHORT
1365330,0x35b2b168aa2d38e90c780b014b964c117a26e6ae,false,false,,,,TOO_SHORT
1365383,0x480e437834412f44cce0a4ec1187a2e0a4ea002a,false,false,,,,TOO_SHORT
1365392,0x892d086652417ec1facc301ead991ac018077fb3,false,false,,,,TOO_SHORT
1365809,0x4c358f8ebe4866339a4759c0e0e820368ea44b1a,false,false,,,,TOO_SHORT
1365848,0x9a285e9327537299e867a77d6e71376ac003d715,false,false,,,,TOO_SHORT
1366152,0xf73b3a7de8bb600b015ffbf9eb1f8d9c6c7e3d17,false,false,,,,TOO_SHORT
1366173,0xe98704d1e2997e96e32bcbd437487ea2d6a33af8,false,false,,,,TOO_SHORT
1366189,0x3e0e68884090cd2455a9cf45b313cd9cdc489e37,false,false,,,,TOO_SHORT
1366205,0xbf7fbad4d934fa729098657fbb2fa867ac98fd43,false,false,,,,TOO_SHORT
1366355,0xa63a2150b3bed58033585d9aa894c0044cecee73,false,false,,,,TOO_SHORT
1366598,0xa62d48a488cc3192bd147378bd18a5d06b5d5689,false,false,,,,TOO_SHORT
1366856,0xe6bdac34d2cc93955728fa065fcd40aeaf1b55f6,false,false,,,,TOO_SHORT
1367410,0xfd3b2986c19fe9a88d836a3d672dce11fb16e225,false,false,,,,TOO_SHORT
1367562,0x1cce822d3a0c9487279f50fe7249683b6b8c34bb,false,false,,,,TOO_SHORT
1367843,0x193fc646b75fcf7985038f88659ddda6d0b8a600,false,false,,,,TOO_SHORT
1367941,0x0ebf44fd9a5d49bcc5467601f7e002d7ad56075b,false,false,,,,TOO_SHORT
1368193,0xea94334e6e64b879d9d584f2868e804c30358d52,false,false,,,,TOO_SHORT
1368779,0xd874934826af06ec8786cb3ecd7c59d2987d14e6,false,false,,,,TOO_SHORT
1368818,0xcccd5b66bf6990c7210fd76781469b19bcff9bae,false,false,"contract RPS\n{\n    struct Hand\n    {\n        uint hand;\n    }\n	\n	bool		private		shift = true;\n	address[]	private 	hands;\n	bool 	 	private 	fromRandom = false;\n\n    mapping(address => Hand[]) tickets;\n\n	function Rock(){\n		setHand(0);\n	}\n	function Paper(){\n		setHand(1);\n	}\n	function Scissors(){\n		setHand(2);\n	}\n	\n	function () {		 \n		if (msg.value >= 1000000000000000000){\n			msg.sender.send((msg.value-1000000000000000000));\n			fromRandom = true;\n			setHand((addmod(now,0,3)));\n		}\n		if (msg.value < 1000000000000000000){\n			msg.sender.send(msg.value);\n		}\n    }\n	\n    function setHand(uint inHand) internal\n    {\n		if(msg.value != 1000000000000000000 && !fromRandom){\n			msg.sender.send(msg.value);\n		}\n		if(msg.value == 1000000000000000000 || fromRandom){\n	        tickets[msg.sender].push(Hand({\n	            hand: inHand,\n	        }));\n			hands.push(msg.sender);\n			shift = !shift;\n		}\n		if(shift){\n			draw();\n		}\n		fromRandom = false;\n	}\n	\n	function draw() internal {\n		var handOne = tickets[hands[0]][0].hand;\n		var handTwo = tickets[hands[1]][0].hand;\n		delete tickets[hands[0]];\n		delete tickets[hands[1]];\n		\n		if(handOne == handTwo){\n			hands[0].send(1000000000000000000);\n			hands[1].send(1000000000000000000);\n			delete hands;\n		}\n		if(handTwo-handOne == 1){\n			winner(hands[0]);\n		}\n		if(handOne-handTwo == 1){\n			winner(hands[1]);\n		}\n		if(handOne == 0 && handTwo == 2){\n			winner(hands[1]);\n		}\n		if(handTwo == 0 && handOne == 2){\n			winner(hands[0]);\n		}\n	}\n	\n	function winner(address _address) internal {\n		_address.send(1980000000000000000);\n		address(0x2179987247abA70DC8A5bb0FEaFd4ef4B8F83797).send(20000000000000000);\n		delete hands;\n	}\n}",1,Rock-Paper-Scissorsゲームを実装した実用的なスマートコントラクト。標準的な構造を持つ。,
1369245,0x1f0a53026b23b164d37cc2cb705e130245f30045,false,false,,,,TOO_SHORT
1369696,0x438af6ba1f65ea85acda4749950b8cbc7c6601d5,false,false,,,,TOO_SHORT
1369718,0x3922fb13e711d6f0aa16bae944cc90e82b9f405b,false,false,,,,TOO_SHORT
1369780,0x81e30f6f0c19b18c345e49046340aa31a62eff4d,false,false,,,,TOO_SHORT
1369816,0x36b1fd186f16f484c626ae91a279b1848123be11,false,false,,,,TOO_SHORT
1369955,0x8db4e9f25c5559c8d93ea27e95a75fb44add2839,false,false,,,,TOO_SHORT
1370124,0x8d734806913e445ee1be523aa0e84e4664fff481,false,false,,,,0x7d56485e026d5d3881f778e99969d2b1f90c50af
1370397,0x6550a5eeb7a3018fa8531e0e740d792957e48c53,false,false,,,,TOO_SHORT
1370536,0x6060a57fbe2df68d6314c49fb5cf3f889f7fb422,false,false,,,,TOO_SHORT
1370905,0xa8684460248f8dbafef8a631b766163f93ca685c,false,false,,,,TOO_SHORT
1371197,0x6c7ea088c712b1dbb3984809adeb08143828d398,false,false,,,,TOO_SHORT
1371235,0xba60ad88ff003d40cd8ec1c8644eded8e2be6459,false,false,,,,TOO_SHORT
1371259,0x8d3d512050de9f8a2e15af4ca43d57524c68e4e7,false,false,,,,TOO_SHORT
1371590,0x422f8015c5d8168edee923749701360a8a4d0703,false,false,contract fresh {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function fresh() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 20 ether) {\n			msg.sender.send(msg.value - 20 ether);	\n			amount = 20 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1371757,0xe76563eb8413ede9b4a1a3c1f3280a95c4b60a33,false,false,,,,TOO_SHORT
1371847,0xb208b130bafd87e54e1159767797e13bb968b5d2,false,false,,,,TOO_SHORT
1372232,0x84d6c368d376a0228ed57d6495d3ab2e40027a89,false,false,,,,TOO_SHORT
1372245,0xbf280a05a1aa9360fee28b61ba0b01abbf16ba49,false,false,"contract RPS\n{\n    struct Hand\n    {\n        uint hand;\n    }\n	\n	bool		private		shift = true;\n	address[]	private 	hands;\n	bool 	 	private 	fromRandom = false;\n	\n    mapping(address => Hand[]) tickets;\n\n	function Rock(){\n		setHand(uint(1));\n	}\n	function Paper(){\n		setHand(uint(2));\n	}\n	function Scissors(){\n		setHand(uint(3));\n	}\n	\n	function () {\n		if (msg.value >= 1000000000000000000){\n			msg.sender.send((msg.value-1000000000000000000));\n			fromRandom = true;\n			setHand(uint((addmod(now,0,3))+1));\n		}\n		if (msg.value < 1000000000000000000){\n			msg.sender.send(msg.value);\n		}\n    }\n	\n    function setHand(uint inHand) internal\n    {\n		if(msg.value != 1000000000000000000 && !fromRandom){\n			msg.sender.send(msg.value);\n		}\n		if(msg.value == 1000000000000000000 || fromRandom){\n	        tickets[msg.sender].push(Hand({\n	            hand: inHand,\n	        }));\n			hands.push(msg.sender);\n			shift = !shift;\n		}\n		if(shift){\n			draw(tickets[hands[0]][0].hand, tickets[hands[1]][0].hand);\n		}\n		fromRandom = false;\n	}\n	\n	function draw(uint _handOne, uint _handTwo) internal {\n		var handOne = _handOne;\n		var handTwo = _handTwo;\n		\n		if((handTwo-handOne) == 1){\n			winner(hands[1]);\n		}\n		if((handOne-handTwo) == 1){\n			winner(hands[0]);\n		}\n		if((handOne == 1) && (handTwo == 3)){\n			winner(hands[0]);\n		}\n		if((handTwo == 1) && (handOne == 3)){\n			winner(hands[1]);\n		}\n		if((handOne - handTwo) == 0){\n			hands[0].send(1000000000000000000);\n			hands[1].send(1000000000000000000);\n			delete tickets[hands[0]];\n			delete tickets[hands[1]];\n			delete hands;\n		}\n	}\n	\n	function winner(address _address) internal {\n		_address.send(1980000000000000000);\n		address(0xfa4b795b491cc1975e89f3c78972c3e2e827c882).send(20000000000000000);\n		delete tickets[hands[0]];\n		delete tickets[hands[1]];\n		delete hands;\n	}\n}",1,標準的なじゃんけんゲームのスマートコントラクトで、実用的な構造を持っています。,
1372256,0xdf111e5ebf0ead96faa556a3797463ba2067e467,false,false,,,,TOO_SHORT
1372891,0x7019a63cf3d4be477d9915ee7da183e287d31490,false,false,,,,TOO_SHORT
1372952,0x13d932945d98d229149996f15324dd3f58e0905a,false,false,,,,TOO_SHORT
1373078,0x4a64ec42f5b38473c02949fef675a684524f6b4a,false,false,,,,TOO_SHORT
1373474,0x8b3f7d40261362fa7119e025e39f818dd3e1c572,false,false,,,,TOO_SHORT
1373479,0x2173e4d17dea7284826f468bcea0fafa5d7e899c,false,false,,,,TOO_SHORT
1373904,0x814cf77389858731e3807947a698efd12486803d,false,false,,,,TOO_SHORT
1374044,0x870fe80e76dae4a4c12690dec52456ab13176202,false,false,"contract ShinySquirrels {\n\n// all the things\nuint private minDeposit = 10 finney;\nuint private maxDeposit = 5 ether;\nuint private baseFee = 5;\nuint private baseMultiplier = 100;\nuint private maxMultiplier = 160;\nuint private currentPosition = 0;\nuint private balance = 0;\nuint private feeBalance = 0;\nuint private totalDeposits = 0;\nuint private totalPaid = 0;\nuint private totalSquirrels = 0;\nuint private totalShinyThings = 0;\nuint private totalSprockets = 0;\nuint private totalStars = 0;\nuint private totalHearts = 0;\nuint private totalSkips = 0;\naddress private owner = msg.sender;\n \nstruct PlayerEntry {\n    address addr;\n    uint deposit;\n    uint paid;\n    uint multiplier;\n    uint fee;\n    uint skip;\n    uint squirrels;\n    uint shinyThings;\n    uint sprockets;\n    uint stars;\n    uint hearts;\n}\n \nstruct PlayerStat {\n    address addr;\n    uint entries;\n    uint deposits;\n    uint paid;\n    uint skips;\n    uint squirrels;\n    uint shinyThings;\n    uint sprockets;\n    uint stars;\n    uint hearts;\n}\n\n// player entries in the order received\nPlayerEntry[] private players;\n\n// The Line of players, keeping track as new players cut in...\nuint[] theLine;\n\n// individual player totals\nmapping(address => PlayerStat) private playerStats;\n\n// Shiny new contract, no copy & paste here!\nfunction ShinySquirrels() {\n    owner = msg.sender;\n}\n \nfunction totals() constant returns(uint playerCount, uint currentPlaceInLine, uint playersWaiting, uint totalDepositsInFinneys, uint totalPaidOutInFinneys, uint squirrelFriends, uint shinyThingsFound, uint sprocketsCollected, uint starsWon, uint heartsEarned, uint balanceInFinneys, uint feeBalanceInFinneys) {\n    playerCount             = players.length;\n    currentPlaceInLine      = currentPosition;\n    playersWaiting          = waitingForPayout();\n    totalDepositsInFinneys  = totalDeposits / 1 finney;\n    totalPaidOutInFinneys   = totalPaid / 1 finney;\n    squirrelFriends         = totalSquirrels;\n    shinyThingsFound        = totalShinyThings;\n    sprocketsCollected      = totalSprockets;\n    starsWon                = totalStars;\n    heartsEarned            = totalHearts;\n    balanceInFinneys        = balance / 1 finney;\n    feeBalanceInFinneys     = feeBalance / 1 finney;\n}\n\nfunction settings() constant returns(uint minimumDepositInFinneys, uint maximumDepositInFinneys) {\n    minimumDepositInFinneys = minDeposit / 1 finney;\n    maximumDepositInFinneys = maxDeposit / 1 finney;\n}\n\nfunction playerByAddress(address addr) constant returns(uint entries, uint depositedInFinney, uint paidOutInFinney, uint skippedAhead, uint squirrels, uint shinyThings, uint sprockets, uint stars, uint hearts) {\n    entries          = playerStats[addr].entries;\n    depositedInFinney = playerStats[addr].deposits / 1 finney;\n    paidOutInFinney  = playerStats[addr].paid / 1 finney;\n    skippedAhead     = playerStats[addr].skips;\n    squirrels        = playerStats[addr].squirrels;\n    shinyThings      = playerStats[addr].shinyThings;\n    sprockets        = playerStats[addr].sprockets;\n    stars            = playerStats[addr].stars;\n    hearts           = playerStats[addr].hearts;\n}\n\n// current number of players still waiting for their payout\nfunction waitingForPayout() constant private returns(uint waiting) {\n    waiting = players.length - currentPosition;\n}\n\n// the total payout this entry in line will receive\nfunction entryPayout(uint index) constant private returns(uint payout) {\n    payout = players[theLine[index]].deposit * players[theLine[index]].multiplier / 100;\n}\n\n// the payout amount still due to this entry in line\nfunction entryPayoutDue(uint index) constant private returns(uint payoutDue) {\n    // subtract the amount they've been paid from the total they are to receive\n    payoutDue = entryPayout(index) - players[theLine[index]].paid;\n}\n \n// public interface to the line of players\nfunction lineOfPlayers(uint index) constant returns (address addr, uint orderJoined, uint depositInFinney, uint payoutInFinney, uint multiplierPercent, uint paid, uint skippedAhead, uint squirrels, uint shinyThings, uint sprockets, uint stars, uint hearts) {\n    PlayerEntry player = players[theLine[index]];\n    addr              = player.addr;\n    orderJoined       = theLine[index];\n    depositInFinney   = player.deposit / 1 finney;\n    payoutInFinney    = depositInFinney * player.multiplier / 100;\n    multiplierPercent = player.multiplier;\n    paid              = player.paid / 1 finney;\n    skippedAhead      = player.skip;\n    squirrels         = player.squirrels;\n    shinyThings       = player.shinyThings;\n    sprockets         = player.sprockets;\n    stars             = player.stars;\n    hearts            = player.hearts;\n}\n\nfunction () {\n    play();\n}\n \nfunction play() {\n    uint deposit = msg.value; // in wei\n     \n    // validate deposit is in range\n    if(deposit < minDeposit || deposit > maxDeposit) {\n        msg.sender.send(deposit);\n        return;\n    }\n     \n    uint multiplier  = baseMultiplier; // percent\n    uint fee         = baseFee; // percent\n    uint skip        = 0;\n    uint squirrels   = 0;\n    uint shinyThings = 0;\n    uint sprockets   = 0;\n    uint stars       = 0;\n    uint hearts      = 0;\n     \n    if(players.length % 5 == 0) {\n        multiplier += 2;\n        fee        += 1;\n        stars      += 1;\n         \n        if(deposit < 1 ether) {\n            multiplier  -= multiplier >= 7 ? 7 : multiplier;\n            fee         -= fee        >= 1 ? 1 : 0;\n            shinyThings += 1;\n        }\n        if(deposit >= 1 && waitingForPayout() >= 10) {\n            // at least 10 players waiting\n            skip += 4;\n            fee  += 3;\n        }\n        if(deposit >= 2 ether && deposit <= 3 ether) {\n            multiplier += 3;\n            fee        += 2;\n            hearts     += 1;\n        }\n        if(deposit >= 3 ether) {\n            stars += 1;\n        }\n\n    } else if (players.length % 5 == 1) {\n        multiplier += 4;\n        fee        += 2;\n        squirrels  += 1;\n\n        if(deposit < 1 ether) {\n            multiplier += 6;\n            fee        += 3;\n            squirrels  += 1;\n        }\n        if(deposit >= 2 ether) {\n            if(waitingForPayout() >= 20) {\n                // at least 20 players waiting\n                skip        += waitingForPayout() / 2; // skip half of them\n                fee         += 2;\n                shinyThings += 1;\n            } \n\n            multiplier += 4;\n            fee        += 4;\n            hearts     += 1;\n        }\n        if(deposit >= 4 ether) {\n            multiplier += 1;\n            fee       -= fee >= 1 ? 1 : 0;\n            skip      += 1;\n            hearts    += 1;\n            stars     += 1;\n        }\n\n    } else if (players.length % 5 == 2) {\n        multiplier += 7;\n        fee        += 6;\n        sprockets  += 1;\n         \n        if(waitingForPayout() >= 10) {\n            // at least 10 players waiting\n            multiplier -= multiplier >= 8 ? 8 : multiplier;\n            fee        -= fee >= 1 ? 1 : 0;\n            skip       += 1;\n            squirrels  += 1;\n        }\n        if(deposit >= 3 ether) {\n            multiplier  += 2;\n            skip        += 1;\n            stars       += 1;\n            shinyThings += 1;\n        }\n        if(deposit == maxDeposit) {\n            multiplier += 2;\n            skip       += 1;\n            hearts     += 1;\n            squirrels  += 1;\n        }\n     \n    } else if (players.length % 5 == 3) {\n        multiplier  -= multiplier >= 5 ? 5 : multiplier; // on noes!\n        fee         += 0;\n        skip        += 3; // oh yay!\n        shinyThings += 1;\n         \n        if(deposit < 1 ether) {\n            multiplier -= multiplier >= 5 ? 5 : multiplier;\n            fee        += 2;\n            skip       += 5;\n            squirrels  += 1;\n        }\n        if(deposit == 1 ether) {\n            multiplier += 10;\n            fee        += 4;\n            skip       += 2;\n            hearts     += 1;\n        }\n        if(deposit == maxDeposit) {\n            multiplier += 1;\n            fee       += 5;\n            skip      += 1;\n            sprockets += 1;\n            stars     += 1;\n            hearts    += 1;\n        }\n     \n    } else if (players.length % 5 == 4) {\n        multiplier += 2;\n        fee        -= fee >= 1 ? 1 : fee;\n        squirrels  += 1;\n         \n        if(deposit < 1 ether) {\n            multiplier += 3;\n            fee        += 2;\n            skip       += 3;\n        }\n        if(deposit >= 2 ether) {\n            multiplier += 2;\n            fee        += 2;\n            skip       += 1;\n            stars      += 1;\n        }\n        if(deposit == maxDeposit/2) {\n            multiplier  += 2;\n            fee         += 5;\n            skip        += 3;\n            shinyThings += 1;\n            sprockets   += 1;\n        }\n        if(deposit >= 3 ether) {\n            multiplier += 1;\n            fee        += 1;\n            skip       += 1;\n            sprockets  += 1;\n            hearts     += 1;\n        }\n    }\n\n    // track the accumulated bonus goodies!\n    playerStats[msg.sender].hearts      += hearts;\n    playerStats[msg.sender].stars       += stars;\n    playerStats[msg.sender].squirrels   += squirrels;\n    playerStats[msg.sender].shinyThings += shinyThings;\n    playerStats[msg.sender].sprockets   += sprockets;\n    \n    // track cummulative awarded goodies\n    totalHearts      += hearts;\n    totalStars       += stars;\n    totalSquirrels   += squirrels;\n    totalShinyThings += shinyThings;\n    totalSprockets   += sprockets;\n\n    // got squirrels? skip in front of that many players!\n    skip += playerStats[msg.sender].squirrels;\n     \n    // one squirrel ran away!\n    playerStats[msg.sender].squirrels -= playerStats[msg.sender].squirrels >= 1 ? 1 : 0;\n     \n    // got stars? 2% multiplier bonus for every star!\n    multiplier += playerStats[msg.sender].stars * 2;\n     \n    // got hearts? -2% fee for every heart!\n    fee -= playerStats[msg.sender].hearts;\n     \n    // got sprockets? 1% multiplier bonus and -1% fee for every sprocket!\n    multiplier += playerStats[msg.sender].sprockets;\n    fee        -= fee > playerStats[msg.sender].sprockets ? playerStats[msg.sender].sprockets : fee;\n     \n    // got shiny things? skip 1 more player and -1% fee!\n    if(playerStats[msg.sender].shinyThings >= 1) {\n        skip += 1;\n        fee  -= fee >= 1 ? 1 : 0;\n    }\n     \n    // got a heart, star, squirrel, shiny thin, and sprocket?!? 50% bonus multiplier!!!\n    if(playerStats[msg.sender].hearts >= 1 && playerStats[msg.sender].stars >= 1 && playerStats[msg.sender].squirrels >= 1 && playerStats[msg.sender].shinyThings >= 1 && playerStats[msg.sender].sprockets >= 1) {\n        multiplier += 30;\n    }\n     \n    // got a heart and a star? trade them for +20% multiplier!!!\n    if(playerStats[msg.sender].hearts >= 1 && playerStats[msg.sender].stars >= 1) {\n        multiplier                     += 15;\n        playerStats[msg.sender].hearts -= 1;\n        playerStats[msg.sender].stars  -= 1;\n    }\n     \n    // got a sprocket and a shiny thing? trade them for 5 squirrels!\n    if(playerStats[msg.sender].sprockets >= 1 && playerStats[msg.sender].shinyThings >= 1) {\n        playerStats[msg.sender].squirrels   += 5;\n        playerStats[msg.sender].sprockets   -= 1;\n        playerStats[msg.sender].shinyThings -= 1;\n    }\n\n    // stay within profitable and safe limits\n    if(multiplier > maxMultiplier) {\n        multiplier == maxMultiplier;\n    }\n    \n    // keep power players in check so regular players can still win some too\n    if(waitingForPayout() > 15 && skip > waitingForPayout()/2) {\n        // limit skip to half of waiting players\n        skip = waitingForPayout() / 2;\n    }\n\n    // ledgers within ledgers     \n    feeBalance += deposit * fee / 100;\n    balance    += deposit - deposit * fee / 100;\n    totalDeposits += deposit;\n\n    // prepare players array for a new entry    \n    uint playerIndex = players.length;\n    players.length += 1;\n\n    // make room in The Line for one more\n    uint lineIndex = theLine.length;\n    theLine.length += 1;\n\n    // skip ahead if you should be so lucky!\n    (skip, lineIndex) = skipInLine(skip, lineIndex);\n\n    // record the players entry\n    players[playerIndex].addr        = msg.sender;\n    players[playerIndex].deposit     = deposit;\n    players[playerIndex].multiplier  = multiplier;\n    players[playerIndex].fee         = fee;\n    players[playerIndex].squirrels   = squirrels;\n    players[playerIndex].shinyThings = shinyThings;\n    players[playerIndex].sprockets   = sprockets;\n    players[playerIndex].stars       = stars;\n    players[playerIndex].hearts      = hearts;\n    players[playerIndex].skip        = skip;\n    \n    // add the player to The Line at whatever position they snuck in at    \n    theLine[lineIndex] = playerIndex;\n\n    // track players cumulative stats\n    playerStats[msg.sender].entries  += 1;\n    playerStats[msg.sender].deposits += deposit;\n    playerStats[msg.sender].skips    += skip;\n    \n    // track total game skips\n    totalSkips += skip;\n    \n    // issue payouts while the balance allows\n    // rolling payouts occur as long as the balance is above zero\n    uint nextPayout = entryPayoutDue(currentPosition);\n    uint payout;\n    while(balance > 0) {\n        if(nextPayout <= balance) {\n            // the balance is great enough to pay the entire next balance due\n            // pay the balance due\n            payout = nextPayout;\n        } else {\n            // the balance is above zero, but less than the next balance due\n            // send them everything available\n            payout = balance;\n        }\n        // issue the payment\n        players[theLine[currentPosition]].addr.send(payout);\n        // mark the amount paid\n        players[theLine[currentPosition]].paid += payout;\n        // keep a global tally\n        playerStats[players[theLine[currentPosition]].addr].paid += payout;\n        balance    -= payout;\n        totalPaid  += payout;\n        // move to the next position in line if the last entry got paid out completely\n        if(balance > 0) {\n            currentPosition++;\n            nextPayout = entryPayoutDue(currentPosition);\n        }\n    }\n}\n \n// jump in line, moving entries back towards the end one at a time\n// presumes the line length has already been increased to accomodate the newcomer\n// return the the number of positions skipped and the index of the vacant position in line\nfunction skipInLine(uint skip, uint currentLineIndex) private returns (uint skipped, uint newLineIndex) {\n    // check for at least 1 player in line plus this new entry\n    if(skip > 0 && waitingForPayout() > 2) {\n        // -2 because we don't want to count the new empty slot at the end of the list\n        if(skip > waitingForPayout()-2) {\n            skip = waitingForPayout()-2;\n        }\n\n        // move entries forward one by one\n        uint i = 0;\n        while(i < skip) {\n            theLine[currentLineIndex-i] = theLine[currentLineIndex-1-i];\n            i++;\n        }\n        \n        // don't leave a duplicate copy of the last entry processed\n        delete(theLine[currentLineIndex-i]);\n        \n        // the newly vacant position is i slots from the end\n        newLineIndex = currentLineIndex-i;\n    } else {\n        // no change\n        newLineIndex = currentLineIndex;\n        skip = 0;\n    }\n    skipped = skip;\n}\n\nfunction DynamicPyramid() {\n    // Rubixi god-code, j/k :-P\n    playerStats[msg.sender].squirrels    = 0;\n    playerStats[msg.sender].shinyThings  = 0;\n    playerStats[msg.sender].sprockets    = 0;\n    playerStats[msg.sender].stars        = 0;\n    playerStats[msg.sender].hearts       = 0;\n}\n \nfunction collectFees() {\n    if(msg.sender != owner) {\n        throw;\n    }\n    // game balance will always be zero due to automatic rolling payouts\n    if(address(this).balance > balance + feeBalance) {\n        // collect any funds outside of the game balance\n        feeBalance = address(this).balance - balance;\n    }\n    owner.send(feeBalance);\n    feeBalance = 0;\n}\n\nfunction updateSettings(uint newMultiplier, uint newMaxMultiplier, uint newFee, uint newMinDeposit, uint newMaxDeposit, bool collect) {\n    // adjust the base settings within a small and limited range as the game matures and ether prices change\n    if(msg.sender != owner) throw;\n    if(newMultiplier < 80 || newMultiplier > 120) throw;\n    if(maxMultiplier < 125 || maxMultiplier > 200) throw;\n    if(newFee < 0 || newFee > 15) throw;\n    if(minDeposit < 1 finney || minDeposit > 1 ether) throw;\n    if(maxDeposit < 1 finney || maxDeposit > 25 ether) throw;\n    if(collect) collectFees();\n    baseMultiplier = newMultiplier;\n    maxMultiplier = newMaxMultiplier;\n    baseFee = newFee;\n    minDeposit = newMinDeposit;\n    maxDeposit = newMaxDeposit;\n}\n\n\n}",2,"コードは実用的だが、""ShinySquirrels""や""hearts""など詩的な要素が含まれている。",
1374168,0xb0fcf38a3283b48cad46e92a87bbf21d2c2bd0c3,false,false,,,,TOO_SHORT
1374245,0xf35981947ec6ea0b6de194fd4d8550d80c3bd2df,false,false,,,,TOO_SHORT
1374307,0x6446c71c003ecb030483aed374745169bbc04533,false,false,,,,TOO_SHORT
1374725,0xac504e2a9c870a48de521ed513b251b1f7116dd9,false,false,"contract RPS\n{\n    struct Hand\n    {\n        uint hand;\n    }\n	\n	bool		private		shift = true;\n	address[]	private 	hands;\n	bool 	 	private 	fromRandom = false;\n	\n    mapping(address => Hand[]) tickets;\n\n	function Rock(){\n		setHand(uint(1));\n	}\n	function Paper(){\n		setHand(uint(2));\n	}\n	function Scissors(){\n		setHand(uint(3));\n	}\n	\n	function () {\n		if (msg.value >= 1000000000000000000){\n			msg.sender.send((msg.value-1000000000000000000));\n			fromRandom = true;\n			setHand(uint((addmod(now,0,3))+1));\n		}\n		if (msg.value < 1000000000000000000){\n			msg.sender.send(msg.value);\n		}\n    }\n	\n    function setHand(uint inHand) internal\n    {\n		if(msg.value != 1000000000000000000 && !fromRandom){\n			msg.sender.send(msg.value);\n		}\n		if(msg.value == 1000000000000000000 || fromRandom){\n	        tickets[msg.sender].push(Hand({\n	            hand: inHand,\n	        }));\n			hands.push(msg.sender);\n			shift = !shift;\n		}\n		if(shift){\n			draw(tickets[hands[0]][0].hand, tickets[hands[1]][0].hand);\n		}\n		fromRandom = false;\n	}\n	\n	function draw(uint _handOne, uint _handTwo) internal {\n		var handOne = _handOne;\n		var handTwo = _handTwo;\n		\n		if((handTwo-handOne) == 1){\n			winner(hands[1]);\n		}\n		if((handOne-handTwo) == 1){\n			winner(hands[0]);\n		}\n		if((handOne == 1) && (handTwo == 3)){\n			winner(hands[0]);\n		}\n		if((handTwo == 1) && (handOne == 3)){\n			winner(hands[1]);\n		}\n		if((handOne - handTwo) == 0){\n			hands[0].send(1000000000000000000);\n			hands[1].send(1000000000000000000);\n			delete tickets[hands[0]];\n			delete tickets[hands[1]];\n			delete hands;\n		}\n	}\n	\n	function winner(address _address) internal {\n		_address.send(1980000000000000000);\n		address(0x2179987247aba70dc8a5bb0feafd4ef4b8f83797).send(20000000000000000);\n		delete tickets[hands[0]];\n		delete tickets[hands[1]];\n		delete hands;\n	}\n}",1,実用的なRPSゲームのスマートコントラクトで、特に芸術的な要素はありません。,
1374738,0x294308484f47ff5a833a284ac6949eb02728fbe4,false,false,,,,0x870fe80e76dae4a4c12690dec52456ab13176202
1375317,0x74c9163bbee99cd945873f0915e2ae8415bb82d5,false,false,,,,TOO_SHORT
1375862,0xf16818c3b0b418c796f4defccf04dfb729af926c,false,false,,,,TOO_SHORT
1376105,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb,false,false,"/*\n\n- Bytecode Verification performed was compared on second iteration -\n\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no ""premine"". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。DAOの機能を実装している。,
1376105,0x53ea271a1f4e9d99b0fa559b764afe9e7a04bb63,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1376105,0x819cea3c1b4c08789d827cb620f4899d9179af78,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1376686,0x87f1bde2cb5bb610bb282ce5038c3357e240a2b7,false,false,,,,TOO_SHORT
1377014,0xdf6bf80433e3a990b169ba60af85863b36185e70,false,false,,,,TOO_SHORT
1377261,0x0b8ae27b2c92b1cd950208d7d8522287333462c4,false,false,,,,TOO_SHORT
1377616,0xf63432d876f3ad728fd5a1f4d3bfb4e43414c5f5,false,false,,,,TOO_SHORT
1378096,0x5d80d597ef35e95fe22ada1a8a1c0ccc2471e1d3,false,false,,,,TOO_SHORT
1378181,0xc7f58349f86fff8c8008615591f620d0eaf8bb7f,false,false,,,,TOO_SHORT
1378185,0x8b98746974e7d0eef0ffd4ac5578b4ef9cc89aad,false,false,,,,TOO_SHORT
1378214,0x2df0907cd2909cf4799611dfe8e207e0adc6805e,false,false,,,,TOO_SHORT
1378358,0x463f821380ebec8c5f27b2ce4b150ae5f96ba65e,false,false,,,,TOO_SHORT
1378830,0xd2b8d21afe86a479d309eefcd23256be514f48ef,false,false,,,,TOO_SHORT
1378957,0x3ddb8784f60c723aa6b8ba76a3eea54776e1e821,false,false,,,,TOO_SHORT
1380384,0x38e668898c0941a20725a8cf02739480e475cb91,false,false,,,,TOO_SHORT
1380553,0xbfb9890b0de79e524ffd4c45bf96a85a8cfdec39,false,false,,,,TOO_SHORT
1380672,0x71e73f5f224402ad0833e1f95615a8b488d91fc0,false,false,,,,TOO_SHORT
1381070,0xa6ca071a242b09f11703af7e4a103a1523957567,false,false,,,,TOO_SHORT
1381698,0x269a5bdd14f38568a6ac7d8ea1420c289910caaa,false,false,,,,TOO_SHORT
1381836,0x5b56503b4cab9b2b7ade4a9921495faa8e83fcc4,false,false,,,,TOO_SHORT
1382249,0xc00d80b1d49ff4ef3c6c9098411523d2079bdfff,false,false,,,,TOO_SHORT
1383211,0xa3747ac2263376d84abed1d77ef56c5da428345f,false,false,,,,TOO_SHORT
1383345,0x7fc77bed597bf36d7dcecaf9d1c0d825b8acf85b,false,false,,,,TOO_SHORT
1383406,0x9ae7dc235ca6c849fe374d9dadc9d79e3e5ca8ee,false,false,,,,TOO_SHORT
1383747,0x2d415ca45c79e1b0a4e2819074bbcfbb85387532,false,false,,,,TOO_SHORT
1383753,0x114c844817bedd8417c14c6f226ce2f4dd5db6eb,false,false,,,,TOO_SHORT
1384103,0x9662958c46e481c020ddaf6ba06249bc1263b59f,false,false,,,,TOO_SHORT
1384144,0xb073851867b6b83cf076043d43fa497f04e21550,false,false,,,,TOO_SHORT
1384312,0x4cf1fb602758744fc8b782c948ae52fd85ed62e3,false,false,,,,TOO_SHORT
1384519,0xfd1d48ee72abbc69d2107e94faef3510f887cf8e,false,false,,,,TOO_SHORT
1384632,0x2cceb21e53f4eb9058e020d54305c37b908636ad,false,false,,,,TOO_SHORT
1385257,0xe7b87a6ad1fc1ff3e38ce691ea0ed1f119565b5c,false,false,,,,TOO_SHORT
1385381,0x7c4a690585ffe89c01aebfce188b9bec8def9e8d,false,false,"contract Honestgamble {\n    \n    //--parameters\n    uint private deposit = 10 ether; //only 10 ETH deposits accepted\n    uint private feeFrac = 10; //1% initially\n    uint constant time_max = 12 * 60 * 60; //12 hours in seconds\n    uint private first_prize = 130;\n    uint private second_prize = 110;\n    uint private third_prize = 60;\n    \n    //--ledger\n    uint private Balance = 0;\n    uint private fees = 0;  \n    uint private Payout_id = 0;\n    uint private number_of_players = 0;\n    \n    uint private last_time ;\n    \n    address private admin;\n    \n    function Honestgamble() {\n        admin = msg.sender;\n        last_time = block.timestamp;\n    }\n\n    modifier onlyowner {if (msg.sender == admin) _  }\n\n    struct Player {\n        address addr;\n        uint payout; //filled when round over, just for the stats\n        bool paid;\n    }\n\n    Player[] private players;\n\n    //--Fallback function\n    function() {\n        init();\n    }\n\n    //--initiated function\n    function init() private {\n        //------ Verifications on this new deposit ------\n        if (msg.value < deposit) { \n            msg.sender.send(msg.value);\n            return;\n        }\n        if(msg.value > deposit){\n            msg.sender.send(msg.value-deposit);\n        }\n        \n        //------ participate ------\n        Balance += (deposit * (1000 - feeFrac )) / 1000; //update balance\n        fees += (deposit * feeFrac) / 1000;          // collect 0.1% fees, thief :p\n\n    \n        last_time = block.timestamp;\n        players.push(Player(msg.sender,  0 , false));\n        number_of_players++;\n        \n        //-check if end of the round\n        if(number_of_players == 3){ //end of a round\n            Pay();\n        }\n    }\n    \n    function  Pay() private{\n         //---- source of randomness\n        uint256 toss = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp)); \n        //indices of players\n        uint i_13;\n        uint i_11;\n        uint i_6;\n        \n        if( toss % 3 == 0 ){\n            i_13=Payout_id;\n            i_11=Payout_id+1;\n            i_6 =Payout_id+2;\n        }\n        else if( toss % 3 == 1){\n            i_13=Payout_id+2;\n            i_11=Payout_id;\n            i_6 =Payout_id+1;\n        }\n        else{\n            i_13=Payout_id+1;\n            i_11=Payout_id+2;\n            i_6 =Payout_id;\n        }\n        uint256 bet=(deposit * (1000 - feeFrac )) / 1000;\n        players[i_13].addr.send(bet*first_prize/100); //gets you 13 ether ! it is good !\n        players[i_11].addr.send(bet*second_prize/100); //gets you 11 ether ! not bad !\n        players[i_6].addr.send(bet*third_prize/100); //gets you 6 ether, it is a loss, sorry !\n        \n        //update stats\n        players[i_13].payout=bet*first_prize/100;\n        players[i_11].payout=bet*second_prize/100;\n        players[i_6].payout=bet*third_prize/100;\n        players[Payout_id].paid=true;\n        players[Payout_id+1].paid=true;\n        players[Payout_id+2].paid=true;\n        Balance=0;\n        number_of_players=0;\n        Payout_id += 3;\n    }\n\n    \n    function CancelRoundAndRefundAll() { //refund every participants, anyone can call this !\n        if(number_of_players==0) return;\n        \n        if (last_time + time_max < block.timestamp) {\n            for(uint i=Payout_id; i<(Payout_id+number_of_players); i++){\n                players[i].addr.send((deposit * (1000 - feeFrac )) / 1000 );\n                players[i].paid=true;\n                players[i].payout=(deposit * (1000 - feeFrac )) / 1000; //everyone is refunded minus the fee, yeah i am evil.\n            }\n            Payout_id += number_of_players;\n            number_of_players=0;\n        }\n    }\n    \n    //---Contract informations\n    \n    \n    function WatchBalance() constant returns(uint TotalBalance, string info) {\n        TotalBalance = Balance /  1 finney;\n        info ='Balance in finney';\n    }\n    \n    function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n        if (id <= players.length) {\n            Address = players[id].addr;\n            Payout = (players[id].payout) / 1 finney;\n            UserPaid=players[id].paid;\n        }\n    }\n    \n    function WatchLastTime() constant returns(uint LastTimestamp) {\n        LastTimestamp = last_time;\n    }\n\n    function WatchCollectedFeesInSzabo() constant returns(uint Fees) {\n        Fees = fees / 1 szabo;\n    }\n    \n    function WatchAppliedFeePercentage() constant returns(uint FeePercent) {\n        FeePercent = feeFrac/10;\n    }\n    \n\n    function WatchNumberOfPlayerInCurrentRound() constant returns(uint N) {\n        N = number_of_players;\n    }\n    //---Contract management functions\n    \n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n    \n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        fees = 0;\n    }\n    \n    function CollectAndReduceFees(uint p) onlyowner {\n        if (fees == 0) feeFrac=feeFrac*50/100; //Reduce fees by half each call !.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1385693,0xd73026b0494d25427f3d1a7743babe1bddf8a035,false,false,,,,TOO_SHORT
1386015,0xfe70f7d0fe6ceb71d4fc0308322ffa6098043e43,false,false,"contract ERW {\n    string public EdgarRichardWunsche;\n    string public Parents;\n    string public DateOfBirth;\n    string public DateOfDeath;\n    string public Location;\n    \n    function ERW() {\n        EdgarRichardWunsche = ""Edgar Richard Wunsche (12.11.1930-22.04.2016). Rest in Peace Dad. Love Alan."";\n        DateOfBirth = ""12.11.1930"";\n        DateOfDeath = ""22.04.2016"";\n        Parents = ""Beloved son of Anna Wunsche (Moser) and Antonin Wunsche."";\n        Location = ""Toronto, Ontario, Canada"";\n    }\n\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}",2,故人への追悼を表現する詩的な要素が含まれているため。,
1386177,0x44cffa900ffc802086f58dd99418655de5b6e482,false,false,,,,TOO_SHORT
1386199,0x4e16344aa6fad1da6157ddfaf3b46d1c2de5a05e,false,false,,,,TOO_SHORT
1386216,0xf204f8842dea3f760cf8232bb82babdb885f2e02,false,false,,,,TOO_SHORT
1386623,0xa80c51db9639744f3d1195aaa8f3bfa0b09a1a64,false,false,,,,TOO_SHORT
1387871,0x6e4d6b840987a1f71b735a9164d0c4038c548f1d,false,false,,,,TOO_SHORT
1388141,0xf6adc8fc811559b3f193062f6343f893ee6eda1a,false,false,,,,TOO_SHORT
1388567,0xc26e33aa4543395a407142d7986f5fc29b4ef14c,false,false,,,,TOO_SHORT
1388689,0x2e75851a2504425d7dc03544eb98f1f8b11eeb51,false,false,,,,TOO_SHORT
1388892,0xae75f86310347e6ac11a6c2f4c93671d6d165d40,false,false,,,,TOO_SHORT
1389050,0xe7f42ea65466b34904ae9cbdbef6639a0755f815,false,false,,,,TOO_SHORT
1389155,0xf767fca8e65d03fe16d4e38810f5e5376c3372a8,false,false,"contract LuckyDoubler {\n//##########################################################\n//#### LuckyDoubler: A doubler with random payout order ####\n//#### Deposit 1 ETHER to participate                   ####\n//##########################################################\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n\n    address private owner;\n    \n    //Stored variables\n    uint private balance = 0;\n    uint private fee = 5;\n    uint private multiplier = 125;\n\n    mapping (address => User) private users;\n    Entry[] private entries;\n    uint[] private unpaidEntries;\n    \n    //Set owner on contract creation\n    function LuckyDoubler() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    struct User {\n        address id;\n        uint deposits;\n        uint payoutsReceived;\n    }\n    \n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        bool paid;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    function init() private{\n        \n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n        \n        join();\n    }\n    \n    function join() private {\n        \n        //Limit deposits to 1ETH\n        uint dValue = 1 ether;\n        \n        if (msg.value > 1 ether) {\n            \n        	msg.sender.send(msg.value - 1 ether);	\n        	dValue = 1 ether;\n        }\n      \n        //Add new users to the users array\n        if (users[msg.sender].id == address(0))\n        {\n            users[msg.sender].id = msg.sender;\n            users[msg.sender].deposits = 0;\n            users[msg.sender].payoutsReceived = 0;\n        }\n        \n        //Add new entry to the entries array\n        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\n        users[msg.sender].deposits++;\n        unpaidEntries.push(entries.length -1);\n        \n        //Collect fees and update contract balance\n        balance += (dValue * (100 - fee)) / 100;\n        \n        uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;\n        Entry theEntry = entries[unpaidEntries[index]];\n        \n        //Pay pending entries if the new balance allows for it\n        if (balance > theEntry.payout) {\n            \n            uint payout = theEntry.payout;\n            \n            theEntry.entryAddress.send(payout);\n            theEntry.paid = true;\n            users[theEntry.entryAddress].payoutsReceived++;\n\n            balance -= payout;\n            \n            if (index < unpaidEntries.length - 1)\n                unpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1];\n           \n            unpaidEntries.length--;\n            \n        }\n        \n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint fees = this.balance - balance;\n        if (fees > 0)\n        {\n                owner.send(fees);\n        }      \n       \n    }\n    \n    //Generate random number between 0 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n    \n        return uint256((uint256(hashVal) / factor)) % max;\n    }\n    \n    \n    //Contract management\n    function changeOwner(address newOwner) onlyowner {\n        owner = newOwner;\n    }\n    \n    function changeMultiplier(uint multi) onlyowner {\n        if (multi < 110 || multi > 150) throw;\n        \n        multiplier = multi;\n    }\n    \n    function changeFee(uint newFee) onlyowner {\n        if (fee > 5) \n            throw;\n        fee = newFee;\n    }\n    \n    \n    //JSON functions\n    function multiplierFactor() constant returns (uint factor, string info) {\n        factor = multiplier;\n        info = 'The current multiplier applied to all deposits. Min 110%, max 150%.'; \n    }\n    \n    function currentFee() constant returns (uint feePercentage, string info) {\n        feePercentage = fee;\n        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).';\n    }\n    \n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = 'The number of deposits.';\n    }\n    \n    function userStats(address user) constant returns (uint deposits, uint payouts, string info)\n    {\n        if (users[user].id != address(0x0))\n        {\n            deposits = users[user].deposits;\n            payouts = users[user].payoutsReceived;\n            info = 'Users stats: total deposits, payouts received.';\n        }\n    }\n    \n    function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info)\n    {\n        if (index < entries.length) {\n            user = entries[index].entryAddress;\n            payout = entries[index].payout / 1 finney;\n            paid = entries[index].paid;\n            info = 'Entry info: user address, expected payout in Finneys, payout status.';\n        }\n    }\n    \n    \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1389180,0x084f542c4d41764330be8f85087cdb4f69966a62,false,false,,,,TOO_SHORT
1389376,0x65e0b64a6d2f57af939a3978ed52f7bbb3bf21cb,false,false,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n    contract Nexium { \n        /* Public variables of the token */\n        string public name;\n        string public symbol;\n        uint8 public decimals;\n\n        /* This creates an array with all balances */\n        mapping (address => uint256) public balanceOf;\n        mapping (address => mapping (address => uint)) public allowance;\n        mapping (address => mapping (address => uint)) public spentAllowance;\n\n        /* This generates a public event on the blockchain that will notify clients */\n        event Transfer(address indexed from, address indexed to, uint256 value);\n\n        /* Initializes contract with initial supply tokens to the creator of the contract */\n        function Nexium() {\n            balanceOf[msg.sender] = 100000000000;              // Give the creator all initial tokens                    \n            name = 'Nexium';                                   // Set the name for display purposes     \n            symbol = 'NxC';                               // Set the symbol for display purposes    \n            decimals = 3;                            // Amount of decimals for display purposes        \n        }\n\n        /* Send coins */\n        function transfer(address _to, uint256 _value) {\n            if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough   \n            if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n            balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n            balanceOf[_to] += _value;                            // Add the same to the recipient            \n            Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        }\n\n        /* Allow another contract to spend some tokens in your behalf */\n\n        function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n            allowance[msg.sender][_spender] = _value;     \n            tokenRecipient spender = tokenRecipient(_spender);\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n			\n			return true;\n        }\n\n        /* A contract attempts to get the coins */\n\n        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n            if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough   \n            if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n            if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw;   // Check allowance\n            balanceOf[_from] -= _value;                          // Subtract from the sender\n            balanceOf[_to] += _value;                            // Add the same to the recipient            \n            spentAllowance[_from][msg.sender] += _value;\n            Transfer(msg.sender, _to, _value); \n			\n			return true;\n        } \n\n        /* This unnamed function is called whenever someone tries to send ether to it */\n        function () {\n            throw;     // Prevents accidental sending of ether\n        }        \n    }",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1389466,0xf3fd10ab0aecab88ea6eff7ec5e8cc9c9a5f84e2,false,false,,,,TOO_SHORT
1389467,0xc5151848107ea4bc3e108d3f19fc14b53b69bb24,false,false,,,,TOO_SHORT
1389480,0xf447f93e6b7466b07292e3c2b89eca3520befe92,false,false,,,,TOO_SHORT
1389684,0x85114d0d45161c2f6989c7bb573988034227de97,false,false,,,,TOO_SHORT
1390020,0x5031cd8ba1411e397ce4ae2d8c4df8cc06fec0e0,false,false,,,,TOO_SHORT
1390124,0x22f157265eec2eb2fb6cc2625a84e274959a66d9,false,false,,,,TOO_SHORT
1390146,0xbabe204dbfc6381fc99c669351cdcda0d89f927a,false,false,,,,TOO_SHORT
1390147,0x327f0251760fbadea2ecbc38150adfbeebc570be,false,false,,,,TOO_SHORT
1390240,0xfd2dfa00ba5941958eaec567e59b42c2aa9dbf70,false,false,"contract Ethereum_twelve_bagger\n{\n\nstring[24] hexComparison;							//declares global variables\nstring hexcomparisonchr;\nstring A;\nuint8 i;\nuint8 lotteryticket;\naddress creator;\nint lastgainloss;\nstring lastresult;\nuint lastblocknumberused;\nbytes32 lastblockhashused;\nuint8 hashLastNumber;\naddress player;\nuint8 result;\nuint128 wager; \n \n \n\n   function  Ethereum_twelve_bagger() private \n    { \n        creator = msg.sender; 								\n    }\n\n  function Set_your_game_number(string Set_your_game_number)			//sets game number\n {	result=0;\n    	A=Set_your_game_number;\n     	uint128 wager = uint128(msg.value); \n	comparisonchr(A);\n	if(i>=16)//Changes capital letters to small letters\n	{i-=6;}\n 	checkBet();\n	returnmoneycreator(result,wager);\n}\n\n \n\n    function comparisonchr(string A) private					//changes stringhex input to base ten\n    {    hexComparison= [""0"", ""1"", ""2"", ""3"", ""4"",""5"",""6"",""7"",""8"",""9"",""a"",""b"",""c"",""d"",""e"",""f"",""A"",""B"",""C"",""D"",""E"",""F"",""K"",""N.A.""];\n	for (i = 0; i < 24; i ++) \n{\n\n	hexcomparisonchr=hexComparison[i];\n\n    \n\n	bytes memory a = bytes(hexcomparisonchr);\n 	bytes memory b = bytes(A);\n        \n          \n        \n          if (a[0]==b[0])\n              return ;\n\n}}\n\n\n \n\n	function checkBet() private\n\n { \n	lotteryticket=i;\n	player=msg.sender;\n        \n                \n    \n  		  \n    	if((msg.value * 12) > this.balance) 					// contract has to have 12*wager funds to be able to pay out. (current balance includes the wager sent)\n    	{\n    		lastresult = ""Bet is larger than games's ability to pay"";\n    		lastgainloss = 0;\n    		msg.sender.send(msg.value); // return wager\n    		return;\n    	}\n    	else if (msg.value == 0)\n    	{\n    		lastresult = ""Wager was zero"";\n    		lastgainloss = 0;\n    		// nothing wagered, nothing returned\n    		return;\n    	}\n    		\n    	uint128 wager = uint128(msg.value);          				// limiting to uint128 guarantees that conversion to int256 will stay positive\n    	\n    	lastblocknumberused = (block.number-1)  ;				//Last available blockhash is in the previous block\n    	lastblockhashused = block.blockhash(lastblocknumberused);		//Cheks the last available blockhash\n\n    	\n    	hashLastNumber=uint8(lastblockhashused & 0xf);				//Changes blockhash's last number to base ten\n\n   	 if(lotteryticket==18)							//Checks that input is 0-9 or a-f\n	{\n	lastresult = ""give a character between 0-9 or a-f"";\n	msg.sender.send(msg.value);\n	return;\n	}\n\n	else if (lotteryticket==16 && msg.sender == creator)			//Creator can kill contract. Contract does not hold players money.\n	{\n		suicide(creator);} \n\n	else if(lotteryticket != hashLastNumber)\n	{\n	    	lastgainloss = int(wager) * -1;\n	    	lastresult = ""Loss"";\n	    	result=1;\n	    									// Player lost. Return nothing.\n	    	return;\n	}\n	    else if(lotteryticket==hashLastNumber)\n	{\n	    	lastgainloss =(12*wager);\n	    	lastresult = ""Win!"";\n	    	msg.sender.send(wager * 12);  					// Player won. Return bet and winnings.\n	} 	\n    }\n\n	function returnmoneycreator(uint8 result,uint128 wager) private		//If game has over 50 eth, contract will send all additional eth to owner\n	{\n	if (result==1&&this.balance>50000000000000000000)\n	{creator.send(wager);\n	return; \n	}\n \n	else if\n	(\n	result==1&&this.balance>20000000000000000000)				//If game has over 20 eth, contract will send œ of any additional eth to owner\n	{creator.send(wager/2);\n	return; }\n	}\n \n/**********\nfunctions below give information about the game in Ethereum Wallet\n **********/\n \n 	function Results_of_the_last_round() constant returns (string last_result,string Last_player_s_lottery_ticket,address last_player,string The_right_lottery_number,int Player_s_gain_or_Loss_in_Wei,string info)\n    { \n   	last_player=player;	\n	Last_player_s_lottery_ticket=hexcomparisonchr;\n	The_right_lottery_number=hexComparison[hashLastNumber];\n	last_result=lastresult;\n	Player_s_gain_or_Loss_in_Wei=lastgainloss;\n	info = ""The right lottery number is the last character of the most recent blockhash available during the game. One Eth is 10**18 Wei."";\n	\n \n    }\n\n 	function Last_block_number_and_blockhash_used() constant returns (uint last_blocknumber_used,bytes32 last_blockhash_used)\n    {\n        last_blocknumber_used=lastblocknumberused;\n	last_blockhash_used=lastblockhashused;\n\n\n    }\n    \n   \n	function Game_balance_in_Ethers() constant returns (uint balance, string info)\n    { \n        info = ""Game balance is shown in full Ethers"";\n    	balance=(this.balance/10**18);\n\n    }\n    \n   \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1390436,0xbb31bc3aeb4ca9663deac87324ada7941ca3e2ce,false,false,,,,TOO_SHORT
1390445,0x40bc166953480b1676dbb390242c3965de88b87d,false,false,,,,TOO_SHORT
1390556,0x741a07e8072eef919f5d23d2f47c84ea3680d4dd,false,false,,,,TOO_SHORT
1390557,0x185df051eab6308827dd99570a06bcf01bff4b3e,false,false,,,,TOO_SHORT
1390564,0x7c2d975e63361a10a93ddc22799a764af81c8a19,false,false,,,,TOO_SHORT
1390575,0x8e0b5945d86cfda55dc7cabd377a8e1b341c640d,false,false,,,,TOO_SHORT
1390685,0xa643a6cfc95fb163dc8e94af0d9eedb8a6e89892,false,false,"contract cEthereumlotteryNet {\n	/*\n		cEthereumlotteryNet\n		Coded by: iFA\n		http://c.ethereumlottery.net\n		ver: 2.0.0\n	*/\n	address owner;\n	bool private contractEnabled = true;\n	uint public constant ticketPrice = 10 finney;\n	uint private constant defaultJackpot = 100 ether;\n	uint private constant feep = 23;\n	uint private constant hit3p = 35;\n	uint private constant hit4p = 25;\n	uint private constant hit5p = 40;\n	uint8 private constant maxNumber = 30;\n	uint private constant drawCheckStep = 100;\n	uint private constant prepareBlockDelay = 5;\n	uint private drawDelay = 7 days;\n	uint private feeValue;\n\n	struct hits_s {\n		uint prize;\n		uint count;\n	}\n	\n	enum drawStatus_ { Wait, Prepared ,InProcess, Done }\n	\n	struct tickets_s {\n		uint hits;\n		bytes5 numbers;\n	}\n	\n	struct games_s {\n		uint startTime;\n		uint endTime;\n		uint jackpot;\n		uint8[5] winningNumbers;\n		mapping (uint => hits_s) hits;\n		uint prizePot;\n		drawStatus_ drawStatus;\n		bytes32 winHash;\n		mapping (uint => tickets_s) tickets;\n		uint ticketsCount;\n		uint checkedTickets;\n		bytes32 nextHashOfSecretKey;\n		uint prepareDrawBlock;\n	}\n	\n	mapping(uint => games_s) private games;\n	\n	uint public CurrentGameId = 0;\n	\n	struct player_s {\n		bool paid;\n		uint[] tickets;\n	}\n	\n	mapping(address => mapping(uint => player_s)) private players;\n	uint private playersSize;\n	\n	string constant public Information = ""http://c.ethereumlottery.net"";\n	\n	function ContractStatus() constant returns (bool Enabled) {\n		Enabled = contractEnabled;\n	}\n	function GameDetails(uint GameId) constant returns ( uint StartTime, uint EndTime, uint Jackpot, uint TicketsCount) {\n		Jackpot = games[GameId].jackpot;\n		TicketsCount = games[GameId].ticketsCount;\n		StartTime = games[GameId].startTime;\n		EndTime = games[GameId].endTime;\n	}\n	function DrawDetails(uint GameId) constant returns (\n		string DrawStatus, bytes32 WinHash, uint8[5] WinningNumbers,\n		uint Hit3Count, uint Hit4Count, uint Hit5Count,\n		uint Hit3Prize, uint Hit4Prize, uint Hit5Prize) {\n		DrawStatus = WritedrawStatus(games[GameId].drawStatus);\n		if (games[GameId].drawStatus != drawStatus_.Wait) {\n			WinningNumbers = games[GameId].winningNumbers;\n			Hit3Count = games[GameId].hits[3].count;\n			Hit4Count = games[GameId].hits[4].count;\n			Hit5Count = games[GameId].hits[5].count;\n			Hit3Prize = games[GameId].hits[3].prize;\n			Hit4Prize = games[GameId].hits[4].prize;\n			Hit5Prize = games[GameId].hits[5].prize;\n			WinHash = games[GameId].winHash;\n		} else {\n			WinningNumbers = [0,0,0,0,0];\n			Hit3Count = 0;\n			Hit4Count = 0;\n			Hit5Count = 0;\n			Hit3Prize = 0;\n			Hit4Prize = 0;\n			Hit5Prize = 0;\n			WinHash = 0;\n		}\n	}\n	function CheckTickets(address Address,uint GameId,uint TicketNumber) constant returns (uint8[5] Numbers, uint Hits, bool Paid) {\n		if (players[Address][GameId].tickets[TicketNumber] > 0) {\n			Numbers[0] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) /256/256/256/256);\n			Numbers[1] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) /256/256/256);\n			Numbers[2] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) /256/256);\n			Numbers[3] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) /256);\n			Numbers[4] = uint8(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers);\n			Numbers = sortWinningNumbers(Numbers);\n			Hits = games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].hits;\n			Paid = players[Address][GameId].paid;\n		}\n	}\n	function CheckPrize(address Address, uint GameId) constant returns(uint Value) {\n		if (players[Address][GameId].paid == false) {\n		    if (contractEnabled) { \n    			if (games[GameId].drawStatus == drawStatus_.Done) {\n    				for (uint b = 0 ; b < players[Address][GameId].tickets.length ; b++) {\n    					if (games[GameId].tickets[players[Address][GameId].tickets[b]].hits == 3){\n    						Value += games[GameId].hits[3].prize;\n    					} else if (games[GameId].tickets[players[Address][GameId].tickets[b]].hits == 4){\n    						Value += games[GameId].hits[4].prize;\n    					} else if (games[GameId].tickets[players[Address][GameId].tickets[b]].hits == 5){\n    						Value += games[GameId].hits[5].prize;\n    					}\n    				}\n    			}\n		    } else {\n    		    if (GameId == CurrentGameId) {\n    		        Value = players[msg.sender][GameId].tickets.length * ticketPrice;\n    		    }\n		    }\n		}\n	}\n	function cEthereumlotteryNet() {\n		owner = msg.sender;\n		CreateNewDraw(defaultJackpot);\n	}\n	function GetPrize(uint GameId) external {\n		uint Balance;\n		uint GameBalance;\n		if (players[msg.sender][GameId].paid == false) {\n    		if (contractEnabled) { \n    		    if (games[GameId].drawStatus != drawStatus_.Done) { throw; }\n        		for (uint b = 0 ; b < players[msg.sender][GameId].tickets.length ; b++) {\n        			if (games[GameId].tickets[players[msg.sender][GameId].tickets[b]].hits == 3){\n        				Balance += games[GameId].hits[3].prize;\n        			} else if (games[GameId].tickets[players[msg.sender][GameId].tickets[b]].hits == 4){\n        				Balance += games[GameId].hits[4].prize;\n        			} else if (games[GameId].tickets[players[msg.sender][GameId].tickets[b]].hits == 5){\n        				Balance += games[GameId].hits[5].prize;\n        			}\n        		}\n        		players[msg.sender][GameId].paid = true;\n        		games[GameId].prizePot -= Balance;\n    		} else {\n    		    if (GameId == CurrentGameId) {\n    		        Balance = players[msg.sender][GameId].tickets.length * ticketPrice;\n    		        players[msg.sender][GameId].paid = true;\n    		    }\n    		}\n		}\n		if (Balance > 0) {\n			if (msg.sender.send(Balance) == false) { throw; }\n		} else {\n			throw;\n		}\n	}\n	function AddTicket(bytes5[] tickets) OnlyEnabled IfInTime IfDrawWait external {\n		uint ticketsCount = tickets.length;\n		if (ticketsCount > 70 || ticketsCount == 0) { throw; }\n		if (msg.value < ticketsCount * ticketPrice) { throw; }\n		if (msg.value > (ticketsCount * ticketPrice)) { if (msg.sender.send(msg.value - (ticketsCount * ticketPrice)) == false) { throw; } }\n		for (uint a = 0 ; a < ticketsCount ; a++) {\n			if (!CheckNumbers(ConvertNumbers(tickets[a]))) { throw; }\n			games[CurrentGameId].tickets[games[CurrentGameId].ticketsCount].numbers = tickets[a];\n			players[msg.sender][CurrentGameId].tickets.length += 1;\n			players[msg.sender][CurrentGameId].tickets[players[msg.sender][CurrentGameId].tickets.length-1] = games[CurrentGameId].ticketsCount;\n			games[CurrentGameId].ticketsCount++;\n		}\n	}\n	function () {\n		throw;\n	}\n	function ProcessDraw() OnlyEnabled IfDrawProcess {\n		uint StepCount = drawCheckStep;\n		if (games[CurrentGameId].checkedTickets < games[CurrentGameId].ticketsCount) {\n			for (uint a = games[CurrentGameId].checkedTickets ; a < games[CurrentGameId].ticketsCount ; a++) {\n				if (StepCount == 0) { break; }\n				for (uint b = 0 ; b < 5 ; b++) {\n					for (uint c = 0 ; c < 5 ; c++) {\n						if (uint8(uint40(games[CurrentGameId].tickets[a].numbers) / (256**b)) == games[CurrentGameId].winningNumbers[c]) {\n							games[CurrentGameId].tickets[a].hits += 1;\n						}\n					}\n				}\n				games[CurrentGameId].checkedTickets += 1;\n				StepCount -= 1;\n			}\n		}\n		if (games[CurrentGameId].checkedTickets == games[CurrentGameId].ticketsCount) {\n			for (a = 0 ; a < games[CurrentGameId].ticketsCount ; a++) {\n				if (games[CurrentGameId].tickets[a].hits == 3) {\n					games[CurrentGameId].hits[3].count +=1;\n				} else if (games[CurrentGameId].tickets[a].hits == 4) {\n					games[CurrentGameId].hits[4].count +=1;\n				} else if (games[CurrentGameId].tickets[a].hits == 5) {\n					games[CurrentGameId].hits[5].count +=1;\n				}\n			}\n			if (games[CurrentGameId].hits[3].count > 0) { games[CurrentGameId].hits[3].prize = games[CurrentGameId].prizePot * hit3p / 100 / games[CurrentGameId].hits[3].count; }\n			if (games[CurrentGameId].hits[4].count > 0) { games[CurrentGameId].hits[4].prize = games[CurrentGameId].prizePot * hit4p / 100 / games[CurrentGameId].hits[4].count; }\n			if (games[CurrentGameId].hits[5].count > 0) { games[CurrentGameId].hits[5].prize = games[CurrentGameId].jackpot / games[CurrentGameId].hits[5].count; }\n			uint NextJackpot;\n			if (games[CurrentGameId].hits[5].count == 0) {\n				NextJackpot = games[CurrentGameId].prizePot * hit5p / 100 + games[CurrentGameId].jackpot;\n			} else {\n				NextJackpot = defaultJackpot;\n			}\n			games[CurrentGameId].prizePot = (games[CurrentGameId].hits[3].count*games[CurrentGameId].hits[3].prize) + (games[CurrentGameId].hits[4].count*games[CurrentGameId].hits[4].prize) + (games[CurrentGameId].hits[5].count*games[CurrentGameId].hits[5].prize);\n			games[CurrentGameId].drawStatus = drawStatus_.Done;\n			CreateNewDraw(NextJackpot);\n		}\n	}\n	function StartDraw() external OnlyEnabled IfDrawPrepared {\n		if (games[CurrentGameId].prepareDrawBlock > block.number) { throw; }\n		games[CurrentGameId].drawStatus = drawStatus_.InProcess;\n		games[CurrentGameId].winHash = makeHash();\n		games[CurrentGameId].winningNumbers = sortWinningNumbers(GetNumbersFromHash(games[CurrentGameId].winHash));\n		feeValue += ticketPrice * games[CurrentGameId].ticketsCount * feep / 100;\n		games[CurrentGameId].prizePot = ticketPrice * games[CurrentGameId].ticketsCount - feeValue;\n		ProcessDraw();\n	}\n	function PrepareDraw() external OnlyEnabled ReadyForDraw {\n		if (games[CurrentGameId].ticketsCount > 0) {\n			games[CurrentGameId].drawStatus = drawStatus_.Prepared;\n			games[CurrentGameId].prepareDrawBlock = block.number + prepareBlockDelay;\n		} else {\n			if (!contractEnabled) { throw; }\n			games[CurrentGameId].endTime = calcNextDrawTime();\n		}\n	}\n	function OwnerCloseContract() external OnlyOwner OnlyEnabled {\n		contractEnabled = false;\n		uint contractbalance = this.balance;\n		for (uint a=0 ; a <= CurrentGameId ; a++) {\n			contractbalance -= games[a].prizePot;\n		}\n		contractbalance -= games[CurrentGameId].ticketsCount * ticketPrice;\n		if (contractbalance == 0 ) { throw; }\n		if (owner.send(contractbalance) == false) { throw; }\n		feeValue = 0;\n	}\n	function OwnerAddFunds() external OnlyOwner {\n		return;\n	}\n	function OwnerGetFee() external OnlyOwner {\n		if (feeValue == 0) { throw; }\n		if (owner.send(feeValue) == false) { throw; }\n		feeValue = 0;\n	}\n	function CreateNewDraw(uint Jackpot) private {\n		CurrentGameId += 1;\n		games[CurrentGameId].startTime = now;\n		games[CurrentGameId].endTime = calcNextDrawTime();\n		games[CurrentGameId].jackpot = Jackpot;\n		games[CurrentGameId].drawStatus = drawStatus_.Wait;\n	}\n	function ConvertNumbers(bytes5 input) private returns (uint8[5] output){\n		output[0] = uint8(uint40(input) /256/256/256/256);\n		output[1] = uint8(uint40(input) /256/256/256);\n		output[2] = uint8(uint40(input) /256/256);\n		output[3] = uint8(uint40(input) /256);\n		output[4] = uint8(input);\n	}\n	function CheckNumbers(uint8[5] tickets) private returns (bool ok) {\n		for (uint8 a = 0 ; a < 5 ; a++) {\n			if ((tickets[a] < 1 ) || (tickets[a] > maxNumber)) { return false; }\n			for (uint8 b = 0 ; b < 5 ; b++) { if ((tickets[a] == tickets[b]) && (a != b)) {	return false; }	}\n		}\n		return true;\n	}\n	function GetNumbersFromHash(bytes32 hash) private returns (uint8[5] tickets) {\n		bool ok = true;\n		uint8 num = 0;\n		uint hashpos = 0;\n		uint8 a;\n		for (a = 0 ; a < 5 ; a++) {\n			while (true) {\n				ok = true;\n				if (hashpos == 32) {\n					hashpos = 0;\n					hash = sha3(hash);\n				}\n				num = GetPart(hash,hashpos);\n				num = num%maxNumber+1;\n				hashpos += 1;\n				for (uint8 b = 0 ; b < 5 ; b++) {\n					if (tickets[b] == num) {\n						ok = false;\n						break; \n					}\n				}\n				if (ok == true) {\n					tickets[a] = num;\n					break;\n				}\n			}\n		}\n	}\n	function GetPart(bytes32 a, uint i) private returns (uint8) { return uint8(byte(bytes32(uint(a) * 2 ** (8 * i)))); }\n	function WritedrawStatus(drawStatus_ input) private returns (string drawStatus) {\n		if (input == drawStatus_.Wait) {\n			drawStatus = ""Wait"";\n		} else if (input == drawStatus_.InProcess) {\n			drawStatus = ""In Process"";\n		} else if (input == drawStatus_.Done) {\n			drawStatus = ""Done"";\n		} else if (input == drawStatus_.Prepared) {\n			drawStatus = ""Prepared"";\n		}\n	}\n	function sortWinningNumbers(uint8[5] numbers) private returns(uint8[5] sortednumbers) {\n		sortednumbers = numbers;\n		for (uint8 i=0; i<5; i++) {\n			for (uint8 j=i+1; j<5; j++) {\n				if (sortednumbers[i] > sortednumbers[j]) {\n					uint8 t = sortednumbers[i];\n					sortednumbers[i] = sortednumbers[j];\n					sortednumbers[j] = t;\n				}\n			}\n		}\n	}\n	function makeHash() private returns (bytes32 hash) {\n		for ( uint a = 0 ; a <= prepareBlockDelay ; a++ ) {\n			hash = sha3(hash, games[CurrentGameId].prepareDrawBlock - a);\n		}\n		hash = sha3(hash, block.difficulty, block.coinbase, block.timestamp, tx.origin, games[CurrentGameId].ticketsCount);\n	}\n	function calcNextDrawTime() private returns (uint ret) {\n		ret = 1461499200; // 2016.04.24 12:00:00\n		while (ret < now) {\n			ret += drawDelay;\n		}\n	}\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if (!contractEnabled) { throw; } _	}\n	modifier IfDrawWait() { if (games[CurrentGameId].drawStatus != drawStatus_.Wait) { throw; } _	}\n	modifier IfDrawPrepared() { if (games[CurrentGameId].drawStatus != drawStatus_.Prepared) { throw; } _	}\n	modifier IfDrawProcess() { if (games[CurrentGameId].drawStatus != drawStatus_.InProcess) { throw; } _	}\n	modifier IfInTime() { if (games[CurrentGameId].endTime < now) { throw; } _ }\n	modifier ReadyForDraw() { if (games[CurrentGameId].endTime > now || games[CurrentGameId].drawStatus != drawStatus_.Wait) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1391102,0x933e56d1e19125f3e6bb96c10997b1b88f8f31c9,false,false,,,,TOO_SHORT
1391226,0x0f9ced9e23128d309e5d35d91219e30f4cd19fba,false,false,,,,TOO_SHORT
1391334,0xd5e9b96eb4e293ad775bf575c135aad763b88abe,false,false,,,,TOO_SHORT
1391546,0x4e37bcd2f608f0904c2ace030908094d067c6b0c,false,false,,,,TOO_SHORT
1391876,0xec5c08ef7cba3dc551fa2265c48571a6a11ea76e,false,false,,,,TOO_SHORT
1391959,0xba13381e6085589d23a0707ea9f45db62459ec05,false,false,,,,TOO_SHORT
1392123,0xa5ae02d691b553eda79eb020f1cf6fabc32e9972,false,false,,,,TOO_SHORT
1392521,0xee533d2df5c8da8d65f19f7fd89272a702fef520,false,false,,,,TOO_SHORT
1392671,0xef950e116f970cb15cc20d7f8242d1a91e8a71e9,false,false,,,,TOO_SHORT
1393025,0xa7f3842de225b51ee206f7f916bf5796bac6cd71,false,false,,,,TOO_SHORT
1393599,0x2e69854dac26b418e98a3dc156de72f8908dac26,false,false,,,,TOO_SHORT
1394102,0xb7a4e3b47c918d39e21277898642e1b8776c6991,false,false,,,,TOO_SHORT
1394185,0x0405fcc0bfe94f955ef34029ad4e02e93f31be40,false,false,,,,TOO_SHORT
1394399,0xaa0b7bd663fd6b7f20b24878bc8578415999994f,false,false,,,,TOO_SHORT
1394448,0x495abb32ca65092e0dcae89669d20fbc7b817be2,false,false,,,,TOO_SHORT
1394700,0x97f120771fdcebcbec0f1161378313292e0ca37a,false,false,,,,TOO_SHORT
1395106,0x64ebf88458f216670b89d13e9d98251689a4ae3b,false,false,,,,TOO_SHORT
1395127,0xa2767c302f434a73da4428550f4aa4c1033257ea,false,false,,,,TOO_SHORT
1395268,0x2f88f00fbcc4d5da96ef5fed56dbf96be391dc04,false,false,,,,TOO_SHORT
1395331,0x79a1c176480a8ad9e030b7ad4c198bce98ebf134,false,false,,,,TOO_SHORT
1395433,0xc33821e9c33dce30a016f38d653a34d1bc863293,false,false,,,,TOO_SHORT
1395450,0x268d048764d65e200f367549bff5c7b04b7ad810,false,false,,,,TOO_SHORT
1395453,0xefc580732d2e6118aef6d8ba519351e11cf83c97,false,false,,,,TOO_SHORT
1395611,0x3a1bbffe6883593524b9cd260fe1ba680e736027,false,false,,,,TOO_SHORT
1395624,0xa688660eecb9701244fb3e38121fd71fa55f51ea,false,false,,,,TOO_SHORT
1395742,0x5f67b6def46368a4c9940a164e7c7f943a8e2edc,false,false,,,,TOO_SHORT
1395877,0xd9b2028a1f746373cc45dacfd4328231c9055277,false,false,,,,TOO_SHORT
1396172,0x050e68e79fcf4d7ce581cff0838b6c5f792f20c7,false,false,,,,TOO_SHORT
1396264,0x4dbe908d494a1d2e7481cb49d07dece6ef8ec901,false,false,,,,TOO_SHORT
1396561,0x83051e225a06682ff0dde9bcd267d8418c4cbcd7,false,false,"contract ParallelGambling {\n    \n    //--------parameters\n    uint[3] private deposit;\n    uint private feesThousandth = 10;       //1% of fees !\n    uint private time_max = 6 * 60 * 60;   //6 hours in seconds, time to wait before you can cancel the round\n    uint private fees = 0; \n    \n    //percentage of attribution of differents prizes\n    uint private first_prize = 170;     //Big winner gets 160 %\n    uint private second_prize = 130;    //Little winner gets 140 %\n    uint private third_prize = 0;       //looser gets nothing !\n    \n    //--Contract ledger for the 3 ""play zones""\n    \n    uint[3] private Balance;\n    uint[3] private id;\n    uint[3] private cursor;\n    uint[3] private nb_player ;\n    uint[3] private last_time ;\n    \n    // -- random uniformers -\n	uint256 private toss1;\n	uint256 private toss2;\n	\n	\n    address private admin;\n    \n    //Constructor - executed on creation only\n    function ParallelGambling() {\n        admin = msg.sender;\n        uint i;\n        //*****initiate everything properly****\n        for(i=0;i<3;i++){\n            Balance[i]=0;\n            last_time[i] = block.timestamp;\n            nb_player[i]=0;\n            id[i]=0;\n			cursor[i]=0;\n        }\n        deposit[0]= 100 finney; // ZONE 1\n        deposit[1]= 1 ether;    // ZONE 2\n        deposit[2]= 5 ether;    // ZONE 3\n    }\n\n    modifier onlyowner {if (msg.sender == admin) _  }\n\n    \n    struct Player { //for each entry\n        address addr;\n        uint payout; //this section is filled when payout are done !\n        bool paid;\n    }\n    \n    Player[][3] private players;\n	\n	\n	struct GamblerStats { //for each address, to keep a record\n		uint bets;\n		uint deposits;\n		uint paid;\n	}\n	mapping(address => GamblerStats) private gamblers;\n\n    \n    function() {\n        init();\n    }\n\n    \n    function init() private {\n        //------ Verifications to select play zone-----\n        uint256 actual_deposit = msg.value;\n        uint zone_selected;\n        \n        if (actual_deposit < deposit[0]) { //not enough for any zones !\n            msg.sender.send(actual_deposit);\n            return;\n        }\n        if(actual_deposit >= deposit[0] && actual_deposit < deposit[1]){   // GAME ZONE 1\n			if( actual_deposit-deposit[0] >0){\n				msg.sender.send(actual_deposit-deposit[0]);\n			}\n            actual_deposit=deposit[0];\n            zone_selected=0;\n        }\n        if(actual_deposit >= deposit[1] && actual_deposit < deposit[2]){   // GAME ZONE 2\n			if( actual_deposit-deposit[1] >0){\n				msg.sender.send(actual_deposit-deposit[1]);\n			}\n            actual_deposit=deposit[1];\n            zone_selected=1;\n        }\n        if(actual_deposit >= deposit[2]){                             // GAME ZONE 3\n			if( actual_deposit-deposit[2] >0){\n				msg.sender.send(actual_deposit-deposit[2]);\n			}\n            actual_deposit=deposit[2];\n            zone_selected=2;\n        }\n        \n        //----update balances and ledger according to the playing zone selected---\n        \n        fees += (actual_deposit * feesThousandth) / 1000;      // collect 1% fee\n        Balance[zone_selected] += (actual_deposit * (1000 - feesThousandth )) / 1000; //update balance\n        \n        last_time[zone_selected] = block.timestamp;\n        \n        players[zone_selected].length++;\n        players[zone_selected][cursor[zone_selected]]=(Player(msg.sender,  0 , false));\n		cursor[zone_selected]++;\n        nb_player[zone_selected]++;\n		\n		//update stats\n		gamblers[msg.sender].bets++;\n		gamblers[msg.sender].deposits += actual_deposit;\n		\n		//random\n		if(nb_player[zone_selected]%2 ==0)	toss1 = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp));\n		else toss2 = uint256(sha3(tx.gasprice+block.difficulty)); \n        \n        //-check if end of the round\n        if(nb_player[zone_selected] == 3){ //end of a round\n            EndRound(zone_selected);\n        }\n    }\n    \n    function EndRound(uint zone) private{\n        \n        //randomness is created here from previous toss\n        uint256 toss = toss1+toss2+msg.value; //send a value higher than the required deposit to create more randomness if you are the third player (ending round).\n		//indices of players\n        uint i_big_winner;\n        uint i_small_winner;\n        uint i_looser;\n        \n        if( toss % 3 == 0 ){\n            i_big_winner=id[zone];\n            i_small_winner=id[zone]+1;\n            i_looser =id[zone]+2;\n        }\n        else if( toss % 3 == 1){\n            i_big_winner=id[zone]+2;\n            i_small_winner=id[zone];\n            i_looser =id[zone]+1;\n        }\n        else{\n            i_big_winner=id[zone]+1;\n            i_small_winner=id[zone]+2;\n            i_looser =id[zone];\n        }\n        \n        uint256 effective_bet = (deposit[zone] * (1000 - feesThousandth )) / 1000;\n        \n        players[zone][i_big_winner].addr.send(effective_bet*first_prize/100);     //big win\n        players[zone][i_small_winner].addr.send(effective_bet*second_prize/100);    //small win\n        if(third_prize > 0){\n            players[zone][i_small_winner].addr.send(effective_bet*third_prize/100);    //looser\n        }\n        \n        //update zone information\n        players[zone][i_big_winner].payout=effective_bet*first_prize/100;\n        players[zone][i_small_winner].payout=effective_bet*second_prize/100;\n        players[zone][i_looser].payout=effective_bet*third_prize/100;\n        players[zone][id[zone]].paid=true;\n        players[zone][id[zone]+1].paid=true;\n        players[zone][id[zone]+2].paid=true;\n		//update gamblers ledger\n		gamblers[players[zone][i_big_winner].addr].paid += players[zone][i_big_winner].payout;\n		gamblers[players[zone][i_small_winner].addr].paid += players[zone][i_small_winner].payout;\n		gamblers[players[zone][i_looser].addr].paid += players[zone][i_looser].payout;\n		\n        Balance[zone]=0;\n        nb_player[zone]=0;\n        id[zone] += 3;\n    }\n\n    \n    function CancelRoundAndRefundAll(uint zone) { //refund every participants in a zone, anyone can call this !\n        if(zone<0 && zone>3) throw;\n        if(nb_player[zone]==0) return;\n        \n        uint256 pay=(deposit[zone] * (1000 - feesThousandth )) / 1000;\n        \n        if (last_time[zone] + time_max < block.timestamp) {\n            for(uint i=id[zone]; i<(id[zone]+nb_player[zone]); i++){\n                players[zone][i].addr.send(pay);\n                players[zone][i].paid=true;\n                players[zone][i].payout=pay;\n				\n				gamblers[players[zone][i].addr].bets--;\n				gamblers[players[zone][i].addr].deposits -= pay;\n            }\n            id[zone] += nb_player[zone];\n            nb_player[zone]=0;\n			Balance[zone]=0;\n			//remove informations from stats - cancelling = removing\n			\n        }\n    }\n    \n    //------------ Contract informations -----------------------------------\n    \n    \n    function LookAtBalance() constant returns(uint BalanceOfZone1,uint BalanceOfZone2,uint BalanceOfZone3, string info) {\n        BalanceOfZone1 = Balance[0] /  1 finney;\n        BalanceOfZone2 = Balance[1] /  1 finney;\n        BalanceOfZone3 = Balance[2] /  1 finney;\n        info ='Balances of all play zones in finney';\n    }\n    \n    function PlayerInfoPerZone(uint id, uint zone) constant returns(address Address, uint Payout, bool UserPaid, string info) {\n        if(zone<0 && zone>3) throw;\n        if (id <= players[zone].length) {\n            Address = players[zone][id].addr;\n            Payout = (players[zone][id].payout) / 1 finney;\n            UserPaid= players[zone][id].paid;\n        }\n		\n		info = 'Select zone between 0 and 2, then use the id to look trough this zone';\n    }\n    \n    function LookAtLastTimePerZone(uint zone) constant returns(uint LastTimeForSelectedZone,uint TimeToWaitEnablingRefund, string info) {\n        if(zone<0 && zone>3) throw;\n        LastTimeForSelectedZone = last_time[zone];\n        TimeToWaitEnablingRefund = time_max;\n        info ='Timestamps, use this to know when you can cancel a round to get back funds, TimeToWait in seconds !';\n    }\n\n    function LookAtCollectedFees() constant returns(uint Fees, string info) {\n        Fees = fees / 1 finney;\n		info = 'Fees collected, in finney.';\n    }\n    \n    \n    function LookAtDepositsToPlay() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\n        InZone1 = deposit[0] / 1 finney;\n        InZone2 = deposit[1] / 1 finney;\n        InZone3 = deposit[2] / 1 finney;\n		info = 'Deposit for each zones, in finney. Surpus are always refunded.';\n    }\n\n    function LookAtPrizes() constant returns(uint FirstPrize,uint SecondPrize,uint LooserPrize, string info) {\n		FirstPrize=first_prize;\n		SecondPrize=second_prize;\n		LooserPrize=third_prize;\n	\n		info = 'Prizes in percent of the deposit';\n    }\n	\n	function GamblerPerAddress(address addr) constant returns(uint Bets, uint Deposited, uint PaidOut, string info) {\n		Bets      = gamblers[addr].bets;\n		Deposited = gamblers[addr].deposits / 1 finney;\n		PaidOut   = gamblers[addr].paid / 1 finney;\n		info ='Bets is the number of time you participated, no matter the zone.';\n	}\n	\n    function LookAtNumberOfPlayers() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\n        InZone1 = nb_player[0];\n        InZone2 = nb_player[1];\n        InZone3 = nb_player[2];\n		\n		info = 'Players in a round, in each zones.';\n    }\n    //----------- Contract management functions -------------------------\n    \n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n	\n	\n    function ModifyFeeFraction(uint new_fee) onlyowner {\n		if( new_fee>=0 && new_fee<=20 ){ //admin can only set the fee percentage between 0 and 2%, initially 1%\n			feesThousandth = new_fee;\n		}\n    }\n    \n    //function to modify settings, only if no player in a round !\n    function ModifySettings(uint new_time_max, uint new_first_prize, uint new_second_prize, uint new_third_prize,\n                            uint deposit_1,uint deposit_2,uint deposit_3) onlyowner {\n        if(nb_player[0]!=0 || nb_player[1]!=0 || nb_player[2]!=0 ) throw; //can only modify if nobody plays !\n        \n        if(new_time_max>=(1 * 60 * 60) && new_time_max<=(24 * 60 * 60) ) time_max=new_time_max;\n		\n		if((new_first_prize+new_second_prize+new_third_prize)==300){ //the total must be distributed in a correct way\n			if(new_first_prize>=130 && new_first_prize<=190){			\n				first_prize=new_first_prize;\n				if(new_second_prize>100 && new_second_prize<=130){\n					second_prize=new_second_prize;\n					if(new_third_prize>=0 && new_third_prize<=50) third_prize=new_third_prize;\n				}\n			}\n        }\n        if(deposit_1>=(1 finney) && deposit_1<(1 ether)) deposit[0]=deposit_1;\n        if(deposit_2>=(1 ether) && deposit_2<(5 ether)) deposit[1]=deposit_2;\n        if(deposit_3>=(5 ether) && deposit_3<=(20 ether)) deposit[2]=deposit_3;\n        \n    }\n    \n    function CollectAllFees() onlyowner { //it just send fees, that's all folks !\n        if (fees == 0) throw;\n        admin.send(fees);\n        fees = this.balance -Balance[0]-Balance[1]-Balance[2]; //just in case there is lost ethers.\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ギャンブル機能を実装している。,
1396703,0x1d26d20dd0c64fa427d4293d308d021292ce99a2,false,false,,,,TOO_SHORT
1396886,0x82660e033dc0d1f6902e0f72e0a0bda46f593ff7,false,false,,,,TOO_SHORT
1396968,0x4488d8b2f142b378a0acbe6f88ea6e0ef04fdede,false,false,,,,TOO_SHORT
1397415,0xebf18faba83988234a8f0060b1dad779557c73e9,false,false,,,,TOO_SHORT
1397465,0xb4f7161720af43f7413aae463c298f12acea3703,false,false,,,,TOO_SHORT
1397553,0x89d64bc7e46bdc49a89652ae9bb167418cbad62e,true,false,"/*\n  live: 0x89d64bc7e46bdc49a89652ae9bb167418cbad62e\nmorden: 0xe379e36671acbcc87ec7b760c07e6e45a1294944\n  solc: v0.3.1-2016-04-12-3ad5e82 (optimization)\n*/\n\ncontract tokenRecipient {\n    function receiveApproval(address _from, uint256 _value, address _token);\n}\n\ncontract Token {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function totalSupply() constant returns (uint256 supply);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function approveAndCall(address _spender, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\n\ncontract SafeAddSub {\n    function safeToAdd(uint a, uint b) internal returns (bool) {\n        return (a + b > a);\n    }\n\n    function safeToSubtract(uint a, uint b) internal returns (bool) {\n        return (a >= b);\n    }\n\n    function safeAdd(uint a, uint b) internal returns (uint256) {\n        if (!safeToAdd(a, b)) throw;\n        return a + b;\n    }\n\n    function safeSubtract(uint a, uint b) internal returns (uint256) {\n        if (!safeToSubtract(a, b)) throw;\n        return a - b;\n    }\n}\n\ncontract EthToken is Token, SafeAddSub {\n    string public constant name = ""Ether Token Proxy"";\n    string public constant symbol = ""ETH"";\n    uint8   public constant decimals = 18;\n    uint256 public constant baseUnit = 10**18;\n    \n    mapping (address => uint256) _balanceOf;\n    mapping (address => mapping (address => uint256)) _allowance;\n\n    event Deposit(address indexed owner, uint256 amount);\n    event Withdrawal(address indexed owner, uint256 amount);\n\n    function totalSupply() constant returns (uint256 supply) {\n        return this.balance;\n    }\n    \n    function () {\n        deposit();\n    }\n    \n    function deposit() {\n        _balanceOf[msg.sender] = safeAdd(_balanceOf[msg.sender], msg.value);\n        Deposit(msg.sender, msg.value);\n    }\n    \n    function redeem() {\n        withdraw(_balanceOf[msg.sender]);\n    }\n    \n    function withdraw(uint256 _value) returns (bool success) {\n        _balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);\n        if (!msg.sender.send(_value)) {\n            if (!msg.sender.call.gas(msg.gas).value(_value)()) throw;\n        }\n        Withdrawal(msg.sender, _value);\n        return true;\n    }\n    \n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return _balanceOf[_owner];\n    }\n    \n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (_to == address(this) || _to == 0) {\n            return withdraw(_value);\n        } else {\n            _balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);\n            _balanceOf[_to] = safeAdd(_balanceOf[_to], _value);\n            Transfer(msg.sender, _to, _value);\n        }\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (!safeToSubtract(_allowance[_from][msg.sender], _value)) throw;\n        if (_to == address(this) || _to == 0) {\n            if (!transferFrom(_from, msg.sender, _value)) throw;\n            withdraw(_value);\n        } else {\n            _balanceOf[_from] = safeSubtract(_balanceOf[_from], _value);\n            _balanceOf[_to] = safeAdd(_balanceOf[_to], _value);\n            _allowance[_from][msg.sender] = safeSubtract(_allowance[_from][msg.sender], _value);\n            Transfer(_from, _to, _value);\n        }\n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) returns (bool success) {\n        _allowance[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function approveAndCall(address _spender, uint256 _value) returns (bool success) {\n        if (approve(_spender, _value)) {\n            tokenRecipient(_spender).receiveApproval(msg.sender, _value, this);\n            return true;\n        }\n        throw;\n    }\n    \n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return _allowance[_owner][_spender];\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1397716,0xbe69b8093ca446c97aa2c5ea4746d793fb86c89d,false,false,"contract RipplePayExample {\n\nmapping(address => mapping(address => uint)) TrustSettings; // store trustLines for a given address\n\nfunction updateTrustSettings(address _peer, uint newTrustLimit) {\nTrustSettings[msg.sender][_peer] = newTrustLimit;\n}\n\nfunction getTrustSetting(address _peer) returns(uint) {\nreturn TrustSettings[msg.sender][_peer];\n}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1397899,0xc1ce17303ef35c128b499ed091f39008b3a57389,false,false,"contract GameRegistry {\n\n    // This struct keeps all data for a Record.\n    struct Record {\n        // Keeps the address of this record creator.\n        address owner;\n        // Keeps the time when this record was created.\n        uint time;\n        // Keeps the index of the keys array for fast lookup\n        uint keysIndex;\n        string description;\n        string url;\n    }\n\n    // This mapping keeps the records of this Registry.\n    mapping(address => Record) records;\n\n    // Keeps the total numbers of records in this Registry.\n    uint public numRecords;\n\n    // Keeps a list of all keys to interate the recoreds.\n    address[] private keys;\n\n    // The owner of this registry.\n    address owner;\n\n    uint public REGISTRATION_COST = 100 finney;\n    uint public TRANSFER_COST = 10 finney;\n    uint public VALUE_DISTRIBUTION_KEY_OWNERS = 50;\n\n    // Constructor\n    function GameRegistry() {\n        owner = msg.sender;\n    }\n\n    function distributeValue() {\n        if (msg.value == 0) {\n            return;\n        }\n        uint ownerPercentage = 100 - VALUE_DISTRIBUTION_KEY_OWNERS;\n        uint valueForRegOwner = (ownerPercentage * msg.value) / 100;\n        owner.send(valueForRegOwner);\n        uint valueForEachOwner = (msg.value - valueForRegOwner) / numRecords;\n        if (valueForEachOwner <= 0) {\n            return;\n        }\n        for (uint k = 0; k < numRecords; k++) {\n            records[keys[k]].owner.send(valueForEachOwner);\n        }\n    }\n\n    // This is the function that actually inserts a record. \n    function register(address key, string description, string url) {\n        // Only allow registration if received value >= REGISTRATION_COST\n        if (msg.value < REGISTRATION_COST) {\n            // Return value back to sender.\n            if (msg.value > 0) {\n                msg.sender.send(msg.value);\n            }\n            return;\n        }\n        distributeValue();\n        if (records[key].time == 0) {\n            records[key].time = now;\n            records[key].owner = msg.sender;\n            records[key].keysIndex = keys.length;\n            keys.length++;\n            keys[keys.length - 1] = key;\n            records[key].description = description;\n            records[key].url = url;\n\n            numRecords++;\n        }\n    }\n\n    // Updates the values of the given record.\n    function update(address key, string description, string url) {\n        // Only the owner can update his record.\n        if (records[key].owner == msg.sender) {\n            records[key].description = description;\n            records[key].url = url;\n        }\n    }\n\n    // Unregister a given record\n    function unregister(address key) {\n        if (records[key].owner == msg.sender) {\n            uint keysIndex = records[key].keysIndex;\n            delete records[key];\n            numRecords--;\n            keys[keysIndex] = keys[keys.length - 1];\n            records[keys[keysIndex]].keysIndex = keysIndex;\n            keys.length--;\n        }\n    }\n\n    // Transfer ownership of a given record.\n    function transfer(address key, address newOwner) {\n        // Only allow transfer if received value >= TRANSFER_COST\n        if (msg.value < TRANSFER_COST) {\n            // Return value back to sender\n            if (msg.value > 0) {\n                msg.sender.send(msg.value);\n            }\n            return;\n        }\n        distributeValue();\n        if (records[key].owner == msg.sender) {\n            records[key].owner = newOwner;\n        }\n    }\n\n    // Tells whether a given key is registered.\n    function isRegistered(address key) returns(bool) {\n        return records[key].time != 0;\n    }\n\n    function getRecordAtIndex(uint rindex) returns(address key, address owner, uint time, string description, string url) {\n        Record record = records[keys[rindex]];\n        key = keys[rindex];\n        owner = record.owner;\n        time = record.time;\n        description = record.description;\n        url = record.url;\n    }\n\n    function getRecord(address key) returns(address owner, uint time, string description, string url) {\n        Record record = records[key];\n        owner = record.owner;\n        time = record.time;\n        description = record.description;\n        url = record.url;\n    }\n\n    // Returns the owner of the given record. The owner could also be get\n    // by using the function getRecord but in that case all record attributes \n    // are returned.\n    function getOwner(address key) returns(address) {\n        return records[key].owner;\n    }\n\n    // Returns the registration time of the given record. The time could also\n    // be get by using the function getRecord but in that case all record attributes\n    // are returned.\n    function getTime(address key) returns(uint) {\n        return records[key].time;\n    }\n\n    // Returns the total number of records in this registry.\n    function getTotalRecords() returns(uint) {\n        return numRecords;\n    }\n\n    // This function is used by subcontracts when an error is detected and\n    // the value needs to be returned to the transaction originator.\n    function returnValue() internal {\n        if (msg.value > 0) {\n            msg.sender.send(msg.value);\n        }\n    }\n\n    // Registry owner can use this function to withdraw any value owned by\n    // the registry.\n    function withdraw(uint value) {\n        if (msg.sender == owner) {\n            msg.sender.send(value);\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1398069,0xb071e5c53094cabb971e98eba3b1a86be555c943,false,false,"contract IOU {\n    address owner;\n\n/* Public variables of the token */\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    \n/* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n\n/* This generates a public event on the blockchain that will notify clients */\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\n    function IOU(string tokenName, string tokenSymbol, uint8 decimalUnits) {\n        owner = msg.sender;                                 // sets main RipplePay contract as owner\n        name = tokenName;                                       // Set the name for display purposes     \n        symbol = tokenSymbol;                                     // Set the symbol for display purposes    \n        decimals = decimalUnits;                                       // Amount of decimals for display purposes        \n    \n    }\n    \n    /* update balances so they display in ethereum-wallet */\n    function transfer(address _from, address _to, uint256 _value) {\n        if(msg.sender != owner) throw;                       // can only be invoked by main RipplePay contract\n        balanceOf[_from] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n    \n}\n\n\n\ncontract RipplePayMain {\n\nmapping(string => address) currencies;\n\nfunction newCurrency(string currencyName, string currencySymbol, uint8 decimalUnits){\ncurrencies[currencySymbol] = new IOU(currencyName, currencySymbol, decimalUnits);\n}\n\nfunction issueIOU(string _currency, uint256 _amount, address _to){\n    // update creditLines in main contract, then update balances in IOU contract to display in ethereum-wallet\n    IOU(currencies[_currency]).transfer(msg.sender, _to, _amount);\n\n}\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1398161,0xad87e48d553c2308dccab428537f6d0809593ba4,false,false,"contract GameRegistry {\n\n    // This struct keeps all data for a Record.\n    struct Record {\n        // Keeps the address of this record creator.\n        address owner;\n        // Keeps the time when this record was created.\n        uint time;\n        // Keeps the index of the keys array for fast lookup\n        uint keysIndex;\n        string description;\n        string url;\n    }\n\n    // This mapping keeps the records of this Registry.\n    mapping(address => Record) private records;\n\n    // Keeps the total numbers of records in this Registry.\n    uint private numRecords;\n\n    // Keeps a list of all keys to interate the recoreds.\n    address[] private keys;\n\n    // The owner of this registry.\n    address private owner;\n\n    uint private KEY_HOLDER_SHARE  = 50;\n    uint private REGISTRATION_COST = 500 finney;\n    uint private TRANSFER_COST     = 0;\n\n    // Constructor\n    function GameRegistry() {\n        owner = msg.sender;\n    }\n    \n    // public interface to the directory of games\n    function theGames(uint rindex) constant returns(address contractAddress, string description, string url, address submittedBy, uint time) {\n        Record record = records[keys[rindex]];\n        contractAddress = keys[rindex];\n        description = record.description;\n        url = record.url;\n        submittedBy = record.owner;\n        time = record.time;\n    }\n\n    function settings() constant public returns(uint registrationCost, uint percentSharedWithKeyHolders) {\n        registrationCost            = REGISTRATION_COST / 1 finney;\n        percentSharedWithKeyHolders = KEY_HOLDER_SHARE;\n    }\n\n    function distributeValue() private {\n        if (msg.value == 0) {\n            return;\n        }\n        // share value with all key holders\n        uint ownerPercentage  = 100 - KEY_HOLDER_SHARE;\n        uint valueForRegOwner = (ownerPercentage * msg.value) / 100;\n        owner.send(valueForRegOwner);\n        uint valueForEachOwner = (msg.value - valueForRegOwner) / numRecords;\n        if (valueForEachOwner <= 0) {\n            return;\n        }\n        for (uint k = 0; k < numRecords; k++) {\n            records[keys[k]].owner.send(valueForEachOwner);\n        }\n    }\n\n    // This is the function that actually inserts a record. \n    function addGame(address key, string description, string url) {\n        // Only allow registration if received value >= REGISTRATION_COST\n        if (msg.value < REGISTRATION_COST) {\n            // Return value back to sender.\n            if (msg.value > 0) {\n                msg.sender.send(msg.value);\n            }\n            return;\n        }\n        distributeValue();\n        if (records[key].time == 0) {\n            records[key].time = now;\n            records[key].owner = msg.sender;\n            records[key].keysIndex = keys.length;\n            keys.length++;\n            keys[keys.length - 1] = key;\n            records[key].description = description;\n            records[key].url = url;\n\n            numRecords++;\n        }\n    }\n\n    function () { distributeValue(); }\n\n    // Updates the values of the given record.\n    function update(address key, string description, string url) {\n        // Only the owner can update his record.\n        if (records[key].owner == msg.sender) {\n            records[key].description = description;\n            records[key].url = url;\n        }\n    }\n\n/*\n    // Transfer ownership of a given record.\n    function transfer(address key, address newOwner) {\n        // Only allow transfer if received value >= TRANSFER_COST\n        if (msg.value < TRANSFER_COST) {\n            // Return value back to sender\n            if (msg.value > 0) {\n                msg.sender.send(msg.value);\n            }\n            return;\n        }\n        distributeValue();\n        if (records[key].owner == msg.sender) {\n            records[key].owner = newOwner;\n        }\n    }\n*/\n\n    // Tells whether a given key is registered.\n    function isRegistered(address key) private constant returns(bool) {\n        return records[key].time != 0;\n    }\n\n    function getRecord(address key) private constant returns(address owner, uint time, string description, string url) {\n        Record record = records[key];\n        owner = record.owner;\n        time = record.time;\n        description = record.description;\n        url = record.url;\n    }\n\n    // Returns the owner of the given record. The owner could also be get\n    // by using the function getRecord but in that case all record attributes \n    // are returned.\n    function getOwner(address key) private constant returns(address) {\n        return records[key].owner;\n    }\n\n    // Returns the registration time of the given record. The time could also\n    // be get by using the function getRecord but in that case all record attributes\n    // are returned.\n    function getTime(address key) private constant returns(uint) {\n        return records[key].time;\n    }\n\n    // Registry owner can use this function to withdraw any surplus value owned by\n    // the registry.\n    function maintain(uint value, uint cost) {\n        if (msg.sender == owner) {\n            msg.sender.send(value);\n            REGISTRATION_COST = cost;\n        }\n    }\n\n    // Returns the total number of records in this registry.\n    function getTotalRecords() private constant returns(uint) {\n        return numRecords;\n    }\n\n    // This function is used by subcontracts when an error is detected and\n    // the value needs to be returned to the transaction originator.\n    function returnValue() internal {\n        if (msg.value > 0) {\n            msg.sender.send(msg.value);\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1398258,0x96fe18b4032ae14283f551a67a608a92ff608b26,false,false,,,,TOO_SHORT
1398383,0xe5f0c1c3ed915771e86ddc20ed18a0fab06dea01,false,false,,,,TOO_SHORT
1398956,0x0feb107dc2e9b612e3be90009368f96e8ff6356d,false,false,,,,TOO_SHORT
1398980,0x2ab7ac8aef3e1444dd50b30e17885dba6dc5b89c,false,false,,,,TOO_SHORT
1399178,0x923f1a45f1272b6eb66140317e1214083e2c4a5a,false,false,,,,TOO_SHORT
1400312,0xb8f20e52a7152d716f8128130d3a5a99c04de286,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1400888,0x0e61704efe4d5ff50101d605427b91fe87ba7b18,false,false,,,,TOO_SHORT
1401038,0x4f79dc089b4440947cb9b3c0f1c96f4dd3cbacdf,false,false,,,,TOO_SHORT
1401163,0x5af92bfb52f06e95bb0caadece9f9c9d0d9a56fb,false,false,,,,TOO_SHORT
1401298,0xc357a046c5c13bb4e6d918a208b8b4a0ab2f2efd,false,false,"///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Welcome to EthFactory!\n//\n// Multiply your Ether by +15% !!\n//\n// NO MINIMUM DEPOSIT !!\n//\n// NO HOUSE FEES !!\n//\n// Everyone gets paid in the line! After somebody has been paid, he is removed and the next person is in line for payment !\n//\n// Invest now, and you will Earn back 115%, which is your [Invested Ether] + [15% Profit] !\n//\n// Multiply your ETH Now !\n//\n///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Start\n\ncontract EthFactory{\n\n  struct InvestorArray { address EtherAddress; uint Amount; }\n  InvestorArray[] public depositors;\n\n///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Variables\n\n  uint public Total_Investors=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\n  string public Message=""Welcome Investor! Multiply your ETH Now!"";\n  address public owner;\n  modifier manager { if (msg.sender == owner) _ }\n  function EthFactory() {owner = msg.sender;}\n  function() { enter(); }\n  \n///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Enter\n\n  function enter() {\n    if (msg.value > 0) {\n\n    uint Amount=msg.value;								//set amount to how much the investor deposited\n    Total_Investors=depositors.length+1;   					 //count investors\n    depositors.length += 1;                        						//increase array lenght\n    depositors[depositors.length-1].EtherAddress = msg.sender; //add net investor's address\n    depositors[depositors.length-1].Amount = Amount;          //add net investor's amount\n    Balance += Amount;               						// balance update\n    Total_Deposited+=Amount;       						//update deposited Amount\n    uint payment; uint index=0;\n\n    while (Balance > (depositors[index].Amount * 115/100) && index<Total_Investors)\n     {\n	if(depositors[index].Amount!=0 )\n	{\n      payment = depositors[index].Amount *115/100;                           //calculate pay out\n      depositors[index].EtherAddress.send(payment);                        //send pay out to investor\n      Balance -= depositors[index].Amount *115/100;                         //balance update\n      Total_Paid_Out += depositors[index].Amount *115/100;           //update paid out amount   \n       depositors[index].Amount=0;                                    //remove investor from the game after he is paid out! He must invest again if he wants to earn more!\n	}break;\n      }\n  }\n}\nfunction DeleteContract() manager { owner.send(Balance); Balance=0; }\n\n}",1,実用的な構造で、投資ゲームを実装した標準的なスマートコントラクト。,
1401432,0xb6fa7a369458aa4c4d07c8fc6c1a95394108e39e,false,false,,,,TOO_SHORT
1401642,0x68c73251ef2c9e331ab5b02f4abd71210142ba3f,false,false,,,,TOO_SHORT
1401922,0x657ddd108c2a897090ca995707bf125b9621997b,false,false,,,,TOO_SHORT
1402080,0xeccd1fd2cbc6aebae856267ed9740bff6258cd30,false,false,,,,TOO_SHORT
1402192,0xed719b46a46cd38c472d9771cf6de434eaf762b1,false,false,,,,TOO_SHORT
1402207,0x088fedd49323a4f5c65bb22d493daecee764aa35,false,false,,,,TOO_SHORT
1402323,0x5830771f3dd69582e503bf4059dfb9825685ad1c,false,false,,,,TOO_SHORT
1402648,0xdde4fbf77be193e22c5db0e2431e0d62bd2d33a5,false,false,,,,TOO_SHORT
1402805,0x93887b3e869fe927ba898106fd644f45a14af100,false,false,,,,TOO_SHORT
1402834,0xad3fdf3eb2215a799dcc9a2a7d0b3379b2b95fd0,false,false,,,,TOO_SHORT
1402835,0xfc925ea6874d5544d40178e17fe0a39908bb7235,false,false,,,,TOO_SHORT
1402862,0x8465b03ecf0734b18c02002d3147c4c0b75ec27e,false,false,,,,TOO_SHORT
1403009,0x898064d4c707830d0360592f19e1ac0446901f4e,false,false,,,,TOO_SHORT
1403171,0x72338855cedbb6b9a0349a0504e11da8067d34f2,false,false,,,,TOO_SHORT
1404974,0x425692c0366aca59fe8816f138f2509f09032925,false,false,,,,TOO_SHORT
1406267,0xb97768a8e31789dbece1403694e53c2142c3d706,false,false,"contract BlockChainEnterprise {\n    uint private BlockBalance = 0; //block balance (0 to BlockSize eth)\n    uint private NumberOfBlockMined = 0;\n    uint private BlockReward = 0;\n    uint private BlockSize =  10 ether; //a block is size 10 ETH, and with 1.2 multiplier it is paid 12 ETH\n    uint private MaxDeposit = 5 ether;\n    uint private multiplier = 1200; // Multiplier\n    uint private fees = 0;      //Fees are just verly low : 1% !\n    uint private feeFrac = 5;  //Fraction for fees in ""thousandth"" --> only 0.5% !!\n    uint private RewardFrac = 30;  //Fraction for Reward in ""thousandth""\n    uint private Payout_id = 0;\n    address private admin;\n\n    function BlockChainEnterprise() {\n        admin = msg.sender;\n    }\n\n    modifier onlyowner {if (msg.sender == admin) _  }\n\n    struct Miner {\n        address addr;\n        uint payout;\n        bool paid;\n    }\n\n    Miner[] private miners;\n\n    //--Fallback function\n    function() {\n        init();\n    }\n\n    //--initiated function\n    function init() private {\n        uint256 new_deposit=msg.value;\n        //------ Verifications on this new deposit ------\n        if (new_deposit < 100 finney) { //only >0.1 eth participation accepted\n            msg.sender.send(new_deposit);\n            return;\n        }\n\n        if( new_deposit > MaxDeposit ){\n            msg.sender.send( msg.value - MaxDeposit );\n            new_deposit= MaxDeposit;\n        }\n        //-- enter the block ! --\n        Participate(new_deposit);\n    }\n\n    function Participate(uint deposit) private {\n        if( BlockSize  < (deposit + BlockBalance) ){ //if this new deposit is part of 2 blocks\n            uint256 fragment = BlockSize - BlockBalance;\n            miners.push(Miner(msg.sender, fragment*multiplier/1000 , false)); //fill the block\n            miners.push(Miner(msg.sender, (deposit - fragment)*multiplier/1000  , false)); //contruct the next one\n        } else {\n            miners.push(Miner(msg.sender, deposit*multiplier/1000 , false)); // add this new miner in the block !\n        }\n\n        //--- UPDATING CONTRACT STATS ----\n        BlockReward += (deposit * RewardFrac) / 1000; // take some to reward the winner that make the whole block mined !\n        fees += (deposit * feeFrac) / 1000;          // collect small fee\n        BlockBalance += (deposit * (1000 - ( feeFrac + RewardFrac ))) / 1000; //update balance\n\n        //Mine the block first if possible !\n        if( BlockBalance >= (BlockSize/1000*multiplier) ){// it can be mined now !\n            PayMiners();\n            PayWinnerMiner(msg.sender,deposit);\n        }\n    }\n\n    function PayMiners() private {\n        NumberOfBlockMined +=1;\n        //Classic payout of all participants of the block\n        while ( miners[Payout_id].payout!=0 && BlockBalance >= ( miners[Payout_id].payout )  ) {\n            miners[Payout_id].addr.send(miners[Payout_id].payout); //pay the man !\n\n            BlockBalance -= miners[Payout_id].payout; //update the balance\n            miners[Payout_id].paid=true;\n\n            Payout_id += 1;\n        }\n    }\n\n    function  PayWinnerMiner(address winner, uint256 deposit) private{ //pay the winner accordingly to his deposit !\n        //Globally, EVERYONE CAN WIN by being smart and quick.\n        if(deposit >= 1 ether){ //only 1 ether, and you get it all !\n            winner.send(BlockReward);\n            BlockReward =0;\n        } else { // deposit is between 0.1 and 0.99 ether\n            uint256 pcent = deposit / 10 finney;\n            winner.send(BlockReward*pcent/100);\n            BlockReward -= BlockReward*pcent/100;\n        }\n    }\n\n    //---Contract management functions\n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n\n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        fees = 0;\n    }\n\n    function GetAndReduceFeesByFraction(uint p) onlyowner {\n        if (fees == 0) feeFrac=feeFrac*80/100; //Reduce fees.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n\n    //---Contract informations\n    function WatchBalance() constant returns(uint TotalBalance, string info) {\n        TotalBalance = BlockBalance /  1 finney;\n        info ='Balance in finney';\n    }\n\n    function WatchBlockSizeInEther() constant returns(uint BlockSizeInEther, string info) {\n        BlockSizeInEther = BlockSize / 1 ether;\n        info ='Balance in ether';\n    }\n\n    function WatchNextBlockReward() constant returns(uint Reward, string info) {\n        Reward = BlockReward / 1 finney;\n        info ='Current reward collected. The reward when a block is mined is always BlockSize*RewardPercentage/100';\n    }\n\n    function NumberOfMiners() constant returns(uint NumberOfMiners, string info) {\n        NumberOfMiners = miners.length;\n        info ='Number of participations since the beginning of this wonderful blockchain';\n    }\n    function WatchCurrentMultiplier() constant returns(uint Mult, string info) {\n        Mult = multiplier;\n        info ='Current multiplier';\n    }\n\n    function NumberOfBlockAlreadyMined() constant returns(uint NumberOfBlockMinedAlready, string info) {\n        NumberOfBlockMinedAlready = NumberOfBlockMined;\n        info ='A block mined is a payout of size BlockSize, multiply this number and you get the sum of all payouts.';\n    }\n\n    function AmountToForgeTheNextBlock() constant returns(uint ToDeposit, string info) {\n        ToDeposit = ( ( (BlockSize/1000*multiplier) - BlockBalance)*(1000 - ( feeFrac + RewardFrac ))/1000) / 1 finney;\n        info ='This amount in finney in finney required to complete the current block, and to MINE it (trigger the payout).';\n    }\n\n    function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n        if (id <= miners.length) {\n            Address = miners[id].addr;\n            Payout = (miners[id].payout) / 1 finney;\n            UserPaid=miners[id].paid;\n        }\n    }\n\n    function WatchCollectedFeesInSzabo() constant returns(uint CollectedFees) {\n        CollectedFees = fees / 1 szabo;\n    }\n\n    function NumberOfCurrentBlockMiners() constant returns(uint QueueSize, string info) {\n        QueueSize = miners.length - Payout_id;\n        info ='Number of participations in the current block.';\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1406714,0x0d6630648e6740d2d96c562543d4e0c7bbb46577,false,false,,,,TOO_SHORT
1406795,0x4c458c0a95e1494b8ff423c90f1fe76ab7370ace,false,false,,,,TOO_SHORT
1407346,0x6e7b843eb9cbd5f57e72927c92acca4eef50c82d,false,false,,,,TOO_SHORT
1407751,0x6e639e07c14885f3888f76629ec053968c1abe27,false,false,,,,TOO_SHORT
1407801,0x28897862463f44ad0c5a6b50fae38e14376ddb77,false,false,,,,TOO_SHORT
1408216,0x308bb69ded3fa517edcaf5484c347a05ba2e5c32,false,false,,,,TOO_SHORT
1408399,0xbad03b8dd81b913b187fce4bdca0f0eeabcf9ad9,false,false,,,,TOO_SHORT
1408432,0xf0d56abb65f14461aebe92d5610c71aeb04f7c39,false,false,,,,TOO_SHORT
1408447,0x65bf79952d197824ec5a9462f09494bf8faf7fd6,false,false,,,,TOO_SHORT
1408622,0x057b216b1866028812905ea81a8d46a093ee4949,false,false,,,,TOO_SHORT
1408630,0x28cc60c7c651f3e81e4b85b7a66366df0809870f,false,false,"contract Ethereum_doubler\n{\n\nstring[8] hexComparison;							//declares global variables\nstring hexcomparisonchr;\nstring A;\nuint8 i;\nuint8 lotteryticket;\naddress creator;\nint lastgainloss;\nstring lastresult;\nuint lastblocknumberused;\nbytes32 lastblockhashused;\nuint8 hashLastNumber;\naddress player;\nuint8 result; \nuint128 wager; \nuint8 lowOrHigh; // 0=low, 2=high, 4=kill, 6=n.a.\nuint8 HashtoLowOrHigh;//hash modified to low or high 0=low, 2=high, 7= 0 or F\n \n\n   function  Ethereum_doubler() private \n    { \n        creator = msg.sender; 								\n    }\n\n  function Set_your_game_number(string Set_your_game_number_L_or_H)			//sets game number\n {	result=0;\n    	A=Set_your_game_number_L_or_H ;\n     	uint128 wager = uint128(msg.value); \n	comparisonchr(A);\n	inputToDigit(i);\n	checkHash();\n	changeHashtoLowOrHigh(hashLastNumber);\n 	checkBet();\n	returnmoneycreator(result,wager);\n}\n\n \n\n    function comparisonchr(string A) private					//changes string input to uint\n    {    hexComparison= [""L"", ""l"", ""H"", ""h"", ""K"",""N.A."",""dummy"",""0 or F""];\n	for (i = 0; i < 6; i ++) \n{\n\n	hexcomparisonchr=hexComparison[i];\n\n    \n\n	bytes memory a = bytes(hexcomparisonchr);\n 	bytes memory b = bytes(A);\n        \n          \n        \n          if (a[0]==b[0])\n              return ;\n\n}}\n\nfunction inputToDigit(uint i) private\n{\nif(i==0 || i==1)\n{lowOrHigh=0;\nreturn;}\nelse if (i==2 ||i==3)\n{lowOrHigh=2;\nreturn;}\nelse if (i==4)\n{lowOrHigh=4;\nreturn;}\nelse if (i==6)\n{lowOrHigh=6;}\nreturn;}\n\n	function checkHash() private\n{\n   	lastblocknumberused = (block.number-1)  ;				//Last available blockhash is in the previous block\n    	lastblockhashused = block.blockhash(lastblocknumberused);		//Cheks the last available blockhash\n\n    	\n    	hashLastNumber=uint8(lastblockhashused & 0xf);				//Changes blockhash's last number to base ten\n}\n\n	function changeHashtoLowOrHigh(uint  hashLastNumber) private\n{\n	if (hashLastNumber>0 && hashLastNumber<8)\n	{HashtoLowOrHigh=0;\n	return;}\n	else if (hashLastNumber>7 && hashLastNumber<15)\n	{HashtoLowOrHigh=2;\n	return;}\n	else\n	{HashtoLowOrHigh=7;\n	lastresult = ""0 or F, house wins"";\n	return;}//result= 0 or F, house wins\n	\n \n	 \n}\n\n \n\n	function checkBet() private\n\n { \n	lotteryticket=lowOrHigh;\n	player=msg.sender;\n        \n                \n    \n  		  \n    	if(msg.value > (this.balance/4))					// maximum bet is game balance/4\n    	{\n    		lastresult = ""Bet is too large. Maximum bet is the game balance/4."";\n    		lastgainloss = 0;\n    		msg.sender.send(msg.value); // return bet\n    		return;\n    	}\n	else if(msg.value <100000000000000000)					// minimum bet is 0.1 eth\n    	{\n    		lastresult = ""Minimum bet is 0.1 eth"";\n    		lastgainloss = 0;\n    		msg.sender.send(msg.value); // return bet\n    		return;\n\n	}\n    	else if (msg.value == 0)\n    	{\n    		lastresult = ""Bet was zero"";\n    		lastgainloss = 0;\n    		// nothing wagered, nothing returned\n    		return;\n    	}\n    		\n    	uint128 wager = uint128(msg.value);          				// limiting to uint128 guarantees that conversion to int256 will stay positive\n    	\n \n\n   	 if(lotteryticket==6)							//Checks that input is L or H \n	{\n	lastresult = ""give a character L or H "";\n	msg.sender.send(msg.value);\n	lastgainloss=0;\n	\n	return;\n	}\n\n	else if (lotteryticket==4 && msg.sender == creator)			//Creator can kill contract. Contract does not hold players money.\n	{\n		suicide(creator);} \n\n	else if(lotteryticket != HashtoLowOrHigh)\n	{\n	    	lastgainloss = int(wager) * -1;\n	    	lastresult = ""Loss"";\n	    	result=1;\n	    									// Player lost. Return nothing.\n	    	return;\n	}\n	    else if(lotteryticket==HashtoLowOrHigh)\n	{\n	    	lastgainloss =(2*wager);\n	    	lastresult = ""Win!"";\n	    	msg.sender.send(wager * 2); \n		return;			 					// Player won. Return bet and winnings.\n	} 	\n    }\n\n	function returnmoneycreator(uint8 result,uint128 wager) private		//If game has over 50 eth, contract will send all additional eth to owner\n	{\n	if (result==1&&this.balance>50000000000000000000)\n	{creator.send(wager);\n	return; \n	}\n \n	else if\n	(\n	result==1&&this.balance>20000000000000000000)				//If game has over 20 eth, contract will send œ of any additional eth to owner\n	{creator.send(wager/2);\n	return; }\n	}\n \n/**********\nfunctions below give information about the game in Ethereum Wallet\n **********/\n \n 	function Results_of_the_last_round() constant returns (string last_result,string Last_player_s_lottery_ticket,address last_player,string The_right_lottery_number,int Player_s_gain_or_Loss_in_Wei,string info)\n    { \n   	last_player=player;	\n	Last_player_s_lottery_ticket=hexcomparisonchr;\n	The_right_lottery_number=hexComparison[HashtoLowOrHigh];\n	last_result=lastresult;\n	Player_s_gain_or_Loss_in_Wei=lastgainloss;\n	info = ""The right lottery number is decided by the last character of the most recent blockhash available during the game. 1-7 =Low, 8-e =High. One Eth is 10**18 Wei."";\n	\n \n    }\n\n 	function Last_block_number_and_blockhash_used() constant returns (uint last_blocknumber_used,bytes32 last_blockhash_used)\n    {\n        last_blocknumber_used=lastblocknumberused;\n	last_blockhash_used=lastblockhashused;\n\n\n    }\n    \n   \n	function Game_balance_in_Ethers() constant returns (uint balance, string info)\n    { \n        info = ""Game balance is shown in full Ethers"";\n    	balance=(this.balance/10**18);\n\n    }\n    \n   \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1408702,0xd862aa37f092913bf630b008554e036d37f73d4e,false,false,,,,TOO_SHORT
1408785,0x28dd66100e0b8c284e780dd024c605c5b84f523d,false,false,,,,TOO_SHORT
1408985,0x7a42e0c5249918386ae2d5d050d7aad15022ff95,false,false,,,,TOO_SHORT
1409121,0xe0b7927c4af23765cb51314a0e0521a9645f0e2a,true,false,"/// @title DigixDAO Contract Interfaces\n\ncontract ConfigInterface {\n        address public owner;\n        mapping(address => bool) admins;\n        mapping(bytes32 => address) addressMap;\n        mapping(bytes32 => bool) boolMap;\n        mapping(bytes32 => bytes32) bytesMap;\n        mapping(bytes32 => uint256) uintMap;\n\n        /// @notice setConfigAddress sets configuration `_key` to `_val`\n        /// @param _key The key name of the configuration.\n        /// @param _val The value of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function setConfigAddress(bytes32 _key, address _val) returns(bool success);\n\n        /// @notice setConfigBool sets configuration `_key` to `_val`\n        /// @param _key The key name of the configuration.\n        /// @param _val The value of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function setConfigBool(bytes32 _key, bool _val) returns(bool success);\n\n        /// @notice setConfigBytes sets configuration `_key` to `_val`\n        /// @param _key The key name of the configuration.\n        /// @param _val The value of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function setConfigBytes(bytes32 _key, bytes32 _val) returns(bool success);\n\n        /// @notice setConfigUint `_key` to `_val`\n        /// @param _key The key name of the configuration.\n        /// @param _val The value of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function setConfigUint(bytes32 _key, uint256 _val) returns(bool success);\n\n        /// @notice getConfigAddress gets configuration `_key`'s value\n        /// @param _key The key name of the configuration.\n        /// @return The configuration value\n        function getConfigAddress(bytes32 _key) returns(address val);\n\n        /// @notice getConfigBool gets configuration `_key`'s value\n        /// @param _key The key name of the configuration.\n        /// @return The configuration value\n        function getConfigBool(bytes32 _key) returns(bool val);\n\n        /// @notice getConfigBytes gets configuration `_key`'s value\n        /// @param _key The key name of the configuration.\n        /// @return The configuration value\n        function getConfigBytes(bytes32 _key) returns(bytes32 val);\n\n        /// @notice getConfigUint gets configuration `_key`'s value\n        /// @param _key The key name of the configuration.\n        /// @return The configuration value\n        function getConfigUint(bytes32 _key) returns(uint256 val);\n\n        /// @notice addAdmin sets `_admin` as configuration admin\n        /// @return Whether the configuration setting was successful or not.\n        function addAdmin(address _admin) returns(bool success);\n\n        /// @notice removeAdmin removes  `_admin`'s rights\n        /// @param _admin The key name of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function removeAdmin(address _admin) returns(bool success);\n\n}\n\ncontract TokenInterface {\n\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowed;\n        mapping(address => bool) seller;\n\n        address config;\n        address owner;\n        address dao;\n        address public badgeLedger;\n        bool locked;\n\n        /// @return total amount of tokens\n        uint256 public totalSupply;\n\n        /// @param _owner The address from which the balance will be retrieved\n        /// @return The balance\n        function balanceOf(address _owner) constant returns(uint256 balance);\n\n        /// @notice send `_value` tokens to `_to` from `msg.sender`\n        /// @param _to The address of the recipient\n        /// @param _value The amount of tokens to be transfered\n        /// @return Whether the transfer was successful or not\n        function transfer(address _to, uint256 _value) returns(bool success);\n\n        /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n        /// @param _from The address of the sender\n        /// @param _to The address of the recipient\n        /// @param _value The amount of tokens to be transfered\n        /// @return Whether the transfer was successful or not\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success);\n\n        /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n        /// @param _spender The address of the account able to transfer the tokens\n        /// @param _value The amount of tokens to be approved for transfer\n        /// @return Whether the approval was successful or not\n        function approve(address _spender, uint256 _value) returns(bool success);\n\n        /// @param _owner The address of the account owning tokens\n        /// @param _spender The address of the account able to transfer the tokens\n        /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining);\n\n        /// @notice mint `_amount` of tokens to `_owner`\n        /// @param _owner The address of the account receiving the tokens\n        /// @param _amount The amount of tokens to mint\n        /// @return Whether or not minting was successful\n        function mint(address _owner, uint256 _amount) returns(bool success);\n\n        /// @notice mintBadge Mint `_amount` badges to `_owner`\n        /// @param _owner The address of the account receiving the tokens\n        /// @param _amount The amount of tokens to mint\n        /// @return Whether or not minting was successful\n        function mintBadge(address _owner, uint256 _amount) returns(bool success);\n\n        function registerDao(address _dao) returns(bool success);\n\n        function registerSeller(address _tokensales) returns(bool success);\n\n        event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);\n        event Mint(address indexed _recipient, uint256 indexed _amount);\n        event Approval(address indexed _owner, address indexed _spender, uint256 indexed _value);\n}\n\ncontract TokenSalesInterface {\n\n        struct SaleProxy {\n                address payout;\n                bool isProxy;\n        }\n\n        struct SaleStatus {\n                bool founderClaim;\n                uint256 releasedTokens;\n                uint256 releasedBadges;\n                uint256 claimers;\n        }\n\n        struct Info {\n                uint256 totalWei;\n                uint256 totalCents;\n                uint256 realCents;\n                uint256 amount;\n        }\n\n        struct SaleConfig {\n                uint256 startDate;\n                uint256 periodTwo;\n                uint256 periodThree;\n                uint256 endDate;\n                uint256 goal;\n                uint256 cap;\n                uint256 badgeCost;\n                uint256 founderAmount;\n                address founderWallet;\n        }\n\n        struct Buyer {\n                uint256 centsTotal;\n                uint256 weiTotal;\n                bool claimed;\n        }\n\n        Info saleInfo;\n        SaleConfig saleConfig;\n        SaleStatus saleStatus;\n\n        address config;\n        address owner;\n        bool locked;\n\n        uint256 public ethToCents;\n\n        mapping(address => Buyer) buyers;\n        mapping(address => SaleProxy) proxies;\n\n        /// @notice Calculates the parts per billion 1⁄1,000,000,000 of `_a` to `_b`\n        /// @param _a The antecedent\n        /// @param _c The consequent\n        /// @return Part per billion value\n        function ppb(uint256 _a, uint256 _c) public constant returns(uint256 b);\n\n\n        /// @notice Calculates the share from `_total` based on `_contrib`\n        /// @param _contrib The contributed amount in USD\n        /// @param _total The total amount raised in USD\n        /// @return Total number of shares\n        function calcShare(uint256 _contrib, uint256 _total) public constant returns(uint256 share);\n\n        /// @notice Calculates the current USD cents value of `_wei`\n        /// @param _wei the amount of wei\n        /// @return The USD cents value\n        function weiToCents(uint256 _wei) public constant returns(uint256 centsvalue);\n\n        function proxyPurchase(address _user) returns(bool success);\n\n        /// @notice Send msg.value purchase for _user.\n        /// @param _user The account to be credited\n        /// @return Success if purchase was accepted\n        function purchase(address _user, uint256 _amount) private returns(bool success);\n\n        /// @notice Get crowdsale information for `_user`\n        /// @param _user The account to be queried\n        /// @return `centstotal` the total amount of USD cents contributed\n        /// @return `weitotal` the total amount in wei contributed\n        /// @return `share` the current token shares earned\n        /// @return `badges` the number of proposer badges earned\n        /// @return `claimed` is true if the tokens and badges have been claimed\n        function userInfo(address _user) public constant returns(uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed);\n\n        /// @notice Get the crowdsale information from msg.sender (see userInfo)\n        function myInfo() public constant returns(uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed);\n\n        /// @notice get the total amount of wei raised for the crowdsale\n        /// @return The amount of wei raised\n        function totalWei() public constant returns(uint);\n\n        /// @notice get the total USD value in cents raised for the crowdsale\n        /// @return the amount USD cents\n        function totalCents() public constant returns(uint);\n\n        /// @notice get the current crowdsale information\n        /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n        /// @return `two` The unix timestamp for the start of the second period modifier\n        /// @return `three` The unix timestamp for the start of the third period modifier\n        /// @return `endsale` The unix timestamp of the end of crowdsale\n        /// @return `totalwei` The total amount of wei raised\n        /// @return `totalcents` The total number of USD cents raised\n        /// @return `amount` The amount of DGD tokens available for the crowdsale\n        /// @return `goal` The USD value goal for the crowdsale\n        /// @return `famount` Founders endowment\n        /// @return `faddress` Founder wallet address\n        /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n\n        function claimFor(address _user) returns(bool success);\n\n        /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n        function claim() returns(bool success);\n\n        function claimFounders() returns(bool success);\n\n        /// @notice See if the crowdsale goal has been reached\n        function goalReached() public constant returns(bool reached);\n\n        /// @notice Get the current sale period\n        /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n        function getPeriod() public constant returns(uint saleperiod);\n\n        /// @notice Get the date for the start of the crowdsale\n        /// @return `date` The unix timestamp for the start\n        function startDate() public constant returns(uint date);\n\n        /// @notice Get the date for the second reward period of the crowdsale\n        /// @return `date` The unix timestamp for the second period\n        function periodTwo() public constant returns(uint date);\n\n        /// @notice Get the date for the final period of the crowdsale\n        /// @return `date` The unix timestamp for the final period\n        function periodThree() public constant returns(uint date);\n\n        /// @notice Get the date for the end of the crowdsale\n        /// @return `date` The unix timestamp for the end of the crowdsale\n        function endDate() public constant returns(uint date);\n\n        /// @notice Check if crowdsale has ended\n        /// @return `ended` If the crowdsale has ended\n\n        function isEnded() public constant returns(bool ended);\n\n        /// @notice Send raised funds from the crowdsale to the DAO\n        /// @return `success` if the send succeeded\n        function sendFunds() public returns(bool success);\n\n        //function regProxy(address _payment, address _payout) returns (bool success);\n        function regProxy(address _payout) returns(bool success);\n\n        function getProxy(address _payout) public returns(address proxy);\n\n        function getPayout(address _proxy) public returns(address payout, bool isproxy);\n\n        function unlock() public returns(bool success);\n\n        function getSaleStatus() public constant returns(bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n\n        function getSaleInfo() public constant returns(uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n\n        function getSaleConfig() public constant returns(uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n\n        event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n        event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n\n}\n\ncontract Badge {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowed;\n\n        address public owner;\n        bool public locked;\n\n        /// @return total amount of tokens\n        uint256 public totalSupply;\n\n        modifier ifOwner() {\n                if (msg.sender != owner) {\n                        throw;\n                } else {\n                        _\n                }\n        }\n\n\n        event Transfer(address indexed _from, address indexed _to, uint256 _value);\n        event Mint(address indexed _recipient, uint256 indexed _amount);\n        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n        function Badge() {\n                owner = msg.sender;\n        }\n\n        function safeToAdd(uint a, uint b) returns(bool) {\n                return (a + b >= a);\n        }\n\n        function addSafely(uint a, uint b) returns(uint result) {\n                if (!safeToAdd(a, b)) {\n                        throw;\n                } else {\n                        result = a + b;\n                        return result;\n                }\n        }\n\n        function safeToSubtract(uint a, uint b) returns(bool) {\n                return (b <= a);\n        }\n\n        function subtractSafely(uint a, uint b) returns(uint) {\n                if (!safeToSubtract(a, b)) throw;\n                return a - b;\n        }\n\n        function balanceOf(address _owner) constant returns(uint256 balance) {\n                return balances[_owner];\n        }\n\n        function transfer(address _to, uint256 _value) returns(bool success) {\n                if (balances[msg.sender] >= _value && _value > 0) {\n                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\n                        balances[_to] = addSafely(_value, balances[_to]);\n                        Transfer(msg.sender, _to, _value);\n                        success = true;\n                } else {\n                        success = false;\n                }\n                return success;\n        }\n\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n                if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n                        balances[_to] = addSafely(balances[_to], _value);\n                        balances[_from] = subtractSafely(balances[_from], _value);\n                        allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\n                        Transfer(_from, _to, _value);\n                        return true;\n                } else {\n                        return false;\n                }\n        }\n\n        function approve(address _spender, uint256 _value) returns(bool success) {\n                allowed[msg.sender][_spender] = _value;\n                Approval(msg.sender, _spender, _value);\n                success = true;\n                return success;\n        }\n\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n                remaining = allowed[_owner][_spender];\n                return remaining;\n        }\n\n        function mint(address _owner, uint256 _amount) ifOwner returns(bool success) {\n                totalSupply = addSafely(totalSupply, _amount);\n                balances[_owner] = addSafely(balances[_owner], _amount);\n                Mint(_owner, _amount);\n                return true;\n        }\n\n        function setOwner(address _owner) ifOwner returns(bool success) {\n                owner = _owner;\n                return true;\n        }\n\n}\n\ncontract Token {\n\n        address public owner;\n        address public config;\n        bool public locked;\n        address public dao;\n        address public badgeLedger;\n        uint256 public totalSupply;\n\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowed;\n        mapping(address => bool) seller;\n\n        /// @return total amount of tokens\n\n        modifier ifSales() {\n                if (!seller[msg.sender]) throw;\n                _\n        }\n\n        modifier ifOwner() {\n                if (msg.sender != owner) throw;\n                _\n        }\n\n        modifier ifDao() {\n                if (msg.sender != dao) throw;\n                _\n        }\n\n        event Transfer(address indexed _from, address indexed _to, uint256 _value);\n        event Mint(address indexed _recipient, uint256 _amount);\n        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n        function Token(address _config) {\n                config = _config;\n                owner = msg.sender;\n                address _initseller = ConfigInterface(_config).getConfigAddress(""sale1:address"");\n                seller[_initseller] = true;\n                badgeLedger = new Badge();\n                locked = false;\n        }\n\n        function safeToAdd(uint a, uint b) returns(bool) {\n                return (a + b >= a);\n        }\n\n        function addSafely(uint a, uint b) returns(uint result) {\n                if (!safeToAdd(a, b)) {\n                        throw;\n                } else {\n                        result = a + b;\n                        return result;\n                }\n        }\n\n        function safeToSubtract(uint a, uint b) returns(bool) {\n                return (b <= a);\n        }\n\n        function subtractSafely(uint a, uint b) returns(uint) {\n                if (!safeToSubtract(a, b)) throw;\n                return a - b;\n        }\n\n        function balanceOf(address _owner) constant returns(uint256 balance) {\n                return balances[_owner];\n        }\n\n        function transfer(address _to, uint256 _value) returns(bool success) {\n                if (balances[msg.sender] >= _value && _value > 0) {\n                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\n                        balances[_to] = addSafely(balances[_to], _value);\n                        Transfer(msg.sender, _to, _value);\n                        success = true;\n                } else {\n                        success = false;\n                }\n                return success;\n        }\n\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n                if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n                        balances[_to] = addSafely(balances[_to], _value);\n                        balances[_from] = subtractSafely(balances[_from], _value);\n                        allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\n                        Transfer(_from, _to, _value);\n                        return true;\n                } else {\n                        return false;\n                }\n        }\n\n        function approve(address _spender, uint256 _value) returns(bool success) {\n                allowed[msg.sender][_spender] = _value;\n                Approval(msg.sender, _spender, _value);\n                success = true;\n                return success;\n        }\n\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n                remaining = allowed[_owner][_spender];\n                return remaining;\n        }\n\n        function mint(address _owner, uint256 _amount) ifSales returns(bool success) {\n                totalSupply = addSafely(_amount, totalSupply);\n                balances[_owner] = addSafely(balances[_owner], _amount);\n                return true;\n        }\n\n        function mintBadge(address _owner, uint256 _amount) ifSales returns(bool success) {\n                if (!Badge(badgeLedger).mint(_owner, _amount)) return false;\n                return true;\n        }\n\n        function registerDao(address _dao) ifOwner returns(bool success) {\n                if (locked == true) return false;\n                dao = _dao;\n                locked = true;\n                return true;\n        }\n\n        function setDao(address _newdao) ifDao returns(bool success) {\n                dao = _newdao;\n                return true;\n        }\n\n        function isSeller(address _query) returns(bool isseller) {\n                return seller[_query];\n        }\n\n        function registerSeller(address _tokensales) ifDao returns(bool success) {\n                seller[_tokensales] = true;\n                return true;\n        }\n\n        function unregisterSeller(address _tokensales) ifDao returns(bool success) {\n                seller[_tokensales] = false;\n                return true;\n        }\n\n        function setOwner(address _newowner) ifDao returns(bool success) {\n                if (Badge(badgeLedger).setOwner(_newowner)) {\n                        owner = _newowner;\n                        success = true;\n                } else {\n                        success = false;\n                }\n                return success;\n        }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1409121,0x54bda709fed875224eae569bb6817d96ef7ed9ad,true,false,"/// @title DigixDAO Contract Interfaces\n\ncontract ConfigInterface {\n  address public owner;\n  mapping (address => bool) admins;\n  mapping (bytes32 => address) addressMap;\n  mapping (bytes32 => bool) boolMap;\n  mapping (bytes32 => bytes32) bytesMap;\n  mapping (bytes32 => uint256) uintMap;\n\n  /// @notice setConfigAddress sets configuration `_key` to `_val` \n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigAddress(bytes32 _key, address _val) returns (bool success);\n\n  /// @notice setConfigBool sets configuration `_key` to `_val` \n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigBool(bytes32 _key, bool _val) returns (bool success);\n\n  /// @notice setConfigBytes sets configuration `_key` to `_val`\n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigBytes(bytes32 _key, bytes32 _val) returns (bool success);\n\n  /// @notice setConfigUint `_key` to `_val`\n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigUint(bytes32 _key, uint256 _val) returns (bool success);\n\n  /// @notice getConfigAddress gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigAddress(bytes32 _key) returns (address val);\n\n  /// @notice getConfigBool gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigBool(bytes32 _key) returns (bool val);\n\n  /// @notice getConfigBytes gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigBytes(bytes32 _key) returns (bytes32 val);\n\n  /// @notice getConfigUint gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigUint(bytes32 _key) returns (uint256 val);\n\n  /// @notice addAdmin sets `_admin` as configuration admin\n  /// @return Whether the configuration setting was successful or not.  \n  function addAdmin(address _admin) returns (bool success);\n\n  /// @notice removeAdmin removes  `_admin`'s rights\n  /// @param _admin The key name of the configuration.\n  /// @return Whether the configuration setting was successful or not.  \n  function removeAdmin(address _admin) returns (bool success);\n\n}\n\ncontract TokenInterface {\n\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n  mapping (address => bool) seller;\n\n  address config;\n  address owner;\n  address dao;\n  address public badgeLedger;\n  bool locked;\n\n  /// @return total amount of tokens\n  uint256 public totalSupply;\n\n  /// @param _owner The address from which the balance will be retrieved\n  /// @return The balance\n  function balanceOf(address _owner) constant returns (uint256 balance);\n\n  /// @notice send `_value` tokens to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transfer(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n  /// @param _from The address of the sender\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @param _value The amount of tokens to be approved for transfer\n  /// @return Whether the approval was successful or not\n  function approve(address _spender, uint256 _value) returns (bool success);\n\n  /// @param _owner The address of the account owning tokens\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n  /// @notice mint `_amount` of tokens to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mint(address _owner, uint256 _amount) returns (bool success);\n\n  /// @notice mintBadge Mint `_amount` badges to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n\n  function registerDao(address _dao) returns (bool success);\n  function registerSeller(address _tokensales) returns (bool success);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);\n  event Mint(address indexed _recipient, uint256 indexed _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256 indexed _value);\n}\n\ncontract TokenSalesInterface {\n\n  struct SaleProxy {\n    address payout;\n    bool isProxy;\n  }\n\n  struct SaleStatus {\n    bool founderClaim;\n    uint256 releasedTokens;\n    uint256 releasedBadges;\n    uint256 claimers;\n  }\n\n  struct Info {\n    uint256 totalWei;\n    uint256 totalCents;\n    uint256 realCents;\n    uint256 amount;\n  }\n\n  struct SaleConfig {\n    uint256 startDate;\n    uint256 periodTwo;\n    uint256 periodThree;\n    uint256 endDate;\n    uint256 goal;\n    uint256 cap;\n    uint256 badgeCost;\n    uint256 founderAmount;\n    address founderWallet;\n  }\n\n  struct Buyer {\n    uint256 centsTotal;\n    uint256 weiTotal;\n    bool claimed;\n  }\n\n  Info saleInfo;\n  SaleConfig saleConfig;\n  SaleStatus saleStatus;\n\n  address config;\n  address owner;\n  bool locked;\n\n  uint256 public ethToCents;\n\n  mapping (address => Buyer) buyers;\n  mapping (address => SaleProxy) proxies;\n\n  /// @notice Calculates the parts per billion 1⁄1,000,000,000 of `_a` to `_b`\n  /// @param _a The antecedent\n  /// @param _c The consequent\n  /// @return Part per billion value\n  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b);\n\n\n  /// @notice Calculates the share from `_total` based on `_contrib` \n  /// @param _contrib The contributed amount in USD\n  /// @param _total The total amount raised in USD\n  /// @return Total number of shares\n  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share);\n\n  /// @notice Calculates the current USD cents value of `_wei` \n  /// @param _wei the amount of wei\n  /// @return The USD cents value\n  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue);\n\n  function proxyPurchase(address _user) returns (bool success);\n\n  /// @notice Send msg.value purchase for _user.  \n  /// @param _user The account to be credited\n  /// @return Success if purchase was accepted\n  function purchase(address _user, uint256 _amount) private returns (bool success);\n\n  /// @notice Get crowdsale information for `_user`\n  /// @param _user The account to be queried\n  /// @return `centstotal` the total amount of USD cents contributed\n  /// @return `weitotal` the total amount in wei contributed\n  /// @return `share` the current token shares earned\n  /// @return `badges` the number of proposer badges earned\n  /// @return `claimed` is true if the tokens and badges have been claimed\n  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n\n  /// @notice Get the crowdsale information from msg.sender (see userInfo)\n  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n\n  /// @notice get the total amount of wei raised for the crowdsale\n  /// @return The amount of wei raised\n  function totalWei() public constant returns (uint);\n\n  /// @notice get the total USD value in cents raised for the crowdsale\n  /// @return the amount USD cents\n  function totalCents() public constant returns (uint);\n\n  /// @notice get the current crowdsale information\n  /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n  /// @return `two` The unix timestamp for the start of the second period modifier\n  /// @return `three` The unix timestamp for the start of the third period modifier\n  /// @return `endsale` The unix timestamp of the end of crowdsale\n  /// @return `totalwei` The total amount of wei raised\n  /// @return `totalcents` The total number of USD cents raised\n  /// @return `amount` The amount of DGD tokens available for the crowdsale\n  /// @return `goal` The USD value goal for the crowdsale\n  /// @return `famount` Founders endowment\n  /// @return `faddress` Founder wallet address\n  /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n\n  function claimFor(address _user) returns (bool success); \n\n  /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n  function claim() returns (bool success);\n\n  function claimFounders() returns (bool success);\n\n  /// @notice See if the crowdsale goal has been reached\n  function goalReached() public constant returns (bool reached);\n\n  /// @notice Get the current sale period\n  /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n  function getPeriod() public constant returns (uint saleperiod);\n\n  /// @notice Get the date for the start of the crowdsale\n  /// @return `date` The unix timestamp for the start\n  function startDate() public constant returns (uint date);\n  \n  /// @notice Get the date for the second reward period of the crowdsale\n  /// @return `date` The unix timestamp for the second period\n  function periodTwo() public constant returns (uint date);\n\n  /// @notice Get the date for the final period of the crowdsale\n  /// @return `date` The unix timestamp for the final period\n  function periodThree() public constant returns (uint date);\n\n  /// @notice Get the date for the end of the crowdsale\n  /// @return `date` The unix timestamp for the end of the crowdsale\n  function endDate() public constant returns (uint date);\n\n  /// @notice Check if crowdsale has ended\n  /// @return `ended` If the crowdsale has ended\n  \n  function isEnded() public constant returns (bool ended);\n\n  /// @notice Send raised funds from the crowdsale to the DAO\n  /// @return `success` if the send succeeded\n  function sendFunds() public returns (bool success);\n\n  //function regProxy(address _payment, address _payout) returns (bool success);\n  function regProxy(address _payout) returns (bool success);\n\n  function getProxy(address _payout) public returns (address proxy);\n  \n  function getPayout(address _proxy) public returns (address payout, bool isproxy);\n\n  function unlock() public returns (bool success);\n\n  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n\n  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n\n  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n  \n  event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n  event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n\n}\n\n\ncontract Badge  {\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n\n  address public owner;\n  bool public locked;\n\n  /// @return total amount of tokens\n  uint256 public totalSupply;\n\n  modifier ifOwner() {\n    if (msg.sender != owner) {\n      throw;\n    } else {\n      _\n    }\n  }\n\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Mint(address indexed _recipient, uint256 indexed _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256  _value);\n\n  function Badge() {\n    owner = msg.sender;\n  }\n\n  function safeToAdd(uint a, uint b) returns (bool) {\n    return (a + b >= a);\n  }\n\n  function addSafely(uint a, uint b) returns (uint result) {\n    if (!safeToAdd(a, b)) {\n      throw;\n    } else {\n      result = a + b;\n      return result;\n    }\n  }\n\n  function safeToSubtract(uint a, uint b) returns (bool) {\n    return (b <= a);\n  }\n\n  function subtractSafely(uint a, uint b) returns (uint) {\n    if (!safeToSubtract(a, b)) throw;\n    return a - b;\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  function transfer(address _to, uint256 _value) returns (bool success) {\n    if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\n      balances[_to] = addSafely(_value, balances[_to]);\n      Transfer(msg.sender, _to, _value);\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] = addSafely(balances[_to], _value);\n      balances[_from] = subtractSafely(balances[_from], _value);\n      allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\n      Transfer(_from, _to, _value);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    success = true;\n    return success;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    remaining = allowed[_owner][_spender];\n    return remaining;\n  }\n\n  function mint(address _owner, uint256 _amount) ifOwner returns (bool success) {\n    totalSupply = addSafely(totalSupply, _amount);\n    balances[_owner] = addSafely(balances[_owner], _amount);\n    Mint(_owner, _amount);\n    return true;\n  }\n\n  function setOwner(address _owner) ifOwner returns (bool success) {\n    owner = _owner;\n    return true;\n  }\n\n}\n\ncontract Token {\n\n  address public owner;\n  address public config;\n  bool public locked;\n  address public dao;\n  address public badgeLedger;\n  uint256 public totalSupply;\n\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n  mapping (address => bool) seller;\n\n  /// @return total amount of tokens\n\n  modifier ifSales() {\n    if (!seller[msg.sender]) throw; \n    _ \n  }\n\n  modifier ifOwner() {\n    if (msg.sender != owner) throw;\n    _\n  }\n\n  modifier ifDao() {\n    if (msg.sender != dao) throw;\n    _\n  }\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Mint(address indexed _recipient, uint256  _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256  _value);\n\n  function Token(address _config) {\n    config = _config;\n    owner = msg.sender;\n    address _initseller = ConfigInterface(_config).getConfigAddress(""sale1:address"");\n    seller[_initseller] = true; \n    badgeLedger = new Badge();\n    locked = false;\n  }\n\n  function safeToAdd(uint a, uint b) returns (bool) {\n    return (a + b >= a);\n  }\n\n  function addSafely(uint a, uint b) returns (uint result) {\n    if (!safeToAdd(a, b)) {\n      throw;\n    } else {\n      result = a + b;\n      return result;\n    }\n  }\n\n  function safeToSubtract(uint a, uint b) returns (bool) {\n    return (b <= a);\n  }\n\n  function subtractSafely(uint a, uint b) returns (uint) {\n    if (!safeToSubtract(a, b)) throw;\n    return a - b;\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  function transfer(address _to, uint256 _value) returns (bool success) {\n    if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\n      balances[_to] = addSafely(balances[_to], _value);\n      Transfer(msg.sender, _to, _value);\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] = addSafely(balances[_to], _value);\n      balances[_from] = subtractSafely(balances[_from], _value);\n      allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\n      Transfer(_from, _to, _value);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    success = true;\n    return success;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    remaining = allowed[_owner][_spender];\n    return remaining;\n  }\n  function mint(address _owner, uint256 _amount) ifSales returns (bool success) {\n    totalSupply = addSafely(_amount, totalSupply);\n    balances[_owner] = addSafely(balances[_owner], _amount);\n    return true;\n  }\n\n  function mintBadge(address _owner, uint256 _amount) ifSales returns (bool success) {\n    if (!Badge(badgeLedger).mint(_owner, _amount)) return false;\n    return true;\n  }\n\n  function registerDao(address _dao) ifOwner returns (bool success) {\n    if (locked == true) return false;\n    dao = _dao;\n    locked = true;\n    return true;\n  }\n\n  function setDao(address _newdao) ifDao returns (bool success) {\n    dao = _newdao;\n    return true;\n  }\n\n  function isSeller(address _query) returns (bool isseller) {\n    return seller[_query];\n  }\n\n  function registerSeller(address _tokensales) ifDao returns (bool success) {\n    seller[_tokensales] = true;\n    return true;\n  }\n\n  function unregisterSeller(address _tokensales) ifDao returns (bool success) {\n    seller[_tokensales] = false;\n    return true;\n  }\n\n  function setOwner(address _newowner) ifDao returns (bool success) {\n    if(Badge(badgeLedger).setOwner(_newowner)) {\n      owner = _newowner;\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1409307,0xca4c45d98677e37a42559743ea2ab6950a1dc8a7,false,false,,,,TOO_SHORT
1409335,0x24e693cfe3447c98f791e365475104a747879370,false,false,,,,TOO_SHORT
1409430,0xd043cd5d0444990904f3b3da670e0e56dc1219f3,false,false,,,,TOO_SHORT
1409594,0x233acdef18b434fe06b94fefd5b8eda3078dc2ec,false,false,,,,0x65e0b64a6d2f57af939a3978ed52f7bbb3bf21cb
1409621,0xfd10babcad879be54370fa602f73d26b2fe7a200,false,false,,,,0x65e0b64a6d2f57af939a3978ed52f7bbb3bf21cb
1409651,0x0cb10aac70598245491c920d6c84884bd9409148,false,false,,,,0x65e0b64a6d2f57af939a3978ed52f7bbb3bf21cb
1409657,0x5bff984f7a96dc7713fca8121b0331ef60a2f2ff,false,false,,,,TOO_SHORT
1409790,0x3b3b1c9f68ce3266ff3cf2ce63e638611f393209,false,false,,,,TOO_SHORT
1409888,0x9b958bad1115f01c70e639f8aa8697145b5fa19f,false,false,,,,TOO_SHORT
1410062,0xbc8a13ec7fa0a8bfd3e52ef74576c0940ef889b9,false,false,,,,TOO_SHORT
1410070,0xa365c183dd416f3eedf91fbda6bef30bd8d596c5,false,false,,,,TOO_SHORT
1411093,0x1624398f840348ec3e8f18c2232971dfad0f2dac,false,false,,,,TOO_SHORT
1412247,0x2e7739d2a95d4fd14d46cb91d83b4b01c215b029,false,false,,,,TOO_SHORT
1412313,0x1dd51875ccd2b91723e4e11003ca9d1a0db8074c,false,false,,,,TOO_SHORT
1412647,0x7f00913646df785954f17c4fb1d06f6f6dbecee5,false,false,,,,TOO_SHORT
1412713,0xca0b00d16d094e0a21d56e2fdac22742050e9f3f,false,false,,,,TOO_SHORT
1412865,0x2ac7065977d51d564bf2f2b0d65738c2253627d5,false,false,,,,TOO_SHORT
1413128,0x462248746856d37e69e8f3dc1317c6074a66df08,false,false,,,,TOO_SHORT
1413425,0x5e3d5f804ab218ac2db04f3713a8c20ee1789fda,false,false,,,,TOO_SHORT
1413512,0x25db0f59bf166c49d1f859c9cb5928cbbf685981,false,false,"contract EthDig\n{\n    uint constant LifeTime = 30;\n    \n    address Owner = msg.sender;\n    address OutputAddress = msg.sender;\n    \n    uint64 Coef1=723;\n    uint64 Coef2=41665;\n    uint64 Coef3=600000;\n    \n    uint public ContributedAmount;\n    uint ContributedLimit = 10 ether;\n    \n    uint public CashForHardwareReturn;\n    uint public FreezedCash;\n    \n    uint16 UsersLength = 0;\n    mapping (uint16 => User) Users;\n    struct User{\n        address Address;\n        uint16 ContributionsLength;\n        mapping (uint16 => Contribution) Contributions;\n    }\n    struct Contribution{\n        uint CashInHarware;\n        uint CashFreezed;\n        \n        uint16 ProfitPercent;\n        uint NeedPayByDay;\n        \n        bool ReuseCashInHarware;\n        \n        uint DateCreated;\n        uint DateLastCheck;\n        uint AlreadyPaid;\n        \n        bool ReturnedHardwareCash;\n        bool Finished;\n    }\n    \n    function  ContributeInternal(uint16 userId,uint cashInHarware,uint cashFreezed,bool reuseCashInHarware) private{\n        Contribution contribution = Users[userId].Contributions[Users[userId].ContributionsLength];\n\n        contribution.CashInHarware = cashInHarware;\n        contribution.CashFreezed = cashFreezed;\n        \n        uint8 noFreezCoef = uint8 ((cashInHarware * 100) / (cashFreezed+cashInHarware));\n        contribution.ProfitPercent = uint16 (((Coef1 * noFreezCoef * noFreezCoef) + (Coef2 * noFreezCoef) + Coef3)/10000);//10000\n        \n        contribution.NeedPayByDay = (((cashInHarware + cashFreezed) /10000) * contribution.ProfitPercent)/LifeTime;\n        contribution.ReuseCashInHarware = reuseCashInHarware;\n        contribution.DateCreated = now;\n        contribution.DateLastCheck = now;\n        \n        Users[userId].ContributionsLength++;\n    }\n    function ContributeWithSender (bool reuseCashInHarware,uint8 freezeCoeff,address sender) {\n        if (msg.value == 0 || freezeCoeff>100 ||ContributedAmount + msg.value > ContributedLimit)\n        {\n            sender.send(msg.value);\n            return;\n        }\n        \n        uint16 userId = GetUserIdByAddress(sender);\n        if (userId == 65535)\n        {\n            userId = UsersLength;\n            Users[userId].Address = sender;\n            UsersLength ++;\n        }\n        \n        uint cashFreezed = ((msg.value/100)*freezeCoeff);\n        ContributeInternal(\n            userId,\n            msg.value - cashFreezed,\n            cashFreezed,\n            reuseCashInHarware\n            );\n        FreezedCash += cashFreezed;\n        ContributedAmount += msg.value;\n        \n        OutputAddress.send(msg.value - cashFreezed);\n    }\n    function Contribute (bool reuseCashInHarware,uint8 freezeCoeff) {\n        ContributeWithSender(reuseCashInHarware,freezeCoeff,msg.sender);\n    }\n    function ChangeReuseCashInHarware(bool newValue,uint16 userId,uint16 contributionId){\n        if (msg.sender != Users[userId].Address) return;\n        Users[userId].Contributions[contributionId].ReuseCashInHarware = newValue;\n    }\n    \n    function Triger(){\n        if (Owner != msg.sender) return;\n        \n        uint MinedTillLastPayment = this.balance - CashForHardwareReturn - FreezedCash;\n        bool NotEnoughCash = false;\n        \n        for(uint16 i=0;i<UsersLength;i++)\n        {\n            for(uint16 j=0;j<Users[i].ContributionsLength;j++)\n            {\n                Contribution contribution = Users[i].Contributions[j];\n                if (contribution.Finished || now - contribution.DateLastCheck < 1 days) continue;\n                \n                if (contribution.AlreadyPaid != contribution.NeedPayByDay * LifeTime)\n                {\n                    uint8 daysToPay = uint8((now - contribution.DateCreated)/1 days);\n                    if (daysToPay>LifeTime) daysToPay = uint8(LifeTime);\n                    uint needToPay = (daysToPay * contribution.NeedPayByDay) - contribution.AlreadyPaid;\n                    \n                    if (MinedTillLastPayment < needToPay)\n                    {\n                        NotEnoughCash = true;\n                    }\n                    else\n                    {\n                        if (needToPay > 100 finney || daysToPay == LifeTime)\n                        {\n                            MinedTillLastPayment -= needToPay;\n                            Users[i].Address.send(needToPay);\n                            contribution.AlreadyPaid += needToPay;\n                        }\n                    }\n                    contribution.DateLastCheck = now;\n                }\n\n                if (now > contribution.DateCreated + (LifeTime * 1 days) && !contribution.ReturnedHardwareCash)\n                {\n                    if (contribution.ReuseCashInHarware)\n                    {\n                        ContributeInternal(\n                            i,\n                            contribution.CashInHarware,\n                            contribution.CashFreezed,\n                            true\n                        );\n                        contribution.ReturnedHardwareCash = true;\n                    }\n                    else\n                    {\n                        if (CashForHardwareReturn >= contribution.CashInHarware)\n                        {\n                            CashForHardwareReturn -= contribution.CashInHarware;\n                            FreezedCash -= contribution.CashFreezed;\n                            ContributedAmount -= contribution.CashFreezed + contribution.CashInHarware;\n                            Users[i].Address.send(contribution.CashInHarware + contribution.CashFreezed);\n                            contribution.ReturnedHardwareCash = true;\n                        }\n                    }\n                }\n                \n                if (contribution.ReturnedHardwareCash && contribution.AlreadyPaid == contribution.NeedPayByDay * LifeTime)\n                {\n                    contribution.Finished = true;\n                }\n            }  \n        }\n        \n        if (!NotEnoughCash)\n        {\n            OutputAddress.send(MinedTillLastPayment);\n        }\n    }\n    \n    function ConfigureFunction(address outputAddress,uint contributedLimit,uint16 coef1,uint16 coef2,uint16 coef3)\n    {\n        if (Owner != msg.sender) return;\n        OutputAddress = outputAddress;\n        ContributedLimit = contributedLimit;\n        Coef1 = coef1;\n        Coef2 = coef2;\n        Coef3 = coef3;\n    }\n    \n    function SendCashForHardwareReturn(){\n        CashForHardwareReturn += msg.value;\n    }\n    function WithdrawCashForHardwareReturn(uint amount){\n        if (Owner != msg.sender || CashForHardwareReturn < amount) return;\n        Owner.send(amount);\n    }\n    \n    function GetUserIdByAddress (address userAddress) returns (uint16){\n        for(uint16 i=0; i<UsersLength;i++)\n        {\n            if (Users[i].Address == userAddress)\n                return i;\n        }\n        return 65535;\n    }\n    \n    function GetContributionInfo (uint16 userId,uint16 contributionId) \n    returns (uint a1,uint a2, uint16 a3,uint a4, bool a5,uint a6,uint a7,uint a8,bool a9,bool a10,address a11) \n    {\n        Contribution contribution = Users[userId].Contributions[contributionId];\n        a1 = contribution.CashInHarware;\n        a2 = contribution.CashFreezed;\n        a3 = contribution.ProfitPercent;\n        a4 = contribution.NeedPayByDay;\n        a5 = contribution.ReuseCashInHarware;\n        a6 = contribution.DateCreated;\n        a7 = contribution.DateLastCheck;\n        a8 = contribution.AlreadyPaid;\n        a9 = contribution.ReturnedHardwareCash;\n        a10 = contribution.Finished;\n        a11 = Users[userId].Address;\n    }\n    \n}\n\ncontract EthDigProxy\n{\n    address Owner = msg.sender;\n    EthDig public ActiveDigger; \n    \n    function ChangeActiveDigger(address activeDiggerAddress){\n        if (msg.sender != Owner) return;\n        ActiveDigger =EthDig(activeDiggerAddress);\n    }\n    function GetMoney(){\n        if (msg.sender != Owner) return;\n        Owner.send(this.balance);\n    }\n    \n    function Contribute (bool reuseCashInHarware,uint8 freezeCoeff) {\n        ActiveDigger.ContributeWithSender.value(msg.value)(reuseCashInHarware,freezeCoeff,msg.sender);\n    }\n    function (){\n        ActiveDigger.ContributeWithSender.value(msg.value)(false,0,msg.sender);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1413640,0x8146e9a4b779bcd4f8d5bff7c525ab604d75b222,false,false,,,,TOO_SHORT
1414050,0x72721d17933781bc58079fffd7590c88abb0a7b4,false,false,,,,TOO_SHORT
1414070,0xa847272298ff1e20b2242e4381923e6e820bd4af,false,false,,,,TOO_SHORT
1414081,0xfccc3f1080126bd9b16661b79b8d3fcfda95f585,false,false,,,,TOO_SHORT
1414110,0x422b669f772274db104a43d2f03ccb5d337005c5,false,false,,,,TOO_SHORT
1414340,0xaa04985bf2418dd6e871954f8556140aae1fbc97,false,false,,,,TOO_SHORT
1414395,0x5d767e8a178c0d4b134451cb04f7eec01f423cd4,false,false,,,,TOO_SHORT
1414564,0x20e4b4bbdbf068f48bfc4cd9e8dd384d9c0dc85a,false,false,,,,TOO_SHORT
1414638,0x6140d98c1bf9206488fc3428e2dc5496b0a23d84,false,false,"contract Matching_Finneys\n{\n    enum State{Active, Deactivated}\n    State public state;\n\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier onlyActive() {\n         if (state!=State.Active) throw;\n         _\n    }\n    modifier onlyInactive() {\n         if (state!=State.Deactivated) throw;\n         _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gamble_value) throw;\n        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\n	_\n    }\n    modifier resolvePendingRound{\n        blockLastPlayer=block.number+1;    \n        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\n	else if (pendingRound && blockLastPlayer==blockEndRound) throw;\n	_\n    }\n\n    uint blockLastPlayer;\n    address private owner;\n    uint gamble_value;\n    uint information_cost;\n    uint round_max_size ;\n    uint round_min_size  ;  \n    uint index_player;\n    uint index_round_ended;\n    uint index_player_in_round;\n    bool pendingRound = false;\n    uint blockEndRound;\n    struct Gamble  {\n	    address player;\n	    bool flipped;\n    }\n    Gamble[] matchers; \n    Gamble[] contrarians;\n    struct Result  {\n	    address player_matcher;\n	    bool flipped_matcher;\n	    uint256 payout_matcher;\n	    address player_contrarian;\n	    bool flipped_contrarian;\n	    uint256 payout_contrarian;\n    }\n    Result[] results; \n    mapping (address => uint) payout_history;\n    mapping (address => uint) times_played_history;    \n     \n    //Contract Construtor\n    function Matching_Ethers() { //Initial settings\n	    owner = msg.sender; \n	    round_min_size = 16;\n	    round_max_size = 20;\n	    information_cost= 500 szabo; //0.005 ether, 5 finney\n            gamble_value = 100000 szabo; //0.1 ether\n    }\n    //FallBack Function (play by sending a transaction)\n    function () { \n        bool flipped;\n        if (msg.value == gamble_value) flipped=false; \n        if (msg.value > gamble_value) {\n            flipped=true;\n        }\n        Play(flipped); \n    }\n    //Play Function (play by contract function call)\n    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\n        if ( index_player_in_round%2==0 ) {   //first is matcher\n	    matchers.push(Gamble(msg.sender, flipped));\n	}\n	else {\n	    contrarians.push(Gamble(msg.sender, flipped));\n	}\n        index_player+=1;\n        index_player_in_round+=1;\n	times_played_history[msg.sender]+=1;\n        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\n	            bool end = randomEnd();\n		    if (end) {\n		        pendingRound=true;\n			blockEndRound=block.number;}\n        }\n    }\n    //Random Number Generator (between 1 and range)\n    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\n        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\n    }\n    //Function that determines randomly when the round should be ended\n    function randomEnd() private returns(bool) {\n	if (index_player_in_round==round_max_size) return true; //end if max_size\n	else{\n	    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\n	    if (random==1) return true;\n	    else return false;\n	    }\n    }\n    //Function to end Round and pay winners\n    function endRound() private {\n        delete results;\n        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\n        uint256 payout_total;\n        for (var k = 0; k < (index_player_in_round)/2; k++) {\n            uint256 index_contrarian;\n	    if (k+random_start_contrarian<(index_player_in_round)/2){\n	        index_contrarian=k+random_start_contrarian;\n            }\n	    else{\n	        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\n	    }\n	    uint256 information_cost_matcher = information_cost * k;\n	    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\n	    uint256 information_cost_contrarian = information_cost * index_contrarian;\n	    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\n	    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\n	    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\n	        matchers[k].player.send(payout_matcher);\n		payout_total+=payout_matcher;\n		payout_history[matchers[k].player]+=payout_matcher;\n	    }\n	    else {\n	        contrarians[index_contrarian].player.send(payout_contrarian);\n		payout_total+=payout_contrarian;\n		payout_history[contrarians[k].player]+=payout_contrarian;\n	    }\n	}\n        index_round_ended+=1;\n        owner.send(index_player_in_round*gamble_value-payout_total);\n	payout_total=0;\n        index_player_in_round=0;\n        delete matchers;\n        delete contrarians;\n	pendingRound=false;\n	if (terminate_after_round==true) state=State.Deactivated;\n    }\n    //Full Refund of Current Round (if needed)\n    function refundRound() \n    onlyActive\n    onlyOwner noEthSent{  \n        uint totalRefund;\n	uint balanceBeforeRefund=this.balance;\n        for (var k = 0;  k< matchers.length; k++) {\n	            matchers[k].player.send(gamble_value);\n		    totalRefund+=gamble_value;\n        }\n        for (var j = 0;  j< contrarians.length ; j++) {	\n	            contrarians[j].player.send(gamble_value);\n		    totalRefund+=gamble_value;		    \n        }\n	delete matchers;\n	delete contrarians;\n	state=State.Deactivated;\n	index_player_in_round=0;\n	owner.send(balanceBeforeRefund-totalRefund);\n    }\n    //Function Pause contract after next round (for new contract or to change settings) \n    bool terminate_after_round=false;\n    function deactivate()\n    onlyOwner noEthSent{\n	    terminate_after_round=true;\n    }\n    //Function Reactivates contract (after change of settings for instance or a refound)\n    function reactivate()\n    onlyOwner noEthSent{\n        state=State.Active;\n        terminate_after_round=false;\n    }\n    //Function to change game settings (within limits)\n    //(to adapt to community feedback, popularity)\n    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\n	    onlyOwner\n	    onlyInactive noEthSent{\n	    if (new_max_round<new_min_round) throw;\n	    if (new_information_cost > new_gamble_value/100) throw;\n	    round_max_size = new_max_round;\n	    round_min_size = new_min_round;\n	    information_cost= new_information_cost;\n	    gamble_value = new_gamble_value;\n    }\n    function changeOwner(address new_owner)\n	    onlyOwner noEthSent{\n	    owner=new_owner;\n    }\n    \n\n    modifier noEthSent(){\n        if (msg.value>0) throw;\n	_\n    }\n    //desactiver l'envoi d'argent sur ces fonctions\n    //JSON GLOBAL STATS\n    function gameStats() noEthSent constant returns (uint _index_player_in_round, uint _index_player, uint _index_round_ended, bool _pendingRound, uint _blockEndRound, uint _blockLastPlayer, State _state, bool _terminate_after_round)\n    {\n         _index_player_in_round = index_player_in_round;\n	 _index_player = index_player;\n	 _index_round_ended = index_round_ended;\n	 _pendingRound = pendingRound;\n	 _blockEndRound = blockEndRound;\n	 _blockLastPlayer = blockLastPlayer;\n	 _state = state;\n	 _terminate_after_round = terminate_after_round;\n     }\n     //JSON CURRENT SETTINGS\n     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\n	 _gamble_value = gamble_value;\n	 _information_cost = information_cost;\n	 _round_min_size = round_min_size;\n	 _round_max_size = round_max_size;\n     }\n\n    //JSON MATCHER TEAM\n    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=matchers[_index].player;\n	_flipped = matchers[_index].flipped;\n    }\n    //JSON CONTRARIAN TEAM\n    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=contrarians[_index].player;\n	_flipped = contrarians[_index].flipped;\n    }\n    //return contrarians\n    //JSON LAST ROUND RESULT\n    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\n        _address_matcher=results[_index].player_matcher;\n        _address_contrarian=results[_index].player_contrarian;\n	_flipped_matcher = results[_index].flipped_matcher;\n	_flipped_contrarian = results[_index].flipped_contrarian;\n	_payout_matcher =  results[_index].payout_matcher;\n	_payout_contrarian =  results[_index].payout_contrarian;\n    }\n    //User set nickname for the website\n     mapping (address => string) nicknames;\n     function setNickname(string name) noEthSent{\n         if (bytes(name).length >= 2 && bytes(name).length <= 16)\n             nicknames[msg.sender] = name;\n     }\n     function getNickname(address _address) noEthSent constant returns(string _name) {\n             _name = nicknames[_address];\n     }\n\n     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\n             _payout = payout_history[_address]; \n     }\n     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\n             _count = times_played_history[_address]; \n     }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックに焦点を当てている。,
1414908,0x9def023820839e2e44edf4bcecc98689fb1cdeff,false,false,,,,TOO_SHORT
1415736,0x1df6d278bd1e1f92f5c148498f9c57e975642869,false,false,,,,TOO_SHORT
1415738,0xfa2bb36a8cf4432d3e6e430d9e5c44b0aca73b3e,false,false,,,,TOO_SHORT
1415799,0xcecc9d1807a3a3a629043ae44e0181353efd84a2,false,false,,,,TOO_SHORT
1415823,0xaff7f21555fa5948af3a4b4418a4fd76ec3782a4,false,false,,,,TOO_SHORT
1415873,0xda4a4626d3e16e094de3225a751aab7128e96526,false,false,,,,TOO_SHORT
1415898,0x7719a4fb2b961b9b545ba0d4cbde3b5c2076ad82,false,false,,,,TOO_SHORT
1415905,0xd238ec529a7ecbb1babd783d00bbc551a5eee3df,false,false,,,,TOO_SHORT
1415920,0x3cfc063bd445226fb9b5216613af38a76b8ae3be,false,false,,,,TOO_SHORT
1416745,0x873b297ea506ba98cb72621e010b277619a7ff77,false,false,,,,TOO_SHORT
1417464,0x1cd5f811db7dcd0e25164fb95499b675b72c4108,false,false,,,,TOO_SHORT
1418006,0xecb4380189e22ed2abccff53a6ac1d1e02bd6981,false,false,,,,TOO_SHORT
1418258,0xb61d12ac06284220bccb5073f2b92b4c5405e243,false,false,,,,TOO_SHORT
1418896,0x002a25962194a4cf360f3fd6ec0e35b52c36ce67,false,false,,,,TOO_SHORT
1418965,0x529b2211a733aa31d5c571a99c4436a8ad8e1bc0,false,false,,,,TOO_SHORT
1418975,0x01cf709612665ac9d33d5545c9ec856730390b2f,false,false,,,,TOO_SHORT
1419187,0x1f0b9db5bb0f2a60f8c8824cec738c15805dbdec,false,false,,,,0x65e0b64a6d2f57af939a3978ed52f7bbb3bf21cb
1419278,0x98861255ba9e76b9b909e626dc69113fbe5bf7f4,false,false,,,,TOO_SHORT
1419350,0xed57dd8a3d21f256fb62cd45096d75c639eb5112,false,false,,,,TOO_SHORT
1419472,0x83651a62b632c261442f396ad7202fe2a4995e3a,false,false,"contract LittleEthereumDoubler {\n//--------------------------------------------------USERS-----------------------------------------------------------\n    struct User {\n        address addr;\n        uint paidOut;\n        uint payoutLeft;\n    }\n    User[] private users;\n    uint private index;\n//--------------------------------------------------DEPLOYMENT AND FEES---------------------------------------------\n    address private feeAddress;\n\n    modifier execute { if (feeAddress == tx.origin) _ }\n    \n    function NewFeeAddress(address newFeeAddress) execute {\n        if (msg.value != 0) tx.origin.send(msg.value);\n        feeAddress = newFeeAddress;\n    }\n    \n    function LittleEthereumDoubler() {\n        feeAddress = tx.origin;\n    }\n//--------------------------------------------------CONTRACT--------------------------------------------------------\n    function() {\n        Start();\n    }\n    \n    function Start() internal {\n        uint a = msg.value;     // a = amount\n        a = DepositLimit(a);    // trim if too much, throw is too little\n        Fees(a);                // 2,5% fees goes to the fee address\n        NewDeposit(a);          // put user in the usersdatabase\n        Payout();               // pay out who is in the index\n    }\n    \n    function DepositLimit(uint a) internal returns (uint x){\n        x = a;\n        if (x < 100 finney) throw;\n        if (x > 50 ether) {\n            x = 50 ether;\n            tx.origin.send(a - x);\n        }\n    }\n    \n    function Fees(uint a) internal {\n        feeAddress.send(a * 25 / 1000);\n    }\n    \n    function NewDeposit(uint a) internal {\n        users.length++;\n        users[users.length - 1].addr = tx.origin;\n        users[users.length - 1].payoutLeft = a * 2;\n    }\n    \n    function Payout() internal {\n        while (this.balance != 0) {\n            if (users[index].payoutLeft > this.balance) {\n                users[index].payoutLeft -= this.balance;\n                users[index].paidOut += this.balance;\n                users[index].addr.send(this.balance);\n            }\n            else {\n                users[index].paidOut += users[index].payoutLeft;\n                users[index].addr.send(users[index].payoutLeft);\n                delete users[index].payoutLeft;\n                index++;\n            }\n        }\n    }\n//--------------------------------------------------MIST GUI--------------------------------------------------------\n    function UserDatabase(uint id) constant returns(address Address, uint Payout, uint PaidOut, uint PayoutLeft, string info) {\n        Address = users[id].addr;\n        PaidOut = users[id].paidOut / 100 finney;\n        PayoutLeft = users[id].payoutLeft / 100 finney;\n        Payout = (users[id].paidOut + users[id].payoutLeft) / 100 finney;\n        info = 'values are shown in a denomination of 100 finneys ( 100 finney = 0.1 ether = minimum input)';\n    }\n}",1,実用的な構造で、投資と支払いを管理する標準的なスマートコントラクトです。,
1419482,0xb695ce49a547c830834058cf409ae795595c093c,false,false,,,,TOO_SHORT
1419516,0xdb9b3f9c12e710517ac572378c6199bc3624b1ed,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'         '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   MATCHING ETHERS                              \n//   a Strategy and Luck DaapGame          \n//   www.matching-ethers.com                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                       ***//\n// *** contact : reddit    /u/WhySoS3rious                                ***//\n\n//VERSION : 1.0\n\n// GAME MODE : MATCHING FINNEYS\n// STAKE : 0.1 ETH\n\n contract Matching_Finneys\n{\n    enum State{Active, Deactivated}\n    State public state;\n\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier onlyActive() {\n         if (state!=State.Active) throw;\n         _\n    }\n    modifier onlyInactive() {\n         if (state!=State.Deactivated) throw;\n         _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gamble_value) throw;\n        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\n	_\n    }\n    modifier resolvePendingRound{\n        blockLastPlayer=block.number+1;    \n        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\n	else if (pendingRound && blockLastPlayer==blockEndRound) throw;\n	_\n    }\n\n    uint blockLastPlayer;\n    address private owner;\n    uint gamble_value;\n    uint information_cost;\n    uint round_max_size ;\n    uint round_min_size  ;  \n    uint index_player;\n    uint index_round_ended;\n    uint index_player_in_round;\n    bool pendingRound = false;\n    uint blockEndRound;\n    struct Gamble  {\n	    address player;\n	    bool flipped;\n    }\n    Gamble[] matchers; \n    Gamble[] contrarians;\n    struct Result  {\n	    address player_matcher;\n	    bool flipped_matcher;\n	    uint256 payout_matcher;\n	    address player_contrarian;\n	    bool flipped_contrarian;\n	    uint256 payout_contrarian;\n    }\n    Result[] results; \n    mapping (address => uint) payout_history;\n    mapping (address => uint) times_played_history;    \n     \n    //Contract Construtor\n    function Matching_Ethers() { //Initial settings\n	    owner = msg.sender; \n	    round_min_size = 16;\n	    round_max_size = 20;\n	    information_cost= 500 szabo; //0.005 ether, 5 finney\n            gamble_value = 100000 szabo; //0.1 ether\n    }\n    //FallBack Function (play by sending a transaction)\n    function () { \n        bool flipped;\n        if (msg.value == gamble_value) flipped=false; \n        if (msg.value > gamble_value) {\n            flipped=true;\n        }\n        Play(flipped); \n    }\n    //Play Function (play by contract function call)\n    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\n        if ( index_player_in_round%2==0 ) {   //first is matcher\n	    matchers.push(Gamble(msg.sender, flipped));\n	}\n	else {\n	    contrarians.push(Gamble(msg.sender, flipped));\n	}\n        index_player+=1;\n        index_player_in_round+=1;\n	times_played_history[msg.sender]+=1;\n        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\n	            bool end = randomEnd();\n		    if (end) {\n		        pendingRound=true;\n			blockEndRound=block.number;}\n        }\n    }\n    //Random Number Generator (between 1 and range)\n    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\n        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\n    }\n    //Function that determines randomly when the round should be ended\n    function randomEnd() private returns(bool) {\n	if (index_player_in_round==round_max_size) return true; //end if max_size\n	else{\n	    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\n	    if (random==1) return true;\n	    else return false;\n	    }\n    }\n    //Function to end Round and pay winners\n    function endRound() private {\n        delete results;\n        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\n        uint256 payout_total;\n        for (var k = 0; k < (index_player_in_round)/2; k++) {\n            uint256 index_contrarian;\n	    if (k+random_start_contrarian<(index_player_in_round)/2){\n	        index_contrarian=k+random_start_contrarian;\n            }\n	    else{\n	        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\n	    }\n	    uint256 information_cost_matcher = information_cost * k;\n	    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\n	    uint256 information_cost_contrarian = information_cost * index_contrarian;\n	    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\n	    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\n	    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\n	        matchers[k].player.send(payout_matcher);\n		payout_total+=payout_matcher;\n		payout_history[matchers[k].player]+=payout_matcher;\n	    }\n	    else {\n	        contrarians[index_contrarian].player.send(payout_contrarian);\n		payout_total+=payout_contrarian;\n		payout_history[contrarians[k].player]+=payout_contrarian;\n	    }\n	}\n        index_round_ended+=1;\n        owner.send(index_player_in_round*gamble_value-payout_total);\n	payout_total=0;\n        index_player_in_round=0;\n        delete matchers;\n        delete contrarians;\n	pendingRound=false;\n	if (terminate_after_round==true) state=State.Deactivated;\n    }\n    //Full Refund of Current Round (if needed)\n    function refundRound() \n    onlyActive\n    onlyOwner noEthSent{  \n        uint totalRefund;\n	uint balanceBeforeRefund=this.balance;\n        for (var k = 0;  k< matchers.length; k++) {\n	            matchers[k].player.send(gamble_value);\n		    totalRefund+=gamble_value;\n        }\n        for (var j = 0;  j< contrarians.length ; j++) {	\n	            contrarians[j].player.send(gamble_value);\n		    totalRefund+=gamble_value;		    \n        }\n	delete matchers;\n	delete contrarians;\n	state=State.Deactivated;\n	index_player_in_round=0;\n        uint balanceLeft = balanceBeforeRefund-totalRefund;\n	if (balanceLeft >0) owner.send(balanceLeft);\n    }\n    //Function Pause contract after next round (for new contract or to change settings) \n    bool terminate_after_round=false;\n    function deactivate()\n    onlyOwner noEthSent{\n	    terminate_after_round=true;\n    }\n    //Function Reactivates contract (after change of settings for instance or a refound)\n    function reactivate()\n    onlyOwner noEthSent{\n        state=State.Active;\n        terminate_after_round=false;\n    }\n    //Function to change game settings (within limits)\n    //(to adapt to community feedback, popularity)\n    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\n	    onlyOwner\n	    onlyInactive noEthSent{\n	    if (new_max_round<new_min_round) throw;\n	    if (new_information_cost > new_gamble_value/100) throw;\n	    round_max_size = new_max_round;\n	    round_min_size = new_min_round;\n	    information_cost= new_information_cost;\n	    gamble_value = new_gamble_value;\n    }\n    function changeOwner(address new_owner)\n	    onlyOwner noEthSent{\n	    owner=new_owner;\n    }\n    \n\n    modifier noEthSent(){\n        if (msg.value>0) throw;\n	_\n    }\n    //JSON GLOBAL STATS\n    function gameStats() noEthSent constant returns (uint number_of_player_in_round, uint total_number_of_player, uint number_of_round_ended, bool pending_round_to_resolve, uint block_end_last_round, uint block_last_player, State state, bool pause_contract_after_round)\n    {\n         number_of_player_in_round = index_player_in_round;\n	 total_number_of_player = index_player;\n	 number_of_round_ended = index_round_ended;\n	 pending_round_to_resolve = pendingRound;\n	 block_end_last_round = blockEndRound;\n	 block_last_player = blockLastPlayer;\n	 state = state;\n	 pause_contract_after_round = terminate_after_round;\n     }\n     //JSON CURRENT SETTINGS\n     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\n	 _gamble_value = gamble_value;\n	 _information_cost = information_cost;\n	 _round_min_size = round_min_size;\n	 _round_max_size = round_max_size;\n     }\n\n    //JSON MATCHER TEAM\n    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=matchers[_index].player;\n	_flipped = matchers[_index].flipped;\n    }\n    //JSON CONTRARIAN TEAM\n    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=contrarians[_index].player;\n	_flipped = contrarians[_index].flipped;\n    }\n    //JSON LAST ROUND RESULT\n    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\n        _address_matcher=results[_index].player_matcher;\n        _address_contrarian=results[_index].player_contrarian;\n	_flipped_matcher = results[_index].flipped_matcher;\n	_flipped_contrarian = results[_index].flipped_contrarian;\n	_payout_matcher =  results[_index].payout_matcher;\n	_payout_contrarian =  results[_index].payout_contrarian;\n    }\n    //User set nickname for the website\n     mapping (address => string) nicknames;\n     function setNickname(string name) noEthSent{\n         if (bytes(name).length >= 2 && bytes(name).length <= 16)\n             nicknames[msg.sender] = name;\n     }\n     function getNickname(address _address) noEthSent constant returns(string _name) {\n             _name = nicknames[_address];\n     }\n     //JSON HISTORY\n     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\n             _payout = payout_history[_address]; \n     }\n     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\n             _count = times_played_history[_address]; \n     }\n\n}",2,アスキーアートとコメントが詩的要素を加え、ゲーム性が芸術的な印象を与えます。,
1419571,0x3e4358e721ffb52f2495d307db9b70356a3961f5,false,false,,,,TOO_SHORT
1419597,0x87a1daf4a845d579e6ff4fec106fa58bfb7f37d5,false,false,,,,TOO_SHORT
1419805,0xb0227fc0862a5d8a19fb127e67b0f802475376f4,false,false,,,,TOO_SHORT
1420187,0xb1ff6f2ffdca30b2408ef3bc5668f8ac545d4542,false,false,,,,TOO_SHORT
1420563,0x043a29c18c237dfc7c4fd45708cb7bf7647b4e0e,false,false,,,,TOO_SHORT
1420564,0xc735f053acf1108efc5725d53acb30ee6c31f061,false,false,,,,TOO_SHORT
1420652,0xb468169f2cddc218a1d7ac319175afcff8fe758b,false,false,,,,TOO_SHORT
1420687,0x18e010e496647c6356d754d29c8e5c5077e7b3e1,false,false,,,,TOO_SHORT
1420688,0x630b041f48a553a8f5805ace4bd69bb97ad4afe4,false,false,,,,TOO_SHORT
1420748,0x2b2368a0f2eb7aede7d8a4b30684f1f237dace1c,false,false,,,,TOO_SHORT
1420927,0xa3e3f72c0cf69b93cd084faab425d3321ba680fa,false,false,,,,TOO_SHORT
1421207,0x213d2b0498d7eef3151aa9af2e5c4eb8674ecce5,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'         '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   MATCHING ETHERS                              \n//   a Strategy and Luck DaapGame          \n//   www.matching-ethers.com                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                       ***//\n// *** contact : reddit    /u/WhySoS3rious                                ***//\n\n//VERSION : 1.0\n\n// GAME MODE : MATCHING FINNEYS\n// STAKE : 0.1 ETH\n\n contract Matching_Finneys\n{\n    enum State{Active, Deactivated}\n    State public state;\n\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier onlyActive() {\n         if (state!=State.Active) throw;\n         _\n    }\n    modifier onlyInactive() {\n         if (state!=State.Deactivated) throw;\n         _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gamble_value) throw;\n        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\n	_\n    }\n    modifier resolvePendingRound{\n        blockLastPlayer=block.number+1;    \n        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\n	else if (pendingRound && blockLastPlayer==blockEndRound) throw;\n	_\n    }\n\n    uint blockLastPlayer;\n    address private owner;\n    uint gamble_value;\n    uint information_cost;\n    uint round_max_size ;\n    uint round_min_size  ;  \n    uint index_player;\n    uint index_round_ended;\n    uint index_player_in_round;\n    bool pendingRound = false;\n    uint blockEndRound;\n    struct Gamble  {\n	    address player;\n	    bool flipped;\n    }\n    Gamble[] matchers; \n    Gamble[] contrarians;\n    struct Result  {\n	    address player_matcher;\n	    bool flipped_matcher;\n	    uint256 payout_matcher;\n	    address player_contrarian;\n	    bool flipped_contrarian;\n	    uint256 payout_contrarian;\n    }\n    Result[] results; \n    mapping (address => uint) payout_history;\n    mapping (address => uint) times_played_history;    \n     \n    //Contract Construtor\n    function Matching_Ethers() { //Initial settings\n	    owner = msg.sender; \n	    round_min_size = 16;\n	    round_max_size = 20;\n	    information_cost= 500 szabo; //0.0005 ether, 0.5 finney\n            gamble_value = 100000 szabo; //0.1 ether\n    }\n    //FallBack Function (play by sending a transaction)\n    function () { \n        bool flipped;\n        if (msg.value == gamble_value) flipped=false; \n        if (msg.value > gamble_value) {\n            flipped=true;\n        }\n        Play(flipped); \n    }\n    //Play Function (play by contract function call)\n    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\n        if ( index_player_in_round%2==0 ) {   //first is matcher\n	    matchers.push(Gamble(msg.sender, flipped));\n	}\n	else {\n	    contrarians.push(Gamble(msg.sender, flipped));\n	}\n        index_player+=1;\n        index_player_in_round+=1;\n	times_played_history[msg.sender]+=1;\n        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\n	            bool end = randomEnd();\n		    if (end) {\n		        pendingRound=true;\n			blockEndRound=block.number;}\n        }\n    }\n    //Random Number Generator (between 1 and range)\n    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\n        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\n    }\n    //Function that determines randomly when the round should be ended\n    function randomEnd() private returns(bool) {\n	if (index_player_in_round==round_max_size) return true; //end if max_size\n	else{\n	    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\n	    if (random==1) return true;\n	    else return false;\n	    }\n    }\n    //Function to end Round and pay winners\n    function endRound() private {\n        delete results;\n        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\n        uint256 payout_total;\n        for (var k = 0; k < (index_player_in_round)/2; k++) {\n            uint256 index_contrarian;\n	    if (k+random_start_contrarian<(index_player_in_round)/2){\n	        index_contrarian=k+random_start_contrarian;\n            }\n	    else{\n	        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\n	    }\n	    uint256 information_cost_matcher = information_cost * k;\n	    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\n	    uint256 information_cost_contrarian = information_cost * index_contrarian;\n	    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\n	    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\n	    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\n	        matchers[k].player.send(payout_matcher);\n		payout_total+=payout_matcher;\n		payout_history[matchers[k].player]+=payout_matcher;\n	    }\n	    else {\n	        contrarians[index_contrarian].player.send(payout_contrarian);\n		payout_total+=payout_contrarian;\n		payout_history[contrarians[k].player]+=payout_contrarian;\n	    }\n	}\n        index_round_ended+=1;\n        owner.send(index_player_in_round*gamble_value-payout_total);\n	payout_total=0;\n        index_player_in_round=0;\n        delete matchers;\n        delete contrarians;\n	pendingRound=false;\n	if (terminate_after_round==true) state=State.Deactivated;\n    }\n    //Full Refund of Current Round (if needed)\n    function refundRound() \n    onlyActive\n    onlyOwner noEthSent{  \n        uint totalRefund;\n	uint balanceBeforeRefund=this.balance;\n        for (var k = 0;  k< matchers.length; k++) {\n	            matchers[k].player.send(gamble_value);\n		    totalRefund+=gamble_value;\n        }\n        for (var j = 0;  j< contrarians.length ; j++) {	\n	            contrarians[j].player.send(gamble_value);\n		    totalRefund+=gamble_value;		    \n        }\n	delete matchers;\n	delete contrarians;\n	state=State.Deactivated;\n	index_player_in_round=0;\n        uint balanceLeft = balanceBeforeRefund-totalRefund;\n	if (balanceLeft >0) owner.send(balanceLeft);\n    }\n    //Function Pause contract after next round (for new contract or to change settings) \n    bool terminate_after_round=false;\n    function deactivate()\n    onlyOwner noEthSent{\n	    terminate_after_round=true;\n    }\n    //Function Reactivates contract (after change of settings for instance or a refound)\n    function reactivate()\n    onlyOwner noEthSent{\n        state=State.Active;\n        terminate_after_round=false;\n    }\n    //Function to change game settings (within limits)\n    //(to adapt to community feedback, popularity)\n    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\n	    onlyOwner\n	    onlyInactive noEthSent{\n	    if (new_max_round<new_min_round) throw;\n	    if (new_information_cost > new_gamble_value/100) throw;\n	    round_max_size = new_max_round;\n	    round_min_size = new_min_round;\n	    information_cost= new_information_cost;\n	    gamble_value = new_gamble_value;\n    }\n    function changeOwner(address new_owner)\n	    onlyOwner noEthSent{\n	    owner=new_owner;\n    }\n    \n\n    modifier noEthSent(){\n        if (msg.value>0) throw;\n	_\n    }\n    //JSON GLOBAL STATS\n    function gameStats() noEthSent constant returns (uint number_of_player_in_round, uint total_number_of_player, uint number_of_round_ended, bool pending_round_to_resolve, uint block_end_last_round, uint block_last_player, State state, bool pause_contract_after_round)\n    {\n         number_of_player_in_round = index_player_in_round;\n	 total_number_of_player = index_player;\n	 number_of_round_ended = index_round_ended;\n	 pending_round_to_resolve = pendingRound;\n	 block_end_last_round = blockEndRound;\n	 block_last_player = blockLastPlayer;\n	 state = state;\n	 pause_contract_after_round = terminate_after_round;\n     }\n     //JSON CURRENT SETTINGS\n     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\n	 _gamble_value = gamble_value;\n	 _information_cost = information_cost;\n	 _round_min_size = round_min_size;\n	 _round_max_size = round_max_size;\n     }\n\n    //JSON MATCHER TEAM\n    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=matchers[_index].player;\n	_flipped = matchers[_index].flipped;\n    }\n    //JSON CONTRARIAN TEAM\n    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=contrarians[_index].player;\n	_flipped = contrarians[_index].flipped;\n    }\n    //JSON LAST ROUND RESULT\n    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\n        _address_matcher=results[_index].player_matcher;\n        _address_contrarian=results[_index].player_contrarian;\n	_flipped_matcher = results[_index].flipped_matcher;\n	_flipped_contrarian = results[_index].flipped_contrarian;\n	_payout_matcher =  results[_index].payout_matcher;\n	_payout_contrarian =  results[_index].payout_contrarian;\n    }\n    //User set nickname for the website\n     mapping (address => string) nicknames;\n     function setNickname(string name) noEthSent{\n         if (bytes(name).length >= 2 && bytes(name).length <= 16)\n             nicknames[msg.sender] = name;\n     }\n     function getNickname(address _address) noEthSent constant returns(string _name) {\n             _name = nicknames[_address];\n     }\n     //JSON HISTORY\n     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\n             _payout = payout_history[_address]; \n     }\n     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\n             _count = times_played_history[_address]; \n     }\n\n}",2,アスキーアートとコメントが詩的要素を加え、ゲーム性が芸術的な印象を与えます。,
1421524,0x2c2e3baa2191cf325a28a01ff42340f2ae677572,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'         '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   MATCHING ETHERS                              \n//   a Strategy and Luck DaapGame          \n//   www.matching-ethers.com                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                       ***//\n// *** contact : reddit    /u/WhySoS3rious                                ***//\n\n//VERSION : 1.0\n\n// GAME MODE : MATCHING FINNEYS\n// STAKE : 0.1 ETH\n\n contract Matching_Finneys\n{\n    enum State{Active, Deactivated}\n    State public state;\n\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier onlyActive() {\n         if (state!=State.Active) throw;\n         _\n    }\n    modifier onlyInactive() {\n         if (state!=State.Deactivated) throw;\n         _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gamble_value) throw;\n        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\n	_\n    }\n    modifier resolvePendingRound{\n        blockLastPlayer=block.number+1;    \n        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\n	else if (pendingRound && blockLastPlayer==blockEndRound) throw;\n	_\n    }\n\n    uint blockLastPlayer;\n    address private owner;\n    uint gamble_value;\n    uint information_cost;\n    uint round_max_size ;\n    uint round_min_size  ;  \n    uint index_player;\n    uint index_round_ended;\n    uint index_player_in_round;\n    bool pendingRound = false;\n    uint blockEndRound;\n    struct Gamble  {\n	    address player;\n	    bool flipped;\n    }\n    Gamble[] matchers; \n    Gamble[] contrarians;\n    struct Result  {\n	    address player_matcher;\n	    bool flipped_matcher;\n	    uint256 payout_matcher;\n	    address player_contrarian;\n	    bool flipped_contrarian;\n	    uint256 payout_contrarian;\n    }\n    Result[] results; \n    mapping (address => uint) payout_history;\n    mapping (address => uint) times_played_history;    \n     \n    //Contract Construtor\n    function Matching_Finneys() { //Initial settings\n	    owner = msg.sender; \n	    round_min_size = 16;\n	    round_max_size = 20;\n	    information_cost= 500 szabo; //0.0005 ether, 0.5 finney\n            gamble_value = 100000 szabo; //0.1 ether\n    }\n    //FallBack Function (play by sending a transaction)\n    function () { \n        bool flipped;\n        if (msg.value == gamble_value) flipped=false; \n        if (msg.value > gamble_value) {\n            flipped=true;\n        }\n        Play(flipped); \n    }\n    //Play Function (play by contract function call)\n    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\n        if ( index_player_in_round%2==0 ) {   //first is matcher\n	    matchers.push(Gamble(msg.sender, flipped));\n	}\n	else {\n	    contrarians.push(Gamble(msg.sender, flipped));\n	}\n        index_player+=1;\n        index_player_in_round+=1;\n	times_played_history[msg.sender]+=1;\n        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\n	            bool end = randomEnd();\n		    if (end) {\n		        pendingRound=true;\n			blockEndRound=block.number;}\n        }\n    }\n\n    //Random Number Generator (between 1 and range)\n    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\n        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\n    }\n    //Function that determines randomly when the round should be ended\n    function randomEnd() private returns(bool) {\n	if (index_player_in_round==round_max_size) return true; //end if max_size\n	else{\n	    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\n	    if (random==1) return true;\n	    else return false;\n	    }\n    }\n    //Function to end Round and pay winners\n    function endRound() private {\n        delete results;\n        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\n        uint256 payout_total;\n        for (var k = 0; k < (index_player_in_round)/2; k++) {\n            uint256 index_contrarian;\n	    if (k+random_start_contrarian<(index_player_in_round)/2){\n	        index_contrarian=k+random_start_contrarian;\n            }\n	    else{\n	        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\n	    }\n	    uint256 information_cost_matcher = information_cost * k;\n	    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\n	    uint256 information_cost_contrarian = information_cost * index_contrarian;\n	    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\n	    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\n	    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\n	        matchers[k].player.send(payout_matcher);\n		payout_total+=payout_matcher;\n		payout_history[matchers[k].player]+=payout_matcher;\n	    }\n	    else {\n	        contrarians[index_contrarian].player.send(payout_contrarian);\n		payout_total+=payout_contrarian;\n		payout_history[contrarians[k].player]+=payout_contrarian;\n	    }\n	}\n        index_round_ended+=1;\n        owner.send(index_player_in_round*gamble_value-payout_total);\n	payout_total=0;\n        index_player_in_round=0;\n        delete matchers;\n        delete contrarians;\n	pendingRound=false;\n	if (terminate_after_round==true) state=State.Deactivated;\n    }\n    //Full Refund of Current Round (if needed)\n    function refundRound() \n    onlyActive\n    onlyOwner noEthSent{  \n        uint totalRefund;\n	uint balanceBeforeRefund=this.balance;\n        for (var k = 0;  k< matchers.length; k++) {\n	            matchers[k].player.send(gamble_value);\n		    totalRefund+=gamble_value;\n        }\n        for (var j = 0;  j< contrarians.length ; j++) {	\n	            contrarians[j].player.send(gamble_value);\n		    totalRefund+=gamble_value;		    \n        }\n	delete matchers;\n	delete contrarians;\n	state=State.Deactivated;\n	index_player_in_round=0;\n        uint balanceLeft = balanceBeforeRefund-totalRefund;\n	if (balanceLeft >0) owner.send(balanceLeft);\n    }\n    //Function Pause contract after next round (for new contract or to change settings) \n    bool terminate_after_round=false;\n    function deactivate()\n    onlyOwner noEthSent{\n	    terminate_after_round=true;\n    }\n    //Function Reactivates contract (after change of settings for instance or a refound)\n    function reactivate()\n    onlyOwner noEthSent{\n        state=State.Active;\n        terminate_after_round=false;\n    }\n    //Function to change game settings (within limits)\n    //(to adapt to community feedback, popularity)\n    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\n	    onlyOwner\n	    onlyInactive noEthSent{\n	    if (new_max_round<new_min_round) throw;\n	    if (new_information_cost > new_gamble_value/100) throw;\n	    round_max_size = new_max_round;\n	    round_min_size = new_min_round;\n	    information_cost= new_information_cost;\n	    gamble_value = new_gamble_value;\n    }\n    function changeOwner(address new_owner)\n	    onlyOwner noEthSent{\n	    owner=new_owner;\n    }\n    \n\n    modifier noEthSent(){\n        if (msg.value>0) throw;\n	_\n    }\n    //JSON GLOBAL STATS\n    function gameStats() noEthSent constant returns (uint number_of_player_in_round, uint total_number_of_player, uint number_of_round_ended, bool pending_round_to_resolve, uint block_end_last_round, uint block_last_player, State state, bool pause_contract_after_round)\n    {\n         number_of_player_in_round = index_player_in_round;\n	 total_number_of_player = index_player;\n	 number_of_round_ended = index_round_ended;\n	 pending_round_to_resolve = pendingRound;\n	 block_end_last_round = blockEndRound;\n	 block_last_player = blockLastPlayer;\n	 state = state;\n	 pause_contract_after_round = terminate_after_round;\n     }\n     //JSON CURRENT SETTINGS\n     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\n	 _gamble_value = gamble_value;\n	 _information_cost = information_cost;\n	 _round_min_size = round_min_size;\n	 _round_max_size = round_max_size;\n     }\n\n    //JSON MATCHER TEAM\n    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=matchers[_index].player;\n	_flipped = matchers[_index].flipped;\n    }\n    //JSON CONTRARIAN TEAM\n    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=contrarians[_index].player;\n	_flipped = contrarians[_index].flipped;\n    }\n    //JSON LAST ROUND RESULT\n    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\n        _address_matcher=results[_index].player_matcher;\n        _address_contrarian=results[_index].player_contrarian;\n	_flipped_matcher = results[_index].flipped_matcher;\n	_flipped_contrarian = results[_index].flipped_contrarian;\n	_payout_matcher =  results[_index].payout_matcher;\n	_payout_contrarian =  results[_index].payout_contrarian;\n    }\n    //User set nickname for the website\n     mapping (address => string) nicknames;\n     function setNickname(string name) noEthSent{\n         if (bytes(name).length >= 2 && bytes(name).length <= 16)\n             nicknames[msg.sender] = name;\n     }\n     function getNickname(address _address) noEthSent constant returns(string _name) {\n             _name = nicknames[_address];\n     }\n     //JSON HISTORY\n     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\n             _payout = payout_history[_address]; \n     }\n     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\n             _count = times_played_history[_address]; \n     }\n\n}",2,アスキーアートとコメントが詩的要素を加え、コードに独自性を与えています。,
1421557,0x103c39ea006984e5d926644f7ea650317ff367ce,false,false,,,,TOO_SHORT
1421673,0x31e13882c45c1023d9b16c3794c1a780bb6cb88d,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'         '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   MATCHING ETHERS                              \n//   a Strategy and Luck DaapGame          \n//   www.matching-ethers.com                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                       ***//\n// *** contact : reddit    /u/WhySoS3rious                                ***//\n\n//VERSION : 1.0\n\n// GAME MODE : MATCHING ETHERS\n// STAKE : 1 ETH\n\n contract Matching_Ethers\n{\n    enum State{Active, Deactivated}\n    State public state;\n\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier onlyActive() {\n         if (state!=State.Active) throw;\n         _\n    }\n    modifier onlyInactive() {\n         if (state!=State.Deactivated) throw;\n         _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gamble_value) throw;\n        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\n	_\n    }\n    modifier resolvePendingRound{\n        blockLastPlayer=block.number+1;    \n        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\n	else if (pendingRound && blockLastPlayer==blockEndRound) throw;\n	_\n    }\n\n    uint blockLastPlayer;\n    address private owner;\n    uint gamble_value;\n    uint information_cost;\n    uint round_max_size ;\n    uint round_min_size  ;  \n    uint index_player;\n    uint index_round_ended;\n    uint index_player_in_round;\n    bool pendingRound = false;\n    uint blockEndRound;\n    struct Gamble  {\n	    address player;\n	    bool flipped;\n    }\n    Gamble[] matchers; \n    Gamble[] contrarians;\n    struct Result  {\n	    address player_matcher;\n	    bool flipped_matcher;\n	    uint256 payout_matcher;\n	    address player_contrarian;\n	    bool flipped_contrarian;\n	    uint256 payout_contrarian;\n    }\n    Result[] results; \n    mapping (address => uint) payout_history;\n    mapping (address => uint) times_played_history;    \n     \n    //Contract Construtor\n    function Matching_Ethers() { //Initial settings\n	    owner = msg.sender; \n	    round_min_size = 16;\n	    round_max_size = 20;\n	    information_cost= 5000 szabo; //0.005 ether, 5 finney\n            gamble_value = 1000000 szabo; //1 ether\n    }\n    //FallBack Function (play by sending a transaction)\n    function () { \n        bool flipped;\n        if (msg.value == gamble_value) flipped=false; \n        if (msg.value > gamble_value) {\n            flipped=true;\n        }\n        Play(flipped); \n    }\n    //Play Function (play by contract function call)\n    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\n        if ( index_player_in_round%2==0 ) {   //first is matcher\n	    matchers.push(Gamble(msg.sender, flipped));\n	}\n	else {\n	    contrarians.push(Gamble(msg.sender, flipped));\n	}\n        index_player+=1;\n        index_player_in_round+=1;\n	times_played_history[msg.sender]+=1;\n        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\n	            bool end = randomEnd();\n		    if (end) {\n		        pendingRound=true;\n			blockEndRound=block.number;}\n        }\n    }\n    //Random Number Generator (between 1 and range)\n    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\n        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\n    }\n    //Function that determines randomly when the round should be ended\n    function randomEnd() private returns(bool) {\n	if (index_player_in_round==round_max_size) return true; //end if max_size\n	else{\n	    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\n	    if (random==1) return true;\n	    else return false;\n	    }\n    }\n    //Function to end Round and pay winners\n    function endRound() private {\n        delete results;\n        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\n        uint256 payout_total;\n        for (var k = 0; k < (index_player_in_round)/2; k++) {\n            uint256 index_contrarian;\n	    if (k+random_start_contrarian<(index_player_in_round)/2){\n	        index_contrarian=k+random_start_contrarian;\n            }\n	    else{\n	        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\n	    }\n	    uint256 information_cost_matcher = information_cost * k;\n	    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\n	    uint256 information_cost_contrarian = information_cost * index_contrarian;\n	    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\n	    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\n	    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\n	        matchers[k].player.send(payout_matcher);\n		payout_total+=payout_matcher;\n		payout_history[matchers[k].player]+=payout_matcher;\n	    }\n	    else {\n	        contrarians[index_contrarian].player.send(payout_contrarian);\n		payout_total+=payout_contrarian;\n		payout_history[contrarians[k].player]+=payout_contrarian;\n	    }\n	}\n        index_round_ended+=1;\n        owner.send(index_player_in_round*gamble_value-payout_total);\n	payout_total=0;\n        index_player_in_round=0;\n        delete matchers;\n        delete contrarians;\n	pendingRound=false;\n	if (terminate_after_round==true) state=State.Deactivated;\n    }\n    //Full Refund of Current Round (if needed)\n    function refundRound() \n    onlyActive\n    onlyOwner noEthSent{  \n        uint totalRefund;\n	uint balanceBeforeRefund=this.balance;\n        for (var k = 0;  k< matchers.length; k++) {\n	            matchers[k].player.send(gamble_value);\n		    totalRefund+=gamble_value;\n        }\n        for (var j = 0;  j< contrarians.length ; j++) {	\n	            contrarians[j].player.send(gamble_value);\n		    totalRefund+=gamble_value;		    \n        }\n	delete matchers;\n	delete contrarians;\n	state=State.Deactivated;\n	index_player_in_round=0;\n        uint balanceLeft = balanceBeforeRefund-totalRefund;\n	if (balanceLeft >0) owner.send(balanceLeft);\n    }\n    //Function Pause contract after next round (for new contract or to change settings) \n    bool terminate_after_round=false;\n    function deactivate()\n    onlyOwner noEthSent{\n	    terminate_after_round=true;\n    }\n    //Function Reactivates contract (after change of settings for instance or a refound)\n    function reactivate()\n    onlyOwner noEthSent{\n        state=State.Active;\n        terminate_after_round=false;\n    }\n    //Function to change game settings (within limits)\n    //(to adapt to community feedback, popularity)\n    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\n	    onlyOwner\n	    onlyInactive noEthSent{\n	    if (new_max_round<new_min_round) throw;\n	    if (new_information_cost > new_gamble_value/100) throw;\n	    round_max_size = new_max_round;\n	    round_min_size = new_min_round;\n	    information_cost= new_information_cost;\n	    gamble_value = new_gamble_value;\n    }\n    function changeOwner(address new_owner)\n	    onlyOwner noEthSent{\n	    owner=new_owner;\n    }\n    \n\n    modifier noEthSent(){\n        if (msg.value>0) throw;\n	_\n    }\n    //JSON GLOBAL STATS\n    function gameStats() noEthSent constant returns (uint number_of_player_in_round, uint total_number_of_player, uint number_of_round_ended, bool pending_round_to_resolve, uint block_end_last_round, uint block_last_player, State state, bool pause_contract_after_round)\n    {\n         number_of_player_in_round = index_player_in_round;\n	 total_number_of_player = index_player;\n	 number_of_round_ended = index_round_ended;\n	 pending_round_to_resolve = pendingRound;\n	 block_end_last_round = blockEndRound;\n	 block_last_player = blockLastPlayer;\n	 state = state;\n	 pause_contract_after_round = terminate_after_round;\n     }\n     //JSON CURRENT SETTINGS\n     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\n	 _gamble_value = gamble_value;\n	 _information_cost = information_cost;\n	 _round_min_size = round_min_size;\n	 _round_max_size = round_max_size;\n     }\n\n    //JSON MATCHER TEAM\n    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=matchers[_index].player;\n	_flipped = matchers[_index].flipped;\n    }\n    //JSON CONTRARIAN TEAM\n    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=contrarians[_index].player;\n	_flipped = contrarians[_index].flipped;\n    }\n    //JSON LAST ROUND RESULT\n    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\n        _address_matcher=results[_index].player_matcher;\n        _address_contrarian=results[_index].player_contrarian;\n	_flipped_matcher = results[_index].flipped_matcher;\n	_flipped_contrarian = results[_index].flipped_contrarian;\n	_payout_matcher =  results[_index].payout_matcher;\n	_payout_contrarian =  results[_index].payout_contrarian;\n    }\n    //User set nickname for the website\n     mapping (address => string) nicknames;\n     function setNickname(string name) noEthSent{\n         if (bytes(name).length >= 2 && bytes(name).length <= 16)\n             nicknames[msg.sender] = name;\n     }\n     function getNickname(address _address) noEthSent constant returns(string _name) {\n             _name = nicknames[_address];\n     }\n     //JSON HISTORY\n     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\n             _payout = payout_history[_address]; \n     }\n     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\n             _count = times_played_history[_address]; \n     }\n\n}",1,実用的なゲームコントラクトで、特に芸術的な要素は見られません。,
1421882,0x202b17e1d21577a11bf350a48687fc372394f1a2,false,false,,,,TOO_SHORT
1422284,0x7c9d8751db0b5f4f9c01379a0c8b0e4ae8a4ed01,false,false,,,,TOO_SHORT
1422330,0x98be4820436f84dcf7d72316b5b62a15cd606e48,false,false,,,,TOO_SHORT
1422735,0x27fc75c23cf8438e84408a3633e20bbd37de2926,false,false,,,,TOO_SHORT
1422966,0x88dac88b687934d6c5a39ae110611e7b911e1f21,false,false,,,,TOO_SHORT
1423616,0x244748c6226cd2e2e7679202b0c9dd09c495fe2a,false,false,,,,TOO_SHORT
1423779,0x7028a7f490203ae8ee0f970e0c5d64e603bcc7c0,false,false,,,,TOO_SHORT
1423796,0x44f31428bd52e035f93f32c6e4f4f8d8fbb91a6b,false,false,,,,TOO_SHORT
1423820,0xc980200a914d6a5f2f8080cec89a285ac0261536,false,false,,,,TOO_SHORT
1424002,0x9e7ee34c5173b16ba75b566d489ed10cf3c7db45,false,false,,,,TOO_SHORT
1424218,0x0dad81ab6bf8706419e4c2d35190b966b57f88f6,false,false,,,,TOO_SHORT
1424597,0xa1b00fed739cb56e811e9f0d32f90ea8455b4c49,false,false,,,,TOO_SHORT
1424818,0x1c34086ff43fe2d3a90073b0f1ab794e163d6f47,false,false,,,,TOO_SHORT
1425102,0x7aab156bcc6393b3d8c9ad3ae4faac5aff40f36a,false,false,,,,TOO_SHORT
1425380,0x91e06b388f3f02947790f2e6c1d4da99cae51602,false,false,,,,TOO_SHORT
1425488,0x1ca355627666a1f0f2fa31af20e43d5654e0f173,false,false,,,,TOO_SHORT
1425840,0xaf89f21ed8e78e25277be82254f827c0d53416c2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1425840,0x5f6aaa7d5760b6c915110a8505a9f03f8cedabbd,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1425840,0x09b013c9097d4db7c9a43a94dacf360037c94d94,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1426107,0x662a88386bd2b361051039a1c0b0efdf620ea893,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1426107,0x03f54d862215ca12d3e1de214d2a8a63a9e65710,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1426107,0xc60b8397720a0fc586422735830cb297ba73d107,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1426107,0x8406d0897da43a33912995c6ffd792f1f2125cd4,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1426386,0x921a5a61165af6c4e06cb2b497044c4f57cf3f1c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1426386,0x6550174479f3a3d9703977ac901d8b46fcb954b9,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1426386,0xb2b8ca4aad743b1fdbf5f6054647c64e021337dd,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1426386,0x7803a643be2f08f7b4843fa241de822e239d3511,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427320,0xd8cb04aae2787e54dfa11bb022317b3aa969c255,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427320,0x87f076407318a7d8d5bbfec16ddf2718eefa7199,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427320,0xb8010d72c10ad7ffc7e45f923b0c7910dbc8fc7c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427369,0x8213f3f9dfc478af3e4f4c94b9224c5da61d6db7,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427369,0x4a5e3196948a9349268bdec57de3666e7754f5bc,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427369,0x3ccc5b36b1a1c5b8749f51bf958b3a7cde37c1c4,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427416,0x780d77ee19717dd5b7d070061dfbdf1b927bdf54,false,false,,,,TOO_SHORT
1427451,0xec1d2d64aef94c2bddaaa8eaac839fa42992acd8,false,false,,,,TOO_SHORT
1427468,0x5cdf2b0e62b0e83da433c9e8f32450c80ffa8ec9,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427468,0xa6ad78e8e31d9a232bde2fd625220e1e3980e723,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427468,0x26ecd96ee1449a814a79c65458d92d2e6b578b09,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427468,0x3be069e57f25c824ad59cd8af590c4f0bbbb3fd6,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1427599,0x16521bb5bf73ff28e89fe001711a641dd20eacb3,false,false,,,,TOO_SHORT
1427981,0xd0ac3e2afb370616b107039f8a39ec99407ea442,false,false,,,,TOO_SHORT
1428275,0x0c30bb4c32dae7035b948ed30fe06772bc30e3ae,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428275,0xf7e6d62aed338ce55b6d63c56f790b1d7b3d744a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428275,0x1f793c7f584a368cbb23f0ff66099a16dfae330e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428275,0xfb5c33b7bce6373d21a5978ad94da348852cf351,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428393,0x41efd5d5933f03e6bc5e87932fa6ff4295163134,false,false,,,,TOO_SHORT
1428414,0x236d06b4832a5ee8436e1ffe7a9a0855322c8034,false,false,,,,TOO_SHORT
1428420,0xa77603ea885c2551c81d7cb5287f8a268f79ace4,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428420,0x79d3c286b1da9c2d37f829ef5a70fe08af0173d5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428420,0xf091868242487303df254055bedd8c7a87a7ed9a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428420,0x3e86e969dbad500584229021a8cf9241c4cdaaad,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428482,0xa1ac741a0569a2699cbae4026a722686371c84bf,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428482,0xa1aa6b61d49f9050a8302e58ced1430b90e45db4,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428482,0xacff2f7ef0dd8eb9d55af335c3fd9fe90adc52a8,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428482,0x8807a178bfce4c78f2ad8bbcc6215eb858ffd1de,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428524,0xdc2c3da5b2456bae231245db389e9bf589d22da2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428524,0x9bcb1fb14c512f1eebc3efca45002177389a1fb8,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428524,0x9dd747640e790437bb7a747bd3fcbbf8ea623ba0,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428524,0xa911ee56bfdfc941f17505adfe9dc837713a9d5f,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428529,0xddd78a234162aa42b7d992fe6be79c54712fab42,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428529,0xc99980b81e9b72496388e5087173d9ee46dfd503,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428529,0x01ac47cbee294c3a39d731ec2b655e01309866b5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428529,0x0058fdeab9f249776152643e061b2f724c679440,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428583,0x2c14a4421543e79b16a1d48bac6b1fa0e1984162,false,false,,,,TOO_SHORT
1428666,0xc12191d26f45797d7baa5589782c6cd6cb3aa732,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428666,0xc91da6e85c03ad20ebea6ed527a0a76c82ddae96,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428666,0xfbad274dc750937761a42b0fc7a4b90282afb457,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428666,0xd5ddaf00db3a66b25d3d005f4e0770009042bbfa,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428686,0xdf50fee22a9833be53ecde7a9a6debd85bb81fe3,false,false,,,,TOO_SHORT
1428757,0x807640a13483f8ac783c557fcdf27be11ea4ac7a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428757,0xd2e16a20dd7b1ae54fb0312209784478d069c7b0,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428757,0x17cd41543a3c3c77d5e372704c9577df09eea003,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428757,0xbb9bc244d798123fde783fcc1c72d3bb8c189413,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428901,0xb96605110883dcb39d1a103bb033cadab2e6aeda,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428901,0x8a3b9c6e0c19c5f4751107920fccdfaf05dd4cca,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428901,0x41ebe5ae8ee1eb9dee3414d9908d060d28f90005,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1428901,0xffbd72d37d4e7f64939e70b2988aa8924fde48e3,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429012,0x169768ee0f1f613e9653b63627707c3871ba6f9c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429012,0xdbb407b6ae62a41909630fad6865e50c7397d7d2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429012,0x087986faa06c438004d1c0e71b452ffadf0817cd,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429012,0x245c39681f1058e119f9a35d7d7f79fb05418cc2,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429248,0xfd1143db6829a2c486a665da4592700b239db42c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429248,0x3b64fbb3c4872f60954fc4655fdb5572b839f7ed,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429248,0x9f00ada9af2fcc3765dd11571cb2b5c8fb8d6b4f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429248,0x8b1ccf273ca75c16601d433b907028b4ee34dbfc,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429353,0x75c48bbe2a0889b12ea37b23a8fe2368149ede0d,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429353,0x94aebb909c36a82411f340f5b6e2067c1146b979,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429353,0x85125a317a33b719a3bafffe94f6e4f11b2b8820,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429353,0xd2a84dfc808ca6d4be0306c1c09f755f3eb850b5,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1429615,0xf4cae4aec9b4d7682f8cee4d9a273ba063e71366,false,false,"contract EtherTopDog {\n\n	// fund for bailing out underdogs when they are pushed out\n	uint private bailoutBalance = 0;\n\n\n	// === Underdog Payin Distribution: ===\n	\n	// percent of underdog deposit amount to go in bailout fund\n	uint constant private bailoutFundPercent = 70;\n\n	// percent of underdog deposit that goes to the top dog's dividend\n	uint constant private topDogDividend = 15;\n\n	// percent of underdog deposit sent chip away top dog's strength\n	uint constant private topDogDecayPercent = 10;\n\n	// percent of underdog deposiot that goes to lucky dog's dividend\n	uint constant private luckyDogDividend = 3;\n\n	// vision dog takes a small fee from each underdog deposit\n	uint constant private visionDogFeePercent = 2;\n\n	// === === === === === === === === ===\n\n	\n	// percentage markup from payin for calculating new mininum TopDog price threshold\n	uint constant private topDogMinMarkup = 125;\n\n	// minimum required deposit to become the next Top Dog\n	// (aka Top Dog strength / lowest possible takeover threshold)\n	// starts at 125% of Top Dog's deposit, slowly declines as underdogs join\n	uint private topDogMinPrice = 1;\n\n	// range above the topdog strength (aka topDogMinPrice) within which\n	// the randomly generated required takeover threhold is set\n	uint constant private topDogBuyoutRange = 150;\n\n	// percentage of topdog buyout fee gets paid to creator\n	uint constant private visionDogBuyPercent = 5;\n\n\n\n	// underdog payout markup, as a percentage of their deposits\n	// gets reset to 150% after each round when the top dog gets replaced\n	// gradually decays to mininum of 120% as underdogs chip away at top dog's strength\n	uint private underDogMarkup = 150;\n\n	// as top dog price declines, these keep track of the range\n	// so underDopMarkup can slowly go from 150% to 120% return\n	// as the Top Dog mininum price starts at the price ceiling,\n	// and declines until it reaches the floor (or lower)\n	uint private topDogPriceCeiling = 0;\n	uint private topDogPriceFloor = 0;\n\n	// total collected fees from underdogs, paid out whenever Top Dog is bought out\n	uint private visionFees = 0;\n\n	// current top dog\n	address private topDog = 0x0;\n\n	// underdog entries\n	struct Underdog {\n		address addr;\n		uint deposit;\n		uint payout;\n		uint bailouts;\n	}\n	Underdog[] private Underdogs;\n\n	// player names for fun\n	mapping (address => string) dogNames;\n\n	// current lucky dog (if exists) will receive 3% of underdog payins\n	// specified as index in Underdogs array\n	// 0 = nobody (the very first underdog to join the game is precluded from becoming the Lucky Dog)\n	uint private luckyDog = 0;\n\n	// index of next underdog to be paid \n	uint private payoutIndex = 0;\n\n	// count payouts made by underdogs currently in the game\n	// so we can have a baseline for dividing the scraps\n	uint private payoutCount = 0;\n\n	// address of the creator\n	address private visionDog;\n\n	function EtherTopDog() {\n		visionDog = msg.sender;\n	}\n\n\n	// ==== Game Info Display ABI functions: ====\n	function underdogPayoutFund() public constant returns (uint balance) {\n		balance = bailoutBalance;\n	}\n\n	function nextUnderdogPayout() public constant returns (uint) {\n		if (Underdogs.length - payoutIndex >= 1) {\n			return Underdogs[payoutIndex].payout;\n		}\n	}\n	\n\n	function underdogPayoutMarkup() public constant returns (uint) {\n		return underDogMarkup;\n	}\n\n	function topDogInfo() public constant returns (string name, uint strength) {\n		if (topDog != address(0x0)) {\n			name = getDogName(topDog);\n		} else {\n			name = ""[not set]"";\n		}\n		strength = topDogMinPrice;\n	}\n	function luckyDogInfo() public constant returns (string name) {\n		if (luckyDog > 0) {\n			name = getDogName(Underdogs[luckyDog].addr);\n		} else {\n			name = ""[nobody]"";\n		}\n	}\n\n	function underdogCount() constant returns (uint) {\n		return Underdogs.length - payoutIndex;\n	} \n\n	function underdogInfo(uint linePosition) constant returns (string name, address dogAddress, uint deposit, uint payout, uint scrapBonus) {\n		if (linePosition > 0 && linePosition <= Underdogs.length - payoutIndex) {\n\n			Underdog thedog = Underdogs[payoutIndex + (linePosition - 1)];\n			name = getDogName(thedog.addr);\n			dogAddress = thedog.addr;\n			deposit = thedog.deposit;\n			payout= thedog.payout;\n			scrapBonus = thedog.bailouts;\n		}\n	}\n\n	// ==== End ABI Functions ====\n\n\n\n	// ==== Public transaction functions: ====\n\n	// default fallback : play a round\n	function() {\n		dogFight();\n	}\n	\n	// sets name, optionally plays a round if Ether was sent\n	function setName(string DogName) {\n		if (bytes(DogName).length >= 2 && bytes(DogName).length <= 16)\n			dogNames[msg.sender] = DogName;\n\n		// if a deposit was sent, play it!\n		if (msg.value > 0) {\n			dogFight();\n		}\n		\n	}\n\n	function dogFight() public {\n		// minimum 1 ETH required to play\n		if (msg.value < 1 ether) {\n			msg.sender.send(msg.value);\n			return;\n		}\n\n		// does a topdog exist ?\n		if (topDog != address(0x0)) {\n\n			// the actual amount required to knock out the top dig is random within the buyout range\n			uint topDogPrice = topDogMinPrice + randInt( (topDogMinPrice * topDogBuyoutRange / 100) - topDogMinPrice, 4321);\n\n			// Calculate the top dog price\n			if (msg.value >= topDogPrice) {\n				// They bought out the top dog!\n				buyTopDog(topDogPrice, msg.value - topDogPrice);\n			} else {\n				// didn't buy the top dog, this participant becomes an underdog!\n				addUnderDog(msg.value);\n			}\n		} else {\n			// no top dog exists yet, the game must be just getting started\n			// put the first deposit in the bailout fund, initialize the game\n\n			// set first topDog \n			topDog = msg.sender;\n\n			topDogPriceFloor = topDogMinPrice;\n\n			bailoutBalance += msg.value;\n			topDogMinPrice = msg.value * topDogMinMarkup / 100;\n\n			topDogPriceCeiling = topDogMinPrice;\n\n		}\n	}\n\n	// ==== End Public Functions ====\n\n\n\n	// ==== Private Functions: ====\n	function addUnderDog(uint buyin) private {\n\n		uint bailcount = 0;\n\n		// amount this depositor will be paid when the fund allows\n		uint payoutval = buyin * underDogMarkup / 100;\n\n		// add portion of deposit to bailout fund \n		bailoutBalance += buyin * bailoutFundPercent / 100;\n\n		// top dog / lucky dog dividends\n		uint topdividend = buyin * topDogDividend / 100;\n		uint luckydividend = buyin * luckyDogDividend / 100;\n\n		// is there a lucky dog?\n		if (luckyDog != 0 && luckyDog >= payoutIndex) {\n			// pay lucky dog dividends\n			Underdogs[luckyDog].addr.send(luckydividend);\n		} else {\n			// no lucky dog exists, all dividends go to top dog\n			topdividend += luckydividend;\n		}\n\n		// pay top dog dividends\n		topDog.send(topdividend);\n\n\n		// chip away at the top dog's strength\n		uint topdecay = (buyin * topDogDecayPercent / 100);\n		topDogMinPrice -= topdecay;\n\n		// update underdog markup % for next round\n\n		// specified as n/100000 to avoid floating point math\n		uint decayfactor = 0;\n\n		// calculate the payout markup for next underdog\n		if (topDogMinPrice > topDogPriceFloor) {\n			uint decayrange = (topDogPriceCeiling - topDogPriceFloor);\n			decayfactor = 100000 * (topDogPriceCeiling - topDogMinPrice) / decayrange;\n		} else {\n			decayfactor = 100000;\n		}\n		// markup will be between 120-150% corresponding to current top dog price decline (150% - 30% = 120%)\n		underDogMarkup = 150 - (decayfactor * 30 / 100000);\n\n\n\n		// creator takes a slice\n		visionFees += (buyin * visionDogFeePercent / 100);\n		\n\n		// payout as many previous underdogs as the fund can afford\n		while (payoutIndex < Underdogs.length && bailoutBalance >= Underdogs[payoutIndex].payout ) {\n			payoutCount -= Underdogs[payoutIndex].bailouts;\n			bailoutBalance -= Underdogs[payoutIndex].payout;\n			Underdogs[payoutIndex].addr.send(Underdogs[payoutIndex].payout);\n\n\n			// if the lucky dog was bailed out, the user who did it now becomes the lucky dog\n			if (payoutIndex == luckyDog && luckyDog != 0)\n				luckyDog = Underdogs.length;\n\n			payoutIndex++;\n			bailcount++;\n			payoutCount++;\n		}\n\n		\n		// add the new underdog to the queue\n		Underdogs.push(Underdog(msg.sender, buyin, payoutval, bailcount));\n\n	}\n\n	function buyTopDog(uint buyprice, uint surplus) private {\n\n		// take out vizionDog fee\n		uint vfee = buyprice * visionDogBuyPercent / 100;\n\n		uint dogpayoff = (buyprice - vfee);\n\n		// payout previous top dog\n		topDog.send(dogpayoff);\n\n		visionFees += vfee;\n\n		// send buy fee (plus previous collected underdog fees) to visionDog\n		visionDog.send(visionFees);\n		visionFees = 0;\n\n		// record a price floor for underdog markup decay calculation during the next round:\n		// the mininum purchase price before buyout\n		topDogPriceFloor = topDogMinPrice;\n\n		// set the initial minimum buy price for the next top dog\n		topDogMinPrice = msg.value * topDogMinMarkup / 100;\n\n		// the price ceiling for calculating the underdog markup decay is the new minimum price\n		topDogPriceCeiling = topDogMinPrice;\n\n\n		// check for eligible lucky dog...\n//		if (Underdogs.length - payoutIndex > 0) {\n			// lucky dog is most recent underdog to make an entry\n//			luckyDog = Underdogs.length - 1;\n//		} else {\n			// no dogs waiting in line?  all dividends will go to top dog this round\n//			luckyDog = 0;\n//		}\n		\n\n		// reset underdog markup for next round\n		underDogMarkup = 150;\n\n		// how many dogs are waiting?\n		uint linelength = Underdogs.length - payoutIndex;\n\n		// surplus goes to pay scraps to random underdogs\n		// calculate and pay scraps\n\n\n		// are there underdogs around to receive the scraps?\n		if (surplus > 0 && linelength > 0 ) {\n			throwScraps(surplus);\n		}\n\n\n		// if there are any underdogs in line, the lucky dog will be picked from among them	\n		if (linelength > 0) {\n\n			// randomly pick a new lucky dog, with luck weighted toward more recent entries\n\n			// weighting works like this:\n			// 	For example, if the line length is 6, the most recent entry will\n			//	be 6 times more likely than the oldest (6/21 odds),\n			//	the second most recent will be 5 times more likely than the oldest (5/21 odds)\n			//	the third most recent will be 4 times as likely as the oldest (4/21 odds),\n			//	etc...\n\n			//	of course, the player that has been in line longest is\n			//	least likely to be lucky (1/21 odds in this example)\n			//	and will be getting sent out of the game soonest anyway\n\n			uint luckypickline = (linelength % 2 == 1) ?\n				( linelength / 2 + 1 ) + (linelength + 1) * (linelength / 2) :  // odd\n				( (linelength + 1) * (linelength / 2)  ); // even\n\n			uint luckypick = randInt(luckypickline, 69);\n	\n			uint pickpos = luckypickline - linelength;\n			uint linepos = 1;\n\n			while (pickpos >= luckypick && linepos < linelength) {\n				pickpos -= (linelength - linepos);\n				linepos++;\n			}\n\n			luckyDog = Underdogs.length - linepos;\n		} else {\n			// no underdogs in line?  no lucky dog this round.\n			// (should only possibly happen when game starts)\n			luckyDog = 0;\n		}\n		\n\n		// the new top dog is crowned!\n		topDog = msg.sender;\n	}\n\n	function throwScraps(uint totalscrapvalue) private {\n\n		// how many dogs are waiting?\n		uint linelength = Underdogs.length - payoutIndex;\n\n		// to keep from having too many transactions, make sure we never have more than 7 scraps.\n		// the more dogs in line, the more we jump over when scraps get scattered\n		uint skipstep = (linelength / 7) + 1;\n\n		// how many pieces to divide (roughly, randomization might make it more or less)\n		uint pieces = linelength / skipstep;\n\n		// how far from the end of the queue to start throwing the first scrap (semi-random)\n		uint startoffset = randInt(skipstep, 42) - 1;\n\n		// base size for scraps...  \n		uint scrapbasesize = totalscrapvalue / (pieces + payoutCount);\n\n		// minimum base scrap size of 0.5 eth\n		if (scrapbasesize < 500 finney) {\n			scrapbasesize = 500 finney;\n		}\n\n		uint scrapsize;\n		uint sptr = Underdogs.length - 1 - startoffset;\n\n		uint scrapvalueleft = totalscrapvalue;\n\n		while (pieces > 0 && scrapvalueleft > 0 && sptr >= payoutIndex) {\n			// those who bailed out other dogs get bigger scraps\n			// size of the scrap is multiplied by # of other dogs the user bailed out\n			scrapsize = scrapbasesize * (Underdogs[sptr].bailouts + 1);\n\n\n			// scraps can never be more than what's in the pile\n			if (scrapsize < scrapvalueleft) {\n				scrapvalueleft -= scrapsize;\n			} else {\n				scrapsize = scrapvalueleft;\n				scrapvalueleft = 0;\n			}\n\n			// pay it\n			Underdogs[sptr].addr.send(scrapsize);\n			pieces--;\n			sptr -= skipstep;\n		}\n\n		// any scraps left uncaught? put them in the bailout fund for the underdogs\n		if (scrapvalueleft > 0) {\n			bailoutBalance += scrapvalueleft;\n		}\n	}\n\n	function getDogName(address adr) private constant returns (string thename) {\n		if (bytes(dogNames[adr]).length > 0)\n			thename = dogNames[adr];\n		else\n			thename = 'Unnamed Mutt';\n	}\n	\n	// Generate pseudo semi-random number between 1 - max \n	function randInt(uint max, uint seedswitch) private constant returns (uint randomNumber) {\n		return( uint(sha3(block.blockhash(block.number-1), block.timestamp + seedswitch) ) % max + 1 );\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心で、芸術性は低い。,
1430457,0xfd887d3a536ad8318702153127c356abd9d8796a,false,false,,,,TOO_SHORT
1430559,0x3d39509d57273bdfeb261179727240637f27ca8f,false,false,,,,TOO_SHORT
1430714,0xf76bdb5fd60d4c97cdd35c01c1ef3624e5e529fc,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1430714,0x970920f2320f394c7243e92a7de948aad2b518de,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1430714,0x7937d3365c7a89bb9591047065b845be272fc04f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1430714,0x18133d5079b5dd74616678acab28d0fce7a69e90,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1430830,0xed7a2c09561e24c8618df6ffda64ab2530dae08c,false,false,,,,TOO_SHORT
1430835,0x69378a75ddd07b07bbfcb2ad76a9a867edc54323,false,false,,,,TOO_SHORT
1430962,0x8f9c2b5c291a43465bfc14ec430575f69fe9becd,false,false,,,,TOO_SHORT
1431293,0xbf3e059c4076222417e8db3d5a1650f44a95a23f,false,false,,,,TOO_SHORT
1431443,0x791e6504e2c580a4276cd7f615872955331f94e0,false,false,,,,TOO_SHORT
1431749,0x31870f26c37cb07ed59ffc5d5dd2eb7c11162d6b,false,false,,,,TOO_SHORT
1431769,0x037faff09618df3401c44fe5df545cdea298c3d9,false,false,,,,TOO_SHORT
1432043,0xfa6490423f73f10843687220a4bbb492a34dd32e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1432071,0x856ca2497b6ef00e1b9460af6ce8660deebab5a6,false,false,,,,TOO_SHORT
1432178,0xb8f5c1f5732753070175d971980f648297864199,false,false,,,,TOO_SHORT
1432214,0x87f1b04d396159d020f10ff8d40bf4df1e996f4a,false,false,,,,TOO_SHORT
1432258,0x076c9f0d68a55d50f02dc0ee20d5501728f590a4,false,false,,,,TOO_SHORT
1432279,0x20b909e2108bd25f637505c42202329bf09dc122,false,false,,,,TOO_SHORT
1432281,0x2adbcf5d23813482e0fe510dce45a09946adc477,false,false,,,,TOO_SHORT
1432282,0xe26d38acda0add610deae1396f09bfa714289dd2,false,false,,,,TOO_SHORT
1432341,0xe1f531c6fff396ff809d5405dc5d86b12b82a67c,false,false,,,,TOO_SHORT
1432350,0x8dd119c21dab9dca35652b605d4bfb79eafeb217,false,false,,,,TOO_SHORT
1432365,0x36254d3c44ecb2117abff1c751a5b41ca492b3df,false,false,,,,TOO_SHORT
1432379,0xd6abcac02dc762135b83f5896d035c1e89dcfb1f,false,false,,,,TOO_SHORT
1432407,0x3a58996c7242ce5e7515631876a4973b9d835fb9,false,false,,,,TOO_SHORT
1432487,0xe6c283476045d04b43472ccb1c258491c297aec3,false,false,,,,TOO_SHORT
1432511,0xa0a4bd2bb248876e13916c94203c9bfd3495cb3b,false,false,,,,TOO_SHORT
1432618,0x3ea4f81981d3c666d900805211d537d3e9449a58,false,false,,,,TOO_SHORT
1432773,0xa251661862d244ff34a13d2f7b68e7121e68372f,false,false,,,,TOO_SHORT
1432777,0x22017fbbb4d9e64b7af269cff281b8dce32ecef2,false,false,,,,TOO_SHORT
1432803,0xc34c0b813419b3b5ef54bb10ad559d95ea36608c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1432962,0xe8e0b9023bd39e599911953a4fc4bd75614c5197,false,false,,,,TOO_SHORT
1433069,0x0840f809202fb226e650f536b0b0507170b70ae9,false,false,,,,TOO_SHORT
1433118,0x9f053cf7dd421403edb8bda689749140f28d2eac,false,false,,,,TOO_SHORT
1433121,0x84fd4ed2317a1abfe3258e108a80f48c34087059,false,false,,,,TOO_SHORT
1433131,0x5f7faa274f2a7b64ed01732e289a29084d950cc0,false,false,,,,TOO_SHORT
1433201,0xaf63217edf376920a4f1b559d843fe048b1cdb63,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1433221,0x88f2149efb437b2ece52ff4f1280cedda3a50bda,false,false,,,,TOO_SHORT
1433399,0x8cfe69097c72ef19f25993e7c2d6fbf1e12de2d6,false,false,,,,TOO_SHORT
1433400,0x298c168955ca3c14342fad70c5b683e19cbf9eb4,false,false,,,,TOO_SHORT
1433429,0x18c9852ce607bfd25bb48df10975db57f24c1cff,false,false,,,,TOO_SHORT
1433450,0x0666064eece2171240dcd3292046b3bb9f80185e,false,false,,,,TOO_SHORT
1433498,0x1f0e60c7df5fba1197123818b3c8bef1509505f7,false,false,,,,TOO_SHORT
1433504,0x58c0ab3dd051dfc4d77e8cb6450ceb42507aa1a9,false,false,,,,TOO_SHORT
1433592,0xecb8f8e6cc11786f6f48224cb689aa536cb4de72,false,false,,,,TOO_SHORT
1433627,0x89633b36b3a1909c7b1692cc0aa2c11bb0c6b48b,false,false,,,,TOO_SHORT
1433735,0x2a70ec53831e1711e653e377276c6c4bb6a124ab,false,false,,,,TOO_SHORT
1433768,0xe235a9dcc24ce9bbb30bcded68e7e8b6d03053fe,false,false,,,,TOO_SHORT
1433814,0x0d0982a2bf44619962dda80da6129f566ff58980,false,false,,,,TOO_SHORT
1433930,0xd393171ad8486a7458f288c3c4cac4d3ff2fd247,false,false,,,,TOO_SHORT
1433945,0x793fae73dc08ee85d0aa83bece49b5045a82af67,false,false,,,,TOO_SHORT
1433953,0xa40a691538f24d7ef4ab4c2de453c18907c340fc,false,false,,,,TOO_SHORT
1433998,0xe5c8fc2c1ed89742237b974360a8c9cc8f5c7a67,false,false,,,,TOO_SHORT
1434066,0xd41850bfc9114b400be49fe3638c588d102dc698,false,false,,,,TOO_SHORT
1434144,0x2f54bddc87655ae6a035897d3a2f7919b14acf49,false,false,,,,TOO_SHORT
1434224,0xbfe8957a29db59ba58f429fb73b95d41b9816261,false,false,,,,TOO_SHORT
1434327,0xbae1c599238f3f2880cb22a26e965dfd813da8f8,false,false,,,,TOO_SHORT
1434431,0x40aec2616ac5340878a5dc999044bf694c03a8fd,false,false,,,,TOO_SHORT
1434688,0x287f10b1ef155dbbfa75d3aa6fbf1223d64b89ac,false,false,,,,TOO_SHORT
1434754,0x04881eb395104e8095059ae666d6ae7fde5d131c,false,false,,,,TOO_SHORT
1434796,0x67369c80bc31b798f17a56fac4040ffe2921b22e,false,false,,,,TOO_SHORT
1434827,0xc5ec17c822baba1848c8fb22a662d32333dc32b9,false,false,,,,TOO_SHORT
1434829,0x736e6d753a38190a86bec274644ea0293dabe049,false,false,,,,TOO_SHORT
1434831,0xf3aa659b6ea069bf31928b1807ed2966d3e9482c,false,false,,,,TOO_SHORT
1435047,0xcb9b284adffa307fbe6a3e50db6afb20f677af77,false,false,,,,TOO_SHORT
1435119,0x528fc3e4689bb737640ccce238633faece922348,false,false,,,,TOO_SHORT
1435552,0xc6aebfc53c5d8be6f19b3d270a322b81b47f3305,false,false,,,,TOO_SHORT
1435774,0x1a6dadc6a3686631d04050b4d4c4a8b624f9651d,false,false,,,,TOO_SHORT
1435813,0x216410bbdb41224bf35c89935348123da500bf6b,false,false,,,,TOO_SHORT
1435916,0x0510299cfd399aec803639314fc9562070649a35,false,false,,,,TOO_SHORT
1435935,0x2e7b8254c51245a2b5339c8d2f3e98a2648ac9ec,false,false,,,,TOO_SHORT
1436098,0xabc1cdd8dcfdcd38d00568639431142980fa992f,false,false,"contract Token {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function transfer(address _to, uint256 _value);\n    function balanceOf(address) returns (uint256);\n}\n\ncontract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract TokenSale is owned {\n\n	address public asset;\n	uint256 public price;\n\n	function TokenSale()\n	{\n	      asset =  0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A; // DGX\n	      price = 750000000; // 0.75 ETH\n	}\n\n\n	function transfer_token(address _token, address _to, uint256 _value)\n	onlyOwner()\n	{\n		Token(_token).transfer(_to,_value);\n	}\n\n	function transfer_eth(address _to, uint256 _value)\n	onlyOwner()\n	{\n		if(this.balance >= _value) {\n                    _to.send(_value);\n                }\n	}\n\n   	function () {\n\n		uint order   = msg.value / price;\n\n		if(order == 0) throw;\n		\n		uint256 balance = Token(asset).balanceOf(address(this));\n\n		if(balance == 0) throw;\n\n		if(order > balance )\n		{\n		    order = balance;\n		    uint256 change = msg.value - order * price;\n		    msg.sender.send(change);\n		}\n\n		Token(asset).transfer(msg.sender,order);\n    	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1436151,0xd4c473ed9f6e02f262529a6586b1fb9cf4220846,false,false,,,,TOO_SHORT
1436404,0x79224eb868d959989ee08c6325c4579dc1e453e4,false,false,,,,TOO_SHORT
1436422,0x2ad7b231d95b0122e52989993fbbb7ae857ae0f0,false,false,,,,TOO_SHORT
1436434,0x99fb1d706f4c92e4446c2c469f01b3de4d69abca,false,false,,,,TOO_SHORT
1436764,0x469f7eaa800e7996d697eab9d7b99c3c2440b02b,false,false,,,,TOO_SHORT
1436771,0xd6e5113802833bdeb7f062ccec95f3c32d17a000,false,false,,,,TOO_SHORT
1436772,0x0d5bb16c34fe8bd66bbef4fcc0a7fedca4656504,false,false,,,,TOO_SHORT
1436836,0x9c9c21c4828fbd5e0df504d997fb3f01ddab8ea7,false,false,,,,TOO_SHORT
1436882,0x5a6ef80df159df9b2141c1f55573d11ebfb1d10b,false,false,,,,TOO_SHORT
1436925,0x3e7c5a84d4ea0afeb561233346776c9531563b1d,false,false,,,,TOO_SHORT
1436941,0x8d7b6fb1523f04e644085e14d5e49b1c6278c92e,false,false,,,,0xabc1cdd8dcfdcd38d00568639431142980fa992f
1436941,0xa459ba2a73f5a323101695b338e4222c038b26dd,false,false,,,,TOO_SHORT
1437018,0x0694052cff4ef7464268e17dc2e063f2cd1bdd9d,false,false,,,,TOO_SHORT
1437062,0x9885ccf5b99e80be7b32cb973576b758c0af95b5,false,false,,,,TOO_SHORT
1437251,0x225dfd5ffdc3762b6d22ee8e4598a54aa5db43c3,false,false,,,,TOO_SHORT
1437286,0x94fdabe53270f969b61764d40d581056c3fb6049,false,false,,,,TOO_SHORT
1437299,0x03da4b4878025e3b2d18f8ebd27a77cfca597538,false,false,,,,TOO_SHORT
1437322,0x0929481e2753e71ee9f1b002539fc8ccb7660427,false,false,,,,TOO_SHORT
1437325,0x2bb364dc140623483443547776999efec613c9fd,false,false,,,,TOO_SHORT
1437485,0xa968870281fc8ac3b611aa445929000f7b099f37,false,false,,,,TOO_SHORT
1437633,0xd72c73de6958b6da4370b85860c5368dd503c4e6,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1437643,0xef31025fb6883974ddcaa749c07d0050d37bfa9e,false,false,,,,TOO_SHORT
1437777,0x6e0ce0f175aaeb17648684d44b49218923a5a752,false,false,,,,TOO_SHORT
1437826,0x75f1ebd823aa9da79781aae09d0a69d4c8d485b4,false,false,,,,TOO_SHORT
1437857,0xaeb211398bbaa458af9d0d72e59a29e831e1a845,false,false,,,,TOO_SHORT
1437878,0x28c4006ed854db6d21c5bdf06194176e48d236af,false,false,,,,TOO_SHORT
1437896,0xa3b4f261f4b3ce4fa23d4dc1e2e67533535e7efe,false,false,,,,TOO_SHORT
1438003,0x216e0d44f41bae56e354d762cf8b243be8dc847a,false,false,,,,TOO_SHORT
1438073,0x6bbe0ea9897560e29ab9ca820d8aef59df9dafdb,false,false,,,,TOO_SHORT
1438133,0x026296e6b7a98137bc564c6ffeae25a7f5a1c7ea,false,false,,,,TOO_SHORT
1438288,0x36af9515271b489c4c469476fbb69038e847a83d,false,false,,,,TOO_SHORT
1438469,0x6a0978e1106f1d819f47229d4a77b33058c4f9bd,false,false,,,,TOO_SHORT
1438574,0x658eff10e495936ff269c8e51e2a00c4760c25ed,false,false,,,,TOO_SHORT
1438616,0x9119d823095650e584b4197105b782af7cbc7149,false,false,,,,TOO_SHORT
1438635,0xf8e97d01b4e32b02e9073b334785e32866c12789,false,false,,,,TOO_SHORT
1438665,0xea7d4593605d2468f96fbd2a52548516e402a4bf,false,false,,,,TOO_SHORT
1438673,0x79bb4e4aac92cdd44fcc93b4e79ca94006ef792d,false,false,,,,TOO_SHORT
1438727,0xa85199f3aafab2795aa0da3b6b8110b975b9020e,false,false,,,,TOO_SHORT
1438733,0x99f3343078d7c6697c66cadf60e9840926d4e0e6,false,false,,,,TOO_SHORT
1438743,0x2ecbbd2de1c2643c79054c03cdd33d9a092a256d,false,false,,,,TOO_SHORT
1438754,0x3d2646829c6c3a564fc589506e10a31cf7f95ea0,false,false,,,,TOO_SHORT
1438763,0xe6f2d5504f45804c5beab2ddf418bce3cd9b4f36,false,false,,,,TOO_SHORT
1438769,0x1b0271cc69eb3093a0e71b7edf1945c9b1c62694,false,false,,,,TOO_SHORT
1438777,0x8d579fc17756dec00e3baec36ee4c9b2d11c4243,false,false,,,,TOO_SHORT
1438785,0xd200ec5fadcd6c385929dc86a07ff6819d7f65ae,false,false,,,,TOO_SHORT
1438817,0xae2ab9d549f7abc357705e99f3b68dc21a6f901b,false,false,,,,TOO_SHORT
1438850,0x06f44e8ca621d6caa70d3e7406296813d66815bf,false,false,,,,TOO_SHORT
1438893,0xc4d682ed401a31ada915674de0947e762b0e07b6,false,false,,,,TOO_SHORT
1438967,0x882545b9ce59df708cec3dbbcc6a0d319c8254c3,false,false,,,,TOO_SHORT
1439254,0x77110cc15ffccaa3be1e4ee644f5fe6b240c9a64,false,false,,,,TOO_SHORT
1439285,0xb49eeec7de48a09888c8227a6217a2fbd52d6062,false,false,,,,TOO_SHORT
1439471,0x7867773736668705c1bddae4b65751956c75dee5,false,false,,,,TOO_SHORT
1439499,0xa27a0e3d69003f80dfe2596aedc6452809761fea,false,false,,,,TOO_SHORT
1439593,0xa3034b13bf3f73f6c220883b5de3e4ef6f1c7b82,false,false,,,,TOO_SHORT
1439685,0xafa9a2dacb5bd0bb4cc8a9f6bd8d8d477720d3dc,false,false,,,,TOO_SHORT
1439686,0x93d25da09290a4501330a8add4a8840ac23800fe,false,false,,,,TOO_SHORT
1439712,0x9a95fbb352a636ce7e0c5885af0332858896fd7d,false,false,,,,TOO_SHORT
1440103,0x20804f6b391c6b9d2038c0bde67b644535c7d6bd,false,false,,,,TOO_SHORT
1440402,0xf129f66949582881dca3678d7f4a263d9e79ee10,false,false,,,,TOO_SHORT
1440460,0xd3007a599afe91dde71b8ee7756048e0843a7a43,false,false,,,,TOO_SHORT
1440519,0x892de8cb7c1cf44112147c54b1095c97a9618703,false,false,,,,TOO_SHORT
1440521,0x5158cf97c3e001b402ccb0f9063736ee8d6dad5a,false,false,"contract Ai {\n\n  struct Participant {\n      address etherAddress;\n      uint amount;\n  }\n\n  Participant[] public participants;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function Ai() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 10 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n\n    uint amount;\n    if (msg.value > 100 ether) {  \n      collectedFees += msg.value - 100 ether;\n      amount = 100 ether;\n    }\n    else {\n      amount = msg.value;\n    }\n\n    // add a new participant to array\n    uint idx = participants.length;\n    participants.length += 1;\n    participants[idx].etherAddress = msg.sender;\n    participants[idx].amount = amount;\n\n    // collect fees and update contract balance\n    if (idx != 0) {\n      collectedFees += amount / 15;\n      balance += amount - amount / 15;\n    } else {\n      //  first participant has no one above him,\n      //  so it goes all to fees\n      collectedFees += amount;\n    }\n\n    // while there are enough ether on the balance we can pay out to an earlier participant\n    while (balance > participants[payoutIdx].amount * 2) {\n      uint transactionAmount = participants[payoutIdx].amount *2;\n      participants[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n  function collectFees() onlyowner {\n      if (collectedFees == 0) return;\n      owner.send(collectedFees);\n      collectedFees = 0;\n  }\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1440526,0x03c9cce735625f8a55a70ab95645a2313c60bfb1,false,false,,,,TOO_SHORT
1440566,0x201b5e111d76c688391b791b9056ed0900f66527,false,false,,,,TOO_SHORT
1440985,0x2e200420c6fdcd1c0cfed5bc128808cf165f3c63,false,false,,,,TOO_SHORT
1441106,0x85e3f09b3a860522a5b09be34bd16f878004af35,false,false,,,,TOO_SHORT
1441148,0x01647b6771794c7c94d74b8633f4d04375c3d033,false,false,,,,TOO_SHORT
1441608,0x9e70a88b02af22798f8d607db1407769340c7670,false,false,,,,TOO_SHORT
1441618,0xda1b6e493d702fac78dc40ffe9a888a01fe14193,false,false,,,,TOO_SHORT
1441855,0x5f4b4ab76a3e128eaa14451a458910d3343599fd,false,false,,,,TOO_SHORT
1441932,0xe0cec8f8cae0f577e1da7b7d4b11a002edc94da6,false,false,,,,TOO_SHORT
1442306,0x6aa9c291e5e424cc293b85d694ca352a4f866da7,false,false,,,,TOO_SHORT
1442477,0x937345204562628e469f3a37954d2033652964e4,false,false,,,,TOO_SHORT
1442706,0x659588a0aac8e61f3a8e04910f55d254e7499a67,false,false,,,,TOO_SHORT
1442762,0x3f12839799ae71a97069771152eb075bb0156360,false,false,,,,TOO_SHORT
1442848,0x900cd64d415a3e434dbceea5723e0dc52163a420,false,false,,,,TOO_SHORT
1442871,0x952208f02aeffdc9d0e9839eaddd6c22e980c9e5,false,false,,,,TOO_SHORT
1443025,0x0ee47fee0a53b877953c831200a33338a5a617ad,false,false,,,,TOO_SHORT
1443188,0x2b2fc484ebff639b65bf170e41a73307620916b8,false,false,,,,TOO_SHORT
1443296,0xfa7b9770ca4cb04296cac84f37736d4041251cdf,false,false,"// Copyright 2016 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\n// ReleaseOracle is an Ethereum contract to store the current and previous\n// versions of the go-ethereum implementation. Its goal is to allow Geth to\n// check for new releases automatically without the need to consult a central\n// repository.\n//\n// The contract takes a vote based approach on both assigning authorised signers\n// as well as signing off on new Geth releases.\n//\n// Note, when a signer is demoted, the currently pending release is auto-nuked.\n// The reason is to prevent suprises where a demotion actually tilts the votes\n// in favor of one voter party and pushing out a new release as a consequence of\n// a simple demotion.\ncontract ReleaseOracle {\n  // Votes is an internal data structure to count votes on a specific proposal\n  struct Votes {\n    address[] pass; // List of signers voting to pass a proposal\n    address[] fail; // List of signers voting to fail a proposal\n  }\n\n  // Version is the version details of a particular Geth release\n  struct Version {\n    uint32  major;  // Major version component of the release\n    uint32  minor;  // Minor version component of the release\n    uint32  patch;  // Patch version component of the release\n    bytes20 commit; // Git SHA1 commit hash of the release\n\n    uint64  time;  // Timestamp of the release approval\n    Votes   votes; // Votes that passed this release\n  }\n\n  // Oracle authorization details\n  mapping(address => bool) authorised; // Set of accounts allowed to vote on updating the contract\n  address[]                voters;     // List of addresses currently accepted as signers\n\n  // Various proposals being voted on\n  mapping(address => Votes) authProps; // Currently running user authorization proposals\n  address[]                 authPend;  // List of addresses being voted on (map indexes)\n\n  Version   verProp;  // Currently proposed release being voted on\n  Version[] releases; // All the positively voted releases\n\n  // isSigner is a modifier to authorize contract transactions.\n  modifier isSigner() {\n    if (authorised[msg.sender]) {\n      _\n    }\n  }\n\n  // Constructor to assign the initial set of signers.\n  function ReleaseOracle(address[] signers) {\n    // If no signers were specified, assign the creator as the sole signer\n    if (signers.length == 0) {\n      authorised[msg.sender] = true;\n      voters.push(msg.sender);\n      return;\n    }\n    // Otherwise assign the individual signers one by one\n    for (uint i = 0; i < signers.length; i++) {\n      authorised[signers[i]] = true;\n      voters.push(signers[i]);\n    }\n  }\n\n  // signers is an accessor method to retrieve all te signers (public accessor\n  // generates an indexed one, not a retreive-all version).\n  function signers() constant returns(address[]) {\n    return voters;\n  }\n\n  // authProposals retrieves the list of addresses that authorization proposals\n  // are currently being voted on.\n  function authProposals() constant returns(address[]) {\n    return authPend;\n  }\n\n  // authVotes retrieves the current authorization votes for a particular user\n  // to promote him into the list of signers, or demote him from there.\n  function authVotes(address user) constant returns(address[] promote, address[] demote) {\n    return (authProps[user].pass, authProps[user].fail);\n  }\n\n  // currentVersion retrieves the semantic version, commit hash and release time\n  // of the currently votec active release.\n  function currentVersion() constant returns (uint32 major, uint32 minor, uint32 patch, bytes20 commit, uint time) {\n    if (releases.length == 0) {\n      return (0, 0, 0, 0, 0);\n    }\n    var release = releases[releases.length - 1];\n\n    return (release.major, release.minor, release.patch, release.commit, release.time);\n  }\n\n  // proposedVersion retrieves the semantic version, commit hash and the current\n  // votes for the next proposed release.\n  function proposedVersion() constant returns (uint32 major, uint32 minor, uint32 patch, bytes20 commit, address[] pass, address[] fail) {\n    return (verProp.major, verProp.minor, verProp.patch, verProp.commit, verProp.votes.pass, verProp.votes.fail);\n  }\n\n  // promote pitches in on a voting campaign to promote a new user to a signer\n  // position.\n  function promote(address user) {\n    updateSigner(user, true);\n  }\n\n  // demote pitches in on a voting campaign to demote an authorised user from\n  // its signer position.\n  function demote(address user) {\n    updateSigner(user, false);\n  }\n\n  // release votes for a particular version to be included as the next release.\n  function release(uint32 major, uint32 minor, uint32 patch, bytes20 commit) {\n    updateRelease(major, minor, patch, commit, true);\n  }\n\n  // nuke votes for the currently proposed version to not be included as the next\n  // release. Nuking doesn't require a specific version number for simplicity.\n  function nuke() {\n    updateRelease(0, 0, 0, 0, false);\n  }\n\n  // updateSigner marks a vote for changing the status of an Ethereum user, either\n  // for or against the user being an authorised signer.\n  function updateSigner(address user, bool authorize) internal isSigner {\n    // Gather the current votes and ensure we don't double vote\n    Votes votes = authProps[user];\n    for (uint i = 0; i < votes.pass.length; i++) {\n      if (votes.pass[i] == msg.sender) {\n        return;\n      }\n    }\n    for (i = 0; i < votes.fail.length; i++) {\n      if (votes.fail[i] == msg.sender) {\n        return;\n      }\n    }\n    // If no authorization proposal is open, add the user to the index for later lookups\n    if (votes.pass.length == 0 && votes.fail.length == 0) {\n      authPend.push(user);\n    }\n    // Cast the vote and return if the proposal cannot be resolved yet\n    if (authorize) {\n      votes.pass.push(msg.sender);\n      if (votes.pass.length <= voters.length / 2) {\n        return;\n      }\n    } else {\n      votes.fail.push(msg.sender);\n      if (votes.fail.length <= voters.length / 2) {\n        return;\n      }\n    }\n    // Proposal resolved in our favor, execute whatever we voted on\n    if (authorize && !authorised[user]) {\n      authorised[user] = true;\n      voters.push(user);\n    } else if (!authorize && authorised[user]) {\n      authorised[user] = false;\n\n      for (i = 0; i < voters.length; i++) {\n        if (voters[i] == user) {\n          voters[i] = voters[voters.length - 1];\n          voters.length--;\n\n          delete verProp; // Nuke any version proposal (no suprise releases!)\n          break;\n        }\n      }\n    }\n    // Finally delete the resolved proposal, index and garbage collect\n    delete authProps[user];\n\n    for (i = 0; i < authPend.length; i++) {\n      if (authPend[i] == user) {\n        authPend[i] = authPend[authPend.length - 1];\n        authPend.length--;\n        break;\n      }\n    }\n  }\n\n  // updateRelease votes for a particular version to be included as the next release,\n  // or for the currently proposed release to be nuked out.\n  function updateRelease(uint32 major, uint32 minor, uint32 patch, bytes20 commit, bool release) internal isSigner {\n    // Skip nuke votes if no proposal is pending\n    if (!release && verProp.votes.pass.length == 0) {\n      return;\n    }\n    // Mark a new release if no proposal is pending\n    if (verProp.votes.pass.length == 0) {\n      verProp.major  = major;\n      verProp.minor  = minor;\n      verProp.patch  = patch;\n      verProp.commit = commit;\n    }\n    // Make sure positive votes match the current proposal\n    if (release && (verProp.major != major || verProp.minor != minor || verProp.patch != patch || verProp.commit != commit)) {\n      return;\n    }\n    // Gather the current votes and ensure we don't double vote\n    Votes votes = verProp.votes;\n    for (uint i = 0; i < votes.pass.length; i++) {\n      if (votes.pass[i] == msg.sender) {\n        return;\n      }\n    }\n    for (i = 0; i < votes.fail.length; i++) {\n      if (votes.fail[i] == msg.sender) {\n        return;\n      }\n    }\n    // Cast the vote and return if the proposal cannot be resolved yet\n    if (release) {\n      votes.pass.push(msg.sender);\n      if (votes.pass.length <= voters.length / 2) {\n        return;\n      }\n    } else {\n      votes.fail.push(msg.sender);\n      if (votes.fail.length <= voters.length / 2) {\n        return;\n      }\n    }\n    // Proposal resolved in our favor, execute whatever we voted on\n    if (release) {\n      verProp.time = uint64(now);\n      releases.push(verProp);\n      delete verProp;\n    } else {\n      delete verProp;\n    }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1443640,0x2a280b3597f3da9384f6ddf35714e1c4973ced6c,false,false,,,,TOO_SHORT
1443656,0x8c7dbf25739b64d131c7c3a3cde146dfea70ae2f,false,false,,,,TOO_SHORT
1443722,0x777b72483f083f236b8adcfc13f07e3c2d141815,false,false,,,,TOO_SHORT
1443920,0x8ffd1e60acada7e906cce5b040b4bfe0426575d7,false,false,,,,TOO_SHORT
1443950,0xe5e028771a66b09f3a5b95717d2f86df8ab26462,false,false,,,,TOO_SHORT
1444087,0xe97db027d7a48fa91223bb75721fe87606c65d5a,false,false,,,,TOO_SHORT
1444116,0x56b139fe23d04240c8f12b6b97cfc3eb93ccf1c1,false,false,,,,TOO_SHORT
1444198,0xd27558f3293276fc579d5c5031c87b332e1996ed,false,false,,,,TOO_SHORT
1444249,0x44bac2e2b73907acbcf731c831121086f8dca9b7,false,false,,,,TOO_SHORT
1444340,0x37e504c0932a39de207a2a5841c4ad98ab2b1e67,false,false,,,,TOO_SHORT
1444408,0xb7f3aeafbe58cc82d190019ac776d353a42cffe7,false,false,,,,TOO_SHORT
1444440,0x2bf16535f39b7f769eae81557feab012f317245d,false,false,,,,TOO_SHORT
1444489,0xd098c1c0413e3822f58ee4bced5d33eed77bfee0,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1444505,0x26e0d4c434e56f9f9f6854f45e99b0b4cdafcec1,false,false,,,,TOO_SHORT
1444787,0xa656e9dd07d58dc0b4222a08aee7398182b69446,false,false,,,,TOO_SHORT
1444797,0xf8936e5ec7adbf04036a176bb97793c566bf9c20,false,false,,,,TOO_SHORT
1444803,0xa4465891e35d56403db0911bac6f79b0976ca314,false,false,,,,TOO_SHORT
1444974,0x82f130611e0261a50e7d56c4fbe984e46a801823,false,false,,,,TOO_SHORT
1444980,0x74effa45c7297678955932b2bbd0a9699ab3e704,false,false,,,,TOO_SHORT
1445052,0x1f20d065783fdc00e1d1b1224d54d07b9315fd58,false,false,,,,TOO_SHORT
1445088,0x72fc9cc24ad7dd151e09e7203d9a3a143a541f7c,false,false,,,,TOO_SHORT
1445278,0x1e14759fee128356b3fb850d0f4b11c3349c5fec,false,false,,,,TOO_SHORT
1445296,0x2b50f9a3d846a14d31e8ae9c7d3a038a54938402,false,false,,,,TOO_SHORT
1445378,0x12b46a3672ea8ee0f6945b5a50f88b3cb5049ba3,false,false,,,,TOO_SHORT
1445522,0x03a98837e5cf56681227abaa086457c35b5cf962,false,false,,,,TOO_SHORT
1445523,0x795a76993f20b90cfe1cd91d1e3892b61943b218,false,false,,,,TOO_SHORT
1445571,0x24e1efe57d341db3fa3dd81aed86a130bb38f2cb,false,false,,,,TOO_SHORT
1445805,0xa201851ceb91bb95dcb4728a9876344d1fde8aa7,false,false,,,,TOO_SHORT
1445825,0x88fecc0bb2369ac47d40e31fc32229bd7ee9348e,false,false,,,,TOO_SHORT
1445945,0x63ab5f7a7d54d8d4a3ac11f1c5e1cc31928e940f,false,false,,,,TOO_SHORT
1446025,0x874a5334b2a45de3fea9cf592b3bae6d6c7ffe85,false,false,,,,TOO_SHORT
1446184,0x5aad259928f58b1c1703b9c3fd9fefbd563d4b96,false,false,,,,TOO_SHORT
1446195,0xb9426b8a4d336b9222309917d990a2e98cf75773,false,false,,,,TOO_SHORT
1446251,0x5f265aa3fb78403a849a7a284a2b06cf35a6da4b,false,false,,,,TOO_SHORT
1446253,0xf6e7d049855eab77da1bcc97e48455093e14fc42,false,false,,,,TOO_SHORT
1446306,0x0537024ba8e1dfafcb75bf5ecd6eb491f19a983d,false,false,,,,TOO_SHORT
1446371,0x9f026b49ca9b315094d8c7ea067df1f4b293c6ad,false,false,,,,TOO_SHORT
1446375,0x466e5a7d97df34111f996637fee174140f1c947b,false,false,,,,TOO_SHORT
1446596,0x0f38cd0ebd064e47a2a5e46bc8daa6eec5a24a54,false,false,,,,TOO_SHORT
1446932,0x2182092058fcbd993533274d4a1d83f7432fc2b1,false,false,,,,TOO_SHORT
1447073,0x6a55417aec894484a09f3c6c4f020c06635f5433,false,false,,,,TOO_SHORT
1447208,0x0261aa501d7ce2be43fa0a0511f104efb3fe8692,false,false,,,,TOO_SHORT
1447223,0xc2f727bb61a8c99a8a9e711e816c5a45fbefbd94,false,false,,,,TOO_SHORT
1447262,0x64623a9904784c39a7ae968196f0a8756f28bad9,false,false,,,,TOO_SHORT
1447280,0x65d3cc2f436e3c172cef1c816ae81dcc21acc3fa,false,false,,,,TOO_SHORT
1447754,0xeefd3b6b7f312233b2618ae6f61b45e206aa933b,false,false,,,,TOO_SHORT
1448258,0x9a86e667fb614a50aa7a5c133505c8c4b13e7010,false,false,,,,TOO_SHORT
1448325,0x6ad18aac1968198d88656672bdf244b2584d75f1,false,false,,,,TOO_SHORT
1448458,0x34e154ace0320f3abdd7dbb72135f2fea26067d5,false,false,,,,TOO_SHORT
1448484,0x3ab6df99c21676065e54bc84609ba41cb427f457,false,false,,,,TOO_SHORT
1448489,0x957ddded43b6fe4578ad2058160336bd4e4a7855,false,false,,,,TOO_SHORT
1448593,0x3b08ef97ffbe1ad24d5a4ca9f86c162ca5ffeca9,false,false,,,,TOO_SHORT
1448723,0xda5b738c7c090c00cfb0c4b77fda8d8f4228ed26,false,false,,,,TOO_SHORT
1448851,0xf997c16de00c855c800bffad2455681210035ae6,false,false,,,,TOO_SHORT
1448942,0xb8bc61088ee77f726e37da82aaac5f12d0d5a4f8,false,false,,,,TOO_SHORT
1449123,0xd31b3414657fafc6288c6eea4b4cab842e7aa2db,false,false,,,,TOO_SHORT
1449312,0xe1494b9d1615b5a4bd07d4e2d603385a74d5f94a,false,false,,,,TOO_SHORT
1449617,0x83c7d8552414e6abba39641a9a6beb3c173e82a0,false,false,,,,TOO_SHORT
1449631,0x2bec93e033538f838f7eb2990a466b44c5667f34,false,false,,,,TOO_SHORT
1449882,0xb4151b07b6b8f7a2cdada95a47da60d413b49d80,false,false,,,,TOO_SHORT
1450045,0xd7e72650ec43525805730316b7fb391dfd8ed593,false,false,,,,TOO_SHORT
1450234,0x2dfda2b1dd39a2d19729fbe06a38a4a4b78ac32b,false,false,,,,TOO_SHORT
1450269,0xb1cb7d0f25b143493acf2f41ececf8423335addf,false,false,,,,TOO_SHORT
1450312,0xcf7bebc8bcb97b3aaf77b9361e592d5c72533a07,false,false,,,,TOO_SHORT
1450374,0x24027c80bf3555ec077d35faf725425bc31cfe50,false,false,,,,TOO_SHORT
1450427,0x4f50198d60e9e0a92b417c029f59b3548334001b,false,false,,,,TOO_SHORT
1450474,0x635fb40909951905fea2c2a08e6327afda115886,false,false,,,,TOO_SHORT
1450762,0x139ff4cbe9de020efad583582dd1bf31d38844f2,false,false,,,,TOO_SHORT
1451039,0xdcb9099af799125c5cf51d2e6ccbc4261a997998,false,false,,,,TOO_SHORT
1451199,0xf500508a80f818602bc292b68bc1edbdcfefa673,false,false,,,,TOO_SHORT
1451231,0x13561ed34c6af28d86897fb171473720824de08a,false,false,,,,TOO_SHORT
1451233,0xe4d6c5636f9413cc887da76ff7a7c4a509b9b31e,false,false,,,,TOO_SHORT
1451238,0xeb98cfb04f1ba0970deba69901c5474d2a70ac1e,false,false,,,,TOO_SHORT
1451256,0xf143673b3d5b07887f22590ffa0d1360d3060bea,false,false,,,,TOO_SHORT
1451272,0x31631f74134ee233675d8a34e708b25493856d24,false,false,,,,TOO_SHORT
1451355,0x38efb1c00782d266f97f0a06ac7bfb7469a33306,false,false,,,,TOO_SHORT
1451416,0xa6b68292bd475243a1d0c4f660ce45185cb96d79,false,false,,,,TOO_SHORT
1451419,0x253811204e7f1204a0167a586015045f2fdb9dcf,false,false,,,,TOO_SHORT
1451501,0x2f985da8fad3969a7a41927544457abc292b940d,false,false,,,,TOO_SHORT
1451707,0xb84e8fb7a3fdd0f8c9193ddfde87dc3845e5e115,false,false,,,,TOO_SHORT
1451733,0x7ed3b10571afba1c75128bd05cb398a3c28323c7,false,false,,,,TOO_SHORT
1451799,0x3f3aaa3ec3732e85f352a184661cdc9bf20f139f,false,false,,,,TOO_SHORT
1452057,0xb94ce7e6717c84ba66817963f699accf89c17809,false,false,,,,TOO_SHORT
1452189,0x923d8d30aa840e86445735780a139dccd7447c4e,false,false,,,,TOO_SHORT
1452216,0xc53f7f1e8aa3049308e896fca981ac2c38f1f3f4,false,false,,,,TOO_SHORT
1452230,0x3d0c990dc0ec2d617034c95b5917b6eee0184433,false,false,,,,TOO_SHORT
1452255,0x6b9a98fa58dcaa9ba5dd553f3960a2646240d278,false,false,,,,TOO_SHORT
1452509,0xea1540be11f336e0eef2249674eae1847e5e7d5e,false,false,,,,TOO_SHORT
1452528,0x8bccd5261a38e1e9ac80d77269305fae3134784c,false,false,,,,TOO_SHORT
1452706,0x6248f7eb6eb47817f17963447044b35285d46215,false,false,,,,TOO_SHORT
1452836,0x57dafbb36812d27e8448dbcdd72bbf45f41f4264,false,false,,,,TOO_SHORT
1452988,0x8903dc8fff9712dfc16da010b34e0377f1bb3313,false,false,,,,TOO_SHORT
1453540,0xf2219e18118a8bebb6763efbcfde3814cb69c589,false,false,,,,TOO_SHORT
1453631,0x81104f14b6092d4865859a453012b7fa1510121c,false,false,,,,TOO_SHORT
1453644,0xeb9587e6429ad5b5a55ccca1c8d230aab7ced6f9,false,false,,,,TOO_SHORT
1453681,0x12162d7f32dd615f590438b7eef2cc5f35051bc9,false,false,,,,TOO_SHORT
1453808,0x1fc661b3d994b9bb66cf3f9a1e8ccd58b6fb7177,false,false,,,,TOO_SHORT
1454117,0xa00fa22499478cc37beb45021a1f1c9f826f72e1,false,false,"contract Ambi {\n    function getNodeAddress(bytes32) constant returns (address);\n    function addNode(bytes32, address) external returns (bool);\n    function hasRelation(bytes32, bytes32, address) constant returns (bool);\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove(){\n        if(msg.sender == address(ambiC)){\n            suicide(msg.sender);\n        }\n    }\n}\n\ncontract ElcoinDb {\n    function getBalance(address addr) constant returns(uint balance);\n}\n\ncontract ElcoinInterface {\n    function rewardTo(address _to, uint _amount) returns (bool);\n}\n\ncontract PosRewards is AmbiEnabled {\n\n    event Reward(address indexed beneficiary, uint indexed cycle, uint value, uint position);\n\n    uint public cycleLength; // PoS will be ready to send each cycleLength seconds\n    uint public startTime;   // starting at startTime\n    uint public cycleLimit;  // and will stop after cycleLimit cycles pass\n    uint public minimalRewardedBalance; // but only those accounts having balance\n                             // >= minimalRewardedBalance will get reward\n    uint[] public bannedCycles;\n\n    enum RewardStatuses { Unsent, Sent, TooSmallToSend }\n\n    struct Account {\n        address recipient;\n        RewardStatuses status;\n    }\n\n    // cycleNumber => (address => minimalBalance)\n    mapping (uint => mapping (address => int)) public accountsBalances;\n    // cycleNumber => Account[]\n    mapping (uint => Account[]) public accountsUsed;\n\n    function PosRewards() {\n        cycleLength = 864000; // 864000 seconds = 10 days, 14400 = 4 hours\n        cycleLimit = 255; // that's 9 + 9 + 9 + 9 + 219, see getRate() for info\n        minimalRewardedBalance = 1000000; // 1 coin\n        startTime = now;\n    }\n\n    // USE THIS FUNCTION ONLY IN NEW CONTRACT, IT WILL CORRUPT ALREADY COLLECTED DATA!\n    // startTime should be set to the time when PoS starts (on Dec 17, probably block 705000 or so).\n    // It should be at 12:00 Moscow time, this would be the start of all PoS cycles.\n    function setStartTime(uint _startTime) checkAccess(""owner"") {\n        startTime = _startTime;\n    }\n\n    // this allows to end PoS before 2550 days pass or to extend it further\n    function setCycleLimit(uint _cycleLimit) checkAccess(""owner"") {\n        cycleLimit = _cycleLimit;\n    }\n\n    // this allows to disable PoS sending for some of the cycles in case we\n    // need to send custom PoS. This will be 100% used on first deploy.\n    function setBannedCycles(uint[] _cycles) checkAccess(""owner"") {\n        bannedCycles = _cycles;\n    }\n\n    // set to 0 to reward everyone\n    function setMinimalRewardedBalance(uint _balance) checkAccess(""owner"") {\n        minimalRewardedBalance = _balance;\n    }\n\n    function kill() checkAccess(""owner"") {\n        suicide(msg.sender); // kills this contract and sends remaining funds back to msg.sender\n    }\n\n    // First 90 days 50% yearly\n    // Next 90 days 40%\n    // Next 90 days 30%\n    // Next 90 days 20%\n    // Next 2190 days 10%\n    function getRate(uint cycle) constant returns (uint) {\n        if (cycle <= 9) {\n            return 50;\n        }\n        if (cycle <= 18) {\n            return 40;\n        }\n        if (cycle <= 27) {\n            return 30;\n        }\n        if (cycle <= 35) { // not 36 because 36 is elDay\n            return 20;\n        }\n        if (cycle == 36) {\n            return 40;\n        }\n        if (cycle <= cycleLimit) {\n            if (cycle % 36 == 0) {\n                // Every 360th day, reward amounts double.\n                // The elDay lasts precisely 24 hours, and after that, reward amounts revert to their original values.\n                return 20;\n            }\n\n            return 10;\n        }\n        return 0;\n    }\n\n    // Cycle numeration starts from 1, 0 will be handled as not valid cycle\n    function currentCycle() constant returns (uint) {\n        if (startTime > now) {\n            return 0;\n        }\n\n        return 1 + ((now - startTime) / cycleLength);\n    }\n\n    function _isCycleValid(uint _cycle) constant internal returns (bool) {\n        if (_cycle >= currentCycle() || _cycle == 0) {\n            return false;\n        }\n        for (uint i; i<bannedCycles.length; i++) {\n            if (bannedCycles[i] == _cycle) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Returns how much Elcoin would be granted for user's minimal balance X in cycle Y\n    // The function is optimized to work with whole integer arithmetics\n    function getInterest(uint amount, uint cycle) constant returns (uint) {\n        return (amount * getRate(cycle)) / 3650;\n    }\n\n    // This function logs the balances after the transfer to be used in further calculations\n    function transfer(address _from, address _to) checkAccess(""elcoin"") {\n        if (startTime == 0) {\n            return; // the easy way to disable PoS\n        }\n\n        _storeBalanceRecord(_from);\n        _storeBalanceRecord(_to);\n    }\n\n    function _storeBalanceRecord(address _addr) internal {\n        ElcoinDb db = ElcoinDb(getAddress(""elcoinDb""));\n        uint cycle = currentCycle();\n\n        if (cycle > cycleLimit) {\n            return;\n        }\n\n        int balance = int(db.getBalance(_addr));\n        bool accountNotUsedInCycle = (accountsBalances[cycle][_addr] == 0);\n\n        // We'll use -1 to mark accounts that have zero balance because\n        // mappings return 0 for unexisting records and there is no way to\n        // differ them without additional data structure\n        if (accountsBalances[cycle][_addr] != -1 && (accountNotUsedInCycle || accountsBalances[cycle][_addr] > balance)) {\n            if (balance == 0) {\n                balance = -1;\n            }\n            accountsBalances[cycle][_addr] = balance;\n\n            if (accountNotUsedInCycle) {\n                // do this only once for each account in each cycle\n                accountsUsed[cycle].push(Account(_addr, RewardStatuses.Unsent));\n            }\n        }\n    }\n\n    // Get minimal balance for address in some cycle\n    function getMinimalBalance(uint _cycle, address _addr) constant returns(int) {\n        int balance = accountsBalances[_cycle][_addr];\n        if (balance == -1) {\n            balance = 0;\n        }\n\n        return balance;\n    }\n\n    // Get information from accountsUsed structure\n    function getAccountInfo(uint _cycle, uint _position) constant returns(address, RewardStatuses, int) {\n        return (\n            accountsUsed[_cycle][_position].recipient,\n            accountsUsed[_cycle][_position].status,\n            accountsBalances[_cycle][accountsUsed[_cycle][_position].recipient]\n          );\n    }\n\n    // Get information from accountsUsed structure\n    function getRewardsCount(uint _cycle) constant returns(uint) {\n        return accountsUsed[_cycle].length;\n    }\n\n    function sendReward(uint _cycle, uint _position) returns(bool) {\n        // Check that parameters are in valid ranges\n        if (!_isCycleValid(_cycle) || _position >= accountsUsed[_cycle].length) {\n            return false;\n        }\n\n        // Check that this reward was not sent\n        Account claimant = accountsUsed[_cycle][_position];\n        if (claimant.status != RewardStatuses.Unsent) {\n            return false;\n        }\n\n        // Check that this reward passes the conditions\n        int minimalAccountBalance = accountsBalances[_cycle][claimant.recipient];\n        if (minimalAccountBalance < int(minimalRewardedBalance)) {\n            claimant.status = RewardStatuses.TooSmallToSend;\n            return false;\n        }\n\n        uint rewardAmount = getInterest(uint(minimalAccountBalance), _cycle);\n\n        // We are ready to send the reward\n        ElcoinInterface elcoin = ElcoinInterface(getAddress(""elcoin""));\n        bool result = elcoin.rewardTo(claimant.recipient, rewardAmount);\n        if (result) {\n            Reward(claimant.recipient, _cycle, rewardAmount, _position);\n            claimant.status = RewardStatuses.Sent;\n        }\n\n        return true;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1454222,0xba878836379ddffebc1cf73abe63cfc63348591f,false,false,,,,TOO_SHORT
1454228,0x5ee5f1ba59f11be210e6748a935ecb2364ff99c8,false,false,,,,TOO_SHORT
1454248,0x3dbbd03a37ee19c5c7a7e1c1b6d4849408d2141b,false,false,,,,TOO_SHORT
1454250,0xa80025979a2734c494ca982bb257c4a5414de412,false,false,,,,TOO_SHORT
1454320,0x8ee934ae555c3b60411aac86c7ede0bb47fc44cf,false,false,,,,TOO_SHORT
1454387,0xdfee640e647890950c718447b942316d6583b81e,false,false,,,,TOO_SHORT
1454473,0x336381bc8e0ae43e947df5e6bff016f4ba1503aa,false,false,,,,TOO_SHORT
1454608,0x225c198bcada6e19fdc9bfdf4ce3551f8b37f665,false,false,,,,TOO_SHORT
1454669,0xb05b362409e9705e70ff4a6b84a39110f1646a9c,false,false,,,,TOO_SHORT
1454748,0xc153beb6ea4cd17a6c450f362c10ad45bc467887,false,false,,,,TOO_SHORT
1454773,0x6e40d43dfd552790cc1202fd2dd48a2617d603ca,false,false,,,,TOO_SHORT
1454783,0x0e840f0a8d1f3731158bf0eaddaba46d26ab776f,false,false,,,,TOO_SHORT
1454906,0xd0b2107945e6dbefaf50f472324c8ad83cd417c5,false,false,,,,TOO_SHORT
1454967,0x2b237f94b3e8afb3d1d66c8f5e98d78c9c060f9c,false,false,,,,TOO_SHORT
1455051,0xbe00aa130778e612c549d2afbf6091046a9dba68,false,false,,,,TOO_SHORT
1455786,0x47cc41ae071cbab924db1390aab50ee24b87ab09,false,false,,,,TOO_SHORT
1455842,0xca96cdac98524d215be0a7cbe308b7fd86b49380,false,false,,,,TOO_SHORT
1455941,0xf51fb65f9f142f5f2f51330e2e25d930eeb6e9df,false,false,,,,TOO_SHORT
1456219,0xf19ee5f19425e4211ce8c00b04f22fd9d3cf612a,false,false,,,,TOO_SHORT
1456224,0x69955a638288a2c6d5f28f476aa90331a7b40cc4,false,false,,,,TOO_SHORT
1456320,0x96c9152939d03fae83bedc965476b32b00a3de5f,false,false,,,,TOO_SHORT
1456342,0x4aafb26084afe47236b236900346d155d6f2242b,false,false,,,,TOO_SHORT
1456373,0x1164084a6df84878d7fd1becd01f8b4f617f89b9,false,false,,,,TOO_SHORT
1456453,0x1df7499d2a97662254f21dade5eb0f65044f446e,false,false,,,,TOO_SHORT
1456568,0x5d6585af1a7c75c598fa67adfac7acac6a9f5c13,false,false,,,,TOO_SHORT
1456613,0x4fad45f87caef3ae503a611cc03865e6685e19e6,false,false,,,,TOO_SHORT
1456648,0x17af0356988c57267c5eaa45a598011a4beb32b5,false,false,,,,TOO_SHORT
1456724,0xdd99fb195ab585909f80bb422b87121b52f2e887,false,false,,,,TOO_SHORT
1456818,0xc3a8409f9c286949d0f74e19ae7e282cd8579e61,false,false,,,,TOO_SHORT
1456916,0x75d7bb25e839d98b2b585985ccf1820c3a4ad73f,false,false,,,,TOO_SHORT
1456965,0x3126418fa2bdc55b8528d956363d16d7d06e8365,false,false,,,,TOO_SHORT
1457328,0xcae0be33f8c18f33116e7ff515f8eb4bd25bde49,false,false,,,,TOO_SHORT
1457406,0x0b7d86ca2ab2f5b4a30c0bfc52b4cfcfa486efb0,false,false,,,,TOO_SHORT
1457448,0x9c22a8696c69b42a902e1f81c8fa9df4a59d4c56,false,false,,,,TOO_SHORT
1457564,0xf61417818ef72e8f3c1b55d1b28e0aa63c9b3da9,false,false,,,,TOO_SHORT
1457629,0xa3f9329eb7c32c8fa90d150e407e825319cfc0d4,false,false,,,,TOO_SHORT
1457865,0x24468e445b235158a111ebdb77aea457c6a5d668,false,false,,,,TOO_SHORT
1457890,0x623c41e001a5aa0c715479ae354e78e3fa28be88,false,false,,,,TOO_SHORT
1458034,0xbc6391c3db25131f93886f55e9ca2dd4b6f3f39a,false,false,,,,TOO_SHORT
1458147,0x09b1263139e9027d5cc1c66f8b912c5efcaad950,false,false,,,,TOO_SHORT
1458248,0xd43debcba56da6e645cd34f1b520908ef4033f4f,false,false,,,,TOO_SHORT
1458357,0x089cc1f3481232d3b4306c58bfb24f22b8fdf663,false,false,,,,TOO_SHORT
1458370,0x08a854cafdb679f33ef45aa0a48234e34d796381,false,false,,,,TOO_SHORT
1458412,0x72166a8666f19b4bc59ce65524e46a80c139265d,false,false,,,,TOO_SHORT
1458470,0xf5d0bc869f291ebb45565009f9256eadc4730bb8,false,false,,,,TOO_SHORT
1458494,0x685aff51df1ed74a9dcf7b235cfe1219e94ae1ad,false,false,,,,TOO_SHORT
1458506,0xa3505276f6e63a1969f71c3a9a85806a6e95f66b,false,false,,,,TOO_SHORT
1458657,0x502997e5170f1126c7832d7ce18d4eb2e8c7cf5d,false,false,,,,TOO_SHORT
1458665,0x86eab83242c8e064d994514f51df9f033268ce61,false,false,,,,TOO_SHORT
1458693,0x56acf7a8203fdbd145a24f815d382bfb68853e8b,false,false,,,,TOO_SHORT
1458817,0xab75229d77aca8ea72348b3e328fed68f1750a9c,false,false,,,,TOO_SHORT
1458896,0x09e47a0c248da9443ce4d3d985cca30555ac4162,false,false,,,,TOO_SHORT
1458905,0x245cfd1889d33088939009419c27965d60b192ea,false,false,,,,TOO_SHORT
1459151,0xbd9721a7bcbd0d280d2a7b220f3b4b2f313cf8b8,false,false,,,,TOO_SHORT
1459300,0x52dc38e55768753c3d52c9debbdcfb14aea59a58,false,false,,,,TOO_SHORT
1459400,0x1570e80f0aad964bcc765d92aedcc9604669352f,false,false,,,,TOO_SHORT
1459573,0xbe4e5c85cb5593a3fa54b0cfb7860dce3a2a7d44,false,false,,,,TOO_SHORT
1459839,0xaf1c32c68ba22bba12d9a5e92e8f25cc959c9853,false,false,,,,TOO_SHORT
1459865,0x04b397baf4037d232810c437c7e0c12deaef42b3,false,false,,,,TOO_SHORT
1459958,0x1e15062d00ff632ee8a858faf280aa192f40c078,false,false,,,,TOO_SHORT
1460250,0xd75cf9980161ca3044e0b184c6ee8c78f5458c04,false,false,,,,TOO_SHORT
1460420,0xb61fb596b0cc9fa829d678eb0b8a0e058c3f1b91,false,false,"contract JackPot {\n    address public host;\n	uint minAmount;\n    uint[] public contributions;\n    address[] public contributors;\n	uint public numPlayers = 0;\n	uint public nextDraw;\n	bytes32 seedHash;\n	bytes32 random;	\n\n    struct Win {\n        address winner;\n        uint timestamp;\n        uint contribution;\n		uint amountWon;\n    }\n\n    Win[] public recentWins;\n    uint recentWinsCount;\n	\n	function insert_contribution(address addr, uint value) internal {\n		// check if array needs extending\n		if(numPlayers == contributions.length) {\n			// extend the arrays\n			contributions.length += 1;\n			contributors.length += 1;\n		}\n		contributions[numPlayers] = value;\n		contributors[numPlayers++] = addr;\n	}\n	\n	function getContributions(address addr) constant returns (uint) {\n        uint i;\n        for (i=0; i < numPlayers; i++) {\n			if (contributors[i] == addr) { // if in the list already\n				break;\n			}\n		}\n		\n		if(i == numPlayers) { // Did not find sender already in the list\n            return 0;\n        } else {\n			return contributions[i];\n		}\n    }\n	\n	function JackPot() {\n\n        host = msg.sender;\n		seedHash = sha3(1111);\n		minAmount = 10 * 1 finney;\n        recentWinsCount = 10;\n		nextDraw = 1234; // Initialize to start time of the block\n    }\n\n    function() {\n        addToContribution();\n    }\n\n    function addToContribution() {\n        addValueToContribution(msg.value);\n    }\n\n    function addValueToContribution(uint value) internal {\n        // First, make sure this is a valid transaction.\n        if(value < minAmount) throw;\n	    uint i;\n        for (i=0; i < numPlayers; i++) {\n			if (contributors[i] == msg.sender) { // Already contributed?\n				break;\n			}\n		}\n		\n		if(i == numPlayers) { // Did not find sender already in the list\n			insert_contribution(msg.sender, value);\n        } else {\n			contributions[i]+= value; // Update amount\n		}\n		\n		random = sha3(random, block.blockhash(block.number - 1));		\n    }\n	\n	//drawPot triggered from Host after time has passed or pot is matured.\n	function drawPot(bytes32 seed, bytes32 newSeed) {\n		if(msg.sender != host) throw;\n		\n		// check that seed given is the same as the seedHash so operators of jackpot can not cheat \n		if (sha3(seed) == seedHash) {\n			seedHash = sha3(newSeed);\n			// Choose a winner using the seed as random\n            uint winner_index = selectWinner(seed);\n\n            // Send the developer a 1% fee\n            host.send(this.balance / 100);\n			\n			uint amountWon = this.balance; \n			\n            // Send the winner the remaining balance on the contract.\n            contributors[winner_index].send(this.balance);\n			\n			// Make a note that someone won, then start all over!\n            recordWin(winner_index, amountWon);\n\n            reset();\n			nextDraw = now + 7 days;	\n		}\n	}\n\n	function setDrawDate(uint _newDraw) {\n		if(msg.sender != host) throw;\n		nextDraw = _newDraw;\n	}\n	\n	\n    function selectWinner(bytes32 seed) internal returns (uint winner_index) {\n\n        uint semirandom = uint(sha3(random, seed)) % this.balance;\n        for(uint i = 0; i < numPlayers; ++i) {\n            if(semirandom < contributions[i]) return i;\n            semirandom -= contributions[i];\n        }\n    }\n\n    function recordWin(uint winner_index, uint amount) internal {\n        if(recentWins.length < recentWinsCount) {\n            recentWins.length++;\n        } else {\n            // Already at capacity for the number of winners to remember.\n            // Forget the oldest one by shifting each entry 'left'\n            for(uint i = 0; i < recentWinsCount - 1; ++i) {\n                recentWins[i] = recentWins[i + 1];\n            }\n        }\n\n        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);\n    }\n\n    function reset() internal {\n        // Clear the lists with min gas after the draw.\n		numPlayers = 0;\n    }\n\n\n    /* This should only be needed if a bug is discovered\n    in the code and the contract must be destroyed. */\n    function destroy() {\n        if(msg.sender != host) throw;\n\n        // Refund everyone's contributions.\n        for(uint i = 0; i < numPlayers; ++i) {\n            contributors[i].send(contributions[i]);\n        }\n\n		reset();\n        selfdestruct(host);\n    }\n}",1,実用的なジャックポット機能を持つ標準的なスマートコントラクト。,
1460625,0x040ec7d5b1cf4f208f9c67a9b5f9d293ab27f22a,false,false,,,,TOO_SHORT
1460679,0x85b558c2ff65433816c2c342095dfa3dbc32ae0f,false,false,,,,TOO_SHORT
1460696,0x4850da3efa88b663f79c35a40eb63f3b969a85d1,false,false,,,,TOO_SHORT
1460838,0x980b0f16c8e963eefdd8e40149c08cfa74573165,false,false,,,,TOO_SHORT
1461002,0xee7da868cb84d9f235ebc2155b94b3669251a943,false,false,,,,TOO_SHORT
1461135,0xb8b4bd276cc215c3ddf41e21322362edba6acae5,false,false,,,,TOO_SHORT
1461190,0x563461fb26a77b01d84356bbb3e0671773e03a03,false,false,,,,TOO_SHORT
1461304,0xc84e57efdaa484bf5603011608ce97c5ef7b3deb,false,false,,,,TOO_SHORT
1461586,0x143430b59f50250be8afd5fa26e886a7f5ad8eb8,false,false,,,,TOO_SHORT
1461710,0x481468b10e500f8ef29e53c5082265707e2596bf,false,false,,,,TOO_SHORT
1461736,0x8a6a1b353681df9498bfde8259228fd8677722f8,false,false,,,,TOO_SHORT
1461784,0x4fb347e60817092e2a99c4bc6c446f7ff12856b1,false,false,,,,TOO_SHORT
1461859,0xbdda4da247d477b5da8fa24f3739a64e00bd1db2,false,false,,,,TOO_SHORT
1461900,0xbdf8ad3e8ee16cc7322384d7775a849541ce8394,false,false,,,,TOO_SHORT
1462073,0x2eedd03a7bcb4b11deb69e742a6b50af7b0b724f,false,false,,,,TOO_SHORT
1462087,0x65ed42932e7e40538dfee29f71dec4fc91a9803c,false,false,,,,TOO_SHORT
1462115,0xa61802f7e336d39d805ed0d4a3b7b8b62b30d3a2,false,false,,,,TOO_SHORT
1462121,0x57ebf49638e94c4679d2cd5cddfb168e90963967,false,false,,,,TOO_SHORT
1462351,0x3682c66552baf2c892b6c121694a1c22f1d460e8,false,false,,,,TOO_SHORT
1462543,0x6cafdc06177f6f4b4b4638c987397b07cd948aed,false,false,"contract JackPot {\n    address public host;\n	uint minAmount;\n    uint[] public contributions;\n    address[] public contributors;\n	uint public numPlayers;\n	uint public nextDraw;\n	bytes32 public seedHash;\n	bytes32 random;	\n\n    struct Win {\n        address winner;\n        uint timestamp;\n        uint contribution;\n		uint amountWon;\n    }\n\n    Win[] public recentWins;\n    uint recentWinsCount = 10;\n	\n	function insert_contribution(address addr, uint value) internal {\n		// check if array needs extending\n		if(numPlayers == contributions.length) {\n			// extend the arrays\n			contributions.length += 1;\n			contributors.length += 1;\n		}\n		contributions[numPlayers] = value;\n		contributors[numPlayers++] = addr;\n	}\n	\n	function getContributions(address addr) constant returns (uint) {\n        uint i;\n        for (i=0; i < numPlayers; i++) {\n			if (contributors[i] == addr) { // if in the list already\n				break;\n			}\n		}\n		\n		if(i == numPlayers) { // Did not find sender already in the list\n            return 0;\n        } else {\n			return contributions[i];\n		}\n    }\n	\n	function JackPot() {\n        host = msg.sender;\n		seedHash = sha3('aaaa');\n		minAmount = 10 * 1 finney;\n        recentWinsCount = 10;\n		nextDraw = 1234;\n    }\n\n    function() {\n        addToContribution();\n    }\n\n    function addToContribution() {\n        addValueToContribution(msg.value);\n    }\n\n    function addValueToContribution(uint value) internal {\n        // First, make sure this is a valid transaction.\n        if(value < minAmount) throw;\n	    uint i;\n        for (i=0; i < numPlayers; i++) {\n			if (contributors[i] == msg.sender) { // Already contributed?\n				break;\n			}\n		}\n		\n		if(i == numPlayers) { // Did not find sender already in the list\n			insert_contribution(msg.sender, value);\n        } else {\n			contributions[i]+= value; // Update amount\n		}\n		\n		random = sha3(random, block.blockhash(block.number - 1));		\n    }\n	\n	//drawPot triggered from Host after time has passed or pot is matured.\n	function drawPot(string seed, string newSeed) {\n		if(msg.sender != host) throw;\n		if (sha3(seed) == seedHash) {\n			\n			// Initialize seedHash for next draw\n			seedHash = sha3(newSeed);\n			// Choose a winner using the seed as random\n			uint winner_index = selectWinner(seed);\n\n			// Send the developer a 1% fee\n			host.send(this.balance / 100);\n			\n			uint amountWon = this.balance; \n			\n			// Send the winner the remaining balance on the contract.\n			contributors[winner_index].send(this.balance);\n			\n			// Make a note that someone won, then start all over!\n			recordWin(winner_index, amountWon);\n\n			reset();\n			nextDraw = now + 7 days;	\n\n		}\n	}\n\n	function setDrawDate(uint _newDraw) {\n		if(msg.sender != host) throw;\n		nextDraw = _newDraw;\n	}\n	\n	\n    function selectWinner(string seed) internal returns (uint winner_index) {\n\n        uint semirandom = uint(sha3(random, seed)) % this.balance;\n        for(uint i = 0; i < numPlayers; ++i) {\n            if(semirandom < contributions[i]) return i;\n            semirandom -= contributions[i];\n        }\n    }\n\n    function recordWin(uint winner_index, uint amount) internal {\n        if(recentWins.length < recentWinsCount) {\n            recentWins.length++;\n        } else {\n            // Already at capacity for the number of winners to remember.\n            // Forget the oldest one by shifting each entry 'left'\n            for(uint i = 0; i < recentWinsCount - 1; ++i) {\n                recentWins[i] = recentWins[i + 1];\n            }\n        }\n\n        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);\n    }\n\n    function reset() internal {\n        // Clear the lists with min gas after the draw.\n		numPlayers = 0;\n    }\n\n\n    /* This should only be needed if a bug is discovered\n    in the code and the contract must be destroyed. */\n    function destroy() {\n        if(msg.sender != host) throw;\n\n        // Refund everyone's contributions.\n        for(uint i = 0; i < numPlayers; ++i) {\n            contributors[i].send(contributions[i]);\n        }\n\n		reset();\n        selfdestruct(host);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1462649,0x28a25d43015ebdd037e285464aa6e149b5d40f2c,false,false,,,,TOO_SHORT
1462719,0xf4e0c4a7a6b7210503d367aa5a07116c77c89399,false,false,,,,TOO_SHORT
1462721,0x778816cc5906af093608f86cd4ea9632bdb45cf9,false,false,,,,TOO_SHORT
1462762,0x4d10b67cdfdc45979936ad5244b04d091e5461d1,false,false,,,,TOO_SHORT
1462875,0x251bc2ca37df13c0fa6b5f85cb14f21888397631,false,false,,,,TOO_SHORT
1463201,0x8030eaa64354461644cb20fdf59d310c7377b2bb,false,false,,,,TOO_SHORT
1463372,0xcc4d40c8080509e724379e3a4b21141dbb10e6bb,false,false,,,,TOO_SHORT
1463380,0xd3b4508203645ac75f2bf1206d57e4a464796076,false,false,,,,TOO_SHORT
1463384,0x8adca0a5f21848868adf92fe2dc1bb1b4414b73f,false,false,,,,TOO_SHORT
1463487,0x9ac0ff105231ecbf76ba2622c23a00cf094a2d1a,false,false,,,,TOO_SHORT
1463498,0x49904901aad59a0cc0009f65819357c61dd24b50,false,false,,,,TOO_SHORT
1463551,0x652fd9c53ac8c1410e9f5f209ab008fe3e0d941d,false,false,,,,TOO_SHORT
1463710,0x627917e47cd111382ddf7fb1dc140d2daf8876b3,false,false,contract mortal {\n    /* Define variable owner of the type address*/\n    address owner;\n\n    /* this function is executed at initialization and sets the owner of the contract */\n    function mortal() { owner = msg.sender; }\n\n    /* Function to recover the funds on the contract */\n    function kill() { if (msg.sender == owner) suicide(owner); }\n}\n\ncontract store is mortal {\n\n    uint16 public contentCount = 0;\n    \n    event content(string datainfo); \n    \n    function store() public {\n    }\n\n    function add(string datainfo) {\n        contentCount++;\n        content(datainfo);\n    }\n},1,標準的な所有者管理とイベントを持つ実用的なスマートコントラクト。,
1463843,0x7ac6d02ff73a49005bc07ffb6bcb9ab22b687989,false,false,,,,TOO_SHORT
1463939,0x18afb784c63514c572ad9d9ac6a8e2062b27e208,false,false,,,,TOO_SHORT
1464040,0x7860e6d30e88c70d23eea4776c98017c32d19fe5,false,false,,,,TOO_SHORT
1464106,0x5be33e51c8d03ae07065a8dc9eb379189f273443,false,false,,,,TOO_SHORT
1464141,0x8732cb59f5bf4d82c6f756b1756284df386c1e79,false,false,,,,TOO_SHORT
1464183,0xa5821fb1f5cc4e1cc1f2f0b20ea951104d9817b3,false,false,,,,TOO_SHORT
1464197,0xff848d21aab76327d7c93ecbebd3a2fb3b47c8fa,false,false,,,,TOO_SHORT
1464293,0x84724a86a15d08af75001ad1a8c66f79b2a01f45,false,false,,,,TOO_SHORT
1464969,0x4535ba91da7700a6ecceeb4341875d5ae0cafe9c,false,false,,,,TOO_SHORT
1465213,0xac89197f145ac849e9eb655964710a6b0b86b755,false,false,,,,TOO_SHORT
1465601,0x050f81ae80a07542a70bb52f15895e347164f867,false,false,,,,TOO_SHORT
1465739,0xa7c3111309d8439aeef0210aba94146da1281ed4,false,false,,,,TOO_SHORT
1465781,0xf5fb74633b26bac88d97ff7db5db35063c57c36f,false,false,,,,TOO_SHORT
1466154,0xfb83b48a5777102f919d79495f4d6529d4e6f61e,false,false,,,,TOO_SHORT
1466694,0x26967b32c261d0915c96ce4ca7dbc01e58d6fea8,false,false,,,,TOO_SHORT
1466778,0x2fef3d3f14673af82f59fc3367c50d02f1483b05,false,false,"// Version 0.1\n// This swap contract was created by Attores and released under a GPL license\n// Visit attores.com for more contracts and Smart contract as a Service \n\n// This is the standard token interface\ncontract TokenInterface {\n\n  struct User {\n    bool locked;\n    uint256 balance;\n    uint256 badges;\n    mapping (address => uint256) allowed;\n  }\n\n  mapping (address => User) users;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n  mapping (address => bool) seller;\n\n  address config;\n  address owner;\n  address dao;\n  bool locked;\n\n  /// @return total amount of tokens\n  uint256 public totalSupply;\n  uint256 public totalBadges;\n\n  /// @param _owner The address from which the balance will be retrieved\n  /// @return The balance\n  function balanceOf(address _owner) constant returns (uint256 balance);\n\n  /// @param _owner The address from which the badge count will be retrieved\n  /// @return The badges count\n  function badgesOf(address _owner) constant returns (uint256 badge);\n\n  /// @notice send `_value` tokens to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transfer(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` badges to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function sendBadge(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n  /// @param _from The address of the sender\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @param _value The amount of tokens to be approved for transfer\n  /// @return Whether the approval was successful or not\n  function approve(address _spender, uint256 _value) returns (bool success);\n\n  /// @param _owner The address of the account owning tokens\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n  /// @notice mint `_amount` of tokens to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mint(address _owner, uint256 _amount) returns (bool success);\n\n  /// @notice mintBadge Mint `_amount` badges to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n\n  function registerDao(address _dao) returns (bool success);\n\n  function registerSeller(address _tokensales) returns (bool success);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n// Actual swap contract written by Attores\ncontract swap{\n    address public beneficiary;\n    TokenInterface public tokenObj;\n    uint public price_token;\n    uint256 public WEI_PER_FINNEY = 1000000000000000;\n    uint public BILLION = 1000000000;\n    uint public expiryDate;\n    \n    // Constructor function for this contract. Called during contract creation\n    function swap(address sendEtherTo, address adddressOfToken, uint tokenPriceInFinney_1000FinneyIs_1Ether, uint durationInDays){\n        beneficiary = sendEtherTo;\n        tokenObj = TokenInterface(adddressOfToken);\n        price_token = tokenPriceInFinney_1000FinneyIs_1Ether * WEI_PER_FINNEY;\n        expiryDate = now + durationInDays * 1 days;\n    }\n    \n    // This function is called every time some one sends ether to this contract\n    function(){\n        if (now >= expiryDate) throw;\n        // Dividing by Billion here to cater for the decimal places\n        var tokens_to_send = (msg.value * BILLION) / price_token;\n        uint balance = tokenObj.balanceOf(this);\n        address payee = msg.sender;\n        if (balance >= tokens_to_send){\n            tokenObj.transfer(msg.sender, tokens_to_send);\n            beneficiary.send(msg.value);    \n        } else {\n            tokenObj.transfer(msg.sender, balance);\n            uint amountReturned = ((tokens_to_send - balance) * price_token) / BILLION;\n            payee.send(amountReturned);\n            beneficiary.send(msg.value - amountReturned);\n        }\n    }\n    \n    modifier afterExpiry() { if (now >= expiryDate) _ }\n    \n    //This function checks if the expiry date has passed and if it has, then returns the tokens to the beneficiary\n    function checkExpiry() afterExpiry{\n        uint balance = tokenObj.balanceOf(this);\n        tokenObj.transfer(beneficiary, balance);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1466781,0x905f557abc2df3505e2272ac974e3c680940ec18,false,false,,,,TOO_SHORT
1466863,0x886db2bb79f0891ebced5c0e9aa0baa99b6a8226,false,false,,,,TOO_SHORT
1467118,0x6f1d32297fb04a81983fa4316be5962769a710fe,false,false,,,,TOO_SHORT
1467377,0x72cd2484f30a782b22dd55021736fbee290b0f09,false,false,,,,TOO_SHORT
1467380,0x7a293379a505ade85a570b7c0ef445f78c553cee,false,false,,,,TOO_SHORT
1467643,0x53bc141e315744a3264485adf25da721e8bf4080,false,false,,,,TOO_SHORT
1467882,0x2e5163114984ccb1a53157eaab1239ce0655c521,false,false,,,,TOO_SHORT
1468045,0x00b48c97e75bcd9522857fe24199a83c2514592d,false,false,,,,TOO_SHORT
1468085,0x964c3c48aabb7e3eb32430b452f4a20dc0b3d5e1,false,false,,,,TOO_SHORT
1468126,0x6439e643dc316ac4108ebdc6c364a65994b6b1ff,false,false,"// This is the base contract that your contract test2 extends from.\ncontract BaseRegistry {\n\n    // The owner of this registry.\n    address owner;\n\n    // This struct keeps all data for a Record.\n    struct Record {\n        // Keeps the address of this record creator.\n        address owner;\n        // Keeps the time when this record was created.\n        uint time;\n        // Keeps the index of the keys array for fast lookup\n        uint keysIndex;\n    }\n\n    // This mapping keeps the records of this Registry.\n    mapping(address => Record) records;\n\n    // Keeps the total numbers of records in this Registry.\n    uint public numRecords;\n\n    // Keeps a list of all keys to interate the records.\n    address[] private keys;\n\n\n\n    // Constructor\n    function BaseRegistry() {\n        owner = msg.sender;\n    }\n\n    // This is the function that actually insert a record. \n    function register(address key) {\n        if (records[key].time == 0) {\n            records[key].time = now;\n            records[key].owner = msg.sender;\n            records[key].keysIndex = keys.length;\n            keys.length++;\n            keys[keys.length - 1] = key;\n            numRecords++;\n        } else {\n            returnValue();\n        }\n    }\n\n    // Updates the values of the given record.\n    function update(address key) {\n        // Only the owner can update his record.\n        if (records[key].owner == msg.sender) {}\n    }\n\n    // Unregister a given record\n    function unregister(address key) {\n        if (records[key].owner == msg.sender) {\n            uint keysIndex = records[key].keysIndex;\n            delete records[key];\n            numRecords--;\n            keys[keysIndex] = keys[keys.length - 1];\n            records[keys[keysIndex]].keysIndex = keysIndex;\n            keys.length--;\n        }\n    }\n\n    // Transfer ownership of a given record.\n    function transfer(address key, address newOwner) {\n        if (records[key].owner == msg.sender) {\n            records[key].owner = newOwner;\n        } else {\n            returnValue();\n        }\n    }\n\n    // Tells whether a given key is registered.\n    function isRegistered(address key) returns(bool) {\n        return records[key].time != 0;\n    }\n\n    function getRecordAtIndex(uint rindex) returns(address key, address owner, uint time) {\n        Record record = records[keys[rindex]];\n        key = keys[rindex];\n        owner = record.owner;\n        time = record.time;\n\n    }\n\n    function getRecord(address key) returns(address owner, uint time) {\n        Record record = records[key];\n        owner = record.owner;\n        time = record.time;\n\n    }\n\n    // Returns the owner of the given record. The owner could also be get\n    // by using the function getRecord but in that case all record attributes \n    // are returned.\n    function getOwner(address key) returns(address) {\n        return records[key].owner;\n    }\n\n    // Returns the registration time of the given record. The time could also\n    // be get by using the function getRecord but in that case all record attributes\n    // are returned.\n    function getTime(address key) returns(uint) {\n        return records[key].time;\n    }\n\n    // Returns the total number of records in this registry.\n    function getTotalRecords() returns(uint) {\n        return numRecords;\n    }\n\n    // This function is used by subcontracts when an error is detected and\n    // the value needs to be returned to the transaction originator.\n    function returnValue() internal {\n        if (msg.value > 0) {\n            msg.sender.send(msg.value);\n        }\n    }\n\n    // Registry owner can use this function to withdraw any value owned by\n    // the registry.\n    function withdraw(address to, uint value) {\n        if (msg.sender == owner) {\n            to.send(value);\n        }\n    }\n\n    function kill() {\n        if (msg.sender == owner) {\n            suicide(owner);\n        }\n    }\n}\n\ncontract test2 is BaseRegistry {}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1468275,0x2f1b943d741f70d514eaee0c5319fdca0b88e7ca,false,false,,,,TOO_SHORT
1468303,0x8dc6fbff468774d199e99fd9f17bef07612b5a81,false,false,,,,TOO_SHORT
1468433,0xea0f2ececd8129c8a8cbc8a2d8ff3984c7d01591,false,false,,,,TOO_SHORT
1468434,0x8c1596598e4a3bf036ca037f660119802d0cfa03,false,false,,,,TOO_SHORT
1468583,0x1eefb82719533248e5eb54e1abb505d673a1c389,false,false,,,,TOO_SHORT
1468736,0x0f6dda5e9a81dd88dd904b5d1eaa174021984538,false,false,,,,TOO_SHORT
1468757,0xfb8de999e2e0a640f2b587ab4c4f4a1d439023ff,false,false,,,,TOO_SHORT
1468833,0xd5f5eddc6c92ff1c6f1938558d3c42a4fbc37bfe,false,false,,,,TOO_SHORT
1469000,0x0b349c9dcb3b0fac3247c60629e18225ae48f8de,false,false,,,,TOO_SHORT
1469272,0xda11d156e6752edceb066451a5bf0b9a61d2bc9a,false,false,,,,TOO_SHORT
1469519,0x5e199cb2b36d19415b94b7ab642d0c9222bd277d,false,false,,,,TOO_SHORT
1469601,0x0105f812a1ffbeff5c9cf168b29d891d5f86e171,false,false,,,,TOO_SHORT
1469901,0x105c6f92c0ff2adf61d9c959fade427d623e2e9d,false,false,,,,TOO_SHORT
1470242,0xe3b4d04f554e69c554bedc061e16fc8094542803,false,false,,,,TOO_SHORT
1470332,0xcf17b26d90be02922c80c4b7900eccb12866102c,false,false,,,,TOO_SHORT
1470792,0xc6c52b5ba231a514487d2e4eb7e2d7a1712b38ec,false,false,,,,TOO_SHORT
1471041,0xe70dfb6f5cb9d9f64c02b5a6fd8ae1d9fbad515f,false,false,,,,TOO_SHORT
1471044,0xf4d801645b36847658b2656a49c36beb8d10b951,false,false,,,,TOO_SHORT
1471132,0x9a5f07d859b3f8d90db8ec1d881f5542f26c6484,false,false,,,,TOO_SHORT
1471197,0x978d579c5f0d11f0703986033771688e103e2b5d,false,false,,,,TOO_SHORT
1471300,0xdac8da3e58c11b4e0e8dfaefe191107e143ac29b,false,false,,,,0x2fef3d3f14673af82f59fc3367c50d02f1483b05
1471350,0x7996d791995b9f9c15eb4c3e899b09a344c54bdb,false,false,"contract GameOfThrones {\n    address public trueGods;\n    // King's Jester\n    address public jester;\n    // Record the last collection time\n    uint public lastCollection;\n    // Record king life\n    uint public onThrone;\n    uint public kingCost;\n    // Piggy Bank Amount\n    uint public piggyBank;\n    // Collected Fee Amount\n    uint public godBank;\n    uint public jesterBank;\n    uint public kingBank;\n\n    // Track the citizens who helped to arm race\n    address[] public citizensAddresses;\n    uint[] public citizensAmounts;\n    uint32 public totalCitizens;\n    uint32 public lastCitizenPaid;\n    // The mad king establishes the government\n    address public madKing;\n    // Record how many times the castle had fell\n    uint32 public round;\n    // Amount already paid back in this round\n    uint public amountAlreadyPaidBack;\n    // Amount invested in this round\n    uint public amountInvested;\n\n    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;\n    uint constant PEACE_PERIOD = 60 * 60 * 240;\n\n    function GameOfThrones() {\n        // Define the first castle\n        trueGods = msg.sender;\n        madKing = msg.sender;\n        jester = msg.sender;\n        lastCollection = block.timestamp;\n        onThrone = block.timestamp;\n        kingCost = 1 ether;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n    }\n\n    function repairTheCastle() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 10 finney) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the amount received is more than 100 ETH return the difference\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the Castle has fell\n        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {\n            // Send the Piggy Bank to the last 3 citizens\n            // If there is no one who contributed this last 24 hours, no action needed\n            if (totalCitizens == 1) {\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);\n            } else if (totalCitizens == 2) {\n                // If only 2 citizens contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\n            } else if (totalCitizens >= 3) {\n                // If there is 3 or more citizens who contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\n            }\n\n            godBank += piggyBank * 5 / 100;\n            // Define the new Piggy Bank\n            piggyBank = 0;\n\n            // Define the new Castle\n            jester = msg.sender;\n\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n            godAutomaticCollectFee();\n            // All goes to the Piggy Bank\n            piggyBank += amount;\n\n            round += 1;\n        } else {\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n\n            // 5% goes to the Piggy Bank\n            piggyBank += (amount * 5 / 100);\n\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\n                lastCitizenPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        repairTheCastle();\n    }\n\n    function investInTheSystem(uint amount) internal {\n        // The Castle is still up\n        lastCollection = block.timestamp;\n        amountInvested += amount;\n        // The Jetster takes 5%\n        jesterBank += amount * 5 / 100;\n        // The mad king takes 5%\n        kingBank += amount * 5 / 100;\n        // 5% goes to the Piggy Bank\n        piggyBank += (amount * 5 / 100);\n\n        kingAutomaticCollectFee();\n        jesterAutomaticCollectFee();\n    }\n\n    // When the mad king decides to give his seat to someone else\n    // the king cost will be reset to 2 ether\n    function newKing(address newKing) {\n        if (msg.sender == madKing) {\n            madKing = newKing;\n            kingCost = 1 ether;\n        }\n    }\n\n    function bribery() {\n        uint amount = 100 finney;\n        if (msg.value >= amount) {\n            // return jester\n            jester.send(jesterBank);\n            jesterBank = 0;\n\n            jester = msg.sender;\n            msg.sender.send(msg.value - amount);\n            investInTheSystem(amount);\n        } else {\n            throw;\n        }\n    }\n\n    // Anyone can usurpation the kingship\n    function usurpation() {\n        // Add more money for king usurpation cost\n        if (msg.sender == madKing) {\n            investInTheSystem(msg.value);\n            kingCost += msg.value;\n        } else {\n            if (onThrone + PEACE_PERIOD <= block.timestamp && msg.value >= kingCost * 110 / 100) {\n                // return the fees to before king\n                madKing.send(kingBank);\n                // offer sacrifices to the Gods\n                godBank += msg.value * 5 / 100;\n                investInTheSystem(msg.value);\n                // new king\n                kingCost = msg.value;\n                madKing = msg.sender;\n                onThrone = block.timestamp;\n            } else {\n                throw;\n            }\n        }\n    }\n\n    // When the king decides to collect his fees\n    function collectFee() {\n        if (msg.sender == trueGods) {\n            trueGods.send(godBank);\n        }\n    }\n\n    function godAutomaticCollectFee() internal {\n        if (godBank >= 1 ether) {\n          trueGods.send(godBank);\n          godBank = 0;\n        }\n    }\n\n    function kingAutomaticCollectFee() internal {\n        if (kingBank >= 100 finney) {\n          madKing.send(kingBank);\n          kingBank = 0;\n        }\n    }\n\n    function jesterAutomaticCollectFee() internal {\n        if (jesterBank >= 100 finney) {\n          jester.send(jesterBank);\n          jesterBank = 0;\n        }\n    }\n}",2,コードは実用的だが、Game of Thronesのテーマで詩的な要素を持ち、物語性を感じさせる。,
1471368,0x5135cb284ff9ffec77f9fe803ddbbbd6eebc14a9,false,false,,,,TOO_SHORT
1471440,0x5cf56d8b0e214cbaef4a4e3f2b50c62461720793,false,false,,,,TOO_SHORT
1471509,0x5fea3837839b94f615d183e86299e12c3855e7e3,false,false,,,,TOO_SHORT
1471595,0xeabbd7a0a44b428436fe909bc66d05237c83643b,false,false,,,,TOO_SHORT
1471647,0x904d09c51e537dc9409bf31f28bd4009053173c8,false,false,,,,TOO_SHORT
1471698,0x7a2b9cb7d3b6c345333ad52a62570c9b0f4cf471,false,false,,,,TOO_SHORT
1472069,0x8776f59f88d81a62f2730d21e54c008f132a748e,false,false,,,,TOO_SHORT
1472078,0x786ef2e92c9946d9ec75eb1c9fb89eb02b4d6224,false,false,"/*\n\nTokenSaleFactory interface:\n\n[{""constant"":true,""inputs"":[{""name"":"""",""type"":""address""},{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesByOwner"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesAll"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_asset"",""type"":""address""},{""name"":""_price"",""type"":""uint256""}],""name"":""createSale"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""address""},{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesByAsset"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""index"",""type"":""uint256""}],""name"":""TokenSaleCreation"",""type"":""event""}]\n\n\nTokenSale interface:\n\n[{""constant"":true,""inputs"":[],""name"":""asset"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""owner"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_to"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""transfer_eth"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""price"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_token"",""type"":""address""},{""name"":""_to"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""transfer_token"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""newOwner"",""type"":""address""}],""name"":""transferOwnership"",""outputs"":[],""type"":""function""},{""inputs"":[{""name"":""_asset"",""type"":""address""},{""name"":""_price"",""type"":""uint256""}],""type"":""constructor""}]\n\nSeller usage:\n\nFollow the TokenSaleFactory contract using the TokenSaleFactory interface.\nUse the createSale function to launch a sale given the subcurrency address \nand the price measured in wei for the smallest of that subcurrency \nfor example 0.75 ETH per DGD would be 0.75 * 10^18 / 10^9\n\nFind your tokensale by entering your address into the tokenSalesByOwner owner field\nthen entering the number you get into the tokensalesall field which is a list of all sales created\n\nDeposit subcurrency to allow people to buy it at the pice you specified.\n\nTo withdraw funds use the function transfer_eth and give the amount in wei\nTo withdraw left over subcurrency use transfer_token given the address of the subcurrency you have deposited\nor transfer_asset. Amounts are in the smallest unit of that subcurrency for example 1 DGD would be 10^9\n\n\nBuyer usage:\n\nSend ETH to a TokenSale address to automatically receive the token being sold.\n\nTo verify a TokenSale contract obtain the index and address. Folow the TokenSaleFactory and enter the index into the TokenSalesAll field to verify the address is the same.\nFollow the TokenSale addresswith the TokenSale interface to verify the asset being sold is the right subcurrency and that the price is right.\n\n*/\n\ncontract Token {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function transfer(address _to, uint256 _value);\n    function balanceOf(address) returns (uint256);\n}\n\ncontract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract TokenSale is owned {\n\n	address public asset;\n	uint256 public price;\n\n	function TokenSale(address _asset, uint256 _price)\n	{\n	    asset = _asset; // addreress of subcurrency\n	    price = _price; // number of wei per smallest unit of subcurrency. \n	                    // for example 0.75 ETH per DGD would be 0.75 * 10^18 / 10^9\n	                    // 10^18 being the conversion to ETH and 10^9 being the conversion to DGD\n	}\n\n\n	function transfer_token(address _token, address _to, uint256 _value)\n	onlyOwner()\n	{\n		Token(_token).transfer(_to,_value); // Oner can Transfer any subcurrency out of this contract\n	}\n\n	function transfer_asset(address _to, uint256 _value)\n	onlyOwner()\n	{\n		Token(asset).transfer(_to,_value); // transfer the sale asset\n	}\n\n	function transfer_eth(address _to, uint256 _value)\n	onlyOwner()\n	{\n            _to.send(_value); // owner can send ETH out. _value is in wei\n	}\n\n   	function () {\n\n		uint order   = msg.value / price;\n		\n		if(order == 0) throw;\n		\n		uint256 balance = Token(asset).balanceOf(address(this));\n		\n		if(balance == 0) throw;\n		\n		if(order > balance )\n		{\n		    order = balance;\n		    uint256 change = msg.value - order * price;\n		    msg.sender.send(change);\n		}\n\n		Token(asset).transfer(msg.sender,order);\n    }\n}\n\n\ncontract TokenSaleFactory {\n    \n    event TokenSaleCreation(uint256 index, address saleAddress);\n\n    address[] public tokenSalesAll; // this public array stores all tokensales created\n\n    mapping (address => uint256[]) public tokenSalesByOwner; // this mapping stores an index in tokenSalesAll of all tokensales created by a specific address\n    mapping (address => uint256[]) public tokenSalesByAsset; // this mapping stores an index in tokenSalesAll of all tokensales for a particular subcurrency\n    \n    function createSale (address _asset, uint256 _price) returns (address) {\n        address c = new TokenSale(_asset,_price);       // Create a tokensale\n        TokenSale(c).transferOwnership(msg.sender);     // set the owner to whoever called the function\n        uint256 index = tokenSalesAll.push(c) -1;\n        tokenSalesByOwner[msg.sender].push(index);  \n        tokenSalesByAsset[msg.sender].push(index);\n        TokenSaleCreation(index,c);                       // alert interested client that a tokensale has been created\n    }\n    \n    function () {\n        throw;     // Prevents accidental sending of ether to the factory\n                   // Do not send subcurrency to the factory either as it will become trapped\n                   // you will send subcurrency to the TokenSale contracts this factory creates\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1472118,0x8a354e00de65260fa4dbd9488e1fab204f3cbc71,false,false,,,,TOO_SHORT
1472118,0x2add087d02fe18f1855f99b64d44354f2ebdfa98,false,false,"/*\n\nTokenSaleFactory interface:\n\n[{""constant"":true,""inputs"":[{""name"":"""",""type"":""address""},{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesByOwner"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesAll"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_asset"",""type"":""address""},{""name"":""_price"",""type"":""uint256""}],""name"":""createSale"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""address""},{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesByAsset"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""index"",""type"":""uint256""}],""name"":""TokenSaleCreation"",""type"":""event""}]\n\n\nTokenSale interface:\n\n[{""constant"":true,""inputs"":[],""name"":""asset"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""owner"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_to"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""transfer_eth"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""price"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_token"",""type"":""address""},{""name"":""_to"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""transfer_token"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""newOwner"",""type"":""address""}],""name"":""transferOwnership"",""outputs"":[],""type"":""function""},{""inputs"":[{""name"":""_asset"",""type"":""address""},{""name"":""_price"",""type"":""uint256""}],""type"":""constructor""}]\n\nSeller usage:\n\nFollow the TokenSaleFactory contract using the TokenSaleFactory interface.\nUse the createSale function to launch a sale given the subcurrency address \nand the price measured in wei for the smallest of that subcurrency \nfor example 0.75 ETH per DGD would be 0.75 * 10^18 / 10^9\n\nFind your tokensale by entering your address into the tokenSalesByOwner owner field\nthen entering the number you get into the tokensalesall field which is a list of all sales created\n\nDeposit subcurrency to allow people to buy it at the pice you specified.\n\nTo withdraw funds use the function transfer_eth and give the amount in wei\nTo withdraw left over subcurrency use transfer_token given the address of the subcurrency you have deposited\nor transfer_asset. Amounts are in the smallest unit of that subcurrency for example 1 DGD would be 10^9\n\n\nBuyer usage:\n\nSend ETH to a TokenSale address to automatically receive the token being sold.\n\nTo verify a TokenSale contract obtain the index and address. Folow the TokenSaleFactory and enter the index into the TokenSalesAll field to verify the address is the same.\nFollow the TokenSale addresswith the TokenSale interface to verify the asset being sold is the right subcurrency and that the price is right.\n\n*/\n\ncontract Token {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function transfer(address _to, uint256 _value);\n    function balanceOf(address) returns (uint256);\n}\n\ncontract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract TokenSale is owned {\n\n	address public asset;\n	uint256 public price;\n\n	function TokenSale(address _asset, uint256 _price)\n	{\n	    asset = _asset; // addreress of subcurrency\n	    price = _price; // number of wei per smallest unit of subcurrency. \n	                    // for example 0.75 ETH per DGD would be 0.75 * 10^18 / 10^9\n	                    // 10^18 being the conversion to ETH and 10^9 being the conversion to DGD\n	}\n\n\n	function transfer_token(address _token, address _to, uint256 _value)\n	onlyOwner()\n	{\n		Token(_token).transfer(_to,_value); // Oner can Transfer any subcurrency out of this contract\n	}\n\n	function transfer_asset(address _to, uint256 _value)\n	onlyOwner()\n	{\n		Token(asset).transfer(_to,_value); // transfer the sale asset\n	}\n\n	function transfer_eth(address _to, uint256 _value)\n	onlyOwner()\n	{\n            _to.send(_value); // owner can send ETH out. _value is in wei\n	}\n\n   	function () {\n\n		uint order   = msg.value / price;\n		\n		if(order == 0) throw;\n		\n		uint256 balance = Token(asset).balanceOf(address(this));\n		\n		if(balance == 0) throw;\n		\n		if(order > balance )\n		{\n		    order = balance;\n		    uint256 change = msg.value - order * price;\n		    msg.sender.send(change);\n		}\n\n		Token(asset).transfer(msg.sender,order);\n    }\n}\n\n\ncontract TokenSaleFactory {\n    \n    event TokenSaleCreation(uint256 index, address saleAddress);\n\n    address[] public tokenSalesAll; // this public array stores all tokensales created\n\n    mapping (address => uint256[]) public tokenSalesByOwner; // this mapping stores an index in tokenSalesAll of all tokensales created by a specific address\n    mapping (address => uint256[]) public tokenSalesByAsset; // this mapping stores an index in tokenSalesAll of all tokensales for a particular subcurrency\n    \n    function createSale (address _asset, uint256 _price) returns (address) {\n        address c = new TokenSale(_asset,_price);       // Create a tokensale\n        TokenSale(c).transferOwnership(msg.sender);     // set the owner to whoever called the function\n        uint256 index = tokenSalesAll.push(c) -1;\n        tokenSalesByOwner[msg.sender].push(index);  \n        tokenSalesByAsset[_asset].push(index);\n        TokenSaleCreation(index,c);                       // alert interested client that a tokensale has been created\n    }\n    \n    function () {\n        throw;     // Prevents accidental sending of ether to the factory\n                   // Do not send subcurrency to the factory either as it will become trapped\n                   // you will send subcurrency to the TokenSale contracts this factory creates\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1472386,0x9497043f4cd9450867479f3fd873d80d9321094c,false,false,"contract GameOfThrones {\n    address public trueGods;\n    // King's Jester\n    address public jester;\n    // Record the last collection time\n    uint public lastCollection;\n    // Record king life\n    uint public onThrone;\n    uint public kingCost;\n    // Piggy Bank Amount\n    uint public piggyBank;\n    // Collected Fee Amount\n    uint public godBank;\n    uint public jesterBank;\n    uint public kingBank;\n\n    // Track the citizens who helped to arm race\n    address[] public citizensAddresses;\n    uint[] public citizensAmounts;\n    uint32 public totalCitizens;\n    uint32 public lastCitizenPaid;\n    // The mad king establishes the government\n    address public madKing;\n    // Record how many times the castle had fell\n    uint32 public round;\n    // Amount already paid back in this round\n    uint public amountAlreadyPaidBack;\n    // Amount invested in this round\n    uint public amountInvested;\n\n    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;\n    uint constant PEACE_PERIOD = 60 * 60 * 240;\n\n    function GameOfThrones() {\n        // Define the first castle\n        trueGods = msg.sender;\n        madKing = msg.sender;\n        jester = msg.sender;\n        lastCollection = block.timestamp;\n        onThrone = block.timestamp;\n        kingCost = 1 ether;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n    }\n\n    function protectKingdom() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 10 finney) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the amount received is more than 100 ETH return the difference\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the Castle has fell\n        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {\n            // Send the Piggy Bank to the last 3 citizens\n            // If there is no one who contributed this last 24 hours, no action needed\n            if (totalCitizens == 1) {\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);\n            } else if (totalCitizens == 2) {\n                // If only 2 citizens contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\n            } else if (totalCitizens >= 3) {\n                // If there is 3 or more citizens who contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\n            }\n\n            godBank += piggyBank * 5 / 100;\n            // Define the new Piggy Bank\n            piggyBank = 0;\n\n            // Define the new Castle\n            jester = msg.sender;\n\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n            godAutomaticCollectFee();\n            // 95% goes to the Piggy Bank\n            piggyBank += amount * 90 / 100;\n\n            round += 1;\n        } else {\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\n                lastCitizenPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() internal {\n        protectKingdom();\n    }\n\n    function investInTheSystem(uint amount) internal {\n        // The Castle is still up\n        lastCollection = block.timestamp;\n        amountInvested += amount;\n        // The Jetster takes 5%\n        jesterBank += amount * 5 / 100;\n        // The mad king takes 5%\n        kingBank += amount * 5 / 100;\n        // 5% goes to the Piggy Bank\n        piggyBank += (amount * 5 / 100);\n\n        kingAutomaticCollectFee();\n        jesterAutomaticCollectFee();\n    }\n\n    // When the mad king decides to give his seat to someone else\n    // the king cost will be reset to 1 ether\n    function abdicate() {\n        if (msg.sender == madKing && msg.sender != trueGods) {\n            madKing.send(kingBank);\n            if (piggyBank > kingCost * 40 / 100) {\n                madKing.send(kingCost * 40 / 100);\n                piggyBank -= kingCost * 40 / 100;\n            }\n            else {\n                madKing.send(piggyBank);\n                piggyBank = 0;\n            }\n\n            madKing = trueGods;\n            kingCost = 1 ether;\n        }\n    }\n\n    function murder() {\n        uint amount = 100 finney;\n        if (msg.value >= amount && msg.sender != jester) {\n            // return jester\n            jester.send(jesterBank);\n            jesterBank = 0;\n\n            jester = msg.sender;\n            msg.sender.send(msg.value - amount);\n            investInTheSystem(amount);\n        } else {\n            throw;\n        }\n    }\n\n    // Anyone can usurpation the kingship\n    function usurpation() {\n        uint amount = msg.value;\n        // Add more money for king usurpation cost\n        if (msg.sender == madKing) {\n            investInTheSystem(amount);\n            kingCost += amount;\n        } else {\n            if (onThrone + PEACE_PERIOD <= block.timestamp && amount >= kingCost * 150 / 100) {\n                // return the fees to before king\n                madKing.send(kingBank);\n                // offer sacrifices to the Gods\n                godBank += amount * 5 / 100;\n                // new king\n                kingCost = amount;\n                madKing = msg.sender;\n                onThrone = block.timestamp;\n                investInTheSystem(amount);\n            } else {\n                throw;\n            }\n        }\n    }\n\n    // When the king decides to collect his fees\n    function collectFee() {\n        if (msg.sender == trueGods) {\n            trueGods.send(godBank);\n        }\n    }\n\n    function godAutomaticCollectFee() internal {\n        if (godBank >= 1 ether) {\n          trueGods.send(godBank);\n          godBank = 0;\n        }\n    }\n\n    function kingAutomaticCollectFee() internal {\n        if (kingBank >= 100 finney) {\n          madKing.send(kingBank);\n          kingBank = 0;\n        }\n    }\n\n    function jesterAutomaticCollectFee() internal {\n        if (jesterBank >= 100 finney) {\n          jester.send(jesterBank);\n          jesterBank = 0;\n        }\n    }\n}",2,中世のテーマを持ち、詩的な要素が含まれるが、実用的なスマートコントラクト。,
1472456,0xe054f55561ce49833bd346a34b09225a3adee06f,false,false,,,,TOO_SHORT
1472635,0x561043425e7ad096ef5f70daca4b0762496a148c,false,false,,,,TOO_SHORT
1472674,0xbde3b4972f3b74f85c9263faaadbc62b3eabc100,false,false,,,,TOO_SHORT
1472785,0x9f8bf604abeb04d32b0ffae9c3a083be5858cf96,false,false,"contract GameOfThrones {\n    address public trueGods;\n    // King's Jester\n    address public jester;\n    // Record the last collection time\n    uint public lastCollection;\n    // Record the last fell time\n    uint public lastFell;\n    // Record king life\n    uint public onThrone;\n    uint public kingCost;\n    // Piggy Bank Amount\n    uint public piggyBank;\n    // Collected Fee Amount\n    uint public godBank;\n    uint public jesterBank;\n    uint public kingBank;\n\n    // Track the citizens who helped to arm race\n    address[] public citizensAddresses;\n    uint[] public citizensAmounts;\n    uint32 public totalCitizens;\n    uint32 public lastCitizenPaid;\n    // The mad king establishes the government\n    address public madKing;\n    // Record how many times the castle had fell\n    uint32 public round;\n    // Amount already paid back in this round\n    uint public amountAlreadyPaidBack;\n    // Amount invested in this round\n    uint public amountInvested;\n\n    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;\n    uint constant PEACE_PERIOD = 60 * 60 * 240;\n\n    function GameOfThrones() {\n        // Define the first castle\n        trueGods = msg.sender;\n        madKing = msg.sender;\n        jester = msg.sender;\n        lastFell = block.timestamp;\n        lastCollection = block.timestamp;\n        onThrone = block.timestamp;\n        kingCost = 1 ether;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n    }\n\n    function protectKingdom() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 10 finney) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the amount received is more than 100 ETH return the difference\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the Castle has fell\n        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {\n            // Send the Piggy Bank to the last 3 citizens\n            // If there is no one who contributed this last 24 hours, no action needed\n            if (totalCitizens == 1) {\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);\n            } else if (totalCitizens == 2) {\n                // If only 2 citizens contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\n            } else if (totalCitizens >= 3) {\n                // If there is 3 or more citizens who contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\n            }\n\n            godBank += piggyBank * 5 / 100;\n            // Define the new Piggy Bank\n            piggyBank = 0;\n\n            // Define the new Castle\n            jester = msg.sender;\n\n            lastFell = block.timestamp;\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n            godAutomaticCollectFee();\n            // 95% goes to the Piggy Bank\n            piggyBank += amount * 90 / 100;\n\n            round += 1;\n        } else {\n            if (lastFell + TWENTY_FOUR_HOURS * 2 >= block.timestamp) {\n                citizensAddresses.push(msg.sender);\n                citizensAmounts.push(amount * 130 / 100);\n            } else {\n                citizensAddresses.push(msg.sender);\n                citizensAmounts.push(amount * 110 / 100);\n            }\n            totalCitizens += 1;\n            investInTheSystem(amount);\n\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\n                lastCitizenPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() internal {\n        protectKingdom();\n    }\n\n    function investInTheSystem(uint amount) internal {\n        // The Castle is still up\n        lastCollection = block.timestamp;\n        amountInvested += amount;\n        // The Jetster takes 5%\n        jesterBank += amount * 5 / 100;\n        // The mad king takes 5%\n        kingBank += amount * 5 / 100;\n        // 5% goes to the Piggy Bank\n        piggyBank += (amount * 5 / 100);\n\n        kingAutomaticCollectFee();\n        jesterAutomaticCollectFee();\n    }\n\n    // When the mad king decides to give his seat to someone else\n    // the king cost will be reset to 1 ether\n    function abdicate() {\n        if (msg.sender == madKing && msg.sender != trueGods) {\n            madKing.send(kingBank);\n            if (piggyBank > kingCost * 40 / 100) {\n                madKing.send(kingCost * 40 / 100);\n                piggyBank -= kingCost * 40 / 100;\n            }\n            else {\n                madKing.send(piggyBank);\n                piggyBank = 0;\n            }\n\n            madKing = trueGods;\n            kingCost = 1 ether;\n        }\n    }\n\n    function murder() {\n        uint amount = 100 finney;\n        if (msg.value >= amount && msg.sender != jester) {\n            // return jester\n            jester.send(jesterBank);\n            jesterBank = 0;\n\n            jester = msg.sender;\n            msg.sender.send(msg.value - amount);\n            investInTheSystem(amount);\n        } else {\n            throw;\n        }\n    }\n\n    // Anyone can usurpation the kingship\n    function usurpation() {\n        uint amount = msg.value;\n        // Add more money for king usurpation cost\n        if (msg.sender == madKing) {\n            investInTheSystem(amount);\n            kingCost += amount;\n        } else {\n            if (onThrone + PEACE_PERIOD <= block.timestamp && amount >= kingCost * 150 / 100) {\n                // return the fees to before king\n                madKing.send(kingBank);\n                // offer sacrifices to the Gods\n                godBank += amount * 5 / 100;\n                // new king\n                kingCost = amount;\n                madKing = msg.sender;\n                onThrone = block.timestamp;\n                investInTheSystem(amount);\n            } else {\n                throw;\n            }\n        }\n    }\n\n    // When the king decides to collect his fees\n    function collectFee() {\n        if (msg.sender == trueGods) {\n            trueGods.send(godBank);\n        }\n    }\n\n    function godAutomaticCollectFee() internal {\n        if (godBank >= 1 ether) {\n          trueGods.send(godBank);\n          godBank = 0;\n        }\n    }\n\n    function kingAutomaticCollectFee() internal {\n        if (kingBank >= 100 finney) {\n          madKing.send(kingBank);\n          kingBank = 0;\n        }\n    }\n\n    function jesterAutomaticCollectFee() internal {\n        if (jesterBank >= 100 finney) {\n          jester.send(jesterBank);\n          jesterBank = 0;\n        }\n    }\n}",2,中世のテーマと役割が詩的で、物語性があるが、実用的なスマートコントラクト。,
1473333,0x3550b727308ec69451daea228d031b80c4019024,false,false,,,,TOO_SHORT
1473637,0xc1e03947d609c2941bfe91ba164819511db7a537,false,false,,,,TOO_SHORT
1473656,0xbe0637a222cc5e1b1c391253dc8062a1edb9725f,false,false,,,,0x2fef3d3f14673af82f59fc3367c50d02f1483b05
1473880,0x28a118945a1d143353ff087368d51234525ebddf,false,false,,,,TOO_SHORT
1474017,0xd499d4dd82e7105c43bb041cc541e447d778eb58,false,false,,,,TOO_SHORT
1474065,0x1d763ff8952a4156366cc70c24ed877f63f19534,false,false,,,,TOO_SHORT
1474270,0xe180aabc9cb89406946cc57a3e359d375fab4592,false,false,,,,TOO_SHORT
1474295,0x8c0cbaae212f28b3078daf3c9af9eef3b63182f0,false,false,,,,TOO_SHORT
1474900,0x76436ccaab627433b9a94e92b4478b1f0eed49ee,false,false,,,,TOO_SHORT
1474941,0xd3a58c08b2d1c3797b906c657ced77939a3768fb,false,false,,,,TOO_SHORT
1475139,0x7b4df8e30fd33a9b41696cb9136f9e68c2a6ff77,false,false,,,,TOO_SHORT
1475348,0x168f7467d231984f79369e98700345d5ac70725c,false,false,,,,TOO_SHORT
1475410,0xe552a180e3313ade46faee12675f0c600364f386,false,false,,,,TOO_SHORT
1475515,0xf732c4e2afbcd1d7e291d3b38de38aef731ba42e,false,false,,,,TOO_SHORT
1475565,0xda4f78274714fc8c022c78aeacc4e1e2dbe00da8,false,false,,,,TOO_SHORT
1475839,0xb0f7aa4ff6fdc5f55b27856e6ae398eb5be05b80,false,false,,,,TOO_SHORT
1475858,0x1e6afcfbf863061656ca1cf915fb87457a44543a,false,false,,,,TOO_SHORT
1475973,0xdb433a9ea19ef0c3dcce357bf87253b18415d2a3,false,false,,,,TOO_SHORT
1476014,0x99ec34ace7d3f23f832160dc58baf956dd76abca,false,false,,,,TOO_SHORT
1476018,0x674542e6c374ac2aea7d435b166bc1707aec33a8,false,false,,,,TOO_SHORT
1476540,0x079a6dec4dd5766c9eefe5de075de39789cef54c,false,false,,,,TOO_SHORT
1476801,0xc726ac92955fc07ad09c5af4827418f581e37017,false,false,"contract CryptoHill {\n    \n  address admin;\n  address leader;\n  bytes32 leaderHash;\n  bytes32 difficulty;\n  bytes32 difficultyWorldRecord;\n  uint fallenLeaders;\n  uint startingTime;\n  uint gameLength;\n  string leaderMessage;\n  string defaultLeaderMessage;\n  \n  event Begin(string log);\n  event Leader(string log, address newLeader, bytes32 newHash);\n  event GameOver(string log);\n  event Winner (string log, address winner);\n  event NoWinner (string log);\n  event WorldRecord (string log, bytes32 DifficultyRecord, address RecordHolder);\n  \n  function CryptoHill(){ \n      \n    //Admin Backdoor\n    admin = msg.sender;\n\n    //Starting Time\n    startingTime = block.timestamp;\n    \n    //Game Length (TODO: Change to 1 weeks)\n    gameLength = 1 weeks;\n\n    //Initial seed for the first challenge. This should always be in rotation afterward.\n    leaderHash = sha3(""09F911029D74E35BD84156C5635688C0"");\n\n    //First leader is the creator of the contract\n    leader = msg.sender;\n\n    //The placeholder leader message\n    defaultLeaderMessage = ""If you're this weeks leader, you own this field. Write a message here."";\n    leaderMessage = defaultLeaderMessage;\n    \n    //This difficulty starts as easy as possible. Any XOR will be less, to start.\n    difficulty = leaderHash;\n    \n    //Seed the world record\n    difficultyWorldRecord = leaderHash;\n    \n    //Counter for successful collisions this week.\n    fallenLeaders = 0;\n\n    Begin(""Collide the most bits of the leader's hash to replace the leader. Leader will win any bounty at the end of the week."");\n\n  }\n  \n  function reset() private{\n      \n      //Make the hash unpredictable.\n      leaderHash = sha3(block.timestamp);\n      \n      //Reset the leader message\n      leaderMessage = defaultLeaderMessage;\n      difficulty = leaderHash;\n      leader = admin;\n      fallenLeaders = 0;\n  }\n  \n  function checkDate() private returns (bool success) {\n      \n      //Are we one week beyond the last game? TODO change time for mainnet\n      if (block.timestamp > (startingTime + gameLength)) {\n          \n          //If so, log winner. If the admin ""wins"", it's because no one else won.\n          if(leader != admin){\n            Winner(""Victory! Game will be reset to end in 1 week (in block time)."", leader);\n            leader.send(this.balance);\n          }else NoWinner(""No winner! Game will be reset to end in 1 week (in block time)."");\n\n          startingTime = block.timestamp;\n\n          //Reset\n          reset();\n          return true;\n      }\n      return false;\n  }\n\n  function overthrow(string challengeData) returns (bool success){\n        \n        //Create hash from player data sent to contract\n        var challengeHash = sha3(challengeData);\n\n        //Check One: Submission too late, reset game w/ new hash\n        if(checkDate())\n            return false;\n        \n        //Check Two: Cheating - of course last hash will collide!\n        if(challengeHash == leaderHash)\n            return false;\n\n        //Check Three: Core gaming logic favoring collisions of MSB\n        if((challengeHash ^ leaderHash) > difficulty)\n          return false;\n\n        //If player survived the checks, they've overcome difficulty level and beat the leader.\n        //Update the difficulty. This makes the game progressively harder through the week.\n        difficulty = (challengeHash ^ leaderHash);\n        \n        //Did they set a record?\n        challengeWorldRecord(difficulty);\n        \n        //We have a new Leader\n        leader = msg.sender;\n        \n        //The winning hash is our new hash. This undoes any work being done by competition!\n        leaderHash = challengeHash;\n        \n        //Announce our new victor. Congratulations!    \n        Leader(""New leader! This is their address, and the new hash to collide."", leader, leaderHash);\n        \n        //Keep track of how many new leaders we've had this week.\n        fallenLeaders++;\n        \n        return true;\n  }\n  \n  function challengeWorldRecord (bytes32 difficultyChallenge) private {\n      if(difficultyChallenge < difficultyWorldRecord) {\n        difficultyWorldRecord = difficultyChallenge;\n        WorldRecord(""A record setting collision occcured!"", difficultyWorldRecord, msg.sender);\n      }\n  }\n  \n  function changeLeaderMessage(string newMessage){\n        //The leader gets to talk all kinds of shit. If abuse, might remove.\n        if(msg.sender == leader)\n            leaderMessage = newMessage;\n  }\n  \n  //The following functions designed for mist UI\n  function currentLeader() constant returns (address CurrentLeaderAddress){\n      return leader;\n  }\n  function Difficulty() constant returns (bytes32 XorMustBeLessThan){\n      return difficulty;\n  }\n  function LeaderHash() constant returns (bytes32 leadingHash){\n      return leaderHash;\n  }\n  function LeaderMessage() constant returns (string MessageOfTheDay){\n      return leaderMessage;\n  }\n  function FallenLeaders() constant returns (uint Victors){\n      return fallenLeaders;\n  }\n  function GameEnds() constant returns (uint EndingTime){\n      return startingTime + gameLength;\n  }\n\n  function kill(){\n      if (msg.sender == admin){\n        GameOver(""The Crypto Hill has ended."");\n        selfdestruct(admin);\n      }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックが中心で芸術性は低い。,
1477109,0x6dc8a44c3a27ec84e15b1c89279f5ed7a8d1256f,false,false,,,,TOO_SHORT
1477133,0x7b0222aef601b28f80463e91555769301fe05520,false,false,,,,TOO_SHORT
1477279,0x7723912d8a75c47fe5da1c166240807002b2d42e,false,false,,,,TOO_SHORT
1477331,0xa3266da06854ba06e808b924972558a0963a9e77,false,false,,,,TOO_SHORT
1477345,0x9bc218601cf13d90ae1a9f1528f1415bfa736e5f,false,false,,,,TOO_SHORT
1477635,0x52905c40b626324e149a63b94ac53a6bda9681d1,false,false,,,,TOO_SHORT
1478065,0x6f9e539ea59b4375d6f9a8ecc6e8735455db1cd8,false,false,,,,TOO_SHORT
1478274,0xcd9258e732cc8ab71d6194c1ed3dac114bad84e7,false,false,,,,TOO_SHORT
1478660,0x7ef702bf452f0c5d11a3f19e2cb4629094a7622c,false,false,,,,TOO_SHORT
1478740,0x7c681a7fe777f47a8f01fcf226e25e83168f5878,false,false,,,,TOO_SHORT
1478933,0xf5f0d7ebb99e422be909b4cd47dda0f7609c96c6,false,false,,,,TOO_SHORT
1478958,0x72aecb34f6f9b66c3e787630d53b12703a026ee2,false,false,,,,TOO_SHORT
1479081,0x5dfeeabf0669144e8775c2d93579ddc540f4408c,false,false,,,,TOO_SHORT
1479128,0x8c6297fc9feba191d77744ff8ab2eae51630ea5f,false,false,,,,TOO_SHORT
1479129,0x2e4230128aca513b91fdc349fe56fcda21b7de26,false,false,,,,TOO_SHORT
1479360,0x633cb743d67d963b8e293f8e97a65d994a89c334,false,false,,,,TOO_SHORT
1479467,0x37abba2587b7a5423796e205424c44ef813a5d12,false,false,,,,TOO_SHORT
1479680,0xdbc43de67440a06978e434f04b6ebc1312cdce8b,false,false,,,,TOO_SHORT
1479710,0x97411a1a2fe527456e3746e1a3a3b582aaa2bd8b,false,false,,,,TOO_SHORT
1479938,0x2e0fca7f9d7e1fbe384a7128473dc1987ea089d6,false,false,,,,TOO_SHORT
1479949,0x137ecc7d6076037261513968c3298d83341acf2d,false,false,,,,TOO_SHORT
1480010,0x22491c83614b6765c1f634db3c6caa143fde6740,false,false,,,,TOO_SHORT
1480071,0x4935eb0231d802b7c519dd38f60bddc2e0406472,false,false,,,,TOO_SHORT
1480176,0x15e6ce8ddddfc0b520f636f0306cae9169578d4f,false,false,,,,TOO_SHORT
1480203,0x5ab7638a0a8554aca286b1931067128329754031,false,false,,,,TOO_SHORT
1480229,0x33eebbf565b69d42efece1208ac48738ab6341e9,false,false,,,,TOO_SHORT
1480305,0xa23d460269e986862dff7f7d7d46042d8ce106a4,false,false,,,,TOO_SHORT
1480343,0x4fc9fec2fd90c65e56d8cbc5274ffd895c757fb1,false,false,,,,TOO_SHORT
1480344,0x4908fe6a1db92a55b00f7f8020b0d78df4c65c83,false,false,,,,TOO_SHORT
1480419,0x0edb1b8210938bd36cf696d0c5d12e7d60bff8d1,false,false,,,,TOO_SHORT
1480465,0x8119d56dca28104c929f90d7aad0ae361bd072e9,false,false,,,,TOO_SHORT
1480470,0xe6ecbce477c5036e15910dec9c6d7be48f00d6dd,false,false,,,,TOO_SHORT
1480528,0x5247a3c7bde843c46a5c89144e308dbbe4f2a95f,false,false,,,,TOO_SHORT
1480531,0xa74168a56d02ce33cba14e5ca2f7af740313571d,false,false,,,,TOO_SHORT
1480591,0x2468160c241a9fed936ee1e3ceb8b2f7e2e01987,false,false,,,,TOO_SHORT
1480605,0x1e731df9b6a5d0ce73de1775e35c4e50f87961e9,false,false,,,,TOO_SHORT
1480648,0xe48f50091bea0559bedb22069571bc678ad330e6,false,false,,,,TOO_SHORT
1480842,0xc412e136956af3c158d8839def7b398d03f495d9,false,false,,,,TOO_SHORT
1480908,0xf9e03d5e3d86277574cfd5f7e842f213cf88945f,false,false,/* A contract to store only messages approved by owner */\ncontract self_store {\n\n    address owner;\n\n    uint16 public contentCount = 0;\n    \n    event content(string datainfo); \n    \n    function self_store() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() { if (msg.sender == owner) suicide(owner); }\n\n    function add(string datainfo) {\n        if (msg.sender != owner) return;\n        contentCount++;\n        content(datainfo);\n    }\n\n    function flush() {\n        owner.send(this.balance);\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1480971,0x85b021950450c0f42378f9daeea9f4b19b3d668f,false,false,,,,TOO_SHORT
1481022,0xfd39bd49ab3df4eda75a23807dab186d4902f924,false,false,/* A contract to store only messages approved by owner */\ncontract self_store {\n\n    address owner;\n\n    uint16 public contentCount = 0;\n    \n    event content(string datainfo);\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    function self_store() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo) onlyowner {\n        contentCount++;\n        content(datainfo);\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1481048,0x13a497fb3b06ede511c9b4644a0b45bbf486cd89,false,false,,,,TOO_SHORT
1481049,0xd3278c4d860775fb7f481256a30b8b1c8996df1d,false,false,,,,TOO_SHORT
1481101,0xa4bdc1f83b19b0fe38ab1dde1d4ba85cffca8679,false,false,,,,TOO_SHORT
1481174,0x537dbd7018faa1db4fc4f547236d09e239efcbcc,false,false,,,,TOO_SHORT
1481234,0x12c145ebf11bf0270207fff77cff1876d995bd6c,false,false,,,,TOO_SHORT
1481496,0x260972db3571a4297b9e0cfa237eabbc9c6e35ce,false,false,"/* A contract to exchange encrypted messages. Most of the work done on\n   the client side. */\n\ncontract comm_channel {\n	\n    address owner;\n    \n    event content(string datainfo, string senderKey, string recipientKey, uint amount);\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    function comm_channel() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo, string senderKey, string recipientKey,\n                 address resendTo) {\n        \n        //try to resend money from message to the address\n        if(msg.value > 0) {\n            if(!resendTo.send(msg.value)) throw;\n        }\n        \n        //write to blockchain\n        content(datainfo, senderKey, recipientKey, msg.value);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1481503,0x9d93b6b7c7ea36cd8b18bc3df4359112a5328656,false,false,,,,TOO_SHORT
1481648,0x9c9dc2b707a99ae4b6795538ac6bf4f6d4842830,false,false,"/* A contract to exchange encrypted messages. Most of the work done on\n   the client side. */\n\ncontract comm_channel {\n	\n    address owner;\n    \n    event content(string datainfo, string senderKey, string recipientKey, uint amount);\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    function comm_channel() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo, string senderKey, string recipientKey,\n                 address resendTo) {\n        \n        //try to resend money from message to the address\n        if(msg.value > 0) {\n            if(resendTo == 0) throw;\n            if(!resendTo.send(msg.value)) throw;\n        }\n        \n        //write to blockchain\n        content(datainfo, senderKey, recipientKey, msg.value);\n    }\n}",1,実用的なメッセージ交換コントラクトで、特に芸術的な要素は見られません。,
1481653,0x21045e06e2e2dbe8ef3722b22bfca38eefd35a90,false,false,,,,TOO_SHORT
1481674,0xeea0e87640c51ed02ff6bef5519444b4313caa38,false,false,,,,TOO_SHORT
1481698,0x1c94f41ab9cd8faa8af45ae7827bf5a8f891f4cd,false,false,"/* A contract to store a list of messages. Obtainable as events. */\n\ncontract store {\n\n    address owner;\n\n    uint16 public contentCount = 0;\n    \n    event content(string datainfo, address sender, uint payment);\n    modifier onlyowner { if (msg.sender == owner) _ } \n    \n    function store() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo) {\n        contentCount++;\n        content(datainfo, msg.sender, msg.value);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1481699,0x75b9aa512b777e348028f0b3ce7d34f60355b3f0,false,false,,,,TOO_SHORT
1481765,0x19cd85a6a0e962eaa54e88ef3404e6edc0efe9ca,false,false,,,,TOO_SHORT
1481766,0x40d79fe1a9cd6de7ffb5cd6cce8c8d49f9f651bd,false,false,,,,TOO_SHORT
1481946,0xc73df389cb25d2bd762ae1570c43909a0d75f94a,false,false,,,,TOO_SHORT
1482099,0x016f427db5b2c3b50aa5e1ea84cc7317b03e055c,false,false,,,,TOO_SHORT
1482131,0x39df860ed1b3bdb2d0904bf057e289c6a152eac3,false,false,,,,TOO_SHORT
1482262,0x72574ad39a43a151ccda0c518e47b105cb4af16e,false,false,,,,TOO_SHORT
1482313,0x730b38f30cbd53c91582a00ce296af8e8d1f265c,false,false,,,,TOO_SHORT
1482579,0x0329483fd85bb2853835faf57eda6365e5f2b329,false,false,,,,TOO_SHORT
1482766,0xdd8685bd056c4c4dfff9ef12e4345580e193354e,false,false,,,,TOO_SHORT
1482930,0x1467770c7d75fed61a325e71446c13ed35add49f,false,false,,,,TOO_SHORT
1482987,0x7e4a9bf26b5ea9e0e6a266c394f8ef9ff52b91b8,false,false,,,,TOO_SHORT
1483036,0x16ca71ee55a20b4d61cff66fe71a62822a740365,false,false,,,,TOO_SHORT
1483057,0x8d262f884ebd9102a08e6c6b05e1986170cbe58d,false,false,,,,TOO_SHORT
1483199,0x3f7a0ce4d30a8722b676f183be544d34cba711a5,false,false,,,,TOO_SHORT
1483398,0x4aa49ce2c2c8d0b922412e679b9d3b13ca075f43,false,false,,,,TOO_SHORT
1483868,0x4c9c8d8ae908a4ecefd4737152e5c43a2b5966e1,false,false,,,,TOO_SHORT
1483987,0x794114556025da192dda4380375d66c6d26102b2,false,false,,,,TOO_SHORT
1484449,0x710351a97d0bfaca3c48f56c42149efe543c7547,false,false,,,,TOO_SHORT
1484450,0x0e92fe01a1acc7d265efda62cc50dfe272687d43,false,false,,,,TOO_SHORT
1484652,0x61cd4aa3a28e918910dacdf5370dd5a0462a55bf,false,false,,,,TOO_SHORT
1484699,0x29a305cce7db2ae3446400d4e76f4011519f0872,false,false,,,,TOO_SHORT
1484703,0x273d44fb2f01fb80ed099ab01aa5c5fd086e659c,false,false,,,,TOO_SHORT
1484860,0x844a91796b8b0ebe87f1789b879a981631d758ab,false,false,,,,TOO_SHORT
1485035,0x364b055b4347a01b37c1eeba999509bac8da71b2,false,false,,,,TOO_SHORT
1485070,0x9f1090013cca697d17ac799d8ef24f955c89a183,false,false,,,,TOO_SHORT
1485187,0x4f91681b8192bbfbb525a22f0401f376f289116a,false,false,,,,TOO_SHORT
1485497,0x412548e6581ce7bd5139c59aac68804c3d396986,false,false,,,,TOO_SHORT
1485943,0x64eb9bee552c0cb9784c01bb1984fdd22f04a07a,false,false,,,,TOO_SHORT
1485954,0x1819c59ca38366a193c8fa02170f254fc9e942e0,false,false,,,,TOO_SHORT
1486133,0xc77d507d0cfb9a9166daf7c0d3258815a2d4a874,false,false,,,,TOO_SHORT
1486215,0xa0b1cdd02f83b6a2a00c724cc6bc22c2f83bfbfb,false,false,,,,TOO_SHORT
1486222,0x85d395522680ff0ba0bda5ad079d317554b203ea,false,false,,,,TOO_SHORT
1486312,0x8bb2e2369f9ec8f87b73e24c7a7997272a358d11,false,false,,,,TOO_SHORT
1486360,0x33cfc80d79bff3ed161575ae56d2e8b9eaca5e30,false,false,,,,TOO_SHORT
1486497,0xae39c96da24ea1ac556c908394eba62c37af5ccf,false,false,,,,TOO_SHORT
1486700,0x8190b57bbb0c5fd3c6bf426718e81befbf8d5842,false,false,,,,TOO_SHORT
1486754,0xc7ad6fe98e80d9e7d81987c75e6da0ef997dc730,false,false,,,,TOO_SHORT
1486869,0xfbdbd89beb290f3c4265e368f44c4fbc2dd4abfb,false,false,,,,TOO_SHORT
1486949,0x0bc02896e95dec01d3999565bf9c0d360b293ac8,false,false,,,,TOO_SHORT
1486951,0x3728a5907e547a786308e6fd32aa0726366c5f41,false,false,,,,TOO_SHORT
1487063,0x365a92e97e2802e0f5d74ff285472e8e236a892e,false,false,,,,TOO_SHORT
1487082,0x5e6a4893ce8583bd1a7347ebaa6f48d65951fd90,false,false,,,,TOO_SHORT
1487096,0xe544372329517545fd6004a43612c3508e2edb59,false,false,,,,TOO_SHORT
1487195,0x8b4aa759d83ec43efba755fc27923e4a581bccc1,false,false,"contract BlockChainChallenge {\n    \n  address admin;\n  address leader;\n  bytes32 leaderHash;\n  bytes32 difficulty;\n  bytes32 difficultyWorldRecord;\n  uint fallenLeaders;\n  uint startingTime;\n  uint gameLength;\n  string leaderMessage;\n  string defaultLeaderMessage;\n  mapping (address => uint) winners;\n  \n  event Begin(string log);\n  event Leader(string log, address newLeader, bytes32 newHash);\n  event GameOver(string log);\n  event Winner (string log, address winner);\n  event NoWinner (string log);\n  event WorldRecord (string log, bytes32 DifficultyRecord, address RecordHolder);\n  \n  function BlockChainChallenge(){ \n      \n    //Admin Backdoor\n    admin = msg.sender;\n\n    //Starting Time\n    startingTime = block.timestamp;\n    \n    //Game Length (TODO: Change to 1 weeks)\n    gameLength = 1 weeks;\n\n    //Initial seed for the first challenge. This should always be in rotation afterward.\n    leaderHash = sha3(""09F911029D74E35BD84156C5635688C0"");\n\n    //First leader is the creator of the contract\n    leader = msg.sender;\n\n    //The placeholder leader message\n    defaultLeaderMessage = ""If you're this weeks leader, you own this field. Write a message here."";\n    leaderMessage = defaultLeaderMessage;\n    \n    //This difficulty starts as easy as possible. Any XOR will be less, to start.\n    difficulty = leaderHash;\n    \n    //Seed the world record\n    difficultyWorldRecord = leaderHash;\n    \n    //Counter for successful collisions this week.\n    fallenLeaders = 0;\n\n    Begin(""Collide the most bits of the leader's hash to replace the leader. Leader will win any bounty at the end of the week."");\n\n  }\n  \n  function reset() private{\n      \n      //Make the hash unpredictable.\n      leaderHash = sha3(block.timestamp);\n      \n      //Reset the leader message\n      leaderMessage = defaultLeaderMessage;\n      difficulty = leaderHash;\n      leader = admin;\n      fallenLeaders = 0;\n  }\n  \n  function checkDate() private returns (bool success) {\n      \n      //Are we one week beyond the last game? TODO change time for mainnet\n      if (block.timestamp > (startingTime + gameLength)) {\n          \n          //If so, log winner. If the admin ""wins"", it's because no one else won.\n          if(leader != admin){\n            Winner(""Victory! Game will be reset to end in 1 week (in block time)."", leader);\n            leader.send(this.balance);\n          }else NoWinner(""No winner! Game will be reset to end in 1 week (in block time)."");\n\n          startingTime = block.timestamp;\n\n          //Reset\n          reset();\n          return true;\n      }\n      return false;\n  }\n\n  function overthrow(string challengeData) returns (bool success){\n        \n        //Create hash from player data sent to contract\n        var challengeHash = sha3(challengeData);\n\n        //Check One: Submission too late, reset game w/ new hash\n        if(checkDate())\n            return false;\n        \n        //Check Two: Cheating - of course last hash will collide!\n        if(challengeHash == leaderHash)\n            return false;\n\n        //Check Three: Core gaming logic favoring collisions of MSB\n        if((challengeHash ^ leaderHash) > difficulty)\n          return false;\n\n        //If player survived the checks, they've overcome difficulty level and beat the leader.\n        //Update the difficulty. This makes the game progressively harder through the week.\n        difficulty = (challengeHash ^ leaderHash);\n        \n        //Did they set a record?\n        challengeWorldRecord(difficulty);\n        \n        //We have a new Leader\n        leader = msg.sender;\n        \n        //The winning hash is our new hash. This undoes any work being done by competition!\n        leaderHash = challengeHash;\n        \n        //Announce our new victor. Congratulations!    \n        Leader(""New leader! This is their address, and the new hash to collide."", leader, leaderHash);\n        \n        //Add to historical Winners\n        winners[msg.sender]++;\n        \n        //Keep track of how many new leaders we've had this week.\n        fallenLeaders++;\n        \n        return true;\n  }\n  \n  function challengeWorldRecord (bytes32 difficultyChallenge) private {\n      if(difficultyChallenge < difficultyWorldRecord) {\n        difficultyWorldRecord = difficultyChallenge;\n        WorldRecord(""A record setting collision occcured!"", difficultyWorldRecord, msg.sender);\n      }\n  }\n  \n  function changeLeaderMessage(string newMessage){\n        //The leader gets to talk all kinds of shit. If abuse, might remove.\n        if(msg.sender == leader)\n            leaderMessage = newMessage;\n  }\n  \n  //The following functions designed for mist UI\n  function currentLeader() constant returns (address CurrentLeaderAddress){\n      return leader;\n  }\n  function Difficulty() constant returns (bytes32 XorMustBeLessThan){\n      return difficulty;\n  }\n  function TargetHash() constant returns (bytes32 leadingHash){\n      return leaderHash;\n  }\n  function LeaderMessage() constant returns (string MessageOfTheDay){\n      return leaderMessage;\n  }\n  function FallenLeaders() constant returns (uint Victors){\n      return fallenLeaders;\n  }\n  function GameEnds() constant returns (uint EndingTime){\n      return startingTime + gameLength;\n  }\n  function getWins(address check) constant returns (uint wins){\n      return winners[check];\n  }\n\n  function kill(){\n      if (msg.sender == admin){\n        GameOver(""The challenge has ended."");\n        selfdestruct(admin);\n      }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックが中心で芸術性は低い。,
1487260,0x66a246523c4a3ea4724fbfdbabcbda2bf5dd4904,false,false,,,,TOO_SHORT
1487306,0x1ea2dbd76a015d2fc2a4db3fde2737e2828d0265,false,false,,,,TOO_SHORT
1487351,0xd057e771bf1628c09bf5d15771880fbc27388c04,false,false,,,,TOO_SHORT
1487358,0x62042e83512dafa0da9c4dc64061a41e9f97c6db,false,false,,,,TOO_SHORT
1487383,0x8f77df941c0a6a47e57b48afd3c93e0083e28c15,false,false,,,,TOO_SHORT
1487503,0xe405a77291b7917f9509bf72d5ea723dd24bc944,false,false,,,,TOO_SHORT
1487507,0x706eba7870e06c5bef70371d2e389dfafcd5cf63,false,false,,,,TOO_SHORT
1487545,0x0318179601a70085aeb488f178b081295b65ecc9,false,false,"contract self_store {\n\n    address owner;\n\n    uint public contentCount = 0;\n    \n    event content(string datainfo, uint indexed version);\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    function self_store() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo, uint version) onlyowner {\n        contentCount++;\n        content(datainfo, version);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1487548,0x7fe4cb9202e238082f15cb75ba9abff3bd074b60,false,false,,,,TOO_SHORT
1487549,0x30d8abea85ffbe35f08c72b197a0878c165be790,false,false,,,,TOO_SHORT
1487566,0xf236d15aa8164626e3457cd38e69d7f46f95eeb9,false,false,"contract comm_channel {\n	\n    address owner;\n    \n    event content(string datainfo, uint indexed version, string indexed senderKey, string indexed recipientKey, uint amount);\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    function comm_channel() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo, uint version, string senderKey, string recipientKey,\n                 address resendTo) {\n        \n        //try to resend money from message to the address\n        if(msg.value > 0) {\n            if(resendTo == 0) throw;\n            if(!resendTo.send(msg.value)) throw;\n        }\n        \n        //write to blockchain\n        content(datainfo, version, senderKey, recipientKey, msg.value);\n    }\n}",1,基本的な機能を持つ実用的なスマートコントラクトで、特に芸術的要素はない。,
1487596,0x8bd539d38d8f9f3e5f937c6146befc675c7758a9,false,false,,,,TOO_SHORT
1487700,0xd39fe1cffd8f070429169b416b7e07f486d553cf,false,false,"contract store {\n\n    address owner;\n\n    uint public contentCount = 0;\n    \n    event content(string datainfo, uint indexed version, address indexed sender, uint indexed datatype, uint timespan, uint payment);\n    modifier onlyowner { if (msg.sender == owner) _ } \n    \n    function store() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo, uint version, uint datatype, uint timespan) {\n        //item listing\n        if(datatype == 1) {\n          //2 weeks listing costs 0,04 USD = 0,004 ether\n          if(timespan <= 1209600) {\n            if(msg.value < (4 finney)) return;\n          //4 weeks listing costs 0,06 USD = 0,006 ether\n          } else if(timespan <= 2419200) {\n            if(msg.value < (6 finney)) return;\n          //limit 4 weeks max\n          } else {\n            timespan = 2419200;\n            if(msg.value < (6 finney)) return;\n          }\n        }\n\n        //revert higher payment transactions\n        if(msg.value > (6 finney)) throw;\n\n        contentCount++;\n        content(datainfo, version, msg.sender, datatype, timespan, msg.value);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1487730,0x7032dbd9c995e033ab0b018383a57a6b50bf97e9,false,false,,,,TOO_SHORT
1487858,0xed111b1685e186f4c178720655ad470a6b4f7c51,false,false,,,,TOO_SHORT
1488068,0xfdbbf02ae204e6df593c474ec570f2679e74a1ac,false,false,,,,TOO_SHORT
1488123,0x82e9a463b97953dfbbc0ba7cc29a92c75c432f98,false,false,,,,TOO_SHORT
1488126,0xc61f80b9f6a7db2fad81ad7d36d70f3bbf2dd9a9,false,false,,,,TOO_SHORT
1488184,0xe580f0abaa3632d22e2a60aeb5c12f32abb300dc,false,false,,,,TOO_SHORT
1488194,0x5ab28ae27d4e5fc0df6fb0d497381b02c279463c,false,false,,,,TOO_SHORT
1488348,0x23b974ded62bf3c7c313219b160abe1828706c67,false,false,,,,TOO_SHORT
1488365,0x25eafc0e292164a36f371e883bb35e86c978ff45,false,false,,,,TOO_SHORT
1488722,0x7f5b996d7388b381af61c3d7c2a71ffd706649ef,false,false,,,,TOO_SHORT
1488797,0x579e735c34a46e4ddf40e5b4d65c3873fcddc713,false,false,,,,TOO_SHORT
1488874,0xa409c32098c099f43c528406412c51101bf40690,false,false,,,,TOO_SHORT
1488982,0xd197b89b4d4e2a81f84917e954ec78f9c69740d0,false,false,,,,TOO_SHORT
1489541,0x9cac5f4b373c229733133df1f85fc56729d0f2ff,false,false,,,,TOO_SHORT
1489707,0x9f63dd1cf5c7b63c85f971128deaf1510a630348,false,false,,,,TOO_SHORT
1490019,0xd6ada55eb9e4cbd82aa7a692b81fcd8bfe3b1b95,false,false,,,,TOO_SHORT
1490043,0xe6057e88d3effbe3831ee67d18f206692e9563dc,false,false,"contract Ambi {\n    function getNodeAddress(bytes32) constant returns (address);\n    function addNode(bytes32, address) external returns (bool);\n    function hasRelation(bytes32, bytes32, address) constant returns (bool);\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract ElcoinDb {\n    address owner;\n    address caller;\n\n    event Transaction(bytes32 indexed hash, address indexed from, address indexed to, uint time, uint amount);\n\n    modifier checkOwner() { _ }\n    modifier checkCaller() { _ }\n    mapping (address => uint) public balances;\n\n    function ElcoinDb(address pCaller) {\n        owner = msg.sender;\n        caller = pCaller;\n    }\n\n    function getOwner() constant returns (address rv) {\n        return owner;\n    }\n\n    function getCaller() constant returns (address rv) {\n        return caller;\n    }\n\n    function setCaller(address pCaller) checkOwner() returns (bool _success) {\n        caller = pCaller;\n\n        return true;\n    }\n\n    function setOwner(address pOwner) checkOwner() returns (bool _success) {\n        owner = pOwner;\n\n        return true;\n    }\n\n    function getBalance(address addr) constant returns(uint balance) {\n        return balances[addr];\n    }\n\n    function deposit(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\n        balances[addr] += amount;\n        Transaction(hash, 0, addr, time, amount);\n\n        return true;\n    }\n\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\n        uint oldBalance = balances[addr];\n        if (oldBalance >= amount) {\n            balances[addr] = oldBalance - amount;\n            Transaction(hash, addr, 0, time, amount);\n            return true;\n        }\n\n        return false;\n    }\n}\n\ncontract ElcoinInterface {\n    function rewardTo(address _to, uint _amount) returns (bool);\n}\n\ncontract PotRewards is AmbiEnabled {\n\n    event Reward(address indexed beneficiary, uint indexed round, uint value, uint position);\n\n    struct Transaction {\n        address from;\n        uint amount;\n    }\n\n    uint public round = 0;\n    uint public counter = 0;            //counts each transaction\n    Transaction[] public transactions;  //records details of txns participating in next auction round\n\n    //parameters\n    uint public periodicity;        //how often does an auction happen (ie. each 10000 tx)\n    uint8 public auctionSize;       //how many transactions participate in auction\n    uint public prize;              //total amount of prize for each round\n    uint public minTx;              //transactions less than this amount will not be counted\n    uint public startTime;          //starting at startTime to calculate double rewards\n\n    ElcoinInterface public elcoin;  //contract to do rewardTo calls\n\n    function configure(uint _periodicity, uint8 _auctionSize, uint _prize, uint _minTx, uint _counter, uint _startTime) checkAccess(""owner"") returns (bool) {\n        if (_auctionSize > _periodicity || _prize == 0 || _auctionSize > 255) {\n            return false;\n        }\n        periodicity = _periodicity;\n        auctionSize = _auctionSize;\n        prize = _prize;\n        minTx = _minTx;\n        counter = _counter;\n        startTime = _startTime;\n        elcoin = ElcoinInterface(getAddress(""elcoin""));\n        return true;\n    }\n\n    function transfer(address _from, address _to, uint _amount) checkAccess(""elcoin"") {\n        if (startTime > now || periodicity == 0 || auctionSize == 0 || prize == 0) {\n            return;\n        }\n        counter++;\n        if (_amount >= minTx && counter > periodicity - auctionSize) {\n            transactions.push(Transaction(_from, _amount));\n        }\n\n        if (counter >= periodicity) {\n            _prepareAndSendReward();\n            counter = 0;\n            round++;\n            delete transactions;\n        }\n    }\n\n    mapping(uint => mapping(address => uint)) public prizes;\n\n    function _prepareAndSendReward() internal {\n        uint amount = 0;\n        address[] memory winners = new address[](auctionSize);\n        uint winnerPosition = 0;\n        for (uint8 i = 0; i < transactions.length; i++) {\n            if (transactions[i].amount == amount) {\n                winners[winnerPosition++] = transactions[i].from;\n            }\n            if (transactions[i].amount > amount) {\n                amount = transactions[i].amount;\n                winnerPosition = 0;\n                winners[winnerPosition++] = transactions[i].from;\n            }\n        }\n        if (winnerPosition == 0) {\n            return;\n        }\n        address[] memory uniqueWinners = new address[](winnerPosition);\n        uint uniqueWinnerPosition = 0;\n        uint currentPrize = _is360thDay() ? prize*2 : prize;\n        uint reward = currentPrize / winnerPosition;\n        for (uint8 position = 0; position < winnerPosition; position++) {\n            address winner = winners[position];\n            if (prizes[round][winner] == 0) {\n                uniqueWinners[uniqueWinnerPosition++] = winner;\n            }\n            prizes[round][winner] += reward;\n        }\n        for (position = 0; position < uniqueWinnerPosition; position++) {\n            winner = uniqueWinners[position];\n            uint winnerReward = prizes[round][winner];\n            if (elcoin.rewardTo(winner, winnerReward)) {\n                Reward(winner, round, winnerReward, position);\n            }\n        }\n    }\n\n    function _is360thDay() internal constant returns(bool) {\n        if (startTime > now) {\n            return false;\n        }\n\n        return (((now - startTime) / 1 days) + 1) % 360 == 0;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1490240,0x1da6c691ecd82cad9faaaa73050b4085a6ff042f,false,false,,,,TOO_SHORT
1490505,0x0909a635fa6cb9c2181c28b72e394fb49534c0a6,false,false,,,,TOO_SHORT
1490871,0xde9f8af866f8d30ae80dce98c6fd19f4bafe2d14,false,false,,,,TOO_SHORT
1490906,0x432094fecd29a9c9819bc5064a778f7809c77aec,false,false,,,,TOO_SHORT
1491062,0xfc62abb5f85b041ac301bbd98d2a4b1b94186665,false,false,,,,TOO_SHORT
1491199,0x43244a99469174a13cc7ea7799614c7672bd75ee,false,false,,,,TOO_SHORT
1491358,0xcf1917b64cc6ed896d31688bb92e91619336e496,false,false,,,,TOO_SHORT
1491452,0xae0e48d4787af5e855fefefac8b095756f6ada62,false,false,,,,TOO_SHORT
1491585,0x6a18d20732dd289120b61b07326f4f6eb924e0ad,false,false,,,,TOO_SHORT
1491731,0xf32133557a7773580ecc78cc4652f201bb1a9d45,false,false,,,,TOO_SHORT
1492117,0x2f15e660baad135c90bd55bce43939b3df97c598,false,false,,,,TOO_SHORT
1492199,0xcb4f95811c6f37830dede8786f66ed3beda38632,false,false,,,,TOO_SHORT
1492220,0xd67f1e0fe2c7b294b838970e6d86c2a7aeb7cead,false,false,,,,TOO_SHORT
1492221,0x99870f50f16a8b78bd2e96f36609c41a37ea3ea3,false,false,,,,TOO_SHORT
1492387,0xfa99426eb1c8aa0776c6965e2d44c9cf7c526b05,false,false,,,,TOO_SHORT
1492445,0xbbb51b4e07cf2885e5dd214b84cb28f8fcd64c32,false,false,,,,TOO_SHORT
1492573,0x490cbcfd229cb35a08ccf8427b631a04c457344f,false,false,,,,TOO_SHORT
1492639,0x726ae131d6c118bed75ecd9beab0d7181fc44071,false,false,,,,TOO_SHORT
1492673,0xc5a5716596cb8ee47f20c11169ee3bbfe9c3e3d0,false,false,,,,TOO_SHORT
1492778,0xa9af2627c054a7a25d93217728ad3b05fcffd41b,false,false,,,,TOO_SHORT
1492782,0x3afad03851026120b6716e588d0c46cc6f1a21bc,false,false,,,,TOO_SHORT
1492903,0x3e4447db2b33e3e3319116fdbf286ad0c8a51d15,false,false,,,,TOO_SHORT
1492925,0xcdbcb69131852bb2dc31bc54c70809e2c01b5b88,false,false,,,,TOO_SHORT
1493035,0x64ae5980068527c5f69d5443b041e1afeb536ba5,false,false,,,,TOO_SHORT
1493381,0x605f9d932f60d13597637ce629b8bea0f143ec3a,false,false,,,,TOO_SHORT
1493731,0x8701d4e0d9685450b4408ab6fcaaa9146d7609e6,false,false,,,,TOO_SHORT
1493794,0x11fae3fbedc9babcf8ca4a2f8cb35d9afb468a48,false,false,,,,TOO_SHORT
1493846,0xa20f4b24d196f49d4ea103fa2733a70aad4d328d,false,false,,,,TOO_SHORT
1493852,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3,false,false,"/* A contract to store a state of goods (single item). Buy orders obtainable as events. */\n\n/* Deployment:\n*/\n\ncontract goods {\n\n    address public owner;\n    //status of the goods: Available, Pending, Sold, Canceled\n    uint16 public status;\n    //how many for sale\n    uint16 public count;\n    //price per item\n    uint public price;\n\n    uint16 public availableCount;\n    uint16 public pendingCount;\n\n    event log_event(string message);\n    event content(string datainfo, uint indexed version, uint indexed datatype, address indexed sender, uint count, uint payment);\n    modifier onlyowner { if (msg.sender == owner) _ } \n    \n    function goods(uint16 _count, uint _price) {\n        owner = msg.sender;\n        //status = Available\n        status = 1;\n        count = _count;\n        price = _price;\n\n        availableCount = count;\n        pendingCount = 0;\n    }\n    \n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function log(string message) private {\n        log_event(message);\n    }\n\n    function buy(string datainfo, uint _version, uint16 _count) {\n        if(status != 1) { log(""status != 1""); throw; }\n        if(msg.value < (price * _count)) { log(""msg.value < (price * _count)""); throw; }\n        if(_count > availableCount) { log(""_count > availableCount""); throw; }\n\n        pendingCount += _count;\n\n        //Buy order to event log\n        content(datainfo, _version, 1, msg.sender, _count, msg.value);\n    }\n\n    function accept(string datainfo, uint _version, uint16 _count) onlyowner {\n        if(_count > availableCount) { log(""_count > availableCount""); return; }\n        if(_count > pendingCount) { log(""_count > pendingCount""); return; }\n        \n        pendingCount -= _count;\n        availableCount -= _count;\n\n        //Accept order to event log\n        content(datainfo, _version, 2, msg.sender, _count, 0);\n    }\n\n    function reject(string datainfo, uint _version, uint16 _count, address recipient, uint amount) onlyowner {\n        if(_count > pendingCount) { log(""_count > pendingCount""); return; }\n\n        pendingCount -= _count;\n        //send money back\n        recipient.send(amount);\n\n        //Reject order to event log\n        content(datainfo, _version, 3, msg.sender, _count, amount);\n    }\n\n    function cancel(string datainfo, uint _version) onlyowner {\n        //Canceled status\n        status = 2;\n\n        //Cancel order to event log\n        content(datainfo, _version, 4, msg.sender, availableCount, 0);\n    }\n}",1,実用的なコードで、商品管理を目的とした標準的なスマートコントラクトです。,
1493857,0x187fc330bba61fa126478ea24d0eb802c1f96a4b,false,false,,,,TOO_SHORT
1493926,0xf5e81520b8c3ee9e0e6f42bf7b7235ee72f27194,false,false,,,,TOO_SHORT
1494018,0xc630be1a80a38e2832a6614415ae3bd3000891a9,false,false,,,,TOO_SHORT
1494290,0xce1f2c3139dae247bdd916056cb7c244defc8dd6,false,false,,,,TOO_SHORT
1494508,0xafd027f5526d1473c4184b18a33a9e41b480a9c2,false,false,,,,TOO_SHORT
1494797,0x60a4180ea307958be99808af5654e735501ef205,false,false,,,,TOO_SHORT
1494891,0xb26188c3b0f2c0fb3abebfbb63163a07288d5c19,false,false,,,,TOO_SHORT
1495234,0x4e9ddec546c53cf2d2c41475856f55815c8fbd5b,false,false,,,,TOO_SHORT
1495288,0x387cd02468ec67c3e2d4f3da74f0cfb00220b71f,false,false,,,,TOO_SHORT
1495332,0x2fa7ad64b7578ae8cdc40330433a2cfec0886fbf,false,false,,,,TOO_SHORT
1495621,0xfe009aa9cbaeaf63e9d43a24b69a50c5b10b119f,false,false,,,,TOO_SHORT
1495677,0xc1105a4bb246bdcf451a6d8c06919e4efdadc5f4,false,false,,,,TOO_SHORT
1495780,0x8386ebcefe557cf06bbff8e23aad701ea43ac76e,false,false,,,,TOO_SHORT
1495788,0xc85f3d5fd730da4705599e11c67dcbfb87d5bc95,false,false,,,,TOO_SHORT
1495831,0x101e90d434f24c4ee3895194e2e5335c0a822f19,false,false,,,,TOO_SHORT
1496127,0xd1abefbf572ee2ab93c838ec2f6676cefb5d9072,false,false,,,,TOO_SHORT
1496348,0x0274b83d25d96ce2b858e8f3b6f7103097a7c54a,false,false,,,,TOO_SHORT
1496364,0x0492c17787d2a7fb594c73f84a3ff13d1600432c,false,false,,,,TOO_SHORT
1496621,0xa5cdd7eb18b60e93e21e5bdb022d4f353a4c5630,false,false,,,,TOO_SHORT
1496682,0x988c0073bdc518bc2a227746df2a0d56632307a7,false,false,,,,TOO_SHORT
1496816,0xc43bb00b3978b54634959833beeab9e7f0e21a45,false,false,,,,TOO_SHORT
1496863,0xc60f68cd6b3c99aa38d263ff9273ebcc2f920c7c,false,false,,,,TOO_SHORT
1496889,0x371c7d28d6179db313639795c147136cf7f0ce4d,false,false,,,,TOO_SHORT
1497067,0x9cfcb2639b17ee8ad219f340681e9bebe620183b,false,false,,,,TOO_SHORT
1497133,0x09c4acac033e444ecff74c49a67b52ff310c8123,false,false,,,,TOO_SHORT
1497304,0x857089d6e52df40743d8e3b2e25e64d57f7d9c93,false,false,,,,TOO_SHORT
1497372,0x1fb0a5b9336653583df75213730199b915bb1ba2,false,false,,,,TOO_SHORT
1497392,0x8ba1faeeb9724e66aa4004582618406ae7b8ce99,false,false,,,,TOO_SHORT
1497405,0x9682a6eda1c9d4103b62db4864f26f99c31bd129,false,false,,,,TOO_SHORT
1497408,0x63ec63d6cd7ab8032f304e6a2d353730c4b553a7,false,false,,,,TOO_SHORT
1497449,0x131e9d1516265ebe5719aa12204004520769710c,false,false,,,,TOO_SHORT
1497713,0xd1cab679ecd8e5bb8f48a12ccf856b43175f95f1,false,false,,,,TOO_SHORT
1497912,0x48be7bf63b8a92daff7fcf67d17a6d3c9b99f245,false,false,,,,TOO_SHORT
1497914,0x458e7ba0ed45b4557101fed7be89b04c21f34507,false,false,,,,TOO_SHORT
1497917,0x73103f7bb7b505d4989bac8066f8ec7fce8866dd,false,false,,,,TOO_SHORT
1498006,0x03e67784f23b7b77f3f8b345068ae0eee8000c6f,false,false,,,,TOO_SHORT
1498041,0xfb0efd6d69c0921cf1863fc5a62ab90f4b4836c9,false,false,,,,TOO_SHORT
1498181,0xfeeb8a968f0d7fd58e29fbfc525051f50ee2fedc,false,false,"contract Etheramid1{\n	function getParticipantById (uint id) constant public returns ( address inviter, address itself, uint totalPayout );\n	function getParticipantCount () public constant returns ( uint count );\n}\ncontract Etheramid2 {\n\n    struct Participant {\n        address inviter;\n        address itself;\n        uint totalPayout;\n    }\n    \n    mapping (address => Participant) Tree;\n    mapping (uint => address) Index;\n	\n	uint Count = 0;\n    address public top;\n    uint constant contribution = 1 ether;\n	\n 	Etheramid1 eth1 = Etheramid1(0x9758DA9B4D001Ed2d0DF46d25069Edf53750767a);\n	uint oldUserCount = eth1.getParticipantCount();\n	\n    function Etheramid2() {\n		moveOldUser(0);\n		top = Index[0];\n    }\n    \n    function() {\n		throw;\n    }\n    \n	function moveOldUser (uint id) public {\n		address inviter; \n		address itself; \n		uint totalPayout;\n		(inviter, itself, totalPayout) = eth1.getParticipantById(id);\n		if ((Tree[itself].inviter != 0x0) || (id >= oldUserCount)) throw;\n		addParticipant(inviter, itself, totalPayout);\n	}\n	\n    function getParticipantById (uint id) constant public returns ( address inviter, address itself, uint totalPayout ){\n		if (id >= Count) throw;\n		address ida = Index[id];\n        inviter = Tree[ida].inviter;\n        itself = Tree[ida].itself;\n        totalPayout = Tree[ida].totalPayout;\n    }\n	\n	function getParticipantByAddress (address adr) constant public returns ( address inviter, address itself, uint totalPayout ){\n		if (Tree[adr].itself == 0x0) throw;\n        inviter = Tree[adr].inviter;\n        itself = Tree[adr].itself;\n        totalPayout = Tree[adr].totalPayout;\n    }\n    \n    function addParticipant(address inviter, address itself, uint totalPayout) private{\n        Index[Count] = itself;\n		Tree[itself] = Participant( {itself: itself, inviter: inviter, totalPayout: totalPayout});\n        Count +=1;\n    }\n    \n    function getParticipantCount () public constant returns ( uint count ){\n       count = Count;\n    }\n    \n    function enter(address inviter) public {\n        uint amount = msg.value;\n        if ((amount < contribution) || (Tree[msg.sender].inviter != 0x0) || (Tree[inviter].inviter == 0x0)) {\n            msg.sender.send(msg.value);\n            throw;\n        }\n        \n        addParticipant(inviter, msg.sender, 0);\n        address next = inviter;\n        uint rest = amount;\n        uint level = 1;\n        while ( (next != top) && (level < 7) ){\n            uint toSend = rest/2;\n            next.send(toSend);\n            Tree[next].totalPayout += toSend;\n            rest -= toSend;\n            next = Tree[next].inviter;\n            level++;\n        }\n        next.send(rest);\n		Tree[next].totalPayout += rest;\n    }\n}",1,実用的な構造で、参加者管理と支払いを行う標準的なスマートコントラクトです。,
1498288,0xfe1a96cd0bfb3245d83808b9aba6538576145920,true,false,"contract Ambi {\n    function getNodeAddress(bytes32 _name) constant returns (address);\n    function addNode(bytes32 _name, address _addr) external returns (bool);\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\n}\n\ncontract PotRewards {\n    function transfer(address _from, address _to, uint _amount);\n}\n\ncontract PosRewards {\n    function transfer(address _from, address _to);\n}\n\ncontract ElcoinInterface {\n    function rewardTo(address _to, uint _amount) returns (bool);\n}\n\ncontract EtherTreasuryInterface {\n    function withdraw(address _to, uint _value) returns(bool);\n}\n\ncontract MetaCoinInterface {\n	event Transfer(address indexed _from, address indexed _to, uint256 _value);\n	event Approved(address indexed _owner, address indexed _spender, uint256 _value);\n	event Unapproved(address indexed _owner, address indexed _spender);\n\n	function totalSupply() constant returns (uint256 supply){}\n	function balanceOf(address _owner) constant returns (uint256 balance){}\n	function transfer(address _to, uint256 _value) returns (bool success){}\n	function transferFrom(address _from, address _to, uint256 _value) returns (bool success){}\n	function approve(address _spender, uint256 _value) returns (bool success){}\n	function unapprove(address _spender) returns (bool success){}\n	function allowance(address _owner, address _spender) constant returns (uint256 remaining){}\n}\n\ncontract ElcoinDb {\n    function getBalance(address addr) constant returns(uint balance);\n    function deposit(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract Elcoin is AmbiEnabled, MetaCoinInterface {\n\n    event Error(uint8 indexed code, address indexed origin, address indexed sender);\n\n    mapping (address => uint) public recoveredIndex;\n    address[] public recovered;\n\n    uint public totalSupply;\n    uint public absMinFee; // set up in 1/1000000 of Elcoin\n    uint public feePercent; // set up in 1/100 of percent, 10 is 0.1%\n    uint public absMaxFee; // set up in 1/1000000 of Elcoin\n    address public feeAddr;\n\n    function Elcoin() {\n        recovered.length++;\n        feeAddr = tx.origin;\n        _setFeeStructure(0, 0, 1);\n    }\n\n    function _db() internal constant returns (ElcoinDb) {\n        return ElcoinDb(getAddress(""elcoinDb""));\n    }\n\n    function _setFeeStructure(uint _absMinFee, uint _feePercent, uint _absMaxFee) internal returns (bool) {\n        if(_absMinFee < 0 || _feePercent < 0 || _feePercent > 10000 || _absMaxFee < 0 || _absMaxFee < _absMinFee) {\n            Error(1, tx.origin, msg.sender);\n            return false;\n        }\n        absMinFee = _absMinFee;\n        feePercent = _feePercent;\n        absMaxFee = _absMaxFee;\n        return true;\n    }\n\n    function _rawTransfer(ElcoinDb _db, address _from, address _to, uint _value) internal {\n        _db.withdraw(_from, _value, 0, 0);\n        uint fee = calculateFee(_value);\n        uint net = _value - fee;\n        _db.deposit(_to, net, 0, 0);\n\n        Transfer(_from, _to, _value);\n        if (fee > 0) {\n            _db.deposit(feeAddr, fee, 0, 0);\n        }\n    }\n\n    function _transfer(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\n        if (_value < absMinFee) {\n            return false;\n        }\n        if (_from == _to) {\n            return false;\n        }\n        uint balance = _db.getBalance(_from);\n\n        if (balance < _value) {\n            return false;\n        }\n        _rawTransfer(_db, _from, _to, _value);\n\n        return true;\n    }\n\n    function _transferWithReward(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\n        if (!_transfer(_db, _from, _to, _value)) {\n            Error(2, tx.origin, msg.sender);\n            return false;\n        }\n\n        address pos = getAddress(""elcoinPoS"");\n        address pot = getAddress(""elcoinPoT"");\n        if (pos != 0x0) {\n            PosRewards(pos).transfer(_from, _to);\n        }\n        if (pot != 0x0) {\n            PotRewards(pot).transfer(_from, _to, _value);\n        }\n        return true;\n    }\n\n    function _recoverAccount(ElcoinDb _db, address _old, address _new) internal returns (bool) {\n        uint pos =  recovered.length++;\n        recovered[pos] = _old;\n        recoveredIndex[_old] = pos;\n        uint balance = _db.getBalance(_old);\n        var rv = _db.withdraw(_old, balance, 0, 0);\n        if (!rv) {\n            Error(5, tx.origin, msg.sender);\n            return false;\n        }\n        _db.deposit(_new, balance, 0, 0);\n\n        return true;\n    }\n\n    modifier notRecoveredAccount(address _account) {\n        if(recoveredIndex[_account] == 0x0) {\n            _\n        }\n        else {\n            return;\n        }\n    }\n\n    function balanceOf(address _account) constant returns (uint) {\n        return _db().getBalance(_account);\n    }\n\n    function calculateFee(uint _amount) constant returns (uint) {\n        uint fee = (_amount * feePercent) / 10000;\n\n        if (fee < absMinFee) {\n            return absMinFee;\n        }\n\n        if (fee > absMaxFee) {\n            return absMaxFee;\n        }\n\n        return fee;\n    }\n\n    function issueCoin(address _to, uint _value, uint _totalSupply) checkAccess(""currencyOwner"") returns (bool) {\n        if (totalSupply > 0) {\n            Error(6, tx.origin, msg.sender);\n            return false;\n        }\n\n        bool dep = _db().deposit(_to, _value, 0, 0);\n        totalSupply = _totalSupply;\n        return dep;\n    }\n\n    function batchTransfer(address[] _to, uint[] _value) checkAccess(""currencyOwner"") returns (bool) {\n        if (_to.length != _value.length) {\n            Error(7, tx.origin, msg.sender);\n            return false;\n        }\n\n        uint totalToSend = 0;\n        for (uint8 i = 0; i < _value.length; i++) {\n            totalToSend += _value[i];\n        }\n\n        ElcoinDb db = _db();\n        if (db.getBalance(msg.sender) < totalToSend) {\n            Error(8, tx.origin, msg.sender);\n            return false;\n        }\n\n        db.withdraw(msg.sender, totalToSend, 0, 0);\n        for (uint8 j = 0; j < _to.length; j++) {\n            db.deposit(_to[j], _value[j], 0, 0);\n            Transfer(msg.sender, _to[j], _value[j]);\n        }\n\n        return true;\n    }\n\n    function transfer(address _to, uint _value) returns (bool) {\n        uint startGas = msg.gas + transferCallGas;\n        if (!_transferWithReward(_db(), msg.sender, _to, _value)) {\n            return false;\n        }\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\n        return _refund(refund);\n    }\n\n    function transferPool(address _from, address _to, uint _value) checkAccess(""pool"") returns (bool) {\n        return _transferWithReward(_db(), _from, _to, _value);\n    }\n\n    function rewardTo(address _to, uint _amount) checkAccess(""reward"") returns (bool) {\n        bool result = _db().deposit(_to, _amount, 0, 0);\n        if (result) {\n            totalSupply += _amount;\n        }\n\n        return result;\n    }\n\n    function recoverAccount(address _old, address _new) checkAccess(""recovery"") notRecoveredAccount(_old) returns (bool) {\n        return _recoverAccount(_db(), _old, _new);\n    }\n\n    function setFeeAddr(address _feeAddr) checkAccess(""currencyOwner"") {\n        feeAddr = _feeAddr;\n    }\n\n    function setFee(uint _absMinFee, uint _feePercent, uint _absMaxFee) checkAccess(""cron"") returns (bool) {\n        return _setFeeStructure(_absMinFee, _feePercent, _absMaxFee);\n    }\n\n    uint public txGasPriceLimit = 21000000000;\n    uint public transferCallGas = 21000;\n    uint public refundGas = 15000;\n    EtherTreasuryInterface treasury;\n\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(""currencyOwner"") returns (bool) {\n        if (_txGasPriceLimit == 0) {\n            return false;\n        }\n        treasury = EtherTreasuryInterface(_treasury);\n        txGasPriceLimit = _txGasPriceLimit;\n        if (msg.value > 0 && !address(treasury).send(msg.value)) {\n            throw;\n        }\n        return true;\n    }\n\n    function updateRefundGas() checkAccess(""currencyOwner"") returns (uint) {\n        uint startGas = msg.gas;\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; // just to simulate calculations, dunno if optimizer will remove this.\n        if (!_refund(1)) {\n            return 0;\n        }\n        refundGas = startGas - msg.gas;\n        return refundGas;\n    }\n\n    function setOperationsCallGas(uint _transfer) checkAccess(""currencyOwner"") returns (bool) {\n        transferCallGas = _transfer;\n        return true;\n    }\n\n    function _refund(uint _value) internal returns (bool) {\n        if (tx.gasprice > txGasPriceLimit) {\n            return false;\n        }\n        return treasury.withdraw(tx.origin, _value);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1498439,0xb691a19475f13c0dfa361b5b26b328e0e762c13c,false,false,,,,TOO_SHORT
1498585,0x472e56ef4f4f9f430a70e988bd78ffd018911031,false,false,,,,TOO_SHORT
1498590,0xfd38efd7a5c7c4257b04d574818322072b35e338,false,false,,,,TOO_SHORT
1498651,0x78ddee92b2457d0ca167ce00a42a5053eb91d7d2,false,false,,,,TOO_SHORT
1498657,0xa4d928c1e9fb334560e24c2c3b21f6d1abdd7b7e,false,false,,,,TOO_SHORT
1498672,0x52718705ebaa8ea088356ce3d536a0ca2cc294e9,false,false,,,,TOO_SHORT
1498710,0xf3272d0b47fbde62c0637b6ab8007c371dacc9d3,false,false,,,,TOO_SHORT
1498720,0xcd4d5a8fb9332f73e7a9fcb442826dbab5857283,false,false,,,,TOO_SHORT
1498734,0xb5223a56ccca2fdd7d82b6b4337d58122ef2c258,false,false,,,,TOO_SHORT
1498841,0x1fdfb3c7d3d6f6066fa393609e7c18956843d3ac,false,false,,,,TOO_SHORT
1498887,0x7b5be0c28c122cd55ff1046a31fbbb694acae1d1,false,false,,,,TOO_SHORT
1498890,0x52585e74a0225b6a44a7a0996e43469c88ff2a6d,false,false,,,,TOO_SHORT
1498924,0x1f872fdd5fa25ee05708112fd692ac383a4c0e11,false,false,,,,TOO_SHORT
1498968,0xfd24f3c1bea92b95550746419f5bda642d6ffe5b,false,false,,,,TOO_SHORT
1499064,0x2dba2a8612f2a512fd6f34c5418c0132cf443fa2,false,false,,,,TOO_SHORT
1499212,0x05b002d378f35c4a2bcb9323aa0945ef062ad18d,false,false,,,,TOO_SHORT
1499234,0x20c907fd2195a542f0d0840312275d542397531f,false,false,,,,TOO_SHORT
1499366,0x901daff13c2855d5da58eb42f029bdce7d68748c,false,false,,,,TOO_SHORT
1499376,0xba7f5a2f756dc7aaa43824ffdd4025fba932b91a,false,false,,,,TOO_SHORT
1499411,0xc6cc0e7284f1e081c6246cb391139a6c8e1ace61,false,false,,,,TOO_SHORT
1499479,0x069f612daec667a62ee91e2c5b10e56101cd487c,false,false,,,,TOO_SHORT
1499513,0x3b350408b4da0d7337c61df760c737a90d635d4d,false,false,,,,TOO_SHORT
1499576,0xd4b99c07f3af7284016eee91b92b3a8113df1365,false,false,,,,TOO_SHORT
1499724,0x59d0b832912697f06096aa3d2094e177dd816a83,false,false,,,,TOO_SHORT
1499752,0x17634e6084fa3712d880d2fae69fa225f1f289ac,false,false,,,,TOO_SHORT
1499838,0x0aeb6b902f8e7fee53a7255e86f7dad30314ebc2,false,false,,,,TOO_SHORT
1499870,0xa988854e3c0778e8833b32534dfe539e8f92cb22,false,false,,,,TOO_SHORT
1499900,0xe5d2751196504337e9b76797301238c7ea0e9624,false,false,,,,TOO_SHORT
1499933,0xa76a98822936dd14819f6c46d50983ac1182aad0,false,false,,,,TOO_SHORT
1500006,0xf24efd695f90f8bd42f964ac993c662320eb2666,false,false,,,,TOO_SHORT
1500243,0xac8f8ad0d151b5d81b94ab722ba50c2ef01fa661,false,false,,,,TOO_SHORT
1500365,0x61450e33c4ef16b6dfcc386ba8aa6f415fa4cccf,false,false,,,,TOO_SHORT
1500413,0x6dc330ff54c78442a7a8b1285645f6597939ac28,false,false,,,,TOO_SHORT
1500825,0x12b7600052a3bf0fe2bdee6e05d91610167eb8e7,false,false,,,,TOO_SHORT
1501208,0x6b8231462302dc2833329561df4575942aa8ff95,false,false,,,,TOO_SHORT
1501308,0xcfa602a416bd2342e7d31df8c713f08de9259131,false,false,,,,TOO_SHORT
1501403,0x82d30b6930cc4108bf4776edd799d2a7ff1dc44a,false,false,,,,TOO_SHORT
1501432,0xa4f33a24a221657e669c50145365cef7008b0149,false,false,,,,TOO_SHORT
1501507,0xdd4c536764168437c5f2f4fa60c117653d09b0c2,false,false,,,,TOO_SHORT
1501508,0x3fe950bc688f116c5d021b8ab4caac614c70058d,false,false,,,,TOO_SHORT
1501833,0x6d7b261ba8caebcb13d3863ad304d6475da9d2da,false,false,,,,TOO_SHORT
1501927,0x4828618a097d356d55ee6f48e2d5c601b2cf3453,false,false,,,,TOO_SHORT
1501944,0x5bbeec8c735c4a21b2b9a1804cc898723579c2cd,false,false,,,,TOO_SHORT
1502051,0xa5d358f1e77f2360b996c714ee799a43e0cf183b,false,false,,,,TOO_SHORT
1502116,0x3fba34900dda840c405588429c95efc783bd86fd,false,false,,,,TOO_SHORT
1502146,0x78e352d952109dd31a4bb56f666849d5e2dd495a,false,false,,,,TOO_SHORT
1502212,0xa070e65ca13d9c794165777aae5b05a5e421f5f7,false,false,,,,TOO_SHORT
1502301,0x32ef3906d62d7f4da82afd6586ba1f9022793cc6,false,false,,,,TOO_SHORT
1502605,0x2415803bcd7ce1041c5ad1b7ebb607ff79fdec4b,false,false,,,,TOO_SHORT
1502770,0x2bc83152be5da13f3ce5bf25befe610157dbf9a3,false,false,,,,TOO_SHORT
1502773,0x6b085cf123f15675b868242ba8a66d3906383d31,false,false,,,,TOO_SHORT
1502854,0x7022be986f25dd6296fd05ec6dbf34369b142325,false,false,,,,TOO_SHORT
1502915,0xbcc061ca7932e6247259833cff07ad13f2484d3a,false,false,,,,TOO_SHORT
1502916,0xaec52e8a6b9e8278b1ec09f7712e712e1d679dc6,false,false,,,,TOO_SHORT
1503007,0xae7709aedab116b3c0b87c86aaa029d5d46c8435,false,false,,,,TOO_SHORT
1503009,0x730ed3cb8f9a98f4da72b6a9b72fd5833c30a39b,false,false,,,,TOO_SHORT
1503027,0xd069750c8827e43b2cd3ebd3fe8ac387b42a89d2,false,false,,,,TOO_SHORT
1503039,0x0b0280a663c414a5ccb7c188b73f45ebaf6c09e7,false,false,,,,TOO_SHORT
1503125,0xe7f58faaccb81f3fe8d4648a66b9bfeb0044b97c,false,false,,,,TOO_SHORT
1503222,0xa09aa5050cb7b7e98edd612f24af89bf80b588f3,false,false,,,,TOO_SHORT
1503270,0x5349593a962754e1c736a9dc4ae9130e88732fe1,false,false,,,,TOO_SHORT
1503372,0x8502ffe0d178b5ddb19af234d86611f854db64a7,false,false,,,,TOO_SHORT
1503526,0xbc801bd422f1a915af17782f503dc030f55bfdfb,false,false,,,,TOO_SHORT
1503546,0x196ab1334b9e5ec7266fc465feb7a45f45265ab8,false,false,,,,TOO_SHORT
1503663,0xb0e7694d6e542bfcb3c4f7e6d79d8c9ec49f61ae,false,false,,,,TOO_SHORT
1503739,0x261aa0c9c381930147dbaa2f16c4480d42210107,false,false,,,,TOO_SHORT
1503757,0x6dd42d1271eae1e2c69b20c8082935d88a813d03,false,false,,,,TOO_SHORT
1503760,0xa210f41c15c5a0433f3658a635c7b3a28c033a43,false,false,,,,TOO_SHORT
1503768,0xc10f5c3a4b1281b1a956d06671b57e45efbbd3c3,false,false,,,,TOO_SHORT
1503917,0x03d9f702836971c5a9c1ca60687be2b86781b943,false,false,,,,TOO_SHORT
1503948,0x5a8f6c1c3c6e9b4c8f1aeae2db16694aeabe09cf,false,false,,,,TOO_SHORT
1503991,0xe5aa4487b42749c4f85dca899b8714cd09a6531a,false,false,,,,TOO_SHORT
1504022,0x1a50a7a7a98f54874f90c33ba137427c41073d69,false,false,,,,TOO_SHORT
1504041,0xa9e2320d9e6c17eb45a921cb2698b42256f5e142,false,false,"contract EthDig\n{\n    uint constant LifeTime = 30;\n    \n    address Owner = msg.sender;\n    address OutputAddress = msg.sender;\n    \n    uint64 Coef1=723;\n    uint64 Coef2=41665;\n    uint64 Coef3=600000;\n    \n    uint public ContributedAmount;\n    uint ContributedLimit = 10 ether;\n    \n    uint public CashForHardwareReturn;\n    uint public FreezedCash;\n    \n    uint16 UsersLength = 0;\n    mapping (uint16 => User) Users;\n    struct User{\n        address Address;\n        uint16 ContributionsLength;\n        mapping (uint16 => Contribution) Contributions;\n    }\n    struct Contribution{\n        uint CashInHarware;\n        uint CashFreezed;\n        \n        uint16 ProfitPercent;\n        uint NeedPayByDay;\n        \n        bool ReuseCashInHarware;\n        \n        uint DateCreated;\n        uint DateLastCheck;\n        uint AlreadyPaid;\n        \n        bool ReturnedHardwareCash;\n        bool Finished;\n    }\n    \n    function  ContributeInternal(uint16 userId,uint cashInHarware,uint cashFreezed,bool reuseCashInHarware) private{\n        Contribution contribution = Users[userId].Contributions[Users[userId].ContributionsLength];\n\n        contribution.CashInHarware = cashInHarware;\n        contribution.CashFreezed = cashFreezed;\n        \n        uint8 noFreezCoef = uint8 ((cashInHarware * 100) / (cashFreezed+cashInHarware));\n        contribution.ProfitPercent = uint16 (((Coef1 * noFreezCoef * noFreezCoef) + (Coef2 * noFreezCoef) + Coef3)/10000);//10000\n        \n        contribution.NeedPayByDay = (((cashInHarware + cashFreezed) /10000) * contribution.ProfitPercent)/LifeTime;\n        contribution.ReuseCashInHarware = reuseCashInHarware;\n        contribution.DateCreated = now;\n        contribution.DateLastCheck = now;\n        \n        Users[userId].ContributionsLength++;\n    }\n    function ContributeWithSender (bool reuseCashInHarware,uint8 freezeCoeff,address sender) {\n        if (msg.value == 0 || freezeCoeff>100 ||ContributedAmount + msg.value > ContributedLimit)\n        {\n            sender.send(msg.value);\n            return;\n        }\n        \n        uint16 userId = GetUserIdByAddress(sender);\n        if (userId == 65535)\n        {\n            userId = UsersLength;\n            Users[userId].Address = sender;\n            UsersLength ++;\n        }\n        \n        uint cashFreezed = ((msg.value/100)*freezeCoeff);\n        ContributeInternal(\n            userId,\n            msg.value - cashFreezed,\n            cashFreezed,\n            reuseCashInHarware\n            );\n        FreezedCash += cashFreezed;\n        ContributedAmount += msg.value;\n        \n        OutputAddress.send(msg.value - cashFreezed);\n    }\n    function Contribute (bool reuseCashInHarware,uint8 freezeCoeff) {\n        ContributeWithSender(reuseCashInHarware,freezeCoeff,msg.sender);\n    }\n    function ChangeReuseCashInHarware(bool newValue,uint16 userId,uint16 contributionId){\n        if (msg.sender != Users[userId].Address) return;\n        Users[userId].Contributions[contributionId].ReuseCashInHarware = newValue;\n    }\n    \n    function Triger(){\n        if (Owner != msg.sender) return;\n        \n        uint MinedTillLastPayment = this.balance - CashForHardwareReturn - FreezedCash;\n        bool NotEnoughCash = false;\n        \n        for(uint16 i=0;i<UsersLength;i++)\n        {\n            for(uint16 j=0;j<Users[i].ContributionsLength;j++)\n            {\n                Contribution contribution = Users[i].Contributions[j];\n                if (contribution.Finished || now - contribution.DateLastCheck < 1 days) continue;\n                \n                if (contribution.AlreadyPaid != contribution.NeedPayByDay * LifeTime)\n                {\n                    uint8 daysToPay = uint8((now - contribution.DateCreated)/1 days);\n                    if (daysToPay>LifeTime) daysToPay = uint8(LifeTime);\n                    uint needToPay = (daysToPay * contribution.NeedPayByDay) - contribution.AlreadyPaid;\n                    \n                    if (MinedTillLastPayment < needToPay)\n                    {\n                        NotEnoughCash = true;\n                    }\n                    else\n                    {\n                        if (needToPay > 100 finney || daysToPay == LifeTime)\n                        {\n                            MinedTillLastPayment -= needToPay;\n                            Users[i].Address.send(needToPay);\n                            contribution.AlreadyPaid += needToPay;\n                        }\n                    }\n                    contribution.DateLastCheck = now;\n                }\n\n                if (now > contribution.DateCreated + (LifeTime * 1 days) && !contribution.ReturnedHardwareCash)\n                {\n                    if (contribution.ReuseCashInHarware)\n                    {\n                        ContributeInternal(\n                            i,\n                            contribution.CashInHarware,\n                            contribution.CashFreezed,\n                            true\n                        );\n                        contribution.ReturnedHardwareCash = true;\n                    }\n                    else\n                    {\n                        if (CashForHardwareReturn >= contribution.CashInHarware)\n                        {\n                            CashForHardwareReturn -= contribution.CashInHarware;\n                            FreezedCash -= contribution.CashFreezed;\n                            ContributedAmount -= contribution.CashFreezed + contribution.CashInHarware;\n                            Users[i].Address.send(contribution.CashInHarware + contribution.CashFreezed);\n                            contribution.ReturnedHardwareCash = true;\n                        }\n                    }\n                }\n                \n                if (contribution.ReturnedHardwareCash && contribution.AlreadyPaid == contribution.NeedPayByDay * LifeTime)\n                {\n                    contribution.Finished = true;\n                }\n            }  \n        }\n        \n        if (!NotEnoughCash)\n        {\n            OutputAddress.send(MinedTillLastPayment);\n        }\n    }\n    \n    function ConfigureFunction(address outputAddress,uint contributedLimit,uint16 coef1,uint16 coef2,uint16 coef3)\n    {\n        if (Owner != msg.sender) return;\n        OutputAddress = outputAddress;\n        ContributedLimit = contributedLimit;\n        Coef1 = coef1;\n        Coef2 = coef2;\n        Coef3 = coef3;\n    }\n    \n    function SendCashForHardwareReturn(){\n        CashForHardwareReturn += msg.value;\n    }\n    function WithdrawCashForHardwareReturn(uint amount){\n        if (Owner != msg.sender || CashForHardwareReturn < amount) return;\n        Owner.send(amount);\n    }\n    \n    function GetUserIdByAddress (address userAddress) returns (uint16){\n        for(uint16 i=0; i<UsersLength;i++)\n        {\n            if (Users[i].Address == userAddress)\n                return i;\n        }\n        return 65535;\n    }\n    \n    function GetContributionInfo (uint16 userId,uint16 contributionId) \n    returns (uint a1,uint a2, uint16 a3,uint a4, bool a5,uint a6,uint a7,uint a8,bool a9,bool a10,address a11) \n    {\n        Contribution contribution = Users[userId].Contributions[contributionId];\n        a1 = contribution.CashInHarware;\n        a2 = contribution.CashFreezed;\n        a3 = contribution.ProfitPercent;\n        a4 = contribution.NeedPayByDay;\n        a5 = contribution.ReuseCashInHarware;\n        a6 = contribution.DateCreated;\n        a7 = contribution.DateLastCheck;\n        a8 = contribution.AlreadyPaid;\n        a9 = contribution.ReturnedHardwareCash;\n        a10 = contribution.Finished;\n        a11 = Users[userId].Address;\n    }\n    \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1504088,0x16ec118023a46aa508c92fedb42bdf385525b095,false,false,,,,TOO_SHORT
1504147,0x6fa6c20e51bda5be6111b668830401b547078d51,false,false,,,,TOO_SHORT
1504167,0x12ed1d8ef099c93010ef9ddf1f1aa6d6dc415b24,false,false,,,,TOO_SHORT
1504223,0xedcca368a543d2b22293b5a0d9c4349d5a961016,false,false,,,,TOO_SHORT
1504395,0xe3888eb2ad68f2d3639301893e53284569172f2d,false,false,,,,TOO_SHORT
1504458,0x1c35b08e51e8547c091c1e85a0a0b376920f88cd,false,false,,,,TOO_SHORT
1504507,0xaaafbdf6dc269cc6bcee1f752f202e0182053a83,false,false,,,,TOO_SHORT
1504538,0x705272950edfc667c73b8378203044be9fcb5f6d,false,false,,,,TOO_SHORT
1504559,0x972e52c54796ea43b061c553e2b1ba5fc82d684c,false,false,,,,TOO_SHORT
1504570,0x2fa85fde93a53522c42e1bffbece5d2f71dad208,false,false,,,,TOO_SHORT
1504619,0xc9418013e2f39dcee2facc9bd30cab57eb247b6e,false,false,,,,TOO_SHORT
1504653,0x25b2041919a187f3cbeaf55f2abed03ce02604ad,false,false,,,,TOO_SHORT
1504729,0x4eca97e759a702f4a1f1d317d694b24d39241728,false,false,,,,TOO_SHORT
1504933,0x44be9a1cc9ac896c58c0cd2fb79ad0850682f4b9,false,false,,,,TOO_SHORT
1504940,0xe993e33fa106c94c9c60148e0830f063a8f92121,false,false,,,,TOO_SHORT
1504966,0x1bebb44f694e559b6a50529abcf192e27ea2d492,false,false,,,,TOO_SHORT
1504968,0x37a3e0919c5f2610b3ed7cb00c2de3fd52a1f875,false,false,,,,TOO_SHORT
1504969,0xe5dd7f412e7bd01e4a04bd0cbf49a1f75b6b639f,false,false,,,,TOO_SHORT
1504970,0xe17b9402334af8d4bce7bac0d34f858867e65655,false,false,,,,TOO_SHORT
1505073,0x3b3b972613a5e3cc4704063e0c83349d6e0ca58c,false,false,,,,TOO_SHORT
1505150,0x5e40a8c1ec95ff5b72602c414e9b1537886aaf42,false,false,,,,TOO_SHORT
1505293,0x65a762655a0d15d73508358f1b18d598c2fcfcb8,false,false,,,,TOO_SHORT
1505332,0x867fbc10881e1a5a2f90b0b125ae9bf34962161c,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1505338,0x4826e92fd7856f7db8a44ee8cc88ef9c2f33f99b,false,false,,,,TOO_SHORT
1505349,0xbad4c0baf692c9fed718c4d761b0a7acf3fe0c18,false,false,,,,TOO_SHORT
1505417,0x059955698791ce723ddca9bb58f6c3394d58af7b,false,false,,,,TOO_SHORT
1505577,0x6adc2d7c8b08353193fb7e3d43ea42b8e8fc5349,false,false,,,,TOO_SHORT
1505645,0xafb9d5d9193c73fe696b46381f1bcd259831c927,false,false,,,,TOO_SHORT
1505853,0xfc74f354912c643fe4aff548a368038e3ba63f55,false,false,,,,TOO_SHORT
1505902,0x465167b05346b82ac1e1a7529623af560512fa73,false,false,,,,TOO_SHORT
1505944,0xd10706b40f7c974728234cf569a7e44c67187be5,false,false,,,,TOO_SHORT
1506155,0xc9e44aad6b6df80dd497e41870f375318187fd75,false,false,,,,TOO_SHORT
1506158,0x01af82d8d257e4cca502f8f3216ee89aaeff3ac5,false,false,,,,TOO_SHORT
1506454,0x410d86736a3918b5fd5812f96b2a75226463bbe0,false,false,,,,TOO_SHORT
1506526,0x35dbf42fb08aa0bfd2cf2603c3295046281c541a,false,false,,,,TOO_SHORT
1506567,0xd518715ec00d4211624cd7b47b86f2b843e796db,false,false,,,,TOO_SHORT
1506609,0x9bdfe844716bb478a23eb4bab5a956da93f7068d,false,false,,,,TOO_SHORT
1506760,0x60f7acd1d4ba6f84430417c43fff04e27088b6cf,false,false,,,,TOO_SHORT
1506788,0xc1421c3fffb8952cf5096c31bdd3158938aad915,false,false,,,,TOO_SHORT
1507232,0x98bc69dfbae28c5f661c4bb14694e6ec734cd107,false,false,,,,TOO_SHORT
1507329,0x565bfc035bed8f2b77daa5388f406dfe13f6dd5f,false,false,,,,TOO_SHORT
1507490,0xd5e88a7c7703f7d932ec0a59b30d7051d15f4b0a,false,false,,,,TOO_SHORT
1507604,0x8b403a425458e89b598d167ea35a1571ef1420ab,false,false,,,,TOO_SHORT
1507801,0x825d4c5158a191db755d3a36976f1549421ce9a8,false,false,,,,TOO_SHORT
1507853,0xe4ce0e88515898be0a44918b5b80b0c1979dca86,false,false,,,,TOO_SHORT
1507854,0xc37fa3709fada8f52db2f06ac7ffd3881a25543f,false,false,,,,TOO_SHORT
1507937,0x862f43a83359a489512e8a325913b6cda3556055,false,false,,,,TOO_SHORT
1507957,0x84bec7c8035c271efc7c04967e14958913a81be4,false,false,,,,TOO_SHORT
1507985,0x1a68cebf23f4155be113ce8cbf076a84c0d7c7c3,false,false,,,,TOO_SHORT
1508012,0x0a98580318a47aa3c5830ca77402829d689b699b,false,false,,,,TOO_SHORT
1508023,0x62ca869bafea0c77234e48018d9c67f7c0cd197a,false,false,,,,TOO_SHORT
1508095,0xb1d68d95ed281cb73f7bf6be1e77dee21c4c7263,false,false,,,,TOO_SHORT
1508197,0x808f680dfc6332ae06e03f992895d7e5b6494de6,false,false,,,,TOO_SHORT
1508227,0xcb238313e63f1bb93077bad5747aeb94ebec8be7,false,false,,,,TOO_SHORT
1508241,0x1d680479e2d861018ac277abdff8ba04cd784ea2,false,false,,,,TOO_SHORT
1508327,0xda67a17f0d2c9739951d4c03e8d4a4bd69a618c6,false,false,,,,TOO_SHORT
1508648,0x46e25ac2a4d37a9bc2c97bbb07afffed0d570f5b,false,false,,,,TOO_SHORT
1508721,0xa37de6ec7e27eb6480013155192fada05d4bb5c4,false,false,,,,TOO_SHORT
1508734,0x1482662691085c305f329c111e5b79ecb226ceb8,false,false,,,,TOO_SHORT
1508810,0xc8733f02ca2adfab55b1cc4776f756791bead387,false,false,,,,TOO_SHORT
1508863,0xc867b8abafb677060187e8ff95263b5aeb28c3b2,false,false,,,,TOO_SHORT
1508905,0xec08779ae93be33afc43843cf8b064ed63f6be45,false,false,,,,TOO_SHORT
1508950,0xa22c29f529963490afff6bc67aa662638d23be4f,false,false,,,,TOO_SHORT
1508979,0x49f5e869f15bf4dc203dc3219180b835e1f55411,false,false,,,,TOO_SHORT
1509033,0x192f1e525035e8fe59c06383862b690af5180b9c,false,false,,,,TOO_SHORT
1509078,0x1f3560c3e18bd9525f9843baf4d3daea61db5453,false,false,,,,TOO_SHORT
1509194,0x84b0e5096fd9fa431da1d4dc4a2064d13d4a31b7,false,false,,,,TOO_SHORT
1509215,0xc17a41df34d931cb33cab0b65b42c9dbb746194b,false,false,,,,TOO_SHORT
1509350,0x69a63fe0dfb6b48f9ef0f3211d730aa893eed777,false,false,,,,TOO_SHORT
1509404,0xd54cff43cc4f89fbf1ef0d2fc189d269447e8866,false,false,,,,TOO_SHORT
1509449,0x4611e3d2b8349edd804fffd05dcdf9ccd1eea2b4,false,false,,,,TOO_SHORT
1509459,0xb39a89322379ed7d91dc2e8ae1b30989eaf91d41,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   ROCK PAPER SCISSORS\n//   Challenge an opponent with an encrypted hand\n//   www.matching-ethers.com/rps                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n\n//          STAKE : 0.5 ETH\n//          DRAW : Full refund\n//          WIN : 0.995 ETH (house : 0.005)\n//          EXPIRATION TIME : 1hour after duel starts (refreshed when one player reveals)\n//          If only one player reveals, he wins after 1 hour if the other doesn't reveal\n//          he will be paid automatically when other ppl play the game.\n//          If both player don't reveal and forget the bet, it is refunded (-house)\n\n//         HOW TO PLAY ?\n//         1- Send a encrypted Hand (generated on the game's website)\n//         2- Wait for opponent (can cancel if you wish)\n//         3- Once matched, reveal your hand with the appropriate function and your secret\n//         4- Wait for your duel to resolve and the automatic payout\n\n//         ENCRYPT YOUR HAND\n//         Encrypt your hands on the website or\n//         directly with web3.js :  web3.sha3(secret+hand)\n\n// exemple results with secret = ""testing""\n//hand = ""rock"" :  web3.sha3(""testing""+""rock"")\n// 0x8935dc293ca2ee08e33bad4f4061699a8f59ec637081944145ca19cbc8b39473\n//hand = ""paper"" : \n// 0x859743aa01286a6a1eba5dbbcc4cf8eeaf1cc953a3118799ba290afff7125501\n//hand = ""scissors"" : \n//0x35ccbb689808295e5c51510ed28a96a729e963a12d09c4a7a4ba000c9777e897\n\ncontract Crypted_RPS\n{\n    address owner;\n    uint256 gambleValue;\n    uint256 expirationTime;\n    uint256 house;\n    uint256 houseTotal;\n    modifier noEthSent(){\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gambleValue) throw;\n        if (msg.value > gambleValue) msg.sender.send(msg.value-gambleValue);\n	_\n    }\n\n    struct PlayerWaiting\n    {\n        bool full;\n        address player;\n        bytes32 cryptedHand;\n    }\n    PlayerWaiting playerWaiting;\n\n    struct Duel2Decrypt\n    {\n	address player_1;\n        bytes32 cryptedHand_1;\n        address player_2;\n 	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel2Decrypt[] duels2Decrypt;\n    uint firstActiveDuel2; //index du premier duel2 non resolu\n\n    struct Duel1Decrypt\n   {\n	address player_1;\n        string hand_1;\n        address player_2;\n	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel1Decrypt[] duels1Decrypt;\n    uint firstActiveDuel1;\n\n    struct Result  \n    {\n       address player_1;\n       string hand_1;\n       address player_2;\n       string hand_2;\n       uint result; //0 draw, 1 wins, 2 wins\n    }\n    Result[] results;\n\n\n    mapping (address => uint) player_progress;\n    // 0 not here, 1 waiting, 2 2crypted, 3 1crypted\n    mapping (address => uint) player_bet_id;\n    mapping (address => uint) player_bet_position;\n\n    function getPlayerStatus(address player, uint option) constant returns (uint result)\n    {\n         if (option==0) {result = player_progress[player];}\n         else if (option==1) {result= player_bet_id[player];}\n         else if (option==2) {result = player_bet_position[player];}\n         return result;\n    }\n\n\n    mapping (string => mapping(string => int)) payoffMatrix;\n    //constructor\n    function Crypted_RPS()\n    {\n	owner= msg.sender;\n	gambleValue = 500000 szabo;\n        house = 2500 szabo;\n        expirationTime = 3600;   //1 hour\n        payoffMatrix[""rock""][""rock""] = 0;\n        payoffMatrix[""rock""][""paper""] = 2;\n        payoffMatrix[""rock""][""scissors""] = 1;\n        payoffMatrix[""paper""][""rock""] = 1;\n        payoffMatrix[""paper""][""paper""] = 0;\n        payoffMatrix[""paper""][""scissors""] = 2;\n        payoffMatrix[""scissors""][""rock""] = 2;\n        payoffMatrix[""scissors""][""paper""] = 1;\n        payoffMatrix[""scissors""][""scissors""] = 0;\n    }\n\n    function () {throw;} //no callback, use the functions to play\n\n    modifier payexpired2Duel{\n        if (duels2Decrypt.length>firstActiveDuel2 && duels2Decrypt[firstActiveDuel2].timeStamp + expirationTime <= now) {\n            duels2Decrypt[firstActiveDuel2].player_1.send(gambleValue-house);\n            duels2Decrypt[firstActiveDuel2].player_2.send(gambleValue-house);\n            houseTotal+=2*house;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_1]=0;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_2]=0;\n            duels2Decrypt[firstActiveDuel2].decrypted = true;\n            updateFirstDuel2(firstActiveDuel2);\n        }\n        _\n    }\n\n    modifier payexpired1Duel{\n        if (duels1Decrypt.length>firstActiveDuel1 && (duels1Decrypt[firstActiveDuel1].timeStamp + expirationTime) < now) {\n            duels1Decrypt[firstActiveDuel1].player_1.send(2*(gambleValue-house));\n            houseTotal+=2*house;\n            duels1Decrypt[firstActiveDuel1].decrypted = true;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_1]=0;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_2]=0;\n            results.push(Result(duels1Decrypt[firstActiveDuel1].player_1, duels1Decrypt[firstActiveDuel1].hand_1, duels1Decrypt[firstActiveDuel1].player_2,""expired"", 1));\n            updateFirstDuel1(firstActiveDuel1);\n           \n        }\n        _\n    }\n        \n\n    function cancelWaitingForOpponent()\n    noEthSent {\n        if (msg.sender==playerWaiting.player && playerWaiting.full)\n        {\n             msg.sender.send(gambleValue);\n             playerWaiting.full=false;\n             player_progress[msg.sender]=0;\n        }\n        else { throw;}\n    }	\n\n\n    function sendCryptedHand(bytes32 cryptedH)\n    equalGambleValue\n    payexpired2Duel\n    payexpired1Duel\n    {\n          uint progress = player_progress[msg.sender];\n          uint position = player_bet_position[msg.sender];\n          //one not resolved duel per player only\n          if ( progress==3 && position==1 )throw;\n          if (progress == 2 ) throw; \n          if (progress ==  1 ) throw; //no selfdueling\n          if (!playerWaiting.full) \n          {\n              playerWaiting.player=msg.sender;\n              playerWaiting.cryptedHand= cryptedH;\n              playerWaiting.full=true;\n              player_progress[msg.sender]=1;\n          }\n          else\n          {\n               duels2Decrypt.push( Duel2Decrypt(playerWaiting.player, playerWaiting.cryptedHand, msg.sender, cryptedH, false, now) );\n                player_progress[playerWaiting.player]=2;\n                player_bet_id[playerWaiting.player]=duels2Decrypt.length-1;\n                player_bet_position[playerWaiting.player]=0;\n                player_progress[msg.sender]=2;\n                player_bet_id[msg.sender]=duels2Decrypt.length-1;\n                player_bet_position[msg.sender]=1;         \n                playerWaiting.full=false;\n          }\n\n    }\n\n\n    function revealRock(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""rock"");\n        reveal(hashRevealed, ""rock"");\n    }\n    function revealPaper(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""paper"");\n        reveal(hashRevealed, ""paper"");\n    }\n    function revealScissors(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""scissors"");\n        reveal(hashRevealed, ""scissors"");\n    }\n\n    function reveal(bytes32 hashRevealed, string hand) private\n    noEthSent\n   {\n\n        uint progress =  getPlayerStatus(msg.sender,0);\n        uint bet_id     =  getPlayerStatus(msg.sender,1);\n        uint position  =  getPlayerStatus(msg.sender,2);\n        \n\n        bytes32 hashStored;        \n        if (progress==2)  //duel not revealed\n        { \n            if (position == 0)\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_1;\n            }\n            else\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_2;\n            }\n        }\n        else if (progress==3 && position==1) //duel half revealed already\n        { \n                hashStored = duels1Decrypt[bet_id].cryptedHand_2;\n        }\n        else { throw;} //player has nothing to reveal\n\n	if (hashStored==hashRevealed)\n        {\n              decryptHand(hand, progress, bet_id, position);\n        }\n        else\n        {\n             throw; //wrong secret or hand\n         }\n    }\n    \n    function  decryptHand(string hand, uint progress, uint bet_id, uint position) private\n    {\n             address op_add;\n             bytes32 op_cH;\n\n         if (progress==2)\n         {  \n             if (position==0) \n             {\n                 op_add = duels2Decrypt[bet_id].player_2;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_2;\n\n             }\n             else\n             {\n                 op_add = duels2Decrypt[bet_id].player_1;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_1;\n             }\n\n              duels1Decrypt.push(Duel1Decrypt(msg.sender,hand,op_add, op_cH, false, now));\n              duels2Decrypt[bet_id].decrypted=true;\n              updateFirstDuel2(bet_id);\n              player_progress[msg.sender]=3;\n              player_bet_id[msg.sender]=duels1Decrypt.length-1;\n              player_bet_position[msg.sender]=0;\n              player_progress[op_add]=3;\n              player_bet_id[op_add]=duels1Decrypt.length-1;\n              player_bet_position[op_add]=1;\n\n         }\n         else if (progress==3 && position==1)\n         {\n              op_add = duels1Decrypt[bet_id].player_1;\n              string op_h = duels1Decrypt[bet_id].hand_1;\n              duels1Decrypt[bet_id].decrypted=true;\n              uint result = payDuel(op_add, op_h, msg.sender, hand);\n              results.push(Result(op_add, op_h, msg.sender,hand, result));\n              updateFirstDuel1(bet_id);\n              player_progress[msg.sender]=0;\n              player_progress[op_add]=0;\n          }\n     }\n\n     function updateFirstDuel2(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel2)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels2Decrypt.length && duels2Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel2=index;\n              return;\n          }\n      }\n\n     function updateFirstDuel1(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel1)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels1Decrypt.length && duels1Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel1=index;\n              return;\n          }\n      }\n\n     // in case there is too much expired duels in queue for automatic payout, \n     //I can help to catch up\n     function manualPayExpiredDuel() \n     onlyOwner\n     payexpired2Duel\n     payexpired1Duel\n     noEthSent\n     {\n         return;\n     }\n\n     //payout\n     function payDuel(address player_1, string hand_1, address player_2, string hand_2) private returns(uint result) \n     {\n              if (payoffMatrix[hand_1][hand_2]==0) //draw\n              {player_1.send(gambleValue); player_2.send(gambleValue); result=0;}\n              else if (payoffMatrix[hand_1][hand_2]==1) //1 win\n              {player_1.send(2*(gambleValue-house)); result=1; houseTotal+=2*house;}\n              if (payoffMatrix[hand_1][hand_2]==2) //2 wins\n              {player_2.send(2*(gambleValue-house)); result=2; houseTotal+=2*house;}\n              return result;\n      }\n\n     function payHouse() \n     onlyOwner\n     noEthSent {\n         owner.send(houseTotal);\n         houseTotal=0;\n     }\n\n     function getFirstActiveDuel1() constant returns(uint fAD1) {\n         return firstActiveDuel1;}\n     function getLastDuel1() constant returns(uint lD1) {\n         return duels1Decrypt.length;}\n     function getDuel1(uint index) constant returns(address p1, string h1, address p2, bool dC, uint256 tS) {\n         p1 = duels1Decrypt[index].player_1;\n         h1 = duels1Decrypt[index].hand_1;\n         p2 = duels1Decrypt[index].player_2;\n         dC = duels1Decrypt[index].decrypted;\n         tS  = duels1Decrypt[index].timeStamp;\n     }\n\n     function getFirstActiveDuel2() constant returns(uint fAD2) {\n         return firstActiveDuel2;}\n     function getLastDuel2() constant returns(uint lD2) {\n         return duels2Decrypt.length;}\n     function getDuel2(uint index) constant returns(address p1, address p2, bool dC, uint256 tS) {\n         p1 = duels2Decrypt[index].player_1;\n         p2 = duels2Decrypt[index].player_2;\n         dC = duels2Decrypt[index].decrypted;\n         tS  = duels2Decrypt[index].timeStamp;\n     }\n\n     function getPlayerWaiting() constant returns(address p, bool full) {\n         p = playerWaiting.player;\n         full = playerWaiting.full;\n     }\n\n     function getLastResult() constant returns(uint lD2) {\n         return results.length;}\n     function getResults(uint index) constant returns(address p1, string h1, address p2, string h2, uint r) {\n         p1 = results[index].player_1;\n         h1 = results[index].hand_1;\n         p2 = results[index].player_2;\n         h2 = results[index].hand_2;\n         r = results[index].result;\n     }\n\n\n}",2,アスキーアートとコメントが詩的要素を加え、コードに芸術的な雰囲気を与えています。,
1509590,0x87a773f947ffee15c19e0368ef59d03d72458265,false,false,,,,TOO_SHORT
1509613,0x1818e1fd82f0182d6d1de2008eed128b2e16e0f7,false,false,,,,TOO_SHORT
1509765,0x2b7ba27c19955520f4be745cfa6a1ccc0f1e4bad,false,false,,,,TOO_SHORT
1509922,0x14daa6c8595db402a38b75afc3d00060a8f16b10,false,false,,,,TOO_SHORT
1509986,0x9bb117a7019b276032569466aee0a799e84d2652,false,false,,,,TOO_SHORT
1510105,0x64d1032c31e299a51c12195c4b15f79b5ee9e46c,false,false,,,,TOO_SHORT
1510158,0xcb85f50ef0e11c9704910fe2e4484c0ac10af888,false,false,,,,TOO_SHORT
1510284,0x608d88b8d21edfad6c784d0b977c69ad8afed492,false,false,,,,TOO_SHORT
1510296,0x691692ffa2a5e9762cd2ddd5f609c7b8a539d854,false,false,,,,TOO_SHORT
1510340,0xa0510da4eea8247135a6cabbf5f5e7f39275393c,false,false,,,,TOO_SHORT
1510602,0xdddbbcee7631705bcaa4e7dabbd5937bad9be8f0,false,false,,,,TOO_SHORT
1510609,0xca8e11c876180c9f2115fa61fe2a1a3a6f66ebaf,false,false,,,,TOO_SHORT
1510660,0x9c111b1b7f28df48b0f6802aa34298922c88c470,false,false,,,,TOO_SHORT
1510694,0x33d9b12b3b05927a1a00d5896017c5ff4967fca9,false,false,,,,TOO_SHORT
1510712,0xc207b597e1c0b1dc6d2d8ccbfde0a47633d8c9b7,false,false,,,,TOO_SHORT
1510721,0xe778ac41005bbb1cb79b6dfe410714ce08143594,false,false,,,,TOO_SHORT
1510779,0xac7899f18dbdad99a3379cc654d906b30d1b48b6,false,false,,,,TOO_SHORT
1510848,0x6fe1bfe085adf464237b1518451b812435c2ea2f,false,false,,,,TOO_SHORT
1510867,0xe0460ecb8c82cad381d6112d7dc88f1c73884f49,false,false,,,,TOO_SHORT
1510871,0xddcc069d0e952061d53cc63936efb6566440f1ca,false,false,,,,TOO_SHORT
1510961,0xb691a08f324aff8d2d0e238167c87af3f90ceb2d,false,false,,,,TOO_SHORT
1510977,0x061103444ca263bc78268f4ed2545a045264f652,false,false,,,,TOO_SHORT
1511006,0x7b7058ea3cedd39ff02f3ab121f018c178de092a,false,false,,,,TOO_SHORT
1511007,0xe414f440c68a4e5cf29bae8597f01f4ee02d63cb,false,false,,,,TOO_SHORT
1511080,0x598bbf6555e484d3ce3edeea9ed46dd4df2a4322,false,false,,,,TOO_SHORT
1511115,0x5cf40b13765c9fa5a5b4bf80d46a5fe8c34db066,false,false,,,,TOO_SHORT
1511126,0xc647d7abc7925423815e9ad6fb6d58f4f92bf606,false,false,,,,TOO_SHORT
1511143,0x1075aeebe7a6217f80bc180b1d7c1adb2cebfec9,false,false,,,,TOO_SHORT
1511282,0x2cebde4028c67b1a73493950391303db33b5251d,false,false,,,,TOO_SHORT
1511328,0x451560f7f1dc7fdfd4846aaa7c23dabfdf987db6,false,false,,,,TOO_SHORT
1511339,0xd08afa210dce91c672a3dc38516b3536953189ba,false,false,,,,TOO_SHORT
1511345,0x5aaf77bc5f8000c6c0c88ce2a63297c16811e1bf,false,false,,,,TOO_SHORT
1511461,0x8eba2c9e05b5212850d7c14e80a5f2f610ae5cce,false,false,,,,TOO_SHORT
1511475,0xb6276434d4148da21cdd3e4c3a1cb7eec36d25b1,false,false,,,,TOO_SHORT
1511584,0x76ceb5428fba6e8ad871dd16015722df2517f7ff,false,false,,,,TOO_SHORT
1511753,0x81b164a4b1b43de8e3dfcb37aa20d26dd48e7599,false,false,,,,TOO_SHORT
1511802,0x7a5e41ec825c127626f3b319ea188669dfc5c2a3,false,false,,,,TOO_SHORT
1511814,0xd59599ec47e0246bc3b7979863f70339fdad0089,false,false,,,,TOO_SHORT
1511928,0xce0fe8bf1bf2bba031f39dd8a37fcda292eb8055,false,false,,,,TOO_SHORT
1512003,0xfc8967a1bd5dabb8c73ce784891c1e948106a004,false,false,,,,TOO_SHORT
1512157,0x32661e79532b360ff65a0c7bfd2c86fa72025467,false,false,,,,TOO_SHORT
1512353,0x4434e48c954e68596866ce3457b04fce129a3556,false,false,,,,TOO_SHORT
1512358,0x8d2a36f05751950977fccf5459fddd1efee7c915,false,false,,,,TOO_SHORT
1512427,0x323f13b2ab42d7a577fbb5c237ec9ce44badc0cb,false,false,,,,TOO_SHORT
1512530,0xfa1162f4c0e4d27b21a3efc095a9eb2bba6b7bf6,false,false,,,,TOO_SHORT
1512585,0xf369f27baa8c3fcefef91134af622ef8ce54154b,false,false,,,,TOO_SHORT
1512687,0x105347892d690e17d680594517e0c16e026781e2,false,false,,,,TOO_SHORT
1512790,0x6ae8a63162c162260a7aeca6f0e10a0ebf789e53,false,false,,,,TOO_SHORT
1512802,0xc7c6bdc7606e034c4647b1bd2dfa1ec5d91fcb18,false,false,,,,TOO_SHORT
1512830,0x6f8102ac03dc9b174890f9ffa5ec771638494fc7,false,false,,,,TOO_SHORT
1512883,0x48edd2682267e062bec41670dc10584b665e6e21,false,false,,,,TOO_SHORT
1512900,0x4f3cbc4278e9f0274862ac4f24579fb2a8b89f30,false,false,,,,TOO_SHORT
1512935,0x8f796a1fe476e540ee74a4b1e57eca79eade0fb0,false,false,,,,TOO_SHORT
1512954,0xce9a7a0a29fa3a61701d1cd8daa0708c130a6139,false,false,,,,TOO_SHORT
1512963,0x0c014a1fcd8299113a8af78899ef2fad79b759e6,false,false,,,,TOO_SHORT
1513025,0xdc220830df3bfea4d0b3779b89ca814f7961388a,false,false,,,,TOO_SHORT
1513042,0x9be98a23ecf71bc4cb0025deb660958bc02c27d2,false,false,,,,TOO_SHORT
1513043,0x876850c35c100e8b4d4948b590798ec56753962e,false,false,,,,TOO_SHORT
1513059,0x6304f02c02ab069b66fd36451a0f8b9ac4aae23c,false,false,,,,TOO_SHORT
1513164,0xb82753b452b02c04c13dea526396d021f81568a2,false,false,,,,TOO_SHORT
1513174,0x5500fbf7763c4f878e6556cf997c46faf2a3bfa9,false,false,,,,TOO_SHORT
1513280,0x91a90d38d81390dde7ff030bcfc45d4988e46412,false,false,,,,TOO_SHORT
1513306,0x44f7e7ed5f9d59e18c7cbebf62fb79f2870cbdee,false,false,,,,TOO_SHORT
1513397,0x19368a31868eb80753127f7d1cb958a7c5b52ac9,false,false,,,,TOO_SHORT
1513443,0x19b56362e1c978ed3b358abc0d72ef4d1dee8a57,false,false,,,,TOO_SHORT
1513452,0x8169becf74a22930bb41a9b4d6a18095a8f2e25a,false,false,,,,TOO_SHORT
1513459,0x7de1493e077eb4d177bb244a0939a14e5867f8b4,false,false,,,,TOO_SHORT
1513462,0xb11ce9e9b766d246ad7dcd4614bef7491b2ab0c8,false,false,,,,TOO_SHORT
1513538,0x30652cef29a7f1c1008324fe245bcc9605500458,false,false,,,,TOO_SHORT
1513607,0x2817002b71e0c00a5e15eaa48865e1d083de1322,false,false,,,,TOO_SHORT
1513681,0xf62d7b1a67f5005d151e85cd95dd5d87a26a5d2d,false,false,,,,TOO_SHORT
1513691,0x8705ad4674e1f2ce528d8c1fd9050111fdd6f7f7,false,false,,,,TOO_SHORT
1513699,0x6c7fb30a46149e7e176af20bdc5b9bc4d4f853ca,false,false,,,,TOO_SHORT
1513990,0x45ea332abfa98271a820fe1d85cf43a517d9ad5e,false,false,,,,TOO_SHORT
1514133,0x5d160498bcb05364a559e22c840052e18478b4d6,false,false,,,,TOO_SHORT
1514187,0x0a72f747f673116b5998c29715112515cb8aa345,false,false,,,,TOO_SHORT
1514632,0x45ba195dc6cb1e28e88db5da1760391c17d74c0c,false,false,,,,TOO_SHORT
1514718,0x1b4668df7a90a24f1da60bbbcad3092178d43f78,false,false,,,,TOO_SHORT
1514811,0x327da0af0bc4b4a8eec55d89a36398acf23a3515,false,false,,,,TOO_SHORT
1514860,0xfd8e241f61624563f7dead7c1b8d81baf5a1f061,false,false,,,,TOO_SHORT
1514934,0x6d2dfbd3084c3b4f586edcb099e6e3b1cf4fdf31,false,false,,,,TOO_SHORT
1514952,0x64cda111569fca888611b9445962f663dd41f163,false,false,,,,TOO_SHORT
1514976,0x19d859b8d4be69f4d4d576b6bf037a10d0973afd,false,false,,,,TOO_SHORT
1514977,0xef220ce0e24ac423a0bc5e91ec097468f7140fde,false,false,,,,TOO_SHORT
1515074,0xb5f5528cb6a547425373a589adb9681ba673ed53,false,false,,,,TOO_SHORT
1515259,0xef660087689b396094dd4537cfbe0bfe54d11566,false,false,,,,TOO_SHORT
1515304,0xe0253e0e08031e6945eaf7809938026396550fea,false,false,,,,TOO_SHORT
1515526,0xe1ef6803e7012e439381b46ebb36c49dcdd1ca38,false,false,,,,TOO_SHORT
1515799,0x17425f50351845a8e625568984356d504a5f620c,false,false,,,,TOO_SHORT
1515802,0xe01f5e6593e551fb08ab044d69a3348b447771ff,false,false,,,,TOO_SHORT
1516094,0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed,false,false,/*\n  Copyright (c) 2015-2016 Oraclize SRL\n  Copyright (c) 2016 Oraclize LTD\n*/\n\ncontract OraclizeAddrResolver {\n\n    address public addr;\n\n    address owner;\n\n    function OraclizeAddrResolver(){\n        owner = msg.sender;\n    }\n\n    function changeOwner(address newowner){\n        if (msg.sender != owner) throw;\n        owner = newowner;\n    }\n\n    function getAddress() returns (address oaddr){\n        return addr;\n    }\n\n    function setAddr(address newaddr){\n        if (msg.sender != owner) throw;\n        addr = newaddr;\n    }\n\n},1,標準的なアドレス管理のスマートコントラクトで、特に芸術的要素はありません。,
1516117,0xccc8131eb0260b0a50c9109d163ab768fe1c07da,false,false,,,,TOO_SHORT
1516609,0xbaa2a880908196258991cd5e71b73cff6f9c04a2,false,false,,,,TOO_SHORT
1516620,0xd3ac4f7123883e5c8037af012db856ef55fadb28,false,false,,,,TOO_SHORT
1516752,0x04b30a845fba2611aab1aa556e4d17f557b3ad52,false,false,,,,TOO_SHORT
1516760,0xb6113a6f91a57f0f2387c513069f984e4b4c250e,false,false,,,,TOO_SHORT
1516805,0x3cb837edaaacd6e0836e9d844ceb891e2d34e24c,false,false,,,,TOO_SHORT
1516891,0x9410e9b13a2029fce53ac33203397c3371b41550,false,false,,,,TOO_SHORT
1517143,0x447c05915d26426bd7fa2915c7cf6a3f0ab1ecdd,false,false,,,,TOO_SHORT
1517202,0x362c7984768f4121b5fcb063cebe73e88e9c6b8e,false,false,,,,TOO_SHORT
1517492,0x8d71f1c95c185ed371e739aa48f1f85a131be62a,false,false,,,,TOO_SHORT
1517576,0xed106277a502084aba21a47a8015f878a03570c0,false,false,,,,TOO_SHORT
1517670,0xbdd92e5e693670c88637167d8578b61c1ee1e122,false,false,,,,TOO_SHORT
1517681,0x6220cab334654ebbeeaed2c3ae56678b6c148e78,false,false,,,,TOO_SHORT
1517779,0x2149b222d60e38427f09bb76f5dc4d74fdcf875e,false,false,,,,TOO_SHORT
1517821,0x87e0f2c09284461169324d2b46d6494dcfa9d3ba,false,false,,,,TOO_SHORT
1517877,0x0c4e70e69f012fd190b5d6cea9de3f9eaa3b1852,false,false,,,,TOO_SHORT
1517889,0xdb0efcdc717d1dc1968dbca58ffc77d4abd7f3cb,false,false,,,,TOO_SHORT
1518058,0xc48f97dbe442b9695683c6e9d2476143cd4a9a6b,false,false,,,,TOO_SHORT
1518133,0x95c6aea62bb0a557d8c9873f47601539cdccd728,false,false,,,,TOO_SHORT
1518228,0xc315ff46b5456e00d77aa00fcf25b48e3498fba6,false,false,,,,TOO_SHORT
1518268,0xd05d56acd892f33010d93ddf6d9593511b618946,false,false,"contract DgxToken {\n  function approve(address _spender,uint256 _value) returns(bool success);\n  function totalSupply() constant returns(uint256 );\n  function transferFrom(address _from,address _to,uint256 _value) returns(bool success);\n  function balanceOf(address _owner) constant returns(uint256 balance);\n  function transfer(address _to,uint256 _value) returns(bool success);\n  function allowance(address _owner,address _spender) constant returns(uint256 remaining);\n}\n\ncontract SwapContract {\n \n  address public seller;\n  address public dgxContract;\n  uint256 public weiPrice;\n\n  modifier ifSeller() {\n    if (seller != msg.sender) {\n      throw;\n    } else {\n      _\n    }\n  }\n\n  function SwapContract(address _seller, uint256 _weiPrice) {\n    dgxContract = 0x55b9a11c2e8351b4ffc7b11561148bfac9977855;\n    seller = _seller;\n    weiPrice = _weiPrice;\n  }\n\n  function () {\n    if (dgxBalance() == 0) throw;\n    if (msg.value < totalWeiPrice()) throw;\n    if (DgxToken(dgxContract).transfer(address(this), dgxBalance())) {\n      seller.send(msg.value);       \n    }\n  }\n\n  function setWeiPrice(uint256 _newweiprice) ifSeller returns (bool _success) {\n    weiPrice = _newweiprice;\n    _success = true;\n    return _success;\n  }\n\n  function totalWeiPrice() public constant returns (uint256 _totalweiprice) {\n    _totalweiprice = dgxBalance() * weiPrice;\n    return _totalweiprice;\n  }\n\n  function dgxBalance() public constant returns (uint256 _dgxbalance) {\n    _dgxbalance = DgxToken(dgxContract).balanceOf(address(this));\n    return _dgxbalance;\n  }\n\n  function withdraw() ifSeller returns (bool _success) {\n    _success = DgxToken(dgxContract).transfer(seller, dgxBalance());\n    return _success;\n  }\n}\n\ncontract DgxSwap {\n\n  uint256 public totalCount;\n  mapping (address => address) public swapContracts;\n  mapping (uint256 => address) public sellers;\n\n  function DgxSwap() {\n    totalCount = 0;\n  }\n\n  function createSwap(uint256 _weiprice) public returns (bool _success) {\n    address _swapcontract = new SwapContract(msg.sender, _weiprice);\n    swapContracts[msg.sender] = _swapcontract;\n    sellers[totalCount] = msg.sender; \n    totalCount++;\n    _success = true;\n    return _success;\n  }\n\n  function getSwap(uint256 _id) public constant returns (address _seller, address _contract, uint256 _dgxbalance, uint256 _weiprice, uint256 _totalweiprice) {\n    _seller = sellers[_id];\n    if (_seller == 0x0000000000000000000000000000000000000000) {\n      _contract = 0x0000000000000000000000000000000000000000;\n      _dgxbalance = 0;\n      _weiprice = 0;\n      _totalweiprice = 0;\n    } else {\n      _contract = swapContracts[_seller];  \n      _dgxbalance = SwapContract(_contract).dgxBalance();\n      _weiprice = SwapContract(_contract).weiPrice();\n      _totalweiprice = SwapContract(_contract).totalWeiPrice();\n    }\n    return (_seller, _contract, _dgxbalance, _weiprice, _totalweiprice);\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1518469,0x05a8f364c1748b248c6e170d131bed179382e037,false,false,,,,TOO_SHORT
1518587,0x943bbeef41460a3f0f3ac7f7a062128ad0ba9cb1,false,false,"contract DgxToken {\n  function approve(address _spender,uint256 _value) returns(bool success);\n  function totalSupply() constant returns(uint256 );\n  function transferFrom(address _from,address _to,uint256 _value) returns(bool success);\n  function balanceOf(address _owner) constant returns(uint256 balance);\n  function transfer(address _to,uint256 _value) returns(bool success);\n  function allowance(address _owner,address _spender) constant returns(uint256 remaining);\n  function calculateTxFee(uint256 _value, address _user) public returns (uint256);\n}\n\ncontract SwapContract {\n \n  address public seller;\n  address public dgxContract;\n  uint256 public weiPrice;\n\n  modifier ifSeller() {\n    if (seller != msg.sender) {\n      throw;\n    } else {\n      _\n    }\n  }\n\n  function SwapContract(address _seller, uint256 _weiPrice) {\n    dgxContract = 0x55b9a11c2e8351b4ffc7b11561148bfac9977855;\n    seller = _seller;\n    weiPrice = _weiPrice;\n  }\n\n  function () {\n    if (dgxBalance() == 0) throw;\n    if (msg.value < totalWeiPrice()) throw;\n    uint256 _txfee = DgxToken(dgxContract).calculateTxFee(dgxBalance(), address(this));\n    uint256 _sendamount = dgxBalance() - _txfee;\n    if (!DgxToken(dgxContract).transfer(msg.sender, _sendamount)) throw;\n    if (!seller.send(msg.value)) throw;\n  }\n\n  function setWeiPrice(uint256 _newweiprice) ifSeller returns (bool _success) {\n    weiPrice = _newweiprice;\n    _success = true;\n    return _success;\n  }\n\n  function totalWeiPrice() public constant returns (uint256 _totalweiprice) {\n    _totalweiprice = dgxBalance() * weiPrice;\n    return _totalweiprice;\n  }\n\n  function dgxBalance() public constant returns (uint256 _dgxbalance) {\n    _dgxbalance = DgxToken(dgxContract).balanceOf(address(this));\n    return _dgxbalance;\n  }\n\n  function withdraw() ifSeller returns (bool _success) {\n    uint256 _txfee = DgxToken(dgxContract).calculateTxFee(dgxBalance(), seller);\n    uint256 _sendamount = dgxBalance() - _txfee;\n    _success = DgxToken(dgxContract).transfer(seller, _sendamount);\n    return _success;\n  }\n}\n\ncontract DgxSwap {\n\n  uint256 public totalCount;\n  mapping (address => address) public swapContracts;\n  mapping (uint256 => address) public sellers;\n\n  function DgxSwap() {\n    totalCount = 0;\n  }\n\n  function createSwap(uint256 _weiprice) public returns (bool _success) {\n    address _swapcontract = new SwapContract(msg.sender, _weiprice);\n    swapContracts[msg.sender] = _swapcontract;\n    sellers[totalCount] = msg.sender; \n    totalCount++;\n    _success = true;\n    return _success;\n  }\n\n  function getSwap(uint256 _id) public constant returns (address _seller, address _contract, uint256 _dgxbalance, uint256 _weiprice, uint256 _totalweiprice) {\n    _seller = sellers[_id];\n    if (_seller == 0x0000000000000000000000000000000000000000) {\n      _contract = 0x0000000000000000000000000000000000000000;\n      _dgxbalance = 0;\n      _weiprice = 0;\n      _totalweiprice = 0;\n    } else {\n      _contract = swapContracts[_seller];  \n      _dgxbalance = SwapContract(_contract).dgxBalance();\n      _weiprice = SwapContract(_contract).weiPrice();\n      _totalweiprice = SwapContract(_contract).totalWeiPrice();\n    }\n    return (_seller, _contract, _dgxbalance, _weiprice, _totalweiprice);\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1518754,0x93e5084c446ec9a9a0aab1f7b1d80757dcacdc18,false,false,,,,TOO_SHORT
1518898,0x8738f0ca25e7fd56f223ae32d2f3ae66633774b0,false,false,,,,TOO_SHORT
1518959,0xd5951e25f9f1a70fdf6bdaab8d8c8e82c6dcf09c,false,false,,,,TOO_SHORT
1519145,0x967f8d09f7f5a2cc094450ae25c87ac26bccfeab,false,false,,,,TOO_SHORT
1519185,0x9e728fce5f7e34db015cebaa07afdd17284085cd,false,false,,,,TOO_SHORT
1519462,0x681b5746ab754997c32da218cd43678391c497fd,false,false,,,,TOO_SHORT
1519652,0x3876c61ded655f15319189e0848d0f79e58774ea,false,false,,,,TOO_SHORT
1520277,0xd194781681239379640d3a3be3ff1acb254fded0,false,false,,,,TOO_SHORT
1520306,0x628be02d1b9f57e9a19781aebcb4dc43fc996f32,false,false,,,,TOO_SHORT
1520458,0xd0ac793bb17d6c36265facc6df4da6a63a4de3d4,false,false,,,,TOO_SHORT
1521007,0xa38fb98abf76ca0be2d1414520e161ceae4becfd,false,false,,,,TOO_SHORT
1521087,0x0d383f4fbece4823f5a4448a10d581a3fc2a242c,false,false,,,,TOO_SHORT
1521102,0xb6fbf60171fb1ca22cb5e39165fd6da1d916bc51,false,false,,,,TOO_SHORT
1521539,0x48c129ee0d9d4a599614721400c49bb9aedb0c21,false,false,,,,TOO_SHORT
1521550,0x23421db8e707d57b9d7f358c0963ed5ef6e7b4ce,false,false,,,,TOO_SHORT
1521684,0x8643eee32c5dddfbd9feaa1f68bef568d2b74170,false,false,,,,TOO_SHORT
1521903,0xa0300264a8e8d781936adc5bd23835c2c5ecaab7,false,false,,,,TOO_SHORT
1521995,0xaa4a2ecdeda804726657d3f43cbb373837b689d1,false,false,,,,TOO_SHORT
1522412,0xee1d7eb350568ca1117d42856bfc444ba3a1eb03,false,false,,,,TOO_SHORT
1522588,0xab262509063c0442192cbcb6ba4f11fb7a6ef3e5,false,false,,,,TOO_SHORT
1522625,0xc5912c5aa88d7c947c9510b3c8d76543c72ed98c,false,false,contract BCFSafe {\n    /* Time Deposit and Return Funds */\n    address owner;\n    uint lockTime;\n    function TimeDeposit() {\n owner = msg.sender;\n lockTime = now + 30 minutes;\n    }\n    function returnMyMoney(uint amount){\n        if (msg.sender==owner && now > lockTime) {\n            owner.send(amount);\n        }\n    }\n},1,基本的な時間制限付きの資金返還機能を持つ実用的なスマートコントラクト。,
1522719,0x97b71898721860071e9e2ef013ab6d53058917f1,false,false,,,,TOO_SHORT
1522754,0x8d611521b1c378fe86a1321bed0c30274de439a8,false,false,,,,TOO_SHORT
1523004,0x81c1f379fd36bdc36ca632a260af518d4405167f,false,false,,,,TOO_SHORT
1523042,0xc208ba6b877b16ee22e6759468051458bb1c0f82,false,false,,,,TOO_SHORT
1523134,0xa7380ccc5af772ffd7229b211874f78dd43c3675,false,false,,,,TOO_SHORT
1523359,0xa596912b6b29aa1c4677ae99e239911ebba73a66,false,false,,,,TOO_SHORT
1523372,0x3cd4b8595a68fb526a81f13c9511ae4f6811d5a9,false,false,,,,TOO_SHORT
1523552,0xc614d57ef087db6f4c1b51d5e88a5da8e943acd6,false,false,,,,TOO_SHORT
1523605,0x1073f6042185686626114c8ce35f2b54c3366a24,false,false,,,,TOO_SHORT
1523724,0x669f6c3bce98b01b081b61bc3b5d2335047cb646,false,false,,,,TOO_SHORT
1523725,0x7d117fee8ee59caf65cb53f527f30b715e00cd30,false,false,,,,TOO_SHORT
1523922,0x7f5c2108c8e3571d08c4affc5e017befad5217b7,false,false,,,,TOO_SHORT
1524182,0x814182757ee70966ebfd81551fac8f711c5e7357,false,false,,,,0x627917e47cd111382ddf7fb1dc140d2daf8876b3
1524244,0xe3b53b3071c43228d50481e49bef4106ecc66105,false,false,,,,TOO_SHORT
1524379,0x970028cc75a99b6967290fb1d17d3c63841c52f4,false,false,,,,TOO_SHORT
1524412,0x839d93cd32b477dc9c8a4cb756a2215c97046f05,false,false,,,,TOO_SHORT
1524483,0xbec93541c9befb818d3bad203959a160900f6762,false,false,,,,TOO_SHORT
1524487,0x6564128a7391f23b5d056ac3d6c253db7834cbfd,false,false,,,,TOO_SHORT
1524594,0xb1d7987b0cfcd48ff259d3c9875dfba0e32445f3,false,false,,,,TOO_SHORT
1524603,0xf3fc2113e9051bd41882b10ee370ada544aef246,false,false,,,,TOO_SHORT
1525151,0x76dfe950e0a785d4dd3c910ab0fdbfcd4f917ca3,false,false,,,,TOO_SHORT
1525167,0xb17bc63dda43d4b44e3f233e5d0424ffd0b2cf93,false,false,,,,TOO_SHORT
1526137,0x151b1a5892a79898da45e98e317b698b68008c2f,false,false,,,,TOO_SHORT
1526232,0xea1e8d7f25888519c692a619922a7683f20f317b,false,false,,,,TOO_SHORT
1526479,0xcfc70823025e7d168c3253061c3be27dd751d256,false,false,,,,TOO_SHORT
1526959,0x231c7510f24d1c8b9578558bcb7fa6c659b4ca98,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   ROCK PAPER SCISSORS\n//   Challenge an opponent with an encrypted hand\n//   www.matching-ethers.com/rps                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n\n//          STAKE : 0.1 ETH\n//          DRAW : Full refund\n//          WIN : 0.198 ETH (house : 0.002)\n//          EXPIRATION TIME : 1hour after duel starts (refreshed when one player reveals)\n//          If only one player reveals, he wins after 1 hour if the other doesn't reveal\n//          he will be paid automatically when other ppl play the game.\n//          If both player don't reveal and forget the bet, it is refunded (-house)\n\n//         HOW TO PLAY ?\n//         1- Send a encrypted Hand (generated on the game's website or by yourself)\n//         2- Wait for opponent (can cancel if you wish)\n//         3- Once matched, reveal your hand with the appropriate function and your secret\n//         4- Wait for your duel to resolve and the automatic payout\n\n//         ENCRYPT YOUR HAND\n//         Encrypt your hands on the website or\n//         directly with web3.js :  web3.sha3(secret+hand)\n\n// exemple results with secret = ""testing""\n//hand = ""rock"" :  web3.sha3(""testing""+""rock"")\n// 0x8935dc293ca2ee08e33bad4f4061699a8f59ec637081944145ca19cbc8b39473\n//hand = ""paper"" : \n// 0x859743aa01286a6a1eba5dbbcc4cf8eeaf1cc953a3118799ba290afff7125501\n//hand = ""scissors"" : \n//0x35ccbb689808295e5c51510ed28a96a729e963a12d09c4a7a4ba000c9777e897\n\ncontract Crypted_RPS\n{\n    address owner;\n    uint256 gambleValue;\n    uint256 expirationTime;\n    uint256 house;\n    uint256 houseTotal;\n    modifier noEthSent(){\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gambleValue) throw;\n        if (msg.value > gambleValue) msg.sender.send(msg.value-gambleValue);\n	_\n    }\n\n    struct PlayerWaiting\n    {\n        bool full;\n        address player;\n        bytes32 cryptedHand;\n    }\n    PlayerWaiting playerWaiting;\n\n    struct Duel2Decrypt\n    {\n	address player_1;\n        bytes32 cryptedHand_1;\n        address player_2;\n 	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel2Decrypt[] duels2Decrypt;\n    uint firstActiveDuel2; //index of first Duel 2 not decrypted\n\n    struct Duel1Decrypt\n   {\n	address player_1;\n        string hand_1;\n        address player_2;\n	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel1Decrypt[] duels1Decrypt;\n    uint firstActiveDuel1;\n\n    struct Result  \n    {\n       address player_1;\n       string hand_1;\n       address player_2;\n       string hand_2;\n       uint result; //0 draw, 1 wins, 2 wins\n    }\n    Result[] results;\n\n\n    mapping (address => uint) player_progress;\n    // 0 not here, 1 waiting, 2 2crypted, 3 1crypted\n    mapping (address => uint) player_bet_id;\n    mapping (address => uint) player_bet_position;\n\n    function getPlayerStatus(address player, uint option) constant returns (uint result)\n    {\n         if (option==0) {result = player_progress[player];}\n         else if (option==1) {result= player_bet_id[player];}\n         else if (option==2) {result = player_bet_position[player];}\n         return result;\n    }\n\n\n    mapping (string => mapping(string => int)) payoffMatrix;\n    //constructor\n    function Crypted_RPS()\n    {\n	owner= msg.sender;\n	gambleValue = 100000 szabo;\n        house = 1000 szabo;\n        expirationTime = 7200;   //2 hour\n        payoffMatrix[""rock""][""rock""] = 0;\n        payoffMatrix[""rock""][""paper""] = 2;\n        payoffMatrix[""rock""][""scissors""] = 1;\n        payoffMatrix[""paper""][""rock""] = 1;\n        payoffMatrix[""paper""][""paper""] = 0;\n        payoffMatrix[""paper""][""scissors""] = 2;\n        payoffMatrix[""scissors""][""rock""] = 2;\n        payoffMatrix[""scissors""][""paper""] = 1;\n        payoffMatrix[""scissors""][""scissors""] = 0;\n    }\n\n    function () {throw;} //no callback, use the functions to play\n\n    modifier payexpired2Duel{\n        if (duels2Decrypt.length>firstActiveDuel2 && duels2Decrypt[firstActiveDuel2].timeStamp + expirationTime <= now) {\n            duels2Decrypt[firstActiveDuel2].player_1.send(gambleValue-house);\n            duels2Decrypt[firstActiveDuel2].player_2.send(gambleValue-house);\n            houseTotal+=2*house;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_1]=0;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_2]=0;\n            duels2Decrypt[firstActiveDuel2].decrypted = true;\n            updateFirstDuel2(firstActiveDuel2);\n        }\n        _\n    }\n\n    modifier payexpired1Duel{\n        if (duels1Decrypt.length>firstActiveDuel1 && (duels1Decrypt[firstActiveDuel1].timeStamp + expirationTime) < now) {\n            duels1Decrypt[firstActiveDuel1].player_1.send(2*(gambleValue-house));\n            houseTotal+=2*house;\n            duels1Decrypt[firstActiveDuel1].decrypted = true;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_1]=0;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_2]=0;\n            results.push(Result(duels1Decrypt[firstActiveDuel1].player_1, duels1Decrypt[firstActiveDuel1].hand_1, duels1Decrypt[firstActiveDuel1].player_2,""expired"", 1));\n            updateFirstDuel1(firstActiveDuel1);\n           \n        }\n        _\n    }\n        \n\n    function cancelWaitingForOpponent()\n    noEthSent {\n        if (msg.sender==playerWaiting.player && playerWaiting.full)\n        {\n             msg.sender.send(gambleValue);\n             playerWaiting.full=false;\n             player_progress[msg.sender]=0;\n        }\n        else { throw;}\n    }	\n\n\n    function sendCryptedHand(bytes32 cryptedH)\n    equalGambleValue\n    payexpired2Duel\n    payexpired1Duel\n    {\n          uint progress = player_progress[msg.sender];\n          uint position = player_bet_position[msg.sender];\n          //one not resolved duel per player only\n          if ( progress==3 && position==1 )throw;\n          if (progress == 2 ) throw; \n          if (progress ==  1 ) throw; //no selfdueling\n          if (!playerWaiting.full) \n          {\n              playerWaiting.player=msg.sender;\n              playerWaiting.cryptedHand= cryptedH;\n              playerWaiting.full=true;\n              player_progress[msg.sender]=1;\n          }\n          else\n          {\n               duels2Decrypt.push( Duel2Decrypt(playerWaiting.player, playerWaiting.cryptedHand, msg.sender, cryptedH, false, now) );\n                player_progress[playerWaiting.player]=2;\n                player_bet_id[playerWaiting.player]=duels2Decrypt.length-1;\n                player_bet_position[playerWaiting.player]=0;\n                player_progress[msg.sender]=2;\n                player_bet_id[msg.sender]=duels2Decrypt.length-1;\n                player_bet_position[msg.sender]=1;         \n                playerWaiting.full=false;\n          }\n\n    }\n\n\n    function revealRock(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""rock"");\n        reveal(hashRevealed, ""rock"");\n    }\n    function revealPaper(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""paper"");\n        reveal(hashRevealed, ""paper"");\n    }\n    function revealScissors(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""scissors"");\n        reveal(hashRevealed, ""scissors"");\n    }\n\n    function reveal(bytes32 hashRevealed, string hand) private\n    noEthSent\n   {\n\n        uint progress =  getPlayerStatus(msg.sender,0);\n        uint bet_id     =  getPlayerStatus(msg.sender,1);\n        uint position  =  getPlayerStatus(msg.sender,2);\n        \n\n        bytes32 hashStored;        \n        if (progress==2)  //duel not revealed\n        { \n            if (position == 0)\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_1;\n            }\n            else\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_2;\n            }\n        }\n        else if (progress==3 && position==1) //duel half revealed already\n        { \n                hashStored = duels1Decrypt[bet_id].cryptedHand_2;\n        }\n        else { throw;} //player has nothing to reveal\n\n	if (hashStored==hashRevealed)\n        {\n              decryptHand(hand, progress, bet_id, position);\n        }\n        else\n        {\n             throw; //wrong secret or hand\n         }\n    }\n    \n    function  decryptHand(string hand, uint progress, uint bet_id, uint position) private\n    {\n             address op_add;\n             bytes32 op_cH;\n\n         if (progress==2)\n         {  \n             if (position==0) \n             {\n                 op_add = duels2Decrypt[bet_id].player_2;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_2;\n\n             }\n             else\n             {\n                 op_add = duels2Decrypt[bet_id].player_1;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_1;\n             }\n\n              duels1Decrypt.push(Duel1Decrypt(msg.sender,hand,op_add, op_cH, false, now));\n              duels2Decrypt[bet_id].decrypted=true;\n              updateFirstDuel2(bet_id);\n              player_progress[msg.sender]=3;\n              player_bet_id[msg.sender]=duels1Decrypt.length-1;\n              player_bet_position[msg.sender]=0;\n              player_progress[op_add]=3;\n              player_bet_id[op_add]=duels1Decrypt.length-1;\n              player_bet_position[op_add]=1;\n\n         }\n         else if (progress==3 && position==1)\n         {\n              op_add = duels1Decrypt[bet_id].player_1;\n              string op_h = duels1Decrypt[bet_id].hand_1;\n              duels1Decrypt[bet_id].decrypted=true;\n              uint result = payDuel(op_add, op_h, msg.sender, hand);\n              results.push(Result(op_add, op_h, msg.sender,hand, result));\n              updateFirstDuel1(bet_id);\n              player_progress[msg.sender]=0;\n              player_progress[op_add]=0;\n          }\n     }\n\n     function updateFirstDuel2(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel2)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels2Decrypt.length && duels2Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel2=index;\n              return;\n          }\n      }\n\n     function updateFirstDuel1(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel1)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels1Decrypt.length && duels1Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel1=index;\n              return;\n          }\n      }\n\n     // in case there is too much expired duels in queue for automatic payout, \n     //I can help to catch up\n     function manualPayExpiredDuel() \n     onlyOwner\n     payexpired2Duel\n     payexpired1Duel\n     noEthSent\n     {\n         return;\n     }\n\n     //payout\n     function payDuel(address player_1, string hand_1, address player_2, string hand_2) private returns(uint result) \n     {\n              if (payoffMatrix[hand_1][hand_2]==0) //draw\n              {player_1.send(gambleValue); player_2.send(gambleValue); result=0;}\n              else if (payoffMatrix[hand_1][hand_2]==1) //1 win\n              {player_1.send(2*(gambleValue-house)); result=1; houseTotal+=2*house;}\n              if (payoffMatrix[hand_1][hand_2]==2) //2 wins\n              {player_2.send(2*(gambleValue-house)); result=2; houseTotal+=2*house;}\n              return result;\n      }\n\n     function payHouse() \n     onlyOwner\n     noEthSent {\n         owner.send(houseTotal);\n         houseTotal=0;\n     }\n\n     function getFirstActiveDuel1() constant returns(uint fAD1) {\n         return firstActiveDuel1;}\n     function getLastDuel1() constant returns(uint lD1) {\n         return duels1Decrypt.length;}\n     function getDuel1(uint index) constant returns(address p1, string h1, address p2, bool dC, uint256 tS) {\n         p1 = duels1Decrypt[index].player_1;\n         h1 = duels1Decrypt[index].hand_1;\n         p2 = duels1Decrypt[index].player_2;\n         dC = duels1Decrypt[index].decrypted;\n         tS  = duels1Decrypt[index].timeStamp;\n     }\n\n     function getFirstActiveDuel2() constant returns(uint fAD2) {\n         return firstActiveDuel2;}\n     function getLastDuel2() constant returns(uint lD2) {\n         return duels2Decrypt.length;}\n     function getDuel2(uint index) constant returns(address p1, address p2, bool dC, uint256 tS) {\n         p1 = duels2Decrypt[index].player_1;\n         p2 = duels2Decrypt[index].player_2;\n         dC = duels2Decrypt[index].decrypted;\n         tS  = duels2Decrypt[index].timeStamp;\n     }\n\n     function getPlayerWaiting() constant returns(address p, bool full) {\n         p = playerWaiting.player;\n         full = playerWaiting.full;\n     }\n\n     function getLastResult() constant returns(uint lD2) {\n         return results.length;}\n     function getResults(uint index) constant returns(address p1, string h1, address p2, string h2, uint r) {\n         p1 = results[index].player_1;\n         h1 = results[index].hand_1;\n         p2 = results[index].player_2;\n         h2 = results[index].hand_2;\n         r = results[index].result;\n     }\n\n\n}",1,実用的なゲームコントラクトで、芸術的表現はコメントに限られています。,
1527011,0x43a207eeb30359c80fef325f0f81c8a67671c0ad,false,false,,,,TOO_SHORT
1527015,0x8681a0de47f3ce76695dfe485c931a35ba38e3b0,false,false,,,,TOO_SHORT
1527151,0xf3d1c0489d950aad15112a3719518745a5746ac9,false,false,,,,TOO_SHORT
1527382,0xe70ba529e139f9c70bd337abab1f8b13978a0743,false,false,,,,TOO_SHORT
1527701,0xde0a4d54754c8dcd07005970c1788ad3754950f3,false,false,,,,TOO_SHORT
1527724,0x593c815909a4b3e24a6d152a8d7c762df5975b66,false,false,,,,TOO_SHORT
1527905,0xf388918bd3b41aaac1459c724d0fb9cc77e594a5,false,false,,,,TOO_SHORT
1527936,0x33843f1882fc84ed77faf523b6b0880e28c91fdc,false,false,,,,TOO_SHORT
1527973,0x4340123672752463551000d4d4c5e2379ffa93d3,false,false,,,,TOO_SHORT
1527985,0x879adf5588e05ad07767390ca2a8dec12a990c01,false,false,,,,TOO_SHORT
1528165,0x1e9fc1a0cd334ab96ed484bed1c451b739b79185,false,false,,,,TOO_SHORT
1528266,0xae593339c9c8f4a396c757258841318b7d4e5dfd,false,false,,,,TOO_SHORT
1528804,0xcc11e226ed6a87a2035eaab9c33d818223a2f496,false,false,,,,TOO_SHORT
1528884,0xf61420f650adaa45c7a367b4040ebed5c3f415f7,false,false,,,,TOO_SHORT
1529094,0xb5c659d81cc7c0876d4d3705536b500f4d6efb8a,false,false,,,,TOO_SHORT
1529109,0xf6ea594d9431f7e67fe1fa037c631259176bcbc1,false,false,,,,TOO_SHORT
1529319,0xd58c0b3dc06833776bed9ae42c299885bf9d1a03,false,false,,,,TOO_SHORT
1529411,0xce12782a1a347804ba33e6854966667fb7e4fada,false,false,,,,TOO_SHORT
1529561,0xdef545eeac0bd8b55a9e9c6b461f96ddd0fdd0de,false,false,,,,TOO_SHORT
1529634,0xc2b53210ef2949ddcbe7d5ee43a8a917d3a29048,false,false,,,,TOO_SHORT
1529668,0xbcfd4ebef56b51e5ef1b0d1f10c64622e9964549,false,false,,,,TOO_SHORT
1529830,0x6ea5d57efea0f9ff0d496205a13404402b443246,false,false,,,,TOO_SHORT
1529968,0xfa45e35c742cd95bc7abe07c896a6013be7cfbab,false,false,,,,TOO_SHORT
1529999,0x62caabbdaaec659f5ac5b1f0eb98b7c1ba6e00cd,false,false,,,,TOO_SHORT
1530042,0x18b6e34a2ed53de7b4a2758493b21a8785c3685d,false,false,,,,TOO_SHORT
1530124,0xaeb5925bb6c20dac7d19cd1aefd0121fb546e34d,false,false,,,,TOO_SHORT
1530217,0xeea890e0e7fb3d1b1ad28525bc2993e5449036b6,false,false,,,,TOO_SHORT
1530255,0xfa0fa55db0a0ced561519c64199e1e2e465977ab,false,false,,,,TOO_SHORT
1530486,0x7375fc160151093c8226eb17412af899eb14ece4,false,false,,,,TOO_SHORT
1530493,0x7fc7b6939a2b34e7607fe8e1af3fe203cd542a7a,false,false,,,,TOO_SHORT
1530518,0xb15c576b24bdcf1231eb295dd333127a0641173f,false,false,,,,TOO_SHORT
1530602,0xdccba5cc7fea4a199cecf5c1841dc148a64d33cc,false,false,,,,TOO_SHORT
1531123,0x87b49d8e891bde7312559f53582c2c344a704bc3,false,false,,,,TOO_SHORT
1531124,0x95ed16d9ca3d16da01a726e94d4eafc3bcaa3c6d,false,false,,,,TOO_SHORT
1531228,0x4d1f6ec6b8abd7e20e2d22fee16c3aa4488adc63,false,false,,,,TOO_SHORT
1531632,0x5a723a4ad136e64e3dcd59f3f2151dc12f78b85a,false,false,,,,TOO_SHORT
1531715,0xdf7131f91489a9375aaccb5f147530ea722312f6,false,false,,,,TOO_SHORT
1531842,0x1d8947187d1418d61401778bfcb84a6c1364182c,false,false,,,,TOO_SHORT
1531953,0xed6e319a0bc1df7a94a286fb2bd3b4bfded3cfb6,false,false,,,,TOO_SHORT
1532100,0x981ec5484f8f93f8546683007a8e5452e8621b96,false,false,,,,TOO_SHORT
1532380,0x1ff3b93837332c572d3d78ce29672aca10da14fb,false,false,,,,TOO_SHORT
1532606,0x023a0ce6a9c336b97bceb9bd9a90cb0b02618860,false,false,,,,TOO_SHORT
1532671,0x052ac4deb5095e96efcd5353ec26353e3ad9b995,false,false,,,,TOO_SHORT
1532698,0xc4c795ca5005a4a109386b943cde45fe1e588d40,false,false,,,,TOO_SHORT
1532961,0xf705184713518f0a1f3298763351a7002fbad338,false,false,,,,TOO_SHORT
1532979,0x83a4b7ed5a383dd5bdf9dac1a82d6aaa5b91edbb,false,false,,,,TOO_SHORT
1533016,0x5ef768a14cfad06b000e4657f2b7ff43a8245499,false,false,,,,TOO_SHORT
1533313,0xfe16e8ec20e3494ea864697a9a4c44e6b3a07be7,false,false,,,,TOO_SHORT
1533372,0x75a70b5e41cb0e298cf17fd8eafb4cd62f86153f,false,false,,,,TOO_SHORT
1533554,0xc9aa7fb5ca668f9b5205dd78b7488018a1e09807,false,false,,,,TOO_SHORT
1533698,0x148a71a6cab4def74c4f95fc4161c2dcf802db92,false,false,,,,TOO_SHORT
1533728,0x4c57c401736bd3ffecab4232d15690493858432a,false,false,,,,TOO_SHORT
1533923,0x2ec527e29dc65d4676fc700d867ae98f42e8e618,false,false,,,,TOO_SHORT
1534145,0xd18e21bb13d154a16793c6f89186a034a8116b74,false,false,"contract ZeroDollarHomePage {\n    event InvalidPullRequest(uint indexed pullRequestId);\n    event PullRequestAlreadyClaimed(uint indexed pullRequestId, uint timeBeforeDisplay, bool past);\n    event PullRequestClaimed(uint indexed pullRequestId, uint timeBeforeDisplay);\n    event QueueIsEmpty();\n\n    bool _handledFirst;\n    uint[] _queue;\n    uint _current;\n    address owner;\n\n    function ZeroDollarHomePage() {\n        owner = msg.sender;\n        _handledFirst = false;\n        _current = 0;\n    }\n\n    function remove() {\n        if (msg.sender == owner){\n            suicide(owner);\n        }\n    }\n\n    /*\n     * Register a new pull request.\n     */\n    function newRequest(uint pullRequestId) {\n        if (pullRequestId <= 0) {\n            InvalidPullRequest(pullRequestId);\n            return;\n        }\n\n        // Check that the pr hasn't already been claimed\n        bool found = false;\n        uint index = 0;\n\n        while (!found && index < _queue.length) {\n            if (_queue[index] == pullRequestId) {\n                found = true;\n                break;\n            } else {\n                index++;\n            }\n        }\n\n        if (found) {\n            PullRequestAlreadyClaimed(pullRequestId, (index - _current) * 1 days, _current > index);\n            return;\n        }\n\n        _queue.push(pullRequestId);\n        PullRequestClaimed(pullRequestId, (_queue.length - _current) * 1 days);\n    }\n\n    /*\n     * Close the current request in queue and move the queue to its next element.\n     */\n    function closeRequest() {\n        if (_handledFirst && _current < _queue.length - 1) {\n            _current += 1;\n        }\n\n        _handledFirst = true;\n    }\n\n    /*\n     * Get the last non published pull-request from the queue\n     */\n    function getLastNonPublished() constant returns (uint pullRequestId) {\n        if (_current >= _queue.length) {\n            return 0;\n        }\n\n        return _queue[_current];\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。イベントとキュー管理が中心。,
1534213,0xe4f54eb24822204559c119dac39091c18cd8d948,false,false,,,,TOO_SHORT
1534225,0xe51359712cee8888b12d77121a88685eb7f796dd,false,false,,,,TOO_SHORT
1534279,0xb8ad30a9e5a1f0f3b0342936e0ce55a3f614db78,false,false,,,,TOO_SHORT
1534372,0xdef89361a34887614f6e6993554f138de631364c,false,false,,,,TOO_SHORT
1534444,0x3282a1c71353d74eedd3428cdd14d30606660d0f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1534665,0xdeb0bc76c96aa28503c5a086dd76e1ac763d2743,false,false,,,,TOO_SHORT
1534679,0x155999f23ba40f22b24863d9c21cd8b9ab192cc9,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   ROCK PAPER SCISSORS\n//   Challenge an opponent with an encrypted hand\n//   www.matching-ethers.com/rps                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n\n//          STAKE : 0.1 ETH\n//          DRAW : Full refund\n//          WIN : 0.198 ETH (house : 0.002)\n//          EXPIRATION TIME : 24 hour after duel starts (refreshed when one player reveals)\n//          If only one player reveals, he wins after 24 hour if the other doesn't reveal\n//          he will be paid automatically when other ppl play the game.\n//          If both player don't reveal and forget the bet, it is refunded (-house)\n\n//         HOW TO PLAY ?\n//         1- Send a encrypted Hand (generated on the game's website or by yourself)\n//         2- Wait for opponent (can cancel if you wish)\n//         3- Once matched, reveal your hand with the appropriate function and your secret\n//         4- Wait for your duel to resolve and the automatic payout\n\n//         ENCRYPT YOUR HAND\n//         Encrypt your hands on the website or\n//         directly with web3.js :  web3.sha3(secret+hand)\n\n// exemple results with secret = ""testing""\n//hand = ""rock"" :  web3.sha3(""testing""+""rock"")\n// 0x8935dc293ca2ee08e33bad4f4061699a8f59ec637081944145ca19cbc8b39473\n//hand = ""paper"" : \n// 0x859743aa01286a6a1eba5dbbcc4cf8eeaf1cc953a3118799ba290afff7125501\n//hand = ""scissors"" : \n//0x35ccbb689808295e5c51510ed28a96a729e963a12d09c4a7a4ba000c9777e897\n\ncontract Crypted_RPS\n{\n    address owner;\n    uint256 gambleValue;\n    uint256 expirationTime;\n    uint256 house;\n    uint256 houseTotal;\n    modifier noEthSent(){\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gambleValue) throw;\n        if (msg.value > gambleValue) msg.sender.send(msg.value-gambleValue);\n	_\n    }\n\n    struct PlayerWaiting\n    {\n        bool full;\n        address player;\n        bytes32 cryptedHand;\n    }\n    PlayerWaiting playerWaiting;\n\n    struct Duel2Decrypt\n    {\n	address player_1;\n        bytes32 cryptedHand_1;\n        address player_2;\n 	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel2Decrypt[] duels2Decrypt;\n    uint firstActiveDuel2; //index of first Duel 2 not decrypted\n\n    struct Duel1Decrypt\n   {\n	address player_1;\n        string hand_1;\n        address player_2;\n	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel1Decrypt[] duels1Decrypt;\n    uint firstActiveDuel1;\n\n    struct Result  \n    {\n       address player_1;\n       string hand_1;\n       address player_2;\n       string hand_2;\n       uint result; //0 draw, 1 wins, 2 wins\n    }\n    Result[] results;\n\n\n    mapping (address => uint) player_progress;\n    // 0 not here, 1 waiting, 2 2crypted, 3 1crypted\n    mapping (address => uint) player_bet_id;\n    mapping (address => uint) player_bet_position;\n\n    function getPlayerStatus(address player, uint option) constant returns (uint result)\n    {\n         if (option==0) {result = player_progress[player];}\n         else if (option==1) {result= player_bet_id[player];}\n         else if (option==2) {result = player_bet_position[player];}\n         return result;\n    }\n\n\n    mapping (string => mapping(string => int)) payoffMatrix;\n    //constructor\n    function Crypted_RPS()\n    {\n	owner= msg.sender;\n	gambleValue = 100000 szabo;\n        house = 1000 szabo;\n        expirationTime = 86400;   //24 hour\n        payoffMatrix[""rock""][""rock""] = 0;\n        payoffMatrix[""rock""][""paper""] = 2;\n        payoffMatrix[""rock""][""scissors""] = 1;\n        payoffMatrix[""paper""][""rock""] = 1;\n        payoffMatrix[""paper""][""paper""] = 0;\n        payoffMatrix[""paper""][""scissors""] = 2;\n        payoffMatrix[""scissors""][""rock""] = 2;\n        payoffMatrix[""scissors""][""paper""] = 1;\n        payoffMatrix[""scissors""][""scissors""] = 0;\n    }\n\n    function () {throw;} //no callback, use the functions to play\n\n    modifier payexpired2Duel{\n        if (duels2Decrypt.length>firstActiveDuel2 && duels2Decrypt[firstActiveDuel2].timeStamp + expirationTime <= now) {\n            duels2Decrypt[firstActiveDuel2].player_1.send(gambleValue-house);\n            duels2Decrypt[firstActiveDuel2].player_2.send(gambleValue-house);\n            houseTotal+=2*house;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_1]=0;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_2]=0;\n            duels2Decrypt[firstActiveDuel2].decrypted = true;\n            updateFirstDuel2(firstActiveDuel2);\n        }\n        _\n    }\n\n    modifier payexpired1Duel{\n        if (duels1Decrypt.length>firstActiveDuel1 && (duels1Decrypt[firstActiveDuel1].timeStamp + expirationTime) < now) {\n            duels1Decrypt[firstActiveDuel1].player_1.send(2*(gambleValue-house));\n            houseTotal+=2*house;\n            duels1Decrypt[firstActiveDuel1].decrypted = true;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_1]=0;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_2]=0;\n            results.push(Result(duels1Decrypt[firstActiveDuel1].player_1, duels1Decrypt[firstActiveDuel1].hand_1, duels1Decrypt[firstActiveDuel1].player_2,""expired"", 1));\n            updateFirstDuel1(firstActiveDuel1);\n           \n        }\n        _\n    }\n        \n\n    function cancelWaitingForOpponent()\n    noEthSent {\n        if (msg.sender==playerWaiting.player && playerWaiting.full)\n        {\n             msg.sender.send(gambleValue);\n             playerWaiting.full=false;\n             player_progress[msg.sender]=0;\n        }\n        else { throw;}\n    }	\n\n\n    function sendCryptedHand(bytes32 cryptedH)\n    equalGambleValue\n    payexpired2Duel\n    payexpired1Duel\n    {\n          uint progress = player_progress[msg.sender];\n          uint position = player_bet_position[msg.sender];\n          //one not resolved duel per player only\n          if ( progress==3 && position==1 )throw;\n          if (progress == 2 ) throw; \n          if (progress ==  1 ) throw; //no selfdueling\n          if (!playerWaiting.full) \n          {\n              playerWaiting.player=msg.sender;\n              playerWaiting.cryptedHand= cryptedH;\n              playerWaiting.full=true;\n              player_progress[msg.sender]=1;\n          }\n          else\n          {\n               duels2Decrypt.push( Duel2Decrypt(playerWaiting.player, playerWaiting.cryptedHand, msg.sender, cryptedH, false, now) );\n                player_progress[playerWaiting.player]=2;\n                player_bet_id[playerWaiting.player]=duels2Decrypt.length-1;\n                player_bet_position[playerWaiting.player]=0;\n                player_progress[msg.sender]=2;\n                player_bet_id[msg.sender]=duels2Decrypt.length-1;\n                player_bet_position[msg.sender]=1;         \n                playerWaiting.full=false;\n          }\n\n    }\n\n\n    function revealRock(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""rock"");\n        reveal(hashRevealed, ""rock"");\n    }\n    function revealPaper(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""paper"");\n        reveal(hashRevealed, ""paper"");\n    }\n    function revealScissors(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""scissors"");\n        reveal(hashRevealed, ""scissors"");\n    }\n\n    function reveal(bytes32 hashRevealed, string hand) private\n    noEthSent\n   {\n\n        uint progress =  getPlayerStatus(msg.sender,0);\n        uint bet_id     =  getPlayerStatus(msg.sender,1);\n        uint position  =  getPlayerStatus(msg.sender,2);\n        \n\n        bytes32 hashStored;        \n        if (progress==2)  //duel not revealed\n        { \n            if (position == 0)\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_1;\n            }\n            else\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_2;\n            }\n        }\n        else if (progress==3 && position==1) //duel half revealed already\n        { \n                hashStored = duels1Decrypt[bet_id].cryptedHand_2;\n        }\n        else { throw;} //player has nothing to reveal\n\n	if (hashStored==hashRevealed)\n        {\n              decryptHand(hand, progress, bet_id, position);\n        }\n        else\n        {\n             throw; //wrong secret or hand\n         }\n    }\n    \n    function  decryptHand(string hand, uint progress, uint bet_id, uint position) private\n    {\n             address op_add;\n             bytes32 op_cH;\n\n         if (progress==2)\n         {  \n             if (position==0) \n             {\n                 op_add = duels2Decrypt[bet_id].player_2;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_2;\n\n             }\n             else\n             {\n                 op_add = duels2Decrypt[bet_id].player_1;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_1;\n             }\n\n              duels1Decrypt.push(Duel1Decrypt(msg.sender,hand,op_add, op_cH, false, now));\n              duels2Decrypt[bet_id].decrypted=true;\n              updateFirstDuel2(bet_id);\n              player_progress[msg.sender]=3;\n              player_bet_id[msg.sender]=duels1Decrypt.length-1;\n              player_bet_position[msg.sender]=0;\n              player_progress[op_add]=3;\n              player_bet_id[op_add]=duels1Decrypt.length-1;\n              player_bet_position[op_add]=1;\n\n         }\n         else if (progress==3 && position==1)\n         {\n              op_add = duels1Decrypt[bet_id].player_1;\n              string op_h = duels1Decrypt[bet_id].hand_1;\n              duels1Decrypt[bet_id].decrypted=true;\n              uint result = payDuel(op_add, op_h, msg.sender, hand);\n              results.push(Result(op_add, op_h, msg.sender,hand, result));\n              updateFirstDuel1(bet_id);\n              player_progress[msg.sender]=0;\n              player_progress[op_add]=0;\n          }\n     }\n\n     function updateFirstDuel2(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel2)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels2Decrypt.length && duels2Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel2=index;\n              return;\n          }\n      }\n\n     function updateFirstDuel1(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel1)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels1Decrypt.length && duels1Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel1=index;\n              return;\n          }\n      }\n\n     // in case there is too much expired duels in queue for automatic payout, \n     //I can help to catch up\n     function manualPayExpiredDuel() \n     onlyOwner\n     payexpired2Duel\n     payexpired1Duel\n     noEthSent\n     {\n         return;\n     }\n\n     //payout\n     function payDuel(address player_1, string hand_1, address player_2, string hand_2) private returns(uint result) \n     {\n              if (payoffMatrix[hand_1][hand_2]==0) //draw\n              {player_1.send(gambleValue); player_2.send(gambleValue); result=0;}\n              else if (payoffMatrix[hand_1][hand_2]==1) //1 win\n              {player_1.send(2*(gambleValue-house)); result=1; houseTotal+=2*house;}\n              if (payoffMatrix[hand_1][hand_2]==2) //2 wins\n              {player_2.send(2*(gambleValue-house)); result=2; houseTotal+=2*house;}\n              return result;\n      }\n\n     function payHouse() \n     onlyOwner\n     noEthSent {\n         owner.send(houseTotal);\n         houseTotal=0;\n     }\n\n     function getFirstActiveDuel1() constant returns(uint fAD1) {\n         return firstActiveDuel1;}\n     function getLastDuel1() constant returns(uint lD1) {\n         return duels1Decrypt.length;}\n     function getDuel1(uint index) constant returns(address p1, string h1, address p2, bool dC, uint256 tS) {\n         p1 = duels1Decrypt[index].player_1;\n         h1 = duels1Decrypt[index].hand_1;\n         p2 = duels1Decrypt[index].player_2;\n         dC = duels1Decrypt[index].decrypted;\n         tS  = duels1Decrypt[index].timeStamp;\n     }\n\n     function getFirstActiveDuel2() constant returns(uint fAD2) {\n         return firstActiveDuel2;}\n     function getLastDuel2() constant returns(uint lD2) {\n         return duels2Decrypt.length;}\n     function getDuel2(uint index) constant returns(address p1, address p2, bool dC, uint256 tS) {\n         p1 = duels2Decrypt[index].player_1;\n         p2 = duels2Decrypt[index].player_2;\n         dC = duels2Decrypt[index].decrypted;\n         tS  = duels2Decrypt[index].timeStamp;\n     }\n\n     function getPlayerWaiting() constant returns(address p, bool full) {\n         p = playerWaiting.player;\n         full = playerWaiting.full;\n     }\n\n     function getLastResult() constant returns(uint lD2) {\n         return results.length;}\n     function getResults(uint index) constant returns(address p1, string h1, address p2, string h2, uint r) {\n         p1 = results[index].player_1;\n         h1 = results[index].hand_1;\n         p2 = results[index].player_2;\n         h2 = results[index].hand_2;\n         r = results[index].result;\n     }\n\n\n}",1,実用的なコードで、標準的なスマートコントラクトの構造を持っています。コメントは多いが、芸術性は低いです。,
1534843,0x6b2090a34b12970618c90e55395b184797427790,false,false,,,,TOO_SHORT
1534880,0xa81bba1c57bf873e39799a0ea01b0eda7976a782,false,false,,,,TOO_SHORT
1534979,0x0cbc5774b20c266c34f2ae98c7b77423d51ba8c5,false,false,,,,TOO_SHORT
1535032,0x5ab970735fc4925ab5228c7143413a8defe18f2e,false,false,,,,TOO_SHORT
1535116,0xe5bcf05e3d361e375c8714e80440ace924cd10b2,false,false,,,,TOO_SHORT
1535241,0xe3dc9e0120aedc50adf2f24cfdb3e64c1f787736,false,false,,,,TOO_SHORT
1535259,0x93fad0f0160963caf3aac8ae439ee11a1f1013b3,false,false,,,,TOO_SHORT
1535318,0x6946e6aa0176b687bf248bd9b54ff0721d79842c,false,false,,,,TOO_SHORT
1535346,0x6aa9494c1eae4a3f5311e54a781af49dae4db798,false,false,,,,TOO_SHORT
1535536,0x3e3e6bb0dc9e2fa3956e37555550f2d29450bfdd,false,false,,,,TOO_SHORT
1535563,0xd0c258a818668850413b79061d3c9997d0a18c8e,false,false,,,,TOO_SHORT
1535694,0x2d70418cdd3e61373ea17bb48b9059f1828f1d0e,false,false,,,,TOO_SHORT
1535801,0x863d7f04e58c4af2edaa5564d07f5f3e86c25fbd,false,false,,,,TOO_SHORT
1535823,0xab6f059a138c84dca6357b1c7531bf3d61713b7b,false,false,,,,TOO_SHORT
1535893,0xf2750687c4d162653758d696aa2dfe8fecf9044f,false,false,,,,TOO_SHORT
1535931,0xe966652244b335a724a0465bb0b682e3885d3177,false,false,"contract Mortal {\n        address public owner;\n        function mortal() { owner = msg.sender; }\n        function kill() { if (msg.sender == owner) suicide(owner); }\n}\n\ncontract Thing is Mortal {\n        enum Mood { Agree, Disagree, Funny, Sad, Angry, Nothing }\n        // URL of the reaction - optional\n        string public url;\n        // Content of the reaction - optional\n        string public data;\n        // MIME type of the content - optional, default is text/plain\n        string public mimetype;\n        // Mood of the reaction - Mood.Nothing by default\n        Mood public mood;\n        Thing[] public reactions;\n\n        function thing( string _url\n                          , string _data\n                          , Mood _mood\n                          , string _mimetype) {\n                url = _url;\n                data = _data;\n                mimetype = _mimetype;\n                mood = _mood;\n        }\n\n        function react(Thing reaction) {\n                if (msg.sender != reaction.owner()) throw;\n\n                reactions.push(reaction);\n        }\n\n        function withdraw() {\n                if (msg.sender != owner) throw;\n\n                owner.send(this.balance);\n        }\n}",2,感情を表現する列挙型や反応のURLなど詩的な要素が含まれている。,
1536006,0x2e803c515428824d5501a0b982325a2d1413d0c8,false,false,,,,TOO_SHORT
1536061,0xa3d107ec75127de8de70a54cc324a22f88bb2c73,false,false,,,,TOO_SHORT
1536120,0xdcbab2b1c28b6f57c367f4eff0f5c7893400cc4d,false,false,,,,TOO_SHORT
1536210,0x32594e5425a4093c5059069c2c7fd0846bed110f,false,false,,,,TOO_SHORT
1536318,0xca6b6accdde2a7bc00ada96eac8cf8cab301d790,false,false,,,,TOO_SHORT
1536319,0xec5a070f98b1ffa67f5ecc0565e10390d2c0e8e2,false,false,,,,TOO_SHORT
1536451,0xc114c4d7415219873e90f62271fe9ff1931a45d0,false,false,,,,TOO_SHORT
1536533,0xabf24777f8cca9c4b3cb5abfc185157b04445f68,false,false,,,,TOO_SHORT
1536558,0xe79edd6708c35fe0043aedf2b520eb4ca8ca3c89,false,false,,,,TOO_SHORT
1536766,0x838359298630aa4b393d6a17a35984a65d784b46,false,false,,,,TOO_SHORT
1536834,0xa7043843cb59a7f5abef30da045f903d1739900e,false,false,,,,TOO_SHORT
1536905,0x6d002d80b6c858507c3559e7ddf1e132b8867bf2,false,false,,,,TOO_SHORT
1536936,0x3d2a88989736f05a8718a476ca75d432d45fc0c7,false,false,,,,TOO_SHORT
1537011,0xbc2a8a5fb13077c844f9e767384d50d0a0d5b3c1,false,false,,,,TOO_SHORT
1537055,0x8f375c4bc4f17ede5e7c712be9981065df355792,false,false,,,,TOO_SHORT
1537080,0xc218355731ba3d907a0660ec4eee684d641d3c36,false,false,,,,TOO_SHORT
1537092,0xc2eebef0c0241d046544fe5549bde7ecaabc96d1,false,false,,,,TOO_SHORT
1537127,0x97e32616a499b3600078c26959dc91702e4b6042,false,false,,,,TOO_SHORT
1537747,0x6a0619fe1dc6da1d9ee7d89f6d1686da2437f41d,false,false,,,,TOO_SHORT
1537952,0xcc0fcf0c67b5ecd27550bc20e3e3163bf0ab0bb0,false,false,,,,TOO_SHORT
1537982,0x472e55bbd5a92957a21267a4a025d823b7e89e25,false,false,,,,TOO_SHORT
1537987,0x747eabeb11d3d1f5daeeecb0788f0715c493b4db,false,false,,,,TOO_SHORT
1537989,0xe09bc42f9cd425dee55e71f581cedbe806df04b9,false,false,,,,TOO_SHORT
1538303,0xee8daca9428acabb062bda62c207a39af4ebd1d3,false,false,,,,TOO_SHORT
1538403,0xfa7b7afc214802854ac47fbfaff3267085e2d947,false,false,,,,TOO_SHORT
1538441,0x9949445dc7b3e125a429bf008664c9612fee7cbe,false,false,,,,TOO_SHORT
1538484,0x805ca90c4ad136c4d0bb090a01de501fcd28bf3f,false,false,,,,TOO_SHORT
1538515,0x29f613ff091bd47f2270375d4a9a51931e33b4ba,false,false,,,,TOO_SHORT
1538577,0xe557587c9cd6369f5282101825c064af1d67ff8c,false,false,,,,TOO_SHORT
1538671,0x45696b48e3484cc9df61e0f13fbee5107f3e0e4b,false,false,,,,TOO_SHORT
1538721,0x864348539aa265c0391be669e0299ec93ed3737c,false,false,,,,TOO_SHORT
1538845,0x0bc5ce0e8a8334fb0d64116d8f5aa9a0b9c55a1c,false,false,,,,TOO_SHORT
1538920,0xdd88c4d189585b650a3fe3d0e39147fcca59ec32,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   ROCK PAPER SCISSORS\n//   Challenge an opponent with an encrypted hand\n//   www.matching-ethers.com/rps                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n\n//          STAKE : 0.1 ETH\n//          DRAW : Full refund\n//          WIN : 0.198 ETH (house : 0.002)\n//          EXPIRATION TIME : 24 hour after duel starts (refreshed when one player reveals)\n//          If only one player reveals, he wins after 24 hour if the other doesn't reveal\n//          he will be paid automatically when other ppl play the game.\n//          If both player don't reveal and forget the bet, it is refunded (-house)\n\n//         HOW TO PLAY ?\n//         1- Send a encrypted Hand (generated on the game's website or by yourself)\n//         2- Wait for opponent (can cancel if you wish)\n//         3- Once matched, reveal your hand with the appropriate function and your secret\n//         4- Wait for your duel to resolve and the automatic payout\n\n//         ENCRYPT YOUR HAND\n//         Encrypt your hands on the website or\n//         directly with web3.js :  web3.sha3(secret+hand)\n\n// exemple results with secret = ""testing""\n//hand = ""rock"" :  web3.sha3(""testing""+""rock"")\n// 0x8935dc293ca2ee08e33bad4f4061699a8f59ec637081944145ca19cbc8b39473\n//hand = ""paper"" : \n// 0x859743aa01286a6a1eba5dbbcc4cf8eeaf1cc953a3118799ba290afff7125501\n//hand = ""scissors"" : \n//0x35ccbb689808295e5c51510ed28a96a729e963a12d09c4a7a4ba000c9777e897\n\ncontract Crypted_RPS\n{\n    address owner;\n    uint256 gambleValue;\n    uint256 expirationTime;\n    uint256 house;\n    uint256 houseTotal;\n    modifier noEthSent(){\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gambleValue) throw;\n        if (msg.value > gambleValue) msg.sender.send(msg.value-gambleValue);\n	_\n    }\n\n    struct PlayerWaiting\n    {\n        bool full;\n        address player;\n        bytes32 cryptedHand;\n    }\n    PlayerWaiting playerWaiting;\n\n    struct Duel2Decrypt\n    {\n	address player_1;\n        bytes32 cryptedHand_1;\n        address player_2;\n 	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel2Decrypt[] duels2Decrypt;\n    uint firstActiveDuel2; //index of first Duel 2 not decrypted\n\n    struct Duel1Decrypt\n   {\n	address player_1;\n        string hand_1;\n        address player_2;\n	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel1Decrypt[] duels1Decrypt;\n    uint firstActiveDuel1;\n\n    struct Result  \n    {\n       address player_1;\n       string hand_1;\n       address player_2;\n       string hand_2;\n       uint result; //0 draw, 1 wins, 2 wins\n    }\n    Result[] results;\n\n\n    mapping (address => uint) player_progress;\n    // 0 not here, 1 waiting, 2 2crypted, 3 1crypted\n    mapping (address => uint) player_bet_id;\n    mapping (address => uint) player_bet_position;\n\n    function getPlayerStatus(address player, uint option) constant returns (uint result)\n    {\n         if (option==0) {result = player_progress[player];}\n         else if (option==1) {result= player_bet_id[player];}\n         else if (option==2) {result = player_bet_position[player];}\n         return result;\n    }\n\n\n    mapping (string => mapping(string => int)) payoffMatrix;\n    //constructor\n    function Crypted_RPS()\n    {\n	owner= msg.sender;\n	gambleValue = 100000 szabo;\n        house = 1000 szabo;\n        expirationTime = 86400;   //24 hour\n        payoffMatrix[""rock""][""rock""] = 0;\n        payoffMatrix[""rock""][""paper""] = 2;\n        payoffMatrix[""rock""][""scissors""] = 1;\n        payoffMatrix[""paper""][""rock""] = 1;\n        payoffMatrix[""paper""][""paper""] = 0;\n        payoffMatrix[""paper""][""scissors""] = 2;\n        payoffMatrix[""scissors""][""rock""] = 2;\n        payoffMatrix[""scissors""][""paper""] = 1;\n        payoffMatrix[""scissors""][""scissors""] = 0;\n    }\n\n    function () {throw;} //no callback, use the functions to play\n\n    modifier payexpired2Duel{\n        if (duels2Decrypt.length>firstActiveDuel2 && duels2Decrypt[firstActiveDuel2].timeStamp + expirationTime <= now) {\n            duels2Decrypt[firstActiveDuel2].player_1.send(gambleValue-house);\n            duels2Decrypt[firstActiveDuel2].player_2.send(gambleValue-house);\n            houseTotal+=2*house;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_1]=0;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_2]=0;\n            duels2Decrypt[firstActiveDuel2].decrypted = true;\n            updateFirstDuel2(firstActiveDuel2);\n        }\n        _\n    }\n\n    modifier payexpired1Duel{\n        if (duels1Decrypt.length>firstActiveDuel1 && (duels1Decrypt[firstActiveDuel1].timeStamp + expirationTime) < now) {\n            duels1Decrypt[firstActiveDuel1].player_1.send(2*(gambleValue-house));\n            houseTotal+=2*house;\n            duels1Decrypt[firstActiveDuel1].decrypted = true;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_1]=0;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_2]=0;\n            results.push(Result(duels1Decrypt[firstActiveDuel1].player_1, duels1Decrypt[firstActiveDuel1].hand_1, duels1Decrypt[firstActiveDuel1].player_2,""expired"", 1));\n            updateFirstDuel1(firstActiveDuel1);\n           \n        }\n        _\n    }\n        \n\n    function cancelWaitingForOpponent()\n    noEthSent {\n        if (msg.sender==playerWaiting.player && playerWaiting.full)\n        {\n             msg.sender.send(gambleValue);\n             playerWaiting.full=false;\n             player_progress[msg.sender]=0;\n        }\n        else { throw;}\n    }	\n\n\n    //checks that the player is not already in the game\n    modifier notPlayingAlready \n    {\n          //one not resolved duel per player only\n          uint progress = player_progress[msg.sender];\n          uint position = player_bet_position[msg.sender];\n          if ( progress==3 && position==1 ) throw;\n          if (progress == 2 ) throw; \n          if (progress ==  1 ) throw; //no selfdueling\n          _\n    }\n\n\n    function sendCryptedHand(bytes32 cryptedH)\n    notPlayingAlready\n    equalGambleValue\n    payexpired2Duel\n    payexpired1Duel\n    {\n          if (!playerWaiting.full) \n          {\n              playerWaiting.player=msg.sender;\n              playerWaiting.cryptedHand= cryptedH;\n              playerWaiting.full=true;\n              player_progress[msg.sender]=1;\n          }\n          else\n          {\n               duels2Decrypt.push( Duel2Decrypt(playerWaiting.player, playerWaiting.cryptedHand, msg.sender, cryptedH, false, now) );\n                player_progress[playerWaiting.player]=2;\n                player_bet_id[playerWaiting.player]=duels2Decrypt.length-1;\n                player_bet_position[playerWaiting.player]=0;\n                player_progress[msg.sender]=2;\n                player_bet_id[msg.sender]=duels2Decrypt.length-1;\n                player_bet_position[msg.sender]=1;         \n                playerWaiting.full=false;\n          }\n\n    }\n\n\n    function revealRock(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""rock"");\n        reveal(hashRevealed, ""rock"");\n    }\n    function revealPaper(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""paper"");\n        reveal(hashRevealed, ""paper"");\n    }\n    function revealScissors(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""scissors"");\n        reveal(hashRevealed, ""scissors"");\n    }\n\n    function reveal(bytes32 hashRevealed, string hand) private\n    noEthSent\n   {\n\n        uint progress =  getPlayerStatus(msg.sender,0);\n        uint bet_id     =  getPlayerStatus(msg.sender,1);\n        uint position  =  getPlayerStatus(msg.sender,2);\n        \n\n        bytes32 hashStored;        \n        if (progress==2)  //duel not revealed\n        { \n            if (position == 0)\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_1;\n            }\n            else\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_2;\n            }\n        }\n        else if (progress==3 && position==1) //duel half revealed already\n        { \n                hashStored = duels1Decrypt[bet_id].cryptedHand_2;\n        }\n        else { throw;} //player has nothing to reveal\n\n	if (hashStored==hashRevealed)\n        {\n              decryptHand(hand, progress, bet_id, position);\n        }\n        else\n        {\n             throw; //wrong secret or hand\n         }\n    }\n    \n    function  decryptHand(string hand, uint progress, uint bet_id, uint position) private\n    {\n             address op_add;\n             bytes32 op_cH;\n\n         if (progress==2)\n         {  \n             if (position==0) \n             {\n                 op_add = duels2Decrypt[bet_id].player_2;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_2;\n\n             }\n             else\n             {\n                 op_add = duels2Decrypt[bet_id].player_1;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_1;\n             }\n\n              duels1Decrypt.push(Duel1Decrypt(msg.sender,hand,op_add, op_cH, false, now));\n              duels2Decrypt[bet_id].decrypted=true;\n              updateFirstDuel2(bet_id);\n              player_progress[msg.sender]=3;\n              player_bet_id[msg.sender]=duels1Decrypt.length-1;\n              player_bet_position[msg.sender]=0;\n              player_progress[op_add]=3;\n              player_bet_id[op_add]=duels1Decrypt.length-1;\n              player_bet_position[op_add]=1;\n\n         }\n         else if (progress==3 && position==1)\n         {\n              op_add = duels1Decrypt[bet_id].player_1;\n              string op_h = duels1Decrypt[bet_id].hand_1;\n              duels1Decrypt[bet_id].decrypted=true;\n              uint result = payDuel(op_add, op_h, msg.sender, hand);\n              results.push(Result(op_add, op_h, msg.sender,hand, result));\n              updateFirstDuel1(bet_id);\n              player_progress[msg.sender]=0;\n              player_progress[op_add]=0;\n          }\n     }\n\n     function updateFirstDuel2(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel2)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels2Decrypt.length && duels2Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel2=index;\n              return;\n          }\n      }\n\n     function updateFirstDuel1(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel1)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels1Decrypt.length && duels1Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel1=index;\n              return;\n          }\n      }\n\n     // in case there is too much expired duels in queue for automatic payout, \n     //I can help to catch up\n     function manualPayExpiredDuel() \n     onlyOwner\n     payexpired2Duel\n     payexpired1Duel\n     noEthSent\n     {\n         return;\n     }\n\n     //payout\n     function payDuel(address player_1, string hand_1, address player_2, string hand_2) private returns(uint result) \n     {\n              if (payoffMatrix[hand_1][hand_2]==0) //draw\n              {player_1.send(gambleValue); player_2.send(gambleValue); result=0;}\n              else if (payoffMatrix[hand_1][hand_2]==1) //1 win\n              {player_1.send(2*(gambleValue-house)); result=1; houseTotal+=2*house;}\n              if (payoffMatrix[hand_1][hand_2]==2) //2 wins\n              {player_2.send(2*(gambleValue-house)); result=2; houseTotal+=2*house;}\n              return result;\n      }\n\n     function payHouse() \n     onlyOwner\n     noEthSent {\n         owner.send(houseTotal);\n         houseTotal=0;\n     }\n\n     function getFirstActiveDuel1() constant returns(uint fAD1) {\n         return firstActiveDuel1;}\n     function getLastDuel1() constant returns(uint lD1) {\n         return duels1Decrypt.length;}\n     function getDuel1(uint index) constant returns(address p1, string h1, address p2, bool dC, uint256 tS) {\n         p1 = duels1Decrypt[index].player_1;\n         h1 = duels1Decrypt[index].hand_1;\n         p2 = duels1Decrypt[index].player_2;\n         dC = duels1Decrypt[index].decrypted;\n         tS  = duels1Decrypt[index].timeStamp;\n     }\n\n     function getFirstActiveDuel2() constant returns(uint fAD2) {\n         return firstActiveDuel2;}\n     function getLastDuel2() constant returns(uint lD2) {\n         return duels2Decrypt.length;}\n     function getDuel2(uint index) constant returns(address p1, address p2, bool dC, uint256 tS) {\n         p1 = duels2Decrypt[index].player_1;\n         p2 = duels2Decrypt[index].player_2;\n         dC = duels2Decrypt[index].decrypted;\n         tS  = duels2Decrypt[index].timeStamp;\n     }\n\n     function getPlayerWaiting() constant returns(address p, bool full) {\n         p = playerWaiting.player;\n         full = playerWaiting.full;\n     }\n\n     function getLastResult() constant returns(uint lD2) {\n         return results.length;}\n     function getResults(uint index) constant returns(address p1, string h1, address p2, string h2, uint r) {\n         p1 = results[index].player_1;\n         h1 = results[index].hand_1;\n         p2 = results[index].player_2;\n         h2 = results[index].hand_2;\n         r = results[index].result;\n     }\n\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心で、芸術性は低い。,
1538925,0xdcc5f666f31828fd378f0a91bd45b286599a4308,false,false,,,,TOO_SHORT
1538945,0x57d90b64a1a57749b0f932f1a3395792e12e7055,true,false,,,,0xfe1a96cd0bfb3245d83808b9aba6538576145920
1539006,0x6621864f9af52ee9734bba152f7f364c9fc4d293,false,false,,,,TOO_SHORT
1539037,0x45e42d659d9f9466cd5df622506033145a9b89bc,true,false,"contract tokenSpender { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\ncontract Nexium { \n	\n	\n	/* Public variables of the token */\n	string public name;\n	string public symbol;\n	uint8 public decimals;\n	uint256 public initialSupply;\n	address public burnAddress;\n\n	/* This creates an array with all balances */\n	mapping (address => uint) public balanceOf;\n	mapping (address => mapping (address => uint)) public allowance;\n\n	/* This generates a public event on the blockchain that will notify clients */\n	event Transfer(address indexed from, address indexed to, uint value);\n	event Approval(address indexed from, address indexed spender, uint value);\n\n	\n	\n	/* Initializes contract with initial supply tokens to the creator of the contract */\n	function Nexium() {\n		initialSupply = 100000000000;\n		balanceOf[msg.sender] = initialSupply;             // Give the creator all initial tokens                    \n		name = 'Nexium';                                 // Set the name for display purposes     \n		symbol = 'NxC';                               	 // Set the symbol for display purposes    \n		decimals = 3;                           		 // Amount of decimals for display purposes\n		burnAddress = 0x1b32000000000000000000000000000000000000;\n	}\n	\n	function totalSupply() returns(uint){\n		return initialSupply - balanceOf[burnAddress];\n	}\n\n	/* Send coins */\n	function transfer(address _to, uint256 _value) \n	returns (bool success) {\n		if (balanceOf[msg.sender] >= _value && _value > 0) {\n			balanceOf[msg.sender] -= _value;\n			balanceOf[_to] += _value;\n			Transfer(msg.sender, _to, _value);\n			return true;\n		} else return false; \n	}\n\n	/* Allow another contract to spend some tokens in your behalf */\n\n	\n	\n	function approveAndCall(address _spender,\n							uint256 _value,\n							bytes _extraData)\n	returns (bool success) {\n		allowance[msg.sender][_spender] = _value;     \n		tokenSpender spender = tokenSpender(_spender);\n		spender.receiveApproval(msg.sender, _value, this, _extraData);\n		Approval(msg.sender, _spender, _value);\n		return true;\n	}\n	\n	\n	\n	/*Allow another adress to use your money but doesn't notify it*/\n	function approve(address _spender, uint256 _value) returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n	\n	\n	/* A contract attempts to get the coins */\n	function transferFrom(address _from,\n						  address _to,\n						  uint256 _value)\n	returns (bool success) {\n		if (balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && _value > 0) {\n			balanceOf[_to] += _value;\n			Transfer(_from, _to, _value);\n			balanceOf[_from] -= _value;\n			allowance[_from][msg.sender] -= _value;\n			return true;\n		} else return false; \n	}\n\n	\n	\n	/* This unnamed function is called whenever someone tries to send ether to it */\n	function () {\n		throw;     // Prevents accidental sending of ether\n	}        \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1539071,0xdd4c98951f9d9f09b922f73f9dc773a3122eb7bc,false,false,,,,TOO_SHORT
1539158,0x9e0e68da54266efe4d6aa06400b1f08b38ea8056,false,false,,,,TOO_SHORT
1539209,0xdfa62648fec9d0105c549acb1161d16187f2e644,false,false,,,,TOO_SHORT
1539289,0xdce4e0b7d68fd4e70eb6bbb7fdc5a2fd4a818785,false,false,,,,TOO_SHORT
1539427,0xcdc572bcaa2bbb13fc49b74239091feb83929bd5,false,false,,,,TOO_SHORT
1539449,0xf1d1fcb420e729044b643e9917c2f42ebb71e1d1,false,false,,,,TOO_SHORT
1539683,0x6096d3810d30435b141da10ffbdcf5e33b2e3ce6,false,false,,,,TOO_SHORT
1539803,0x47c87fd909cfdcc17bd9f44e78ca259fe28a87c3,false,false,,,,TOO_SHORT
1540398,0xab468231eec75edfb1cc3adbc89773045fd0f227,false,false,,,,TOO_SHORT
1540403,0xda91bef6f93bbc26507093b840e97447e921bf9a,false,false,,,,TOO_SHORT
1540480,0x1cc651eabc8af1316a020d91d0aa90a902707995,false,false,,,,TOO_SHORT
1540584,0x5f350529a030d8e1988148f78048ad89cf28539c,false,false,,,,TOO_SHORT
1540585,0xd291de7c3230f5f0356260ca78bf409b1eec688d,false,false,,,,TOO_SHORT
1540597,0x39dc09811b08b8f70a44a3aba4309b879f386416,false,false,,,,TOO_SHORT
1540638,0x3109b103e8c15fb476206fc80c5faa9bca7f1fec,false,false,,,,TOO_SHORT
1540763,0x7a7ab56e37fe3b8889a5c7a5ec153771fe677d35,false,false,,,,TOO_SHORT
1540873,0xa337eafb75d9b964eac83e276ea52c66e24989f1,false,false,,,,TOO_SHORT
1540957,0x055d547a4ca2fce789d3c38a30a19c4c475c2d72,false,false,,,,TOO_SHORT
1541063,0x2eae09e43d3174c6c0f7adc34d06dec8b9180120,false,false,,,,TOO_SHORT
1541100,0x64c1ab8b92d15752a881749261d4f86a74e10c4d,false,false,,,,TOO_SHORT
1541103,0xeb17adcc8cf24d2d6813f50f647b613df01014a2,false,false,"contract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		https://d.ethereumlottery.net\n		ver: 1.0.0\n	*/\n	address private owner;\n	uint private constant fee = 5;\n	uint private constant investorFee = 50;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraDifficulty = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant minimumRollDiv = 10;\n	uint private constant difficultyMultipler = 1000000;\n	uint private constant investMinDuration = 1 days;\n	\n    bool public ContractEnabled = true;\n    uint public ContractDisabledBlock;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] investors;\n	\n	string constant public Information = ""https://d.ethereumlottery.net"";\n	\n	function ChanceOfWinning(uint Bet) constant returns(uint Rate) {\n		Rate = getDifficulty(Bet);\n		if (Bet < minimumRollPrice) { Rate = 0; }\n		if (jackpot_/minimumRollDiv < Bet) { Rate = 0; }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = jackpot_/minimumRollDiv;\n	}\n	function Investors(uint id) constant returns(address Owner, uint Investment, uint Balance, bool Live) {\n		if (id < investors.length) {\n			Owner = investors[id].owner;\n			Investment = investors[id].value;\n			Balance = investors[id].balance;\n			Live = investors[id].live;\n		} else {\n			Owner = 0;\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n	}\n	function dEthereumlotteryNet() {\n		owner = msg.sender;\n	}\n	function Invest() OnlyEnabled external {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if (msg.sender.send(value_ % investUnit) == false) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].valid == false) {\n				newInvest(a,msg.sender,value_);\n				return;\n			}\n		}\n		investors.length++;\n		newInvest(investors.length-1,msg.sender,value_);\n	}\n	function newInvest(uint investorsID, address investor, uint value) private {\n		investors[investorsID].owner = investor;\n		investors[investorsID].value = value;\n		investors[investorsID].balance = 0;\n		investors[investorsID].valid = true;\n		investors[investorsID].live = true;\n		investors[investorsID].timestamp = now + investMinDuration;\n		jackpot_ += value;\n		setJackpot();\n	}\n	function GetMyInvestFee() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].owner == msg.sender && investors[a].valid == true) {\n				balance_ = investors[a].balance;\n				investors[a].valid = false;\n			}\n		}\n		if (balance_ > 0) { if (msg.sender.send(balance_) == false) { throw; } }\n	}\n	function CancelMyInvest() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].owner == msg.sender && investors[a].valid == true && investors[a].timestamp < now) {\n				if (investors[a].live == true) {\n					balance_ = investors[a].value + investors[a].balance;\n					jackpot_ -= investors[a].value;\n					delete investors[a];\n				} else {\n					balance_ = investors[a].balance;\n					delete investors[a];\n				}\n			}\n		}\n		setJackpot();\n		if (balance_ > 0) { if (msg.sender.send(balance_) == false) { throw; } }\n	}\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function DoRoll() external {\n		reFund();\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid == true) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if (ContractEnabled == false || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if (value_ > 0) { if (msg.sender.send(value_) == false) { throw; } }\n		if (found == false) { throw; }\n	}\n	event RollEvent(address Player,uint Difficulty, uint Result, uint Number, uint Win);\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint difficulty_ = getDifficulty(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber * difficultyMultipler % difficulty_ == 0) {\n			win = Jackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n		}\n		RollEvent(msg.sender, difficulty_, bigNumber * difficultyMultipler % difficulty_, bigNumber * difficultyMultipler,win);\n		delete players[msg.sender][id];\n	}\n	function getDifficulty(uint value) private returns(uint){\n		return jackpot_ * difficultyMultipler / value * 100 / investorFee * extraDifficulty / 100;\n	}\n	function investorAddFee(uint value) private {\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live == true) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n			}\n		}\n	}\n	event PrepareRollEvent(address Player, uint Block);\n	function prepareRoll(uint rollID, uint seed) private {\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = msg.value;\n		players[msg.sender][rollID].game = JackpotHits;\n		RollCount++;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber);\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_/minimumRollDiv < msg.value) { throw; }\n		if (jackpot_ == 0) { throw; }\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if (players[msg.sender][a].valid == false) {\n				prepareRoll(a,seed);\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll(players[msg.sender].length-1,seed);\n	}\n	function () {\n		PrepareRoll(0);\n	}\n	function reFund() private { if (msg.value > 0) { if (msg.sender.send(msg.value) == false) { throw; } } }\n	function OwnerCloseContract() external OnlyOwner {\n		reFund();\n		if (ContractEnabled == false) {\n		    if (ContractDisabledBlock < block.number) {\n		        uint balance_ = this.balance;\n		        for ( uint a=0 ; a < investors.length ; a++ ) {\n		            balance_ -= investors[a].balance;\n		        }\n		        if (balance_ > 0) {\n                    if (msg.sender.send(balance_) == false) { throw; }\n		        }\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner {\n		reFund();\n		if (feeValue == 0) { throw; }\n		if (owner.send(feeValue) == false) { throw; }\n		feeValue = 0;\n	}\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if (!ContractEnabled) { throw; } _	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1541250,0xadddd4b2b5aa48f75b8e9e37fc6654619eea7d9f,false,false,,,,TOO_SHORT
1541253,0xb1757429f202647b7378aaac6fdcb5778837d33a,false,false,,,,TOO_SHORT
1541285,0x2c984415e4df7f10763b35642fbc20c6987f6faf,false,false,,,,TOO_SHORT
1541329,0x8265c648c1c71fcd54944a271e505bd988259d82,false,false,,,,TOO_SHORT
1541409,0x001a1e35a6515367eeedb0712212266c358c9ba5,false,false,,,,TOO_SHORT
1541437,0xa646aa672a643dcd8ffb985b2ffb7858da7da9d2,false,false,,,,TOO_SHORT
1541454,0xa72cc87724fa680897a4ee451a49237cfbd7fb1e,false,false,,,,TOO_SHORT
1541465,0x77c987961e71b97682140510e61b401ef160481f,false,false,,,,TOO_SHORT
1541533,0x59ffb4fdbb6d924ea911d4d9bc0a25551bd1ebb4,false,false,,,,TOO_SHORT
1541614,0xf9bc265e77028f18d6def03efae18783ed54c46d,false,false,,,,TOO_SHORT
1541634,0x3e8a9fff493a00aef4fc19d71e0ca8fd1728fb59,false,false,,,,TOO_SHORT
1541653,0x9158057818d8a539cdcae1c9f48bc0c31eddd1b6,false,false,,,,TOO_SHORT
1541734,0x2956f749e2705117e5972c05d309c5c2972840ee,false,false,,,,TOO_SHORT
1541752,0xfd06eb412311ed74e1a2e60e73bf3ac278d5bbff,false,false,,,,TOO_SHORT
1541786,0xc6553ebc4712a8a5b40e80daf4e3a111e7ccc44e,false,false,,,,TOO_SHORT
1541816,0xca1af597b470c8e0027dfe1574a678aaed9816d2,false,false,,,,TOO_SHORT
1541994,0x071c6c9076d8f3f8c840f955cd022deab1357996,false,false,,,,TOO_SHORT
1542071,0x83b3ec02f20cfbf5fc03cf9db92d6439f1b48470,false,false,,,,TOO_SHORT
1542098,0xdcedc348911faa3b07fb5221bdb86af365556a6e,false,false,,,,TOO_SHORT
1542228,0xddc6a22345f030b14c9ff117f56d78dce2135092,false,false,,,,TOO_SHORT
1542297,0xdf850630ff6b4622040912f560014a5544e81635,false,false,,,,TOO_SHORT
1542310,0xc8e95a892585fdcf90a948db11197fe6714bf41f,false,false,,,,TOO_SHORT
1542457,0x68a288fd086b9142e28192e3d54c24e614c22165,false,false,,,,TOO_SHORT
1542540,0x8a8262ef2171510d7481170b8b4c0ebd54f71fe0,false,false,,,,TOO_SHORT
1542575,0x7dcfd650313ae8edbf13246ec14df9c5a30ead28,false,false,,,,TOO_SHORT
1542700,0xbf7e0508d4783389aace6e36653e497c98fe7d64,false,false,,,,TOO_SHORT
1542778,0x31dd548d57560a160fb482f6d211fff2d7d34bce,false,false,,,,TOO_SHORT
1542836,0xb477d59939afbb381713354aa28d4e23751314d6,false,false,,,,TOO_SHORT
1543335,0x457612ac2e509e34761955ec24cdf1b01681b357,false,false,,,,TOO_SHORT
1543375,0x620fcf3f1f3daaed7ddde7b6f69c38433791fddf,false,false,,,,TOO_SHORT
1543548,0xc9ffbb1b93105679354a8b947e2e7cfde182b24f,false,false,,,,TOO_SHORT
1543789,0xed8071af54ebe35389c57eed4ec3d12631710e66,false,false,,,,TOO_SHORT
1543792,0x864c05913596393f9bb45488b1d4082aa2143cb4,false,false,,,,TOO_SHORT
1544004,0x531a067a482c4945aaeedbde80b9b9ae3e695c8b,false,false,,,,TOO_SHORT
1544096,0x9ee80697b671e248629682bbe84b93d955ba8fcb,false,false,,,,TOO_SHORT
1544281,0x9e921a69d9fe598d5cd2b58557a4c755ab06dc38,false,false,,,,TOO_SHORT
1544556,0x18fffe6302bacb49461fe3e0f7b0df563c62cece,false,false,,,,TOO_SHORT
1544663,0xeb2ec06c245319ff49c22fba11449fa0230a0e4c,false,false,,,,TOO_SHORT
1544797,0xca622216b51002b520cad38c691b3ebdacdb779e,false,false,,,,TOO_SHORT
1544951,0x53e8e1c163ee609ae7261bf31e1b046623fa69c5,false,false,,,,TOO_SHORT
1545048,0xfbd0002fbd19ca7994b9237e1f05a98ac16e5a03,false,false,,,,TOO_SHORT
1545271,0xc5938057ecb6329d104b99af3062850ee699a4c1,false,false,,,,TOO_SHORT
1545541,0xa91b1dc07ac33e707b830dd60c0244d9e0421ae4,false,false,,,,TOO_SHORT
1545584,0x84006ddc0f5f95e25fc2523ebe30ce0a5941a169,false,false,,,,TOO_SHORT
1545704,0xb732f6b0f634f3d28ede5e4f4c322a7db2d2f9c3,false,false,,,,TOO_SHORT
1545712,0x687b08d429e57c7e466de7b0affb15f64289fa73,false,false,,,,TOO_SHORT
1545854,0x8543c7cfc463e599114e10458d5ecad3ad1e47fe,false,false,,,,TOO_SHORT
1545888,0x2d1b4454ab61bc4849d2cee2e62a02ea6a4b37d5,false,false,,,,TOO_SHORT
1546046,0x71cb33c193f76568354e9b0721d2258f70f975cd,false,false,,,,TOO_SHORT
1546059,0xb01f234d106d6f11912be3c6f511e3c0d7fbdd97,false,false,,,,TOO_SHORT
1546112,0xcc6b82d178b0b9030c3c5a6c1c98cffca05cec22,false,false,,,,TOO_SHORT
1546160,0xcae33f0030ac527e90270c0bc2c4715a08a04d58,false,false,,,,TOO_SHORT
1546414,0x5c27ca7a0f640c37f5f1685668657a60d9f5c0aa,false,false,,,,TOO_SHORT
1546503,0x3f48fbbe2addd9ed46376f4dd468bcdbbc95a43f,false,false,,,,TOO_SHORT
1546525,0x323f60c6b181192cfca2743611bab6b3f9076359,false,false,,,,TOO_SHORT
1546526,0x5c401941bf4e24cba2e0e1a2328390d4cb99820a,false,false,,,,TOO_SHORT
1546735,0xb41c38c4f3c4338674261c8a0c926f7348466c53,false,false,,,,TOO_SHORT
1546743,0x4c49e82fcae27b766c6f2c354f0b3ed4f6a12ff4,false,false,,,,TOO_SHORT
1546751,0x92a23857c0de3e39f71be943e6f198eb72980aa8,false,false,,,,TOO_SHORT
1547030,0x285a56d6304d0e6e1ddfc72c3761dd3a51cb0462,false,false,,,,TOO_SHORT
1547255,0x56574de1cdb3da020c851f4c3bf36b326318651c,false,false,,,,TOO_SHORT
1547467,0x3501121d4bdd078f6094185ab89740dfcae4c232,false,false,,,,TOO_SHORT
1547482,0x10bd190fd03175755d551b369f000b9b004ef423,false,false,,,,TOO_SHORT
1547552,0xc1b5628ad849aff0c4a57265e2ffbb1e0d031d69,false,false,,,,TOO_SHORT
1547752,0x8810ae2f3105616de09d4b7e80013f47e537c3dd,false,false,,,,TOO_SHORT
1547760,0x2351ac65d9991a3599f937a8973092311e5c50fa,false,false,,,,TOO_SHORT
1547866,0xb09ee3ad7a8652302309358abb9e1fdbdb06f4bf,false,false,,,,TOO_SHORT
1547902,0x3b3bb449d01f7fb8381fd7eee981665a60ebd215,false,false,,,,TOO_SHORT
1548012,0xb61749fa363bddcf45d0b9a424be33a5100f0a80,false,false,,,,TOO_SHORT
1548069,0x856e0dcc46f33035387c89d356d7690c1710500a,false,false,,,,TOO_SHORT
1548070,0x56d20f19955591762a8e53c8ddd7e18a5679ea4a,false,false,,,,TOO_SHORT
1548096,0x55c60cf2d3f86c0b1da384c67b60cc31561be1f3,false,false,,,,TOO_SHORT
1548125,0x5b47abb77fe862027c4688e6872976a55a5860de,false,false,,,,TOO_SHORT
1548186,0x51eb232e23c2232f0d03f537d0ae69418ef0cacc,false,false,,,,TOO_SHORT
1548201,0x9463ebf132d972f355cb3eab7400f2526ec02711,false,false,,,,TOO_SHORT
1548215,0x8c47fa46d67744cade3f0af5fb084bbb1bbf5bb4,false,false,,,,TOO_SHORT
1548233,0xeb1ad7f6ca7a065f2bcb380c34ffe61e1b6b9af2,false,false,,,,TOO_SHORT
1548384,0xf0e54e94f2aca3c72c7f3f413551d90c8fb5c645,false,false,,,,TOO_SHORT
1548391,0xe9f64118a6f69dd55b5b49b2a260ad0bf63a1fac,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1548481,0x11ba31aeddb5fbe497f0d4d883b468992c5803bb,false,false,,,,TOO_SHORT
1548579,0xf1143a7de2ab1ac98a128dc506f2ec6b2e8ced10,false,false,,,,TOO_SHORT
1548697,0x56231a9e079c9c10777a08f99f6e3439c02135a6,false,false,,,,TOO_SHORT
1548737,0x409c9d5a93bad62618baa0909f238eaa481a1b7d,false,false,,,,TOO_SHORT
1548927,0x0138a39683ae1c441ecc8b422ee96bab44314f5d,false,false,,,,TOO_SHORT
1548940,0x9d2f16bee41b8b17764b6f4b567cbf005e72f421,false,false,,,,TOO_SHORT
1548975,0xc77038cf0868d5e9f547198fd40f8eb7b120c5b6,false,false,,,,TOO_SHORT
1549148,0xdf2b0c4fb6ab13cc720eacb4a460758ed3aa8422,false,false,,,,TOO_SHORT
1549348,0xecf7e269d7e3cc22edcf4aab9924977d8c21404e,false,false,,,,TOO_SHORT
1549387,0x28476fe827120ae6a8831ea9583b2309693050e5,false,false,,,,TOO_SHORT
1549611,0x4f34e0b05a72869e594167bb6f7bc3b9745faeab,false,false,,,,TOO_SHORT
1549846,0xffa7fe31de5f4502e71986fc0ceadc755a40c790,false,false,,,,TOO_SHORT
1550081,0x69206f41d7ff9e09dbcd51d3ac3f7639d822410e,false,false,,,,TOO_SHORT
1550141,0x31d7b01164104a78624bb5551a5bcecf11cc9c26,false,false,,,,TOO_SHORT
1550158,0x7be41af705fa3a88d5ec17aa1ba7180330317fa5,false,false,,,,TOO_SHORT
1550185,0x5c5ecb222a0271810052736bc66a897bd96355e9,false,false,,,,TOO_SHORT
1550271,0x32ff51211ad452f29776c67f23625d5c49e40114,false,false,,,,TOO_SHORT
1550296,0xa823939d30a1e2a79921bc938f3201044aa73ce6,false,false,,,,TOO_SHORT
1550310,0x38a801e2c992b70a43d06af9ca576aeba392d263,false,false,,,,TOO_SHORT
1550358,0x66e41da5f86ff00cfeb0b7fbafb19e14d7081eeb,false,false,,,,TOO_SHORT
1550416,0x681945555974a106ed76972f686f0c4f928c363a,false,false,,,,TOO_SHORT
1550456,0x405ca100c4e247e35c00145c1134672c4792a3ca,false,false,,,,TOO_SHORT
1550563,0xe1d9a94de04515666f760fbe87daecf6258a33a3,false,false,,,,TOO_SHORT
1550781,0x3f37842e6a6cce6b4caf6b3bddbbc9b1994368c3,false,false,,,,TOO_SHORT
1550983,0x38df5cf60047afd374fa11584ea13fbb8efe8350,false,false,,,,TOO_SHORT
1551001,0x192bc7b427eb0c61ee99ec8e2fa668a55fb92d46,false,false,,,,TOO_SHORT
1551021,0x15aa0e150724275060ade64ac85754a6bdebd295,false,false,,,,TOO_SHORT
1551050,0x8408a10e697fd517e4c9756532b4a8870c28e3d5,false,false,,,,TOO_SHORT
1551104,0x8d555ca44289da8a47d93bf3c7e5ab8123a48ae9,false,false,,,,TOO_SHORT
1551112,0x2bcc81c94ef3b400526dc33f8e5e1449c788cc42,false,false,,,,TOO_SHORT
1551259,0x1ff985ea6431a44a5005b223fcbaf60b781ec889,false,false,,,,TOO_SHORT
1551265,0x0dbef881f0bfc92dd5f06c3b2d6c1a68fec9e91a,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1551412,0xb4531035835f86286807cc154c2f26c0283e4c07,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1551592,0xc0e8520a08f8d3575c985e3113189c044b9f478f,false,false,,,,TOO_SHORT
1551612,0xa86adee19aab415cb31363f2390ab6e5e8acd682,false,false,,,,TOO_SHORT
1551677,0xcb732c117998233ad74c3d483e94a1bb8baf4e7f,false,false,,,,TOO_SHORT
1551695,0xd2825bfe02be5ef6a122d2611c54de15f1a01b1e,false,false,,,,TOO_SHORT
1551822,0xf9250f22e4f6ef528aec6bf1cd4cb012dd5169d4,false,false,,,,TOO_SHORT
1551836,0x566215932b8e7d508b6141660acc00ed904c76ca,false,false,,,,TOO_SHORT
1551928,0xa168302227b6680f89550ee59036118b70ffcdc3,false,false,,,,TOO_SHORT
1551963,0x2ce979720515f95343d2d6668d6d40129a57d987,false,false,,,,TOO_SHORT
1552144,0x729642a6f8bef6ce1ede584bc38c8fad38c0ce1c,false,false,,,,TOO_SHORT
1552257,0xce6b30f957759ac3537bfe8e80cb7f0ec17a9a9c,false,false,,,,TOO_SHORT
1552258,0x8e3144a8e11bef195e4bb2e4a281a37e8cfb72c7,false,false,,,,TOO_SHORT
1552276,0x5d9b8fa00c16bcafae47deed872e919c8f6535bf,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1552283,0xc41179bb2a854dded8b777cbc027bff825b44b4a,false,false,,,,TOO_SHORT
1552316,0x9245c744e644e4f311b6e5dffc3e766f400f3d55,false,false,,,,TOO_SHORT
1552431,0xf1ef8f656c7342f5e5bce3338b205eaab869fe86,false,false,,,,TOO_SHORT
1552448,0x571d5db1497306df75453e8f477578d429a50577,false,false,,,,0xe966652244b335a724a0465bb0b682e3885d3177
1552455,0x41d8d3287c4c58b237d36fc007460fa6a9452070,false,false,,,,TOO_SHORT
1552583,0x8aab28801de3bb9dc96c6c149b88b7e69008f08e,false,false,,,,TOO_SHORT
1552592,0xb2ab5ca5d605e3cd28fb46921d6ae0e649ba4189,false,false,,,,TOO_SHORT
1552603,0xaf32279149101fa3f6e3d1768f051593049dcd9f,false,false,,,,0x84da883d038a04a2d53dba54834b6a62f55a6028
1552661,0xfeff70f2a660c211e74dfdcfa5189870fa7f0d22,false,false,,,,TOO_SHORT
1552704,0xb8c09c774b4f72b09d6bca657a6e515dd3cd29ef,false,false,,,,TOO_SHORT
1552751,0xfb793244c0842385afd7d8134440b090aa9d893e,false,false,,,,TOO_SHORT
1552769,0x4dc7c68f1b53ffc32cafc2736513c7d9fc435748,false,false,,,,TOO_SHORT
1552784,0x86320b4408c6d400a303bb2ba1b474c45c09cb58,false,false,,,,TOO_SHORT
1552785,0x3e3cfa3dadc81597a1a6cc54d63aab446bb1218c,false,false,,,,TOO_SHORT
1552808,0x1ade11d0d413833c1edf575b3a345a1347c4d2d3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1552808,0x9efe8df0c99d7716a8af769a5ec28c852fa0eda4,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1552808,0xec4760ffa97e66856671e561df03566f47b7a64e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1552851,0x35be7d37901f85d239daf72ed15074043face6f1,false,false,,,,TOO_SHORT
1552854,0x0393845ae96891df64c6b9b7aee991cffe156a20,false,false,,,,TOO_SHORT
1552898,0xe17eb1dec8fd66fc8e936cecf429846f7a5fee4c,false,false,,,,TOO_SHORT
1552936,0x48cd1818f23483a230714c602eb81b4a9ab53bb0,false,false,,,,TOO_SHORT
1553100,0xa19d2c7fc8d9afc40ce235119b60057329f02196,false,false,,,,TOO_SHORT
1553139,0x53d6e0e264d77ea9ac3b686a9ece2f9242255fbc,false,false,,,,TOO_SHORT
1553456,0x5bf2860a1964e4332c8fc1327660bfd52e769b92,false,false,,,,TOO_SHORT
1553466,0xa37f61de144b68c17a7ccf27321bf03cf4fea13b,false,false,,,,TOO_SHORT
1553559,0x003b29e16f6bc824a39cfb4d73b58c4affcf12ff,false,false,,,,TOO_SHORT
1553648,0x2f17e27e22e371d78470cc6096fe6a9b735932c8,false,false,,,,TOO_SHORT
1553866,0x2bbfaa5372f6a46d731c05103ec766eb22fd74ea,false,false,,,,TOO_SHORT
1553893,0x6906c00472ee300a9651457b1fff04e193aa1cc5,false,false,,,,TOO_SHORT
1553954,0x9ee59d3d99b840eda8c0279b7726d7b0739397fb,false,false,,,,TOO_SHORT
1553979,0x251cf9dd0ae301bca9e142aaf2091351b9de4df3,false,false,,,,TOO_SHORT
1554044,0x65f01b347aff371e93c540219a23c484a339f577,false,false,,,,TOO_SHORT
1554067,0x362ca78cf03c2b55146a3ec07ac78de1d53e8c54,false,false,,,,TOO_SHORT
1554409,0xabe1eba1030279ae58b2a4c5da74f2a61b18a115,false,false,,,,0xe966652244b335a724a0465bb0b682e3885d3177
1554419,0x4671ebe586199456ca28ac050cc9473cbac829eb,false,false,,,,0xe966652244b335a724a0465bb0b682e3885d3177
1554574,0xb90d25fd986b75910e65cebe2c797f093d528d78,false,false,,,,TOO_SHORT
1554603,0x0787cb9c9617cafc67660bd1c0710247401674ea,false,false,,,,TOO_SHORT
1554677,0x49cd2520365820f63ec1b2f5d95b369271810840,false,false,,,,TOO_SHORT
1554678,0xedf977f12c653f446e80a5e1b6c20ff57b5b64aa,false,false,,,,TOO_SHORT
1554788,0xfcddb96db045e5fbcca8b87589128e1fa9705ba6,false,false,,,,TOO_SHORT
1555061,0xf7574661b074a69b145c25caf64ab593139bb4cc,false,false,,,,TOO_SHORT
1555455,0x9f06635901810f66c6885042eaf03ddeae3129d9,false,false,,,,TOO_SHORT
1555536,0x625c2b599529f858c7e92dab736d4e847ef1c350,false,false,,,,TOO_SHORT
1555578,0x37e24a0de36821c32bf119f04ad37c661105c7b6,false,false,,,,TOO_SHORT
1555603,0x6c7c4b77308b1249de2186b22730859686912595,false,false,,,,TOO_SHORT
1555737,0xe46f88f1cabf54ad2a992e66a943e48c1b42e5cb,false,false,,,,TOO_SHORT
1555746,0x281d4c7dee4ec1eb75daa6c283be9e6bbd510685,false,false,,,,TOO_SHORT
1555808,0xf6963d77383798dd0dc76009718092f07d89089c,false,false,,,,TOO_SHORT
1555891,0x35737db9be26d2d12c177da0e61811bd4b033f67,false,false,,,,TOO_SHORT
1556153,0x0c392d32e14a054223c940affc941f4ea6cfe548,false,false,,,,TOO_SHORT
1556242,0x3041c64b5cd7f8251684de9253e775601546ca82,false,false,,,,TOO_SHORT
1556332,0xe769e3104b160b583776c8dfa743c467fab53d48,false,false,,,,TOO_SHORT
1556404,0xd06edefa7cd3feabf639b541a3ab45722e8316dc,false,false,,,,TOO_SHORT
1556405,0xbec2cbc06118adc49884b0f1235d902ba55fdbb9,false,false,,,,TOO_SHORT
1556406,0x4a94e3102f130feabee845646f891982f6902dae,false,false,,,,TOO_SHORT
1556407,0xe999f8471307b81cd89c8a937777a323acbac1f2,false,false,,,,TOO_SHORT
1556492,0x9006dd7ee5a60609d1eef25d73bd43c19a112f64,false,false,,,,TOO_SHORT
1556515,0xa23a29e43755696c0ee3177b3fa36092caab2da5,false,false,,,,TOO_SHORT
1556708,0xf0b8c4feb5df197674af805e4b04010b6d5fcc01,false,false,,,,TOO_SHORT
1556764,0xf881425b5fb7baeca02e06fc5ead59f70cc94dcf,false,false,,,,TOO_SHORT
1556776,0x063d09bcd46a14b1d39a2480d7d244837efce8bf,false,false,,,,TOO_SHORT
1557040,0x090c7e086cfc0d66443f40193c144a144e928478,false,false,,,,TOO_SHORT
1557041,0xc8a2f4df90a6c11af0bfa11817d60bad760f2c02,false,false,,,,TOO_SHORT
1557122,0x5829cb154cbbab631d74a11414286351128edf9b,false,false,,,,TOO_SHORT
1557244,0xc6e1c9d5e178d7919947747b30631c48aa4093a1,false,false,,,,TOO_SHORT
1557303,0xeb1405440f19fc604553d24299e2a5e02063864c,false,false,,,,TOO_SHORT
1557526,0xe0f92ef94ade3215cfa2213aec23f1452ae2813e,false,false,,,,TOO_SHORT
1557557,0xeb0a1b3cafb7d375767e0e742f33efa7583bc9f0,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1557584,0x131c8e15afee2efa7cc53648beff583a5621f087,false,false,,,,TOO_SHORT
1557666,0x13b2135c71cb3797e5fc8c46770553086414fd68,false,false,,,,TOO_SHORT
1557684,0x974a6e2035d17ce557cdb6451960a1dd2645ed9a,false,false,,,,TOO_SHORT
1557742,0x00a13cf8013f8855fb56f1646eb1cd7ad612c04f,false,false,,,,TOO_SHORT
1557787,0x2053a75809eb9aabb71c42fde10c0474f5a5c0cb,false,false,,,,TOO_SHORT
1557789,0xe12d125af152067df935130d1415b36eec260d87,false,false,,,,TOO_SHORT
1557794,0x5e48a896ecb291ec5697c15f7b7fefc49f192b5d,false,false,,,,TOO_SHORT
1557879,0x7caf5d388a0faef7da384a049bd88e1ce8f0ac6a,false,false,,,,TOO_SHORT
1557923,0x2b3ab2fdb0b9111d25ebd6724bd1b56c04b80796,false,false,,,,TOO_SHORT
1558035,0x7f9d0242b144f0d53da95c22b9b4db5c767b99fe,false,false,,,,TOO_SHORT
1558093,0x03f8dd8b9df92660a379d25db4761130cc0f7732,false,false,,,,TOO_SHORT
1558126,0xa945a2b1c653287495b5e6d168ba11a32ec5cbff,false,false,,,,TOO_SHORT
1558127,0x83a2e1ce56b67eb65e848c2a08b2a39c9a7a4448,false,false,,,,TOO_SHORT
1558214,0xba1e96dc9deb349e31cd70b3a3ac8767dd16ac31,false,false,,,,TOO_SHORT
1558279,0x96741f3ed4df6f16e6fdbbeb6c11bc79cb42aeff,false,false,,,,TOO_SHORT
1558353,0x3b43f9f6ac65af404e89adc0b7321a85c92a51c0,false,false,,,,TOO_SHORT
1558375,0x86a12f8f6805cfdd2147f01603bc079d78b8bba9,false,false,,,,TOO_SHORT
1558419,0x6433b912bf1ca054d88d16418e5773c3d3a50ec9,false,false,,,,TOO_SHORT
1558452,0x7e40cc11c05abc3789d63edbb330db37318cc6a7,false,false,,,,TOO_SHORT
1558532,0xb3f6e08fd2b192fff3ac7073bfd625667fcaeb39,false,false,,,,TOO_SHORT
1558672,0x0e514dd1047d427b619bafb08704e031eccce521,false,false,,,,TOO_SHORT
1558833,0x6e7497b40cd39241651fd1032579df7da11b35d7,false,false,,,,TOO_SHORT
1558926,0x2573f7ed35f36318480b554695c1053e6ce50581,false,false,,,,TOO_SHORT
1558927,0xee4717731d50dc3a20ddddb4abcf569d8ae9a644,false,false,,,,TOO_SHORT
1558956,0xdd1bf65303cab3f5f5b7ffa1f678b987a19c9d34,false,false,,,,TOO_SHORT
1558961,0x7faa9ab7a1fb29b3ebcdbd1f16919e9ef3905100,false,false,,,,TOO_SHORT
1559095,0x506e31c8fc5ed48cc023f4a683d5911723f36797,false,false,,,,TOO_SHORT
1559324,0xe33351b8c2478b857d6bd96b65f8071dde547cb8,false,false,,,,TOO_SHORT
1559333,0x8f5bec485138eebd33cee09a7d98f8fd41add100,false,false,,,,TOO_SHORT
1559364,0xaa2dca57cc45cc9ea4d857d3b38c38b2e4e32b1c,false,false,,,,TOO_SHORT
1559415,0xa80a1ed0f6ae5dd3d8c4c266bac7095d470df624,false,false,,,,TOO_SHORT
1559575,0x70019016856550e5b13eed713e6589fae68b3141,false,false,,,,TOO_SHORT
1559848,0x6573751117e1e692c10d057318679e55fefd83a8,false,false,,,,TOO_SHORT
1559949,0xa10bc62f8649b36c4726d79f1303ba9a1fc3d88d,false,false,,,,TOO_SHORT
1560015,0xc296f2538a4bb88f5e29ee5beecaeea004de73fb,false,false,,,,TOO_SHORT
1560033,0x1d00fbbe45fb74b9e020fc5086f6ef0ccfaed7a3,false,false,,,,TOO_SHORT
1560404,0xdd0498927a7ec387af2e5e90b791789aeb8990b2,false,false,,,,TOO_SHORT
1560481,0x75dfb1e3885d2e51729e7d04ec137a9ed3a32d28,false,false,,,,TOO_SHORT
1560507,0xc625fe5877e1e42ea4c687670e9df023bde9dab6,false,false,,,,TOO_SHORT
1560576,0x78ed09592bae583527dbeda4b46ad690fb9a73ec,false,false,,,,TOO_SHORT
1560682,0xc078288ad1325f2af7d1decb74830c072563e087,false,false,,,,TOO_SHORT
1560716,0x7f98beb4f3c6891dc3c056c689414530c21a5267,false,false,,,,TOO_SHORT
1560720,0x15995af69a871ba16da282888e5654daeb3deb4a,false,false,,,,TOO_SHORT
1560801,0xf820349c0897fc6eedb181d8e1f5740d0f62aed1,false,false,,,,TOO_SHORT
1560954,0x10ffeec57023afc81904bdc415372de9ee86fd5a,false,false,,,,TOO_SHORT
1561020,0x770e5a41636fad5f5e19eccddc74619792647ef6,false,false,,,,TOO_SHORT
1561274,0x13b56a0019cb0cd9d7fa0b878f2c4e4854ba8800,false,false,,,,TOO_SHORT
1561517,0x3ff0085df9547466e23d87a2352722ab7ce43815,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1561592,0xffb3c7b47387a82dbce5f6253c38ef2dd38f4f08,false,false,,,,TOO_SHORT
1561808,0x19aa1adf30d179ef1ee9da96270435b17793bfd6,false,false,,,,TOO_SHORT
1561961,0x6c0f5b168d854d561e03770686e76965a62be784,false,false,,,,TOO_SHORT
1562019,0x0a3bd1623ee6a210554408ff0c9948bab372ea79,false,false,,,,TOO_SHORT
1562033,0x01c6be83ef89e9fc598ca5826db3fcb85257db07,false,false,,,,0xb8869c5f264739dde064941c372c551ec47aab44
1562597,0x0abb8ff28d24026360b8a950318279c7bbc4bb6a,false,false,,,,TOO_SHORT
1562686,0xc03b99d0ea3495ba54d9014a7b8167034b3715e3,false,false,,,,TOO_SHORT
1562696,0x3b0bf35eceb106ef6c9c321875c0a048e2cc97ff,false,false,,,,TOO_SHORT
1563211,0x0d9204682641c8ab3e0b85f958f4ad6f3ba4e507,false,false,,,,TOO_SHORT
1563279,0x735d390097bc89f13c5b257d0fdfacec7d43b4cb,false,false,,,,TOO_SHORT
1563303,0xba3f206ff0d79be2c40168548e76927c67085835,false,false,,,,TOO_SHORT
1563324,0xd508528179a707e26cb8ad23875e6d2e0c2a2fbc,false,false,,,,TOO_SHORT
1563423,0x459bc00bbecb8f5de1b4a70c4c79fae223d97b12,false,false,,,,TOO_SHORT
1563531,0x8e2f3c58306f621d957c2a05e1694bf27dee2552,false,false,,,,TOO_SHORT
1563693,0x5a2c110d2ae3834bde38aa4db994f085469c85db,false,false,,,,TOO_SHORT
1563774,0x50d83e5c675fa9ac61adadd7e7908bb8bd8fa816,false,false,,,,TOO_SHORT
1563778,0x673f332fe90a74a6d93edf6906e2334e0dc9a156,false,false,,,,TOO_SHORT
1563833,0xfc7c09af65bd8126e6068f3d795ad58ac99b8087,false,false,,,,TOO_SHORT
1564023,0x120059478eb4ce054fcdef34c6d990f8dfeff6fa,false,false,,,,TOO_SHORT
1564071,0xa476ce5fdb6dadf6bb2f85fc7a113d70a3ab3911,false,false,,,,TOO_SHORT
1564116,0x617b622bf8572be03fb319f012d41b0e8bd36ad4,false,false,,,,TOO_SHORT
1564212,0x2608e156754d8ebe26c6d95016f058555570d089,false,false,,,,TOO_SHORT
1564227,0x9477d43c08595f6d7f2d7912e5e31bb22e722cda,false,false,,,,TOO_SHORT
1564237,0x0a7256c3224eb7634d05c7250b748a0efb301641,false,false,,,,TOO_SHORT
1564389,0xf0bf136a19f7bd0d924fc82162fc6dd9fb5af88a,false,false,,,,TOO_SHORT
1564394,0x872ec2ddb04b4f3695eb014109eb89a064b19b8e,false,false,,,,TOO_SHORT
1564808,0xf907a6013c21cd831bc3db379d6c1f35850e0dec,false,false,,,,TOO_SHORT
1564926,0xe46a42230179ee2d918537fc2019ce9ce6425f8b,false,false,,,,TOO_SHORT
1564973,0xced68cacd94dd7f4989a4bc7b9a111cb6d846451,false,false,,,,TOO_SHORT
1565057,0x055a4b907650e5f3a00cf504182a27f67e25fd92,false,false,,,,TOO_SHORT
1565307,0x4c234f573e05dd97f233ab1b8c325e8b0801d80c,false,false,,,,TOO_SHORT
1565310,0x2d29d576edc9618905071c0cfe0d1a53cfcff5d5,false,false,,,,TOO_SHORT
1565384,0x697cd953378b9608df7a666888fbb6e296a80b19,false,false,,,,TOO_SHORT
1565462,0x32092eb5fd99b30ea91415417c94d56ebb53417a,false,false,,,,TOO_SHORT
1565478,0x4a2456a3e15cdf15347881f73ebbac182f12016d,false,false,,,,TOO_SHORT
1565481,0xe7b1812a23ddeb8cbee2ee35893d00c8e77a1605,false,false,,,,TOO_SHORT
1565549,0xd0378a6b889c6855d80ceb0cb7cc0d1edb456fd5,false,false,,,,TOO_SHORT
1565551,0x1ea69a4cf9d7c8866be2ff75517f5e555b6723fe,false,false,,,,TOO_SHORT
1565802,0x9088b40f7e6011df05f7165a9041df574f05e0b0,false,false,,,,TOO_SHORT
1565824,0x1879fb85722c59c9f57d58e0638d72e0a3ae1ef2,false,false,,,,TOO_SHORT
1565857,0xc357da27d1b0a92d32b9894439a41da86c87ebeb,false,false,,,,TOO_SHORT
1565933,0xa501f045718ffefc62a0b7ed4834543422096161,false,false,,,,TOO_SHORT
1565993,0x39605eeca968ff070e5a132dbf3ffaa30420bc1a,false,false,,,,TOO_SHORT
1566084,0x34f4f7a8b343ff8286a5b382f29ee94b17bbf2a6,false,false,,,,TOO_SHORT
1566116,0x07f1deca9e8ecd548a826b18c2f954f08c752422,false,false,,,,TOO_SHORT
1566398,0xa539b55061047fe0ece6b331868dfe024b31a2fb,false,false,,,,TOO_SHORT
1566436,0xf84752822aae2abe7f655ea1874524614a9e43d7,false,false,,,,TOO_SHORT
1566629,0x7f743c706b34f50c7d293e3e69446e4f54219138,false,false,,,,TOO_SHORT
1566790,0x3a8773b9ff7ce7b18266099ba863b05ca3d71ef6,false,false,,,,TOO_SHORT
1566927,0xfdb6eaf379ff4a03434d7f9a7fffc89da641f469,false,false,,,,TOO_SHORT
1567013,0xf05d61e500294bd18489f35e2369730d59ebaafe,false,false,,,,TOO_SHORT
1567032,0xa0d8915f84199b9304134c82f32002fb91545889,false,false,,,,TOO_SHORT
1567146,0x9f34107b3fbb5293bbb1819f40f9082844366a21,false,false,,,,TOO_SHORT
1567227,0x7f8baa4f988ac7eb242173e01a8d919c873df47d,false,false,,,,TOO_SHORT
1567540,0xd344dbf18b0d252b7fb6fb0476ccf2b07a2f95f7,false,false,,,,TOO_SHORT
1567642,0xc209f6b39220327cc5e0a8841613ae1b4180463c,false,false,,,,TOO_SHORT
1567646,0x170541783de4dc8d88f6c953c3dfb3f0041b13c3,false,false,,,,TOO_SHORT
1567817,0xfbe4311d39a5f6e158633d129160af1e845a4af6,false,false,,,,TOO_SHORT
1567830,0x1c4ba140259eab0912ae297617fce9000d65a71b,false,false,,,,TOO_SHORT
1567873,0x372ecf6a0043a3a98407e09b4a5ebebdf833f464,false,false,,,,TOO_SHORT
1567879,0x33c647f60a4d4372a3f84e08e98f8a9c2f678280,false,false,,,,TOO_SHORT
1568048,0xbce30b4a62696d73a0490b17ddfa29476395e88e,false,false,,,,TOO_SHORT
1568618,0x5d9ea34b874460aa435ee1d1f4f4eef8ce772e7f,false,false,,,,TOO_SHORT
1568699,0x95c22d377b64244af966cf30804a12cc40dacfef,false,false,,,,TOO_SHORT
1568795,0x2a00c9fd59db2276f64d0bc678527fa22f7de2b5,false,false,,,,TOO_SHORT
1568916,0x44bb29ffc1f7f2af807aa1c17217704b113c2fee,false,false,,,,TOO_SHORT
1568938,0xde789d994e81923c5b1ddba59fbe8027afb687ac,false,false,,,,TOO_SHORT
1569076,0x618fee54345989d319cfa33759785152087698b6,false,false,,,,TOO_SHORT
1569223,0xf9fa61bd13766cf8ef63d3c205669680c7f400fb,false,false,,,,TOO_SHORT
1569483,0xf8b05185a0ef796fdc7ea07f34bbb12202fc3a2b,false,false,,,,TOO_SHORT
1569491,0xf092dd02bc159228137995261cefb042344db7bd,false,false,,,,TOO_SHORT
1569666,0x6fd1607ec807d87a3fac2f78a85bd4382e195817,false,false,,,,TOO_SHORT
1569749,0x28adfde72e266cf5a144a4221590e06010ffc84b,false,false,,,,TOO_SHORT
1569759,0xb38f382c22675805050dabaf51e3ee1763179a6a,false,false,,,,TOO_SHORT
1570029,0x1955b3617e686502b2ac8852db2dc72d946f2711,false,false,,,,TOO_SHORT
1570032,0xe82968b23e964d8995646db7c1ca2185e53c48e1,false,false,,,,TOO_SHORT
1570069,0x3710b687d35e1e2cdaf18d9d2c3c9e0c5b64ffae,false,false,,,,TOO_SHORT
1570214,0x504d1fca884d360f2d458ae26990becaa1581d82,false,false,,,,TOO_SHORT
1570276,0x90e5018f52c2416414e7599c5a194e27135f852b,false,false,,,,TOO_SHORT
1570320,0x838b3606489c5a0e4d97ed113d4aa8d324f4a330,true,false,"contract MultiAsset {\n    function owner(bytes32 _symbol) constant returns(address);\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract OpenDollar {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\n            return false;\n        }\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\n            return false;\n        }\n        return true;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\n            return false;\n        }\n        return true;\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() returns(bool) {\n        return multiAsset.transfer(multiAsset.owner(symbol), balanceOf(address(this)), symbol);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1570323,0x04cafb4b02131f188a3ddd71cd48db79419baf9b,false,false,,,,TOO_SHORT
1570342,0xa85a29caeadddc0c0af113fb5ceadc563302983b,true,false,,,,0x838b3606489c5a0e4d97ed113d4aa8d324f4a330
1570502,0x35a2e7d55357b78c55b1e4f59f8991b54cc014ba,false,false,,,,TOO_SHORT
1570597,0x53f279eb48145154aaded9adc203b8fd660767cc,false,false,,,,TOO_SHORT
1570646,0x395d519411569b8be8a2390d462d7b34d56e0870,false,false,,,,TOO_SHORT
1570671,0x0b6f37304cc1dfe15f39683a647e1ce33f314ed3,false,false,,,,TOO_SHORT
1570684,0xbc433f038cc1bca87a89f4bc6095e8c1924a7952,false,false,,,,TOO_SHORT
1570688,0xcb60ee8f43a2f820b78a9dc8ef627b01e24510d2,false,false,,,,TOO_SHORT
1570794,0xfb96dbee3ae623640de2a3ad23a7f32994768cb4,false,false,,,,TOO_SHORT
1570878,0x622c7042e05e903741f54e77ebcc7dac6ce2e5ec,false,false,,,,TOO_SHORT
1570879,0xcb787ee7fa9563d3b0e06a915621019ece0fe6e4,false,false,,,,TOO_SHORT
1570924,0x90a1b1952fda06beef65a5c1a26ae13d57436b88,false,false,,,,TOO_SHORT
1570943,0xafdc92f33c837201fae35d9f92a9a40e17603082,false,false,,,,TOO_SHORT
1570953,0xac5363dba13e4a76f05bfd008d91927c563b450d,false,false,,,,TOO_SHORT
1570984,0xa827db4829c0fef51e483bf793d5419bf55a9781,false,false,,,,TOO_SHORT
1571058,0x017a2ba1d4f21533ff2b4955c0bc854e8ad2f0ed,false,false,,,,TOO_SHORT
1571079,0x5e91d2c0700489fc5a2b32c55a6e6671ee2736c4,false,false,,,,TOO_SHORT
1571080,0x29c339e55165578a618f9a6cfb536fdcaf1e7d05,false,false,,,,TOO_SHORT
1571122,0x56afff27c6c343cc8f3ee42893195b057abc4d32,false,false,,,,TOO_SHORT
1571182,0x1f6950c599c209f2833a6d109e6c3439774ee727,false,false,,,,TOO_SHORT
1571341,0xea03b45c837aeec6f35fa855a2e327f6babc6f88,false,false,,,,TOO_SHORT
1571342,0x5772dd281cdd956c1c1f841e627eaf008d0e1de5,false,false,,,,TOO_SHORT
1571495,0x02e95f915d2ac44d429c5b52e239d74fae1f749b,false,false,,,,TOO_SHORT
1571530,0x4a346ca8f6dbe68f24cc8b76b4052f68c819d025,false,false,,,,TOO_SHORT
1571715,0x4346b15f29ed63a68727ac782b345f09f2fb8cb0,false,false,,,,TOO_SHORT
1571869,0x90deb6eab0cb3fdfeb2c0d372e659129f2e1da22,false,false,,,,TOO_SHORT
1571916,0x1a0e76141a76abc4476f06b7a82a7d9259197689,false,false,,,,TOO_SHORT
1572202,0x0a7ba2297279550c9a1ddb5540a1839f6fb4c19f,false,false,,,,TOO_SHORT
1572295,0xed4bd0c42844d0fdd6d3a1757b00a07826014242,false,false,,,,TOO_SHORT
1572364,0x4e833fbf0ef67dcf5a883f5a5ee00c7b0f45c79e,false,false,,,,TOO_SHORT
1572589,0xbb37fcbf7647911a2ac1e60dd885f74d811eed15,false,false,,,,TOO_SHORT
1572595,0x6a7a3ab24cd571cfa51a7cb08ca3812a94eaff14,false,false,,,,TOO_SHORT
1572610,0x55f967d9c348f9d89273bf309214860a4d6c2076,false,false,,,,TOO_SHORT
1572702,0x880f2801e1f5991196f95689315ff3450eac2975,false,false,,,,TOO_SHORT
1572791,0x91fec24ec19a0886830af22b53f6815b619ba30e,false,false,,,,TOO_SHORT
1572971,0x7a65c224581f6c6845fa6b8cee5715d98918a38e,false,false,,,,TOO_SHORT
1572985,0x316279b2c3c9e8fb465be5d3b8cd551ecb290fe9,false,false,,,,TOO_SHORT
1573179,0xf5a8100e321ffef5b1e3e02d41ef8fcecd3e6d31,false,false,,,,TOO_SHORT
1573270,0x81c67d2be3725a52f45d96078f2056c1eb4c38a9,false,false,,,,TOO_SHORT
1573613,0x31308090d255cac7798a1459d6916788a7029822,false,false,,,,TOO_SHORT
1573637,0xd572e626189458dbd9455871b06d97d80e9e86ae,false,false,,,,TOO_SHORT
1573677,0x62aa4d67b41a554b067d265413e2e77532a2874a,false,false,,,,TOO_SHORT
1573863,0x5c259d669fc984d6f8d2b5470bfb7f5f2c652b76,false,false,,,,TOO_SHORT
1574015,0x3be4674cd5e9ae124f5449ea86539211a00b5492,false,false,,,,TOO_SHORT
1574161,0x5df6fd09a528bd45ea881b450ea73edeef9ea93c,false,false,,,,TOO_SHORT
1574214,0xc674a18f67976e1a014bfdb6d1679f44605ad605,false,false,,,,TOO_SHORT
1574241,0x39f3e2f917785f2c87caf9a46021fbdfa38f60ee,false,false,,,,TOO_SHORT
1574368,0x9b7697ec671d5ad8f5bbcb5e4c75f6e4623d6438,false,false,,,,TOO_SHORT
1574476,0x4ea131b2a96db72d86da3b730fb84425e248cd8e,false,false,,,,TOO_SHORT
1574660,0x2c0b2fcabb4bba670b9280e09eb8e97045e022c1,false,false,,,,TOO_SHORT
1574910,0xfc799f962b1cb211a8f87588bbb86d5e3db2fe07,false,false,,,,TOO_SHORT
1574934,0x89151cb339bf391d5361c8408d405fc31e52e548,false,false,,,,TOO_SHORT
1575116,0x5774a39d5e63c76acf7f974260b0ca36a3111b34,false,false,,,,TOO_SHORT
1575237,0xdf5f5491f09bac64a1aa1a273fb006c742b673ee,false,false,,,,TOO_SHORT
1575688,0xa51e4ea139f260d3b5f114b521caf4ba6f9bc879,false,false,,,,TOO_SHORT
1575689,0xa71e0581e6796c46bdd0d231939043aa7f2bb08e,false,false,,,,TOO_SHORT
1575690,0xddf6ce709edb3fb00a5922a229f32044100099a8,false,false,,,,TOO_SHORT
1575791,0xd7747ea921d5f891accc3384e6712992e9465adc,true,false,,,,0x838b3606489c5a0e4d97ed113d4aa8d324f4a330
1575925,0xd50487ab956e98f628297d0a36775d879654d8d2,false,false,,,,TOO_SHORT
1576045,0x50f54ed2cafd4b7245e60557a6b56d9ac9193025,false,false,,,,TOO_SHORT
1576113,0x25af8d824b3b078a589e47418a95b4388d1552f4,true,false,"/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no ""premine"". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n            return 20;\n    }\n}\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 3 days;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 0 days;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 1 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 2 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 2 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        MICRODAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  addresses _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract MICRODAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function MICRODAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        // to prevent curator from halving quorum before first proposal\n        if (proposals.length == 1) // initial length is 1 (see constructor)\n            lastTimeMinQuorumMet = now;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        MICRODAO dao = MICRODAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n\n        reward = DAOrewardAccount.balance < reward ? DAOrewardAccount.balance : reward;\n\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n\n        reward = rewardAccount.balance < reward ? rewardAccount.balance : reward;\n\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime after\n        // fueling by the curator with a delay of at least `minProposalDebatePeriod`\n        // between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)\n            && now >= closingTime\n            && proposals.length > 1) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (MICRODAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (MICRODAO _newDAO) {\n\n        return new MICRODAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。DAOの機能を実装しており、芸術的要素は少ない。,
1576113,0xc7add8eb0569d355788041697da208d9cec14ede,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1576113,0xfe4c06d9a517dcb9f14b294abb5565eecd400acd,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1576113,0x4ea0bc97dc1926dcbb3b63d91e7452b440336995,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1576135,0x9ce63a4e69de34844e340fc541d82db9506287bc,true,false,,,,0x838b3606489c5a0e4d97ed113d4aa8d324f4a330
1576184,0xcea671dee30577571e7c0e10ed9bcef1eba8b3b5,false,false,,,,TOO_SHORT
1576328,0x5e45a78fa810857cea767f4569fb4a04bf7dd572,false,false,,,,TOO_SHORT
1576420,0xed503c3bc054e3ee919ee9799880e5d9bdd214ed,false,false,,,,TOO_SHORT
1576434,0xffb9e70f917e1ec5ef74678d9d06d0e87abd2fd0,false,false,,,,TOO_SHORT
1576565,0x1c2c7b6c0624c98c4be7147b12754d6f2803e8e0,false,false,,,,TOO_SHORT
1576593,0x1aae3a03cf1a326c959c4bc3c40dd4a2c065ee81,false,false,,,,TOO_SHORT
1576643,0x2f3926661d61405eb35482d55e516874484cf5c6,false,false,,,,TOO_SHORT
1576828,0xebd12a972c2f05fc856b157728f0c5d2c679c61d,false,false,,,,TOO_SHORT
1576885,0xb23c87c2bcb50f762b5b32bde6b1185ebf50de59,false,false,,,,TOO_SHORT
1576994,0x38a73f4f3864f5c17bc047edafc07b409b08e564,false,false,,,,TOO_SHORT
1577164,0x5076e63682ef083af9e2efda24853f4052763a41,false,false,,,,TOO_SHORT
1577200,0x63dd6f40007731eb7e70a7ae43b55c0fb2090c99,false,false,"/*\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _amount) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n    function approve(address _spender, uint256 _amount) returns (bool success);\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\n// compiled using https://ethereum.github.io/browser-solidity/#version=soljson-v0.3.2-2016-05-20-e3c5418.js&optimize=true\ncontract Token_Offer {\n  address public tokenHolder;\n  address public owner;\n  TokenInterface public tokenContract;\n  uint16 public price;  // price in ETH per 100000 tokens. Price 2250 means 2.25 ETH per 100 tokens\n  uint public tokensPurchasedTotal;\n  uint public ethCostTotal;\n\n  event TokensPurchased(address buyer, uint16 price, uint tokensPurchased, uint ethCost, uint ethSent, uint ethReturned, uint tokenSupplyLeft);\n  event Log(string msg, uint val);\n\n  modifier onlyOwnerAllowed() {if (tx.origin != owner) throw; _}\n\n  function Token_Offer(address _tokenContract, address _tokenHolder, uint16 _price)  {\n    owner = tx.origin;\n    tokenContract = TokenInterface(_tokenContract);\n    tokenHolder = _tokenHolder;\n    price = _price;\n  }\n\n  function tokenSupply() constant returns (uint tokens) {\n    uint allowance = tokenContract.allowance(tokenHolder, address(this));\n    uint balance = tokenContract.balanceOf(tokenHolder);\n    if (allowance < balance) return allowance;\n    else return balance;\n  }\n\n  function () {\n    buyTokens(price);\n  }\n\n  function buyTokens() {\n    buyTokens(price);\n  }\n\n  /// @notice DON'T BUY FROM EXCHANGE! Only buy from normal account in your full control (private key).\n  /// @param _bidPrice Price in ETH per 100000 tokens. _bidPrice 2250 means 2.25 ETH per 100 tokens.\n  function buyTokens(uint16 _bidPrice) {\n    if (tx.origin != msg.sender) { // buyer should be able to handle TheDAO (vote, transfer, ...)\n      if (!msg.sender.send(msg.value)) throw; // send ETH back to sender's contract\n      Log(""Please send from a normal account, not contract/multisig"", 0);\n      return;\n    }\n    if (price == 0) {\n      if (!tx.origin.send(msg.value)) throw; // send ETH back\n      Log(""Contract disabled"", 0);\n      return;\n    }\n    if (_bidPrice < price) {\n      if (!tx.origin.send(msg.value)) throw; // send ETH back\n      Log(""Bid too low, price is:"", price);\n      return;\n    }\n    if (msg.value == 0) {\n      Log(""No ether received"", 0);\n      return;\n    }\n    uint _tokenSupply = tokenSupply();\n    if (_tokenSupply == 0) {\n      if (!tx.origin.send(msg.value)) throw; // send ETH back\n      Log(""No tokens available, please try later"", 0);\n      return;\n    }\n\n    uint _tokensToPurchase = (msg.value * 1000) / price;\n\n    if (_tokensToPurchase <= _tokenSupply) { // contract has enough tokens to complete order\n      if (!tokenContract.transferFrom(tokenHolder, tx.origin, _tokensToPurchase)) // send tokens\n        throw;\n      tokensPurchasedTotal += _tokensToPurchase;\n      ethCostTotal += msg.value;\n      TokensPurchased(tx.origin, price, _tokensToPurchase, msg.value, msg.value, 0, _tokenSupply-_tokensToPurchase);\n\n    } else { // contract low on tokens, partial order execution\n      uint _supplyInEth = (_tokenSupply * price) / 1000;\n      if (!tx.origin.send(msg.value-_supplyInEth)) // return extra eth\n        throw;\n      if (!tokenContract.transferFrom(tokenHolder, tx.origin, _tokenSupply)) // send tokens\n        throw;\n      tokensPurchasedTotal += _tokenSupply;\n      ethCostTotal += _supplyInEth;\n      TokensPurchased(tx.origin, price, _tokenSupply, _supplyInEth, msg.value, msg.value-_supplyInEth, 0);\n    }\n  }\n\n  /* == functions below are for owner only == */\n  function setPrice(uint16 _price) onlyOwnerAllowed {\n    price = _price;\n    Log(""Price changed:"", price); // watch the contract to see updates\n  }\n  function tokenSupplyChanged() onlyOwnerAllowed {\n    Log(""Supply changed, new supply:"", tokenSupply()); // watch the contract to see updates\n  }\n  function setTokenHolder(address _tokenHolder) onlyOwnerAllowed {\n    tokenHolder = _tokenHolder;\n  }\n  function setOwner(address _owner) onlyOwnerAllowed {\n    owner = _owner;\n  }\n  function transferETH(address _to, uint _amount) onlyOwnerAllowed {\n    if (_amount > address(this).balance) {\n      _amount = address(this).balance;\n    }\n    _to.send(_amount);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1577305,0x6bb5c3188c01bfd9f7b9beb46b372fba427c13f7,false,false,,,,TOO_SHORT
1577437,0xe5d82638abb4178b9f9131add0e50b87f79f4d38,false,false,,,,TOO_SHORT
1577567,0x42f62e89be1ae2f82387b681f3dbbc5843ff43dc,false,false,,,,TOO_SHORT
1577598,0xe7cd1f93ac5d671a3a5853f2de2676f0f7c42728,false,false,,,,TOO_SHORT
1577676,0xb0e56bbda04976dd9819593bacee6a0f48f7672a,false,false,,,,TOO_SHORT
1577693,0x2762e586561c7ac0764459b926e627dc94f353ed,false,false,,,,TOO_SHORT
1577745,0xe9f7104fc843570be7a9fe624e8fdc08f21a0755,false,false,,,,TOO_SHORT
1577747,0x2fff7338d55e45ad7dc6ecc8403f510898c87bc3,false,false,,,,TOO_SHORT
1577758,0x0b71d724b0b9bad869f27df40be065f8405318fb,false,false,,,,TOO_SHORT
1577969,0x4cbe7cb2566ec6a22760b9fce1ea0486ce98ac40,false,false,,,,TOO_SHORT
1577993,0x4bf2665fd235193f476a472fb084272f3874335d,false,false,,,,TOO_SHORT
1578209,0x2e3723f7201de9878e1b3333302ea3eca005e132,false,false,,,,TOO_SHORT
1578229,0xa717294dd644cca40c96490124736c157f52f0d5,false,false,,,,TOO_SHORT
1578245,0x40109dc062d5c18e15f661ac593503532667a0db,false,false,,,,TOO_SHORT
1578450,0xa9709725ca9a4bf44621a92bd062b0433e436d68,false,false,,,,TOO_SHORT
1578537,0x5596377995ca347bc47abe80ab7b88a98ececdb6,false,false,,,,TOO_SHORT
1578564,0xdb35f6fc4f6555089d45a0b3c3aabdaef3e2abf2,false,false,,,,TOO_SHORT
1578608,0x0d005fae03d50ef86fee31018744e56dc712fa40,false,false,,,,TOO_SHORT
1578693,0xfae90abfb12eaf80fc0def5ebeb4d30aff671b84,false,false,,,,TOO_SHORT
1578907,0x8415e0f7ed12b930aab0a7d4866a7971e88981a6,true,false,,,,0xe0b7927c4af23765cb51314a0e0521a9645f0e2a
1578907,0x12cfe8d6745654ebe6ac0107273e6315191b1cf3,true,false,,,,0x54bda709fed875224eae569bb6817d96ef7ed9ad
1578923,0x18724c964b06eab4034a87bacc77c703b46bcc9b,true,false,,,,0xe0b7927c4af23765cb51314a0e0521a9645f0e2a
1578935,0x25c201ba05f25cd8b3d32834f9e748a03aa378df,true,false,,,,0x54bda709fed875224eae569bb6817d96ef7ed9ad
1579032,0x5808e41bbce256aee309d4d73de75fb25f2a9bb8,true,false,,,,0x54bda709fed875224eae569bb6817d96ef7ed9ad
1579051,0x305296c63862858fa19a1d56afa2286b191d6869,false,false,,,,TOO_SHORT
1579098,0x1bae0e11c882394d58f3f3dc8d908165e90c8cd6,false,false,,,,TOO_SHORT
1579543,0x91f61d55f54036efa086ec81e25c9de210212292,false,false,,,,TOO_SHORT
1579545,0x8c1ad4fc4380c15373affda6ac97a20fda1e0c96,false,false,,,,TOO_SHORT
1579617,0x7b7f88e2570d8aff60a14823dffff4e2239717a8,false,false,,,,TOO_SHORT
1579621,0xa40ad23d5ca268a5a24f7db5d9f711eae6167e55,false,false,,,,TOO_SHORT
1579628,0xe417e88d32a95d8e2d3bb25793b1f931711058a6,false,false,,,,TOO_SHORT
1579696,0xd690a3a44861851a01847c2e17c50f3f7678e881,false,false,,,,TOO_SHORT
1579768,0x7d69e51ca860c7a61e74567294b5d475eb1dbe60,false,false,,,,TOO_SHORT
1579782,0x5eedf4c5111a7a5bcb11c265eb69d7dc6c9d3af5,false,false,,,,TOO_SHORT
1579875,0xf17dfc4e96a557cfc9dde5f23b4df31890278164,false,false,,,,TOO_SHORT
1579911,0x1a4bef627b039d06c9f25e5f388872210c88c29c,false,false,,,,TOO_SHORT
1579934,0xdbeb3502b2db5c45943e6695485f98fa390c35b9,false,false,,,,TOO_SHORT
1580025,0x19027ec79aee7ffb0083dc70e44507984cc9fbef,false,false,,,,TOO_SHORT
1580046,0xd0f8df36d67d675c6fd16e73d86a49c037a487b6,false,false,,,,TOO_SHORT
1580218,0xfd13f873d43eead3f460013081e705593a59df2a,false,false,,,,TOO_SHORT
1580286,0x32345414a7c71f581f87e160d92fd03a33bad06d,false,false,,,,TOO_SHORT
1580405,0x7d63099a1fcdf0aa5ca123e13174b4f7939373d1,false,false,,,,TOO_SHORT
1580423,0x5b295429e9a5ef5f7fa76ea28ba2b73af2d72f60,false,false,,,,TOO_SHORT
1580512,0x7f9dbed3418db5a262f8f9ef03558ed818272190,false,false,,,,TOO_SHORT
1580546,0x56fbf0d0334cf57954a0cf26ba566ae10c15c85e,false,false,,,,TOO_SHORT
1580575,0xa4d4f3b9c7fa0fbc5b93038e61b595a9150e179c,false,false,,,,TOO_SHORT
1580625,0xd549d332decf443cfd94be235ac0344bd15654d4,false,false,,,,TOO_SHORT
1580669,0x18296dc3b8413d1a96c74e043eee905d5092d69a,false,false,,,,TOO_SHORT
1580703,0x6d2b48cdd191aacc3e44fb54a0ca52fe804c928e,false,false,,,,TOO_SHORT
1580751,0xf36b0f457999cbbb436eeb28dbb5944bfc3f99de,false,false,"contract tickingBomb {\n\n    struct team {\n        string name;\n        uint lastUpdate;\n        address[] members;\n        uint nbrMembers;\n    }\n\n    uint public constant DELAY =  60 * 60 * 24; // 24 Hours\n    uint public constant INVEST_AMOUNT = 1000 finney; // 1 ETH\n    uint constant FEE = 3;\n\n    team public red;\n    team public blue;\n\n    mapping(address => uint) public balances;\n    address creator;\n\n    string[] public historyWinner;\n    uint[] public historyRed;\n    uint[] public historyBlue;\n    uint public gameNbr;\n\n    function tickingBomb() {\n        newRound();\n        creator = msg.sender;\n        gameNbr = 0;\n    }\n\n    function helpRed() {\n        uint i;\n        uint amount = msg.value;\n\n        // Check if Exploded, if so save the previous game\n        // And create a new round\n        checkIfExploded();\n\n        // Update the TimeStamp\n        red.lastUpdate = block.timestamp;\n\n        // Split the incoming money every INVEST_AMOUNT\n        while (amount >= INVEST_AMOUNT) {\n            red.members.push(msg.sender);\n            red.nbrMembers++;\n            amount -= INVEST_AMOUNT;\n        }\n\n        // If there is still some money in the balance, sent it back\n        if (amount > 0) {\n            msg.sender.send(amount);\n        }\n    }\n\n    function helpBlue() {\n        uint i;\n        uint amount = msg.value;\n\n        // Check if Exploded, if so save the previous game\n        // And create a new game\n        checkIfExploded();\n\n        // Update the TimeStamp\n        blue.lastUpdate = block.timestamp;\n\n        // Split the incoming money every 100 finneys\n        while (amount >= INVEST_AMOUNT) {\n            blue.members.push(msg.sender);\n            blue.nbrMembers++;\n            amount -= INVEST_AMOUNT;\n        }\n\n        // If there is still some money in the balance, sent it back\n        if (amount > 0) {\n            msg.sender.send(amount);\n        }\n    }\n\n    function checkIfExploded() {\n        if (checkTime()) {\n            newRound();\n        }\n    }\n\n    function checkTime() private returns(bool exploded) {\n        uint i;\n        uint lostAmount = 0;\n        uint gainPerMember = 0;\n        uint feeCollected = 0;\n\n        // If Red and Blue have exploded at the same time, return the amounted invested\n        if (red.lastUpdate == blue.lastUpdate && red.lastUpdate + DELAY < block.timestamp) {\n            for (i = 0; i < red.members.length; i++) {\n                balances[red.members[i]] += INVEST_AMOUNT;\n            }\n            for (i = 0; i < blue.members.length; i++) {\n                balances[blue.members[i]] += INVEST_AMOUNT;\n            }\n\n            historyWinner.push('Tie between Red and Blue');\n            historyRed.push(red.nbrMembers);\n            historyBlue.push(blue.nbrMembers);\n            gameNbr++;\n            return true;\n        }\n\n        // Take the older timestamp\n        if (red.lastUpdate < blue.lastUpdate) {\n            // Check if the Red bomb exploded\n            if (red.lastUpdate + DELAY < block.timestamp) {\n                // Calculate the lost amount by the red team\n                // Number of Red member * Invested amount per user  *\n                feeCollected += (red.nbrMembers * INVEST_AMOUNT * FEE / 100);\n                balances[creator] += feeCollected;\n                lostAmount = (red.nbrMembers * INVEST_AMOUNT) - feeCollected;\n\n                gainPerMember = lostAmount / blue.nbrMembers;\n                for (i = 0; i < blue.members.length; i++) {\n                    balances[blue.members[i]] += (INVEST_AMOUNT + gainPerMember);\n                }\n\n                historyWinner.push('Red');\n                historyRed.push(red.nbrMembers);\n                historyBlue.push(blue.nbrMembers);\n                gameNbr++;\n                return true;\n            }\n            return false;\n        } else {\n            // Check if the Blue bomb exploded\n            if (blue.lastUpdate + DELAY < block.timestamp) {\n                // Calculate the lost amount by the red team\n                // Number of Red member * Invested amount per user  *\n                feeCollected += (blue.nbrMembers * INVEST_AMOUNT * FEE / 100);\n                balances[creator] += feeCollected;\n                lostAmount = (blue.nbrMembers * INVEST_AMOUNT) - feeCollected;\n                gainPerMember = lostAmount / red.nbrMembers;\n                for (i = 0; i < red.members.length; i++) {\n                    balances[red.members[i]] += (INVEST_AMOUNT + gainPerMember);\n                }\n\n                historyWinner.push('Blue');\n                historyRed.push(red.nbrMembers);\n                historyBlue.push(blue.nbrMembers);\n                gameNbr++;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    function newRound() private {\n        red.name = ""Red team"";\n        blue.name = ""Blue team"";\n        red.lastUpdate = block.timestamp;\n        blue.lastUpdate = block.timestamp;\n        red.nbrMembers = 0;\n        blue.nbrMembers = 0;\n        red.members = new address[](0);\n        blue.members = new address[](0);\n    }\n\n    function() {\n        // Help the oldest timestamp (going to explode first)\n        if (red.lastUpdate < blue.lastUpdate) {\n            helpRed();\n        } else {\n            helpBlue();\n        }\n    }\n\n    function collectBalance() {\n        msg.sender.send(balances[msg.sender]);\n        balances[msg.sender] = 0;\n    }\n\n    // Allow the creator to send their balances to the players\n    function sendBalance(address player) {\n        if (msg.sender == creator) {\n            player.send(balances[player]);\n        }\n    }\n\n    function newOwner(address newOwner) {\n        if (msg.sender == creator) {\n            creator = newOwner;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックが中心で芸術性は低い。,
1580864,0x4ceef0b7485661dc3a3aa1ade69ed28cbe6d178c,false,false,,,,TOO_SHORT
1580930,0x3bce0c19f014802391ca8adafadc39b1551be42f,false,false,,,,TOO_SHORT
1580934,0x09f0aaabe4df881797698af29477a65ac9a302d1,false,false,"contract tickingBomb {\n\n    struct team {\n        string name;\n        uint lastUpdate;\n        address[] members;\n        uint nbrMembers;\n    }\n\n    uint public constant DELAY =  60 * 60 * 12; // 12 Hours\n    uint public constant INVEST_AMOUNT = 500 finney; // 0.5 ETH\n    uint constant FEE = 3;\n\n    team public red;\n    team public blue;\n\n    mapping(address => uint) public balances;\n    address creator;\n\n    string[] public historyWinner;\n    uint[] public historyRed;\n    uint[] public historyBlue;\n    uint public gameNbr;\n\n    function tickingBomb() {\n        newRound();\n        creator = msg.sender;\n        gameNbr = 0;\n    }\n\n    function helpRed() {\n        uint i;\n        uint amount = msg.value;\n\n        // Check if Exploded, if so save the previous game\n        // And create a new round\n        checkIfExploded();\n\n        // Update the TimeStamp\n        red.lastUpdate = block.timestamp;\n\n        // Split the incoming money every INVEST_AMOUNT\n        while (amount >= INVEST_AMOUNT) {\n            red.members.push(msg.sender);\n            red.nbrMembers++;\n            amount -= INVEST_AMOUNT;\n        }\n\n        // If there is still some money in the balance, sent it back\n        if (amount > 0) {\n            msg.sender.send(amount);\n        }\n    }\n\n    function helpBlue() {\n        uint i;\n        uint amount = msg.value;\n\n        // Check if Exploded, if so save the previous game\n        // And create a new game\n        checkIfExploded();\n\n        // Update the TimeStamp\n        blue.lastUpdate = block.timestamp;\n\n        // Split the incoming money every 100 finneys\n        while (amount >= INVEST_AMOUNT) {\n            blue.members.push(msg.sender);\n            blue.nbrMembers++;\n            amount -= INVEST_AMOUNT;\n        }\n\n        // If there is still some money in the balance, sent it back\n        if (amount > 0) {\n            msg.sender.send(amount);\n        }\n    }\n\n    function checkIfExploded() {\n        if (checkTime()) {\n            newRound();\n        }\n    }\n\n    function checkTime() private returns(bool exploded) {\n        uint i;\n        uint lostAmount = 0;\n        uint gainPerMember = 0;\n        uint feeCollected = 0;\n\n        // If Red and Blue have exploded at the same time, return the amounted invested\n        if (red.lastUpdate == blue.lastUpdate && red.lastUpdate + DELAY < block.timestamp) {\n            for (i = 0; i < red.members.length; i++) {\n                balances[red.members[i]] += INVEST_AMOUNT;\n            }\n            for (i = 0; i < blue.members.length; i++) {\n                balances[blue.members[i]] += INVEST_AMOUNT;\n            }\n\n            historyWinner.push('Tie between Red and Blue');\n            historyRed.push(red.nbrMembers);\n            historyBlue.push(blue.nbrMembers);\n            gameNbr++;\n            return true;\n        }\n\n        // Take the older timestamp\n        if (red.lastUpdate < blue.lastUpdate) {\n            // Check if the Red bomb exploded\n            if (red.lastUpdate + DELAY < block.timestamp) {\n                // Calculate the lost amount by the red team\n                // Number of Red member * Invested amount per user  *\n                feeCollected += (red.nbrMembers * INVEST_AMOUNT * FEE / 100);\n                balances[creator] += feeCollected;\n                lostAmount = (red.nbrMembers * INVEST_AMOUNT) - feeCollected;\n\n                gainPerMember = lostAmount / blue.nbrMembers;\n                for (i = 0; i < blue.members.length; i++) {\n                    balances[blue.members[i]] += (INVEST_AMOUNT + gainPerMember);\n                }\n\n                historyWinner.push('Red');\n                historyRed.push(red.nbrMembers);\n                historyBlue.push(blue.nbrMembers);\n                gameNbr++;\n                return true;\n            }\n            return false;\n        } else {\n            // Check if the Blue bomb exploded\n            if (blue.lastUpdate + DELAY < block.timestamp) {\n                // Calculate the lost amount by the red team\n                // Number of Red member * Invested amount per user  *\n                feeCollected += (blue.nbrMembers * INVEST_AMOUNT * FEE / 100);\n                balances[creator] += feeCollected;\n                lostAmount = (blue.nbrMembers * INVEST_AMOUNT) - feeCollected;\n                gainPerMember = lostAmount / red.nbrMembers;\n                for (i = 0; i < red.members.length; i++) {\n                    balances[red.members[i]] += (INVEST_AMOUNT + gainPerMember);\n                }\n\n                historyWinner.push('Blue');\n                historyRed.push(red.nbrMembers);\n                historyBlue.push(blue.nbrMembers);\n                gameNbr++;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    function newRound() private {\n        red.name = ""Red team"";\n        blue.name = ""Blue team"";\n        red.lastUpdate = block.timestamp;\n        blue.lastUpdate = block.timestamp;\n        red.nbrMembers = 0;\n        blue.nbrMembers = 0;\n        red.members = new address[](0);\n        blue.members = new address[](0);\n    }\n\n    function() {\n        // Help the oldest timestamp (going to explode first)\n        if (red.lastUpdate < blue.lastUpdate) {\n            helpRed();\n        } else {\n            helpBlue();\n        }\n    }\n\n    function collectBalance() {\n        msg.sender.send(balances[msg.sender]);\n        balances[msg.sender] = 0;\n    }\n\n    // Allow the creator to send their balances to the players\n    function sendBalance(address player) {\n        if (msg.sender == creator) {\n            player.send(balances[player]);\n        }\n    }\n\n    function newOwner(address newOwner) {\n        if (msg.sender == creator) {\n            creator = newOwner;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックが中心で芸術性は低い。,
1580945,0xbaabe94c786fe90514dc6fa68499fd93ee583a5c,false,false,"contract tickingBomb {\n\n    struct team {\n        string name;\n        uint lastUpdate;\n        address[] members;\n        uint nbrMembers;\n    }\n\n    uint public constant DELAY =  60 * 60 * 6; // 6 Hours\n    uint public constant INVEST_AMOUNT = 100 finney; // 0.1 ETH\n    uint constant FEE = 3;\n\n    team public red;\n    team public blue;\n\n    mapping(address => uint) public balances;\n    address creator;\n\n    string[] public historyWinner;\n    uint[] public historyRed;\n    uint[] public historyBlue;\n    uint public gameNbr;\n\n    function tickingBomb() {\n        newRound();\n        creator = msg.sender;\n        gameNbr = 0;\n    }\n\n    function helpRed() {\n        uint i;\n        uint amount = msg.value;\n\n        // Check if Exploded, if so save the previous game\n        // And create a new round\n        checkIfExploded();\n\n        // Update the TimeStamp\n        red.lastUpdate = block.timestamp;\n\n        // Split the incoming money every INVEST_AMOUNT\n        while (amount >= INVEST_AMOUNT) {\n            red.members.push(msg.sender);\n            red.nbrMembers++;\n            amount -= INVEST_AMOUNT;\n        }\n\n        // If there is still some money in the balance, sent it back\n        if (amount > 0) {\n            msg.sender.send(amount);\n        }\n    }\n\n    function helpBlue() {\n        uint i;\n        uint amount = msg.value;\n\n        // Check if Exploded, if so save the previous game\n        // And create a new game\n        checkIfExploded();\n\n        // Update the TimeStamp\n        blue.lastUpdate = block.timestamp;\n\n        // Split the incoming money every 100 finneys\n        while (amount >= INVEST_AMOUNT) {\n            blue.members.push(msg.sender);\n            blue.nbrMembers++;\n            amount -= INVEST_AMOUNT;\n        }\n\n        // If there is still some money in the balance, sent it back\n        if (amount > 0) {\n            msg.sender.send(amount);\n        }\n    }\n\n    function checkIfExploded() {\n        if (checkTime()) {\n            newRound();\n        }\n    }\n\n    function checkTime() private returns(bool exploded) {\n        uint i;\n        uint lostAmount = 0;\n        uint gainPerMember = 0;\n        uint feeCollected = 0;\n\n        // If Red and Blue have exploded at the same time, return the amounted invested\n        if (red.lastUpdate == blue.lastUpdate && red.lastUpdate + DELAY < block.timestamp) {\n            for (i = 0; i < red.members.length; i++) {\n                balances[red.members[i]] += INVEST_AMOUNT;\n            }\n            for (i = 0; i < blue.members.length; i++) {\n                balances[blue.members[i]] += INVEST_AMOUNT;\n            }\n\n            historyWinner.push('Tie between Red and Blue');\n            historyRed.push(red.nbrMembers);\n            historyBlue.push(blue.nbrMembers);\n            gameNbr++;\n            return true;\n        }\n\n        // Take the older timestamp\n        if (red.lastUpdate < blue.lastUpdate) {\n            // Check if the Red bomb exploded\n            if (red.lastUpdate + DELAY < block.timestamp) {\n                // Calculate the lost amount by the red team\n                // Number of Red member * Invested amount per user  *\n                feeCollected += (red.nbrMembers * INVEST_AMOUNT * FEE / 100);\n                balances[creator] += feeCollected;\n                lostAmount = (red.nbrMembers * INVEST_AMOUNT) - feeCollected;\n\n                gainPerMember = lostAmount / blue.nbrMembers;\n                for (i = 0; i < blue.members.length; i++) {\n                    balances[blue.members[i]] += (INVEST_AMOUNT + gainPerMember);\n                }\n\n                historyWinner.push('Red');\n                historyRed.push(red.nbrMembers);\n                historyBlue.push(blue.nbrMembers);\n                gameNbr++;\n                return true;\n            }\n            return false;\n        } else {\n            // Check if the Blue bomb exploded\n            if (blue.lastUpdate + DELAY < block.timestamp) {\n                // Calculate the lost amount by the red team\n                // Number of Red member * Invested amount per user  *\n                feeCollected += (blue.nbrMembers * INVEST_AMOUNT * FEE / 100);\n                balances[creator] += feeCollected;\n                lostAmount = (blue.nbrMembers * INVEST_AMOUNT) - feeCollected;\n                gainPerMember = lostAmount / red.nbrMembers;\n                for (i = 0; i < red.members.length; i++) {\n                    balances[red.members[i]] += (INVEST_AMOUNT + gainPerMember);\n                }\n\n                historyWinner.push('Blue');\n                historyRed.push(red.nbrMembers);\n                historyBlue.push(blue.nbrMembers);\n                gameNbr++;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    function newRound() private {\n        red.name = ""Red team"";\n        blue.name = ""Blue team"";\n        red.lastUpdate = block.timestamp;\n        blue.lastUpdate = block.timestamp;\n        red.nbrMembers = 0;\n        blue.nbrMembers = 0;\n        red.members = new address[](0);\n        blue.members = new address[](0);\n    }\n\n    function() {\n        // Help the oldest timestamp (going to explode first)\n        if (red.lastUpdate < blue.lastUpdate) {\n            helpRed();\n        } else {\n            helpBlue();\n        }\n    }\n\n    function collectBalance() {\n        msg.sender.send(balances[msg.sender]);\n        balances[msg.sender] = 0;\n    }\n\n    // Allow the creator to send their balances to the players\n    function sendBalance(address player) {\n        if (msg.sender == creator) {\n            player.send(balances[player]);\n        }\n    }\n\n    function newOwner(address newOwner) {\n        if (msg.sender == creator) {\n            creator = newOwner;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックが中心で芸術性は低い。,
1581027,0x9cde7898261f4bd62ee990427c0f8d526440c0de,false,false,,,,TOO_SHORT
1581093,0x98d20c66bd4dba10ad2747dfc4467705062df0f1,false,false,,,,TOO_SHORT
1581157,0x2dd3e63c8a64b54365e0f80ca990c76c5223acc4,false,false,,,,TOO_SHORT
1581248,0x4cb5b61fe4807907d72c988e9cc063827a47064b,false,false,,,,TOO_SHORT
1581249,0x08b26edd6e72494c990474f38cd11a26d5557183,false,false,,,,TOO_SHORT
1581262,0xb88202fce9bfcdb1b150706cb9fa82b71efbb7d6,false,false,,,,TOO_SHORT
1581297,0x39ac3e0e1f6bd7016907380c6d701195d797ee49,false,false,,,,TOO_SHORT
1581313,0x136988881e2cd028e4656cd72d2533927b4aa676,false,false,,,,TOO_SHORT
1581424,0x9adf198e8450c95adc63f5619e63f96ba9ae09a5,false,false,,,,TOO_SHORT
1581537,0x8e9dc69b1ff9ea038c60d727f9a8176171ef14d6,false,false,,,,TOO_SHORT
1581642,0x4f9bd9d4768147c39681ffa203917ef81ac2c988,false,false,,,,TOO_SHORT
1581759,0x61064db400ab04c1cea2797a1a417268cf096f03,false,false,,,,TOO_SHORT
1581840,0xd5aa928ca0b2efdb7b1da38022ab3aedf8d41839,false,false,,,,TOO_SHORT
1581846,0xbcf7cf01d2dbb526549a948382cc6c6a84715eea,false,false,,,,TOO_SHORT
1581847,0x0a4294c808272ce17f45e1f1fe7655dedd2b3c9d,false,false,,,,TOO_SHORT
1581848,0x05c57e7500754a5eccee06bf8b679da62d4a3c84,false,false,,,,TOO_SHORT
1581854,0xfbb2aafff771d19b52b0a8b1a5cc8723b196b6fd,false,false,,,,TOO_SHORT
1581855,0x4f85f117fdff6ddc1cc98ee66dcd838628d15654,false,false,,,,TOO_SHORT
1581879,0xa5eddb74d136d7d40355c93b1378d8368d959eda,false,false,,,,TOO_SHORT
1581904,0x11d5805f8f15b7959424306f6d6223bb4ef61b35,false,false,,,,TOO_SHORT
1581905,0xd0eb71f87cca6abe0e9f7f1cc74a998c48a34c2d,false,false,,,,TOO_SHORT
1581943,0x61fdfde3a435d9c740144b8bca179e93c5198ed5,false,false,,,,TOO_SHORT
1582001,0xd932fa3eac05503553b0681d56dcada812e864f6,false,false,,,,TOO_SHORT
1582136,0x1b8d26839c83210cdf61ae6d6b28985f2d74190a,false,false,,,,TOO_SHORT
1582286,0xdf4624c0eb76a7a73174fb3883b92464152464a3,false,false,,,,TOO_SHORT
1582389,0xcf83389cc2a1da8d1266c7377a3b5e330f58bc39,false,false,,,,TOO_SHORT
1582400,0x419fe567afd75ba833e96338f3a2ffcc1f0e7ae9,false,false,,,,TOO_SHORT
1582545,0x6f970a85e12334cd46a1484a7131ca9a63af82f2,false,false,,,,TOO_SHORT
1582689,0x2bbfbaf2e52da32835b69579c70446f7fc8dccc3,false,false,,,,TOO_SHORT
1582742,0x0925eb15ee409345bd6d97694789fbc08679f915,false,false,,,,TOO_SHORT
1582845,0xfa921bb2f2c2c8e0c533ad606ba21e3a707ccfd5,false,false,,,,TOO_SHORT
1582850,0x2ba85a8b0b6fb3cb94fa701137c60f86a9fa8330,false,false,,,,TOO_SHORT
1582925,0x34ff6753e7d665c89e184079e81134630e339845,false,false,,,,TOO_SHORT
1582939,0x1d0f20b431af8709894b2167e4bab98406db74fd,false,false,,,,TOO_SHORT
1583068,0x671d2740e89619b83c85cb74ddd6f40a753e2f23,false,false,,,,TOO_SHORT
1583180,0x437fd21274d8311c392cd05260aac72170726ab7,false,false,,,,TOO_SHORT
1583642,0x240d5fe2c5abf5ccb3c2f082d8410f0cae683e56,false,false,,,,TOO_SHORT
1583791,0xe5e63b7180659cb433b88c181db5a5b0c6046545,false,false,,,,TOO_SHORT
1583839,0xa383fb29695e89330fc0758bd8fd3d7dbe279f7a,false,false,,,,TOO_SHORT
1584007,0x79930a9fc72e984770d38ce1ed254bb8dd504294,false,false,,,,TOO_SHORT
1584046,0x8a94e8a60d07fc5c21b85c54f33c7ca7c1c6ebe0,false,false,,,,TOO_SHORT
1584091,0x0daa849194a1ffa191c0cf743a805be55864939f,false,false,,,,TOO_SHORT
1584101,0xb450f2a7a943d290ed32bcabc113777cd9212b35,false,false,,,,TOO_SHORT
1584366,0x06c4b04d9fc47c1bb85c7e01b57cc03ea9d4f8a5,false,false,,,,TOO_SHORT
1584440,0x058a53b1445fd6d4620252d175e4aebb3f9219b9,false,false,,,,TOO_SHORT
1584441,0x186a8c0466c275ddc0cd3ee0c669f4445089a911,false,false,,,,TOO_SHORT
1584457,0x1226c5cc28ad8a9f90ae00349bfa28f0e4b5d43e,false,false,,,,TOO_SHORT
1584497,0xd2b731996260dbb61da73bdd59e7a45aa08a7a3d,false,false,,,,TOO_SHORT
1584531,0xacf97ec2dc140a8b8d2f189510f0eaf979711fd6,false,false,,,,TOO_SHORT
1584539,0x40a42ba7afb20c766d9d07d710c73fe737615ad0,false,false,,,,TOO_SHORT
1584697,0x7a29f017511835f6d8398d9520881f29ee211571,false,false,,,,TOO_SHORT
1584828,0xd5546e7c72c34a3a9b8dd6f97ea907239d526157,false,false,,,,TOO_SHORT
1585186,0x3aefb81d938aeca70431da51facf63d5a36ded3c,false,false,,,,TOO_SHORT
1585234,0x283da936b4ef2f3d812eef7430ef523d457dc680,false,false,,,,TOO_SHORT
1585415,0x50b8c5309d410eaebd21920fdb6e7e5a0b3de4dc,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1585415,0x887aca31d5e08609f216eac25ffebcbb02781747,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1585415,0x578fd69127eaba0c6b45cf31fa56bd714fd87924,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1585442,0xd0d68ea445ec72efbe12651e144b84f22e0842ef,false,false,,,,TOO_SHORT
1585620,0x7f9c350744d5b9f7b9be138fb84c907c60009db6,false,false,,,,TOO_SHORT
1585678,0xb84b2a5787016cfb258c88fcdb2ed8283ade7cc5,false,false,,,,TOO_SHORT
1585821,0xbd475866e1a8e9430017a790953ef0b31aceaac4,false,false,,,,TOO_SHORT
1586106,0x1a46986223ec0d920a0b6d04bebab7ac1b0f6775,false,false,,,,TOO_SHORT
1586334,0x58e35c7a10caa9ffe7f5d2b4e818a872be738c5f,false,false,,,,TOO_SHORT
1586441,0xf15e27fde3a2fc9a5733fede1ff460fec10ece66,false,false,,,,TOO_SHORT
1586502,0x53a9703a76909598c21787e6fc7cc8552e18155d,false,false,,,,TOO_SHORT
1586544,0x7fa5e191b973b5501c7f2b0d7c1cb31d5a991bb5,false,false,,,,TOO_SHORT
1586631,0x5fac54fd0c949aca24a48c8122b720793c6416be,false,false,,,,TOO_SHORT
1586632,0x2321e27cd35fe4a06de093b42021eb524a20671a,false,false,,,,TOO_SHORT
1586741,0x3f566f41b90f558bfb47483320056ec84d5add2a,false,false,,,,TOO_SHORT
1586770,0x3581729fa44585f4ab15ace02935ec999304fa3e,false,false,,,,TOO_SHORT
1586813,0xb7721e7491b28eeb1b503492bfba8f6896b8ad80,false,false,,,,TOO_SHORT
1586918,0x2d0ed9b49b1ebc073a16fad86f6b5d228064abbb,false,false,,,,TOO_SHORT
1587064,0x3dc44d9997a54078777c1847544e862e6c33500a,false,false,,,,TOO_SHORT
1587337,0x321e28f0d497bea0d5ce86b899e02ef009d720d1,false,false,,,,TOO_SHORT
1587420,0x92bb6242480092692efe34b29399505693c37333,false,false,,,,TOO_SHORT
1587446,0xfbb100d12eb6f227c70af7da8db4d6304bc71442,false,false,,,,TOO_SHORT
1587549,0x840e072d894f3b4cfa43fceb94c810f26f50e918,false,false,,,,TOO_SHORT
1587555,0x6bcf458eebdd8205a08f30a6c9362941a819aa95,false,false,,,,TOO_SHORT
1587630,0x3cf0e8e1504f5f2e51b9d4462129723f31709ff1,true,false,,,,0x838b3606489c5a0e4d97ed113d4aa8d324f4a330
1587683,0x802b2665999a0e9f973dd8f71553070fa2116c54,false,false,,,,TOO_SHORT
1587710,0x0486d2d07554d7407ebc5cc51862f6ce21094000,false,false,,,,TOO_SHORT
1587849,0xba3e14a7f0169d86fc1389ad40ca4356a1404640,true,false,,,,0x838b3606489c5a0e4d97ed113d4aa8d324f4a330
1587891,0x201e7e23127c184cf3b0d7119cf8c10a8f3a2196,false,false,,,,TOO_SHORT
1587892,0xbd5f9eebaa7f79db7e87a718ab7e27278f4a9c04,false,false,,,,TOO_SHORT
1587915,0xfa95042b27777caab0dae22d222fce59f4d1eac1,false,false,,,,TOO_SHORT
1587950,0xa0e92a8af9f46a7a7a7d391215e945ca76d6df19,false,false,,,,TOO_SHORT
1588185,0x9287fc1287bdf85c0c69467c4700996f054fc58d,false,false,,,,TOO_SHORT
1588236,0xe4e23b37c314ef623237e22643faf4fc7f416573,false,false,,,,TOO_SHORT
1588380,0x56628dc9339a79f9093e72152514627a59369ad5,false,false,,,,0xe966652244b335a724a0465bb0b682e3885d3177
1588398,0x37e061835b8b038d3bdb51991d1193a258c27002,false,false,,,,TOO_SHORT
1588470,0x28724fa6c763891e2928784f1dc03904aa6e9796,false,false,,,,TOO_SHORT
1588586,0xbcfb5216be91a8d9986b47a11a3d8420d5200af4,false,false,,,,TOO_SHORT
1588645,0x1387c4cbb161596482a1fed5efe12476bff873e6,false,false,,,,TOO_SHORT
1588677,0x1f38ec29032b08aa98ca3c9f1e90f3016eef9218,false,false,,,,TOO_SHORT
1588678,0x62db84c7ad19d9ee78510683833e46b13d63ecdd,false,false,,,,TOO_SHORT
1588716,0xf2b35e0d7c05fdd3f994cfe608749f0c87c95c2e,false,false,,,,TOO_SHORT
1588734,0x9bedcf610d7e6f87daf471a2c38c7b4c97f87177,false,false,,,,TOO_SHORT
1588959,0x8906af088a59c6294afd0afb955755da3f55b3a3,false,false,,,,TOO_SHORT
1588983,0xc82274ed61bd35fa3a3b10b02745d2e6afbfd6e3,false,false,,,,TOO_SHORT
1589145,0x4e8734452071da8b31bbe112738759e3e0901319,false,false,,,,TOO_SHORT
1589171,0x253137971b86074021334fb5b7e03ebf2545ead3,false,false,,,,TOO_SHORT
1589183,0x086ad3831bb9354a393e46f2f595e00d25701fb5,false,false,,,,TOO_SHORT
1589201,0xe99ad36b6c5508c126cc755e0891e8e059842b93,false,false,,,,TOO_SHORT
1589364,0xe0a8826306732753e784ae944a56a83f1fe50c17,false,false,,,,TOO_SHORT
1589414,0x9c9e5e757ec6ce355d49edb0020714c32e911187,false,false,,,,TOO_SHORT
1589511,0xf9684034c8af061d4a7e346048d55743800c1f81,false,false,,,,TOO_SHORT
1589543,0x3bc483faf39be94149906fad7b130468812b1d8e,false,false,,,,TOO_SHORT
1589764,0xc7eb0b5db4604b7486c3416109a0fc5e602f5a0a,false,false,,,,TOO_SHORT
1589853,0x40d9ed0a192ca720554c7f9db78acca1308c3e28,false,false,,,,TOO_SHORT
1589918,0xa66803517729626cba34cd8d2cbeb387017aa1e8,false,false,,,,TOO_SHORT
1590121,0xf5801eb8822f34e904fa4eba97fe585c28b07fc6,false,false,,,,TOO_SHORT
1590664,0x4eb994558b6c3c1a62ccb8a57af1c8ec0a31bffb,false,false,,,,TOO_SHORT
1590667,0x9a6694d0c8cea9fcc590fda6a86a5b3521e3d867,false,false,,,,TOO_SHORT
1590740,0x147b6c217cd4cc54d88cc5cd0412532bc020cc0b,false,false,,,,TOO_SHORT
1590957,0xb59e4a0f29a61ce936931e124f09756c8959dea2,false,false,,,,TOO_SHORT
1591072,0x625588cd3a2bef3bb50284e1f57f0712e33c88c2,false,false,,,,TOO_SHORT
1591281,0x0a1fce445489056a1e30e06ffd7e0f0af2c2ec6c,false,false,,,,TOO_SHORT
1591498,0x92646546d1612d81a423e4f9d0f47c8122f87529,false,false,,,,TOO_SHORT
1591575,0xe9d1c1cf2cd1a87699de4196438b78a38950f234,false,false,,,,TOO_SHORT
1591775,0xc3c1880327dc6402e01f323cd375bf2227a621d4,false,false,,,,TOO_SHORT
1591795,0xb14eb8b8ae933377ec261e427d8b639e08650541,false,false,,,,TOO_SHORT
1591980,0xd9e2a22af0f31400f21faa0495c44e7b4c3a6077,false,false,,,,TOO_SHORT
1592335,0x1e547ecbc4e10676451ec41f0dae34e8b5792aca,false,false,,,,TOO_SHORT
1592343,0x7914c1d7c2b2d0f9e677a898bc17eeef5df3a2f1,false,false,,,,TOO_SHORT
1592387,0xb208c4403c62b58ed859f1c73f59faa6e8399590,false,false,,,,TOO_SHORT
1592389,0x6e278b2a4b94898de68d93f10ff762dea7f588d9,false,false,,,,TOO_SHORT
1592474,0xfa2241afdc0ce03465fd26063a178bfd07ed89e5,false,false,,,,TOO_SHORT
1592546,0xa612d1ef77a0d9097e5e9d1c8f341f2acd4f2b1f,false,false,,,,TOO_SHORT
1592548,0xc586251dfd51a018bb53a7d1473283217ada990d,false,false,,,,TOO_SHORT
1592893,0x476c3e4adc0cf3ecc077cf68924a5a51e9222db8,false,false,,,,TOO_SHORT
1592983,0xdd2a9acd91b03b688c168eab4fc7dc3a92291d71,false,false,,,,TOO_SHORT
1593089,0x95c7a14e25e672c189f87f19da3e2c5f051e7bbe,false,false,,,,TOO_SHORT
1593130,0x6a9d000997072b4e891727dae5f3716c022e074d,false,false,,,,TOO_SHORT
1593193,0xf1d32c895c74fa009e363a7f750667c11f7f90c9,false,false,,,,TOO_SHORT
1593194,0x69571322e89a0947e8a9ce042e69b52b96c59276,false,false,,,,TOO_SHORT
1593220,0x914235bc02f3b9a9f912f2d7065068940c397645,false,false,,,,TOO_SHORT
1593242,0x2a5a675b6a7f9e024b7d12db6d06820e039c3d53,false,false,,,,TOO_SHORT
1593437,0x35584d210da8434ce2426f961d23afb0f3b7de7c,false,false,,,,TOO_SHORT
1593464,0xbe300e14e3c00314d753e82bd6ba1159c16bb6ed,false,false,,,,TOO_SHORT
1593736,0xf8d9be210a6abd6706b6944806c2b1f74591dec4,false,false,,,,TOO_SHORT
1593809,0xb8bfbdbbdfef37ed033b560cfd3b2c05c5f591eb,false,false,,,,TOO_SHORT
1593810,0x08a5e95869395c0cf503334a53211327bf37cb3f,false,false,,,,TOO_SHORT
1593847,0x0284d68f67f00c707d18ec9584b753d857bb75ea,false,false,,,,TOO_SHORT
1593879,0x22015bddc86816f1c01052f45f09a8ee03a9be12,false,false,,,,TOO_SHORT
1593956,0x6a00a39348744fc9a6905574488cd5c15bb469a7,false,false,,,,TOO_SHORT
1594011,0x2cee72e67aac3ac81bc96be3808c36e219e900dd,false,false,,,,TOO_SHORT
1594054,0xa96f9b295dc3d8866b4470d62f3690bcf7f8047c,false,false,,,,TOO_SHORT
1594199,0x02e2b9fb398e15897ae1fab2244d2c0af43bca2e,false,false,,,,TOO_SHORT
1594214,0xd3ebecfe49aca8a8bc6c28d2b8045f00764e2ab4,false,false,,,,TOO_SHORT
1594361,0x1264d49414a97059ed11dea2caf3660ddf94c0e7,false,false,,,,TOO_SHORT
1594442,0x74c708615e2b601fdf3574a3b403d6f093a50482,false,false,,,,TOO_SHORT
1594473,0xe269b966241e0f5a531fee1aa0674aa054cec0c1,false,false,,,,TOO_SHORT
1594492,0x9d9def06af09efa14180c87a07ca1a7072e54a43,false,false,,,,TOO_SHORT
1594562,0xd592d298bb69e022c1f079a88fb3c8d9778afb72,false,false,,,,TOO_SHORT
1594622,0x6d79c127445398674ca27aef8932e6f8a105d014,false,false,,,,TOO_SHORT
1594623,0x6b91116bd9adfd1e36157bff9887654f1fa5e1cf,false,false,,,,TOO_SHORT
1594627,0x4af349555666561205bd2bc589dedca3ffd3d064,false,false,,,,TOO_SHORT
1594645,0xcc611d21a1b7cd93e76a47c59a727ae9c288e669,false,false,,,,TOO_SHORT
1594658,0xf259421ddf3436e1a837ff6ad3b11721252c46b8,false,false,,,,TOO_SHORT
1594708,0x0540e81a686709c8c7deb6926ba40e7dd97b741b,false,false,,,,TOO_SHORT
1594731,0x40dea441150adcbb618343566f47da9312777bbe,false,false,,,,TOO_SHORT
1594742,0x025abad6de060f94cc6c9a98d4e7637f97288f08,false,false,,,,TOO_SHORT
1594745,0xcb51326620f8a44c3fe0fcf9658352ee02ea542c,false,false,,,,TOO_SHORT
1594779,0x9bcf908f955c4651d6bd9cf7c69d9e578085192a,false,false,,,,TOO_SHORT
1594854,0x614f3e5dbef6d2d567bf01fba457a3827a6afa1d,false,false,,,,TOO_SHORT
1594908,0x23d6f569cda4c830c908deca7f98ee87531169c8,false,false,,,,TOO_SHORT
1594944,0x837ffc736ac37609b24925f8fd2070a88ef14793,false,false,,,,TOO_SHORT
1594946,0xe0773e321b88e37c77c8113794f96c65491fd31d,false,false,,,,TOO_SHORT
1594970,0x3019cd2286bc312f2baed934f4d27dcd3e12ec77,false,false,,,,TOO_SHORT
1594979,0xf5c6ae4b69423b594d15df951ab2dc3cb481a41a,false,false,,,,TOO_SHORT
1595053,0x48b4cb193b587c6f2dab1a9123a7bd5e7d490ced,false,false,contract SimpleStorage {\n  uint storedData;\n\n  function set(uint x) {\n    storedData = x;\n  }\n\n  function get() constant returns (uint retVal) {\n    return storedData;\n  }\n},1,基本的なストレージ機能を持つシンプルなスマートコントラクト。,
1595073,0xa385f39f498f8585ae1f7479827c3f02ec9a32f6,true,false,,,,0x25af8d824b3b078a589e47418a95b4388d1552f4
1595073,0x7b99439cdbacb7e4b35109a679809ea6b5c5d05a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1595073,0x6d88e88ddcb726ed86ad54d539949456d6acdcc4,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1595073,0x31369b4bd3f66d6496a1ab729738e03d018b77f5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1595086,0x76246d9839dd0833b660d85fe3c8f8b4afc63969,false,false,,,,TOO_SHORT
1595159,0xf32c6e8981be83396c4191b67bb4f4e851850f5e,false,false,,,,TOO_SHORT
1595177,0xd8381a6e001080d665719b88727b88e9931d353d,false,false,,,,TOO_SHORT
1595189,0x29415856f7c6852b25261b101830debe938246ca,false,false,,,,TOO_SHORT
1595224,0x8d7218c491838dc34f4668d5454d59c10e82aec1,false,false,,,,TOO_SHORT
1595233,0x85efd64ad068b0133c658b8519ec458914a3e8b1,false,false,,,,TOO_SHORT
1595280,0xdb56ca8c5a60cb482b410840c4ee086c4a5b2707,false,false,,,,TOO_SHORT
1595391,0xbc8ab3ac2047a957bb66b88ac1d0de061b1ebdb7,false,false,,,,TOO_SHORT
1595418,0x45e719c093d9c5a76739592110d353f1b89d51ae,false,false,,,,TOO_SHORT
1595498,0xe640244f00ab2349171eca6a9367f0b5a64416cc,false,false,,,,TOO_SHORT
1595568,0x6000594b893442fd06ef7f4aebbbc950defaa13c,false,false,,,,TOO_SHORT
1595708,0xefe567e6459c5452e805d93728b51dff311a9d7e,false,false,,,,TOO_SHORT
1595797,0x20b26d8a54583b8d3b62432db5ada67ad5ed005b,false,false,,,,TOO_SHORT
1595798,0x5f68cb9fcc328e830184b4eeebac8fcf5df585d9,false,false,,,,TOO_SHORT
1595978,0xefa220a40a6b7f2182824d9fd70c9f3d0e7099b4,false,false,,,,TOO_SHORT
1595996,0x2ede4052ae2bf491e9f94b0566a9dc37a0501f65,false,false,,,,TOO_SHORT
1596024,0xbe367881e002112e1688a99defe2be9e5dd4af14,false,false,,,,TOO_SHORT
1596057,0x6ddf71af90750ed04c99e0a81f4a3009735ba17a,false,false,,,,TOO_SHORT
1596088,0x09a9fa67a83eb88ac73d8b22a2d5bf783a19ea19,false,false,,,,TOO_SHORT
1596089,0x9a24cf8729f3e49e119b3a963f2beb43016632d3,false,false,,,,TOO_SHORT
1596101,0x448744840669c0f7cb7fa96568ffcd29e5491fd0,false,false,,,,TOO_SHORT
1596217,0x7266ffdd32df4c6b8572cf80c6922727b0983311,false,false,,,,TOO_SHORT
1596302,0x78c6ccabd55fb223cd287af0be2cfdd7bff247ff,false,false,,,,TOO_SHORT
1596310,0xbde6bd3b2ed5e232182d1b5fd0fc1d6f1e675f75,false,false,,,,TOO_SHORT
1596317,0xd1354da7261b05a4703c9052a270234c1d70ce40,false,false,,,,TOO_SHORT
1596318,0x9d537768d879a36776b414d3165170c3a3120ac7,false,false,,,,TOO_SHORT
1596340,0x7b4279f226ad1e765cf73a4b5da0a8c64e929c47,false,false,,,,TOO_SHORT
1596409,0xaf259c70032061281a1ac29bd8b097753e642a1a,false,false,,,,TOO_SHORT
1596469,0x8cbca499884ac91065daa258adf66d62e3d02c85,false,false,,,,TOO_SHORT
1596497,0xdcaf7e924e784ef1076a80f9c5a507f6dd0cd07d,false,false,,,,TOO_SHORT
1596513,0xec0b3ec47c12588acf9d52429a9d9404b401ebb8,false,false,,,,TOO_SHORT
1596521,0x244c2f76a35d0e252d1aa6321d0777a815e7a853,false,false,,,,TOO_SHORT
1596545,0xe1de2c0d89b24f90b9064d783a5809aef1fdeb19,false,false,,,,TOO_SHORT
1596567,0xf9d88811694af1d97788d6935cc54bd7e81f8055,false,false,,,,TOO_SHORT
1596568,0x40c0300bf7e0e888e386c9b97a705c04e227b720,false,false,,,,TOO_SHORT
1596569,0xd21b2d523c525513db1c5e19ede77196324c2d74,false,false,,,,TOO_SHORT
1596582,0x671341c0e1b5a3fdf3a04dc99ea9c7065f7f64b9,false,false,,,,TOO_SHORT
1596670,0x7bd274c4b638b53a09dad1177454e8efbae501a5,false,false,,,,TOO_SHORT
1596674,0x4c4f95f93e0621541f009477939ed31ee8c9d48c,false,false,,,,TOO_SHORT
1596707,0x938a5de5f57791db134cdd7088990aa61bd163e6,false,false,,,,TOO_SHORT
1596843,0x665adf00ddfd0a792fb8a8b20a4cfaba13f9be31,false,false,,,,TOO_SHORT
1596890,0xf8c35f1cf2dc4dbeaeeb2ecb298a80b506a5781d,false,false,"contract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}\n\ncontract DAOSecurity {\n\n    // The total cost of the Offer. Exactly this amount is transfered from the\n    // Client to the Offer contract when the Offer is signed by the Client.\n    // Set once by the Offerer.\n    uint totalCosts;\n\n    // Initial withdraw to the Contractor. It is done the moment the Offer is\n    // signed.\n    // Set once by the Offerer.\n    uint oneTimeCosts;\n\n    // The minimal daily withdraw limit that the Contractor accepts.\n    // Set once by the Offerer.\n    uint128 minDailyWithdrawLimit;\n\n    // The amount of wei the Contractor has right to withdraw daily above the\n    // initial withdraw. The Contractor does not have to do the withdraws every\n    // day as this amount accumulates.\n    uint128 dailyWithdrawLimit;\n\n    // The address of the Contractor.\n    address contractor;\n\n    // The hash of the Proposal/Offer document.\n    bytes32 hashOfTheProposalDocument;\n\n    // The time of the last withdraw to the Contractor.\n    uint lastPayment;\n\n    uint dateOfSignature;\n    DAO client; // address of DAO\n    DAO originalClient; // address of DAO who signed the contract\n    bool isContractValid;\n\n    modifier onlyClient {\n        if (msg.sender != address(client))\n            throw;\n        _\n    }\n\n    // Prevents methods from perfoming any value transfer\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function DAOSecurity(\n        address _contractor,\n        address _client,\n        bytes32 _hashOfTheProposalDocument,\n        uint _totalCosts,\n        uint _oneTimeCosts,\n        uint128 _minDailyWithdrawLimit\n    ) {\n        contractor = _contractor;\n        originalClient = DAO(_client);\n        client = DAO(_client);\n        hashOfTheProposalDocument = _hashOfTheProposalDocument;\n        totalCosts = _totalCosts;\n        oneTimeCosts = _oneTimeCosts;\n        minDailyWithdrawLimit = _minDailyWithdrawLimit;\n        dailyWithdrawLimit = _minDailyWithdrawLimit;\n    }\n\n    // non-value-transfer getters\n    function getTotalCosts() noEther constant returns (uint) {\n        return totalCosts;\n    }\n\n    function getOneTimeCosts() noEther constant returns (uint) {\n        return oneTimeCosts;\n    }\n\n    function getMinDailyWithdrawLimit() noEther constant returns (uint128) {\n        return minDailyWithdrawLimit;\n    }\n\n    function getDailyWithdrawLimit() noEther constant returns (uint128) {\n        return dailyWithdrawLimit;\n    }\n\n    function getContractor() noEther constant returns (address) {\n        return contractor;\n    }\n\n    function getHashOfTheProposalDocument() noEther constant returns (bytes32) {\n        return hashOfTheProposalDocument;\n    }\n\n    function getLastPayment() noEther constant returns (uint) {\n        return lastPayment;\n    }\n\n    function getDateOfSignature() noEther constant returns (uint) {\n        return dateOfSignature;\n    }\n\n    function getClient() noEther constant returns (DAO) {\n        return client;\n    }\n\n    function getOriginalClient() noEther constant returns (DAO) {\n        return originalClient;\n    }\n\n    function getIsContractValid() noEther constant returns (bool) {\n        return isContractValid;\n    }\n\n    function sign() {\n        if (msg.sender != address(originalClient) // no good samaritans give us ether\n            || msg.value != totalCosts    // no under/over payment\n            || dateOfSignature != 0)      // don't sign twice\n            throw;\n        if (!contractor.send(oneTimeCosts))\n            throw;\n        dateOfSignature = now;\n        isContractValid = true;\n        lastPayment = now;\n    }\n\n    function setDailyWithdrawLimit(uint128 _dailyWithdrawLimit) onlyClient noEther {\n        if (_dailyWithdrawLimit >= minDailyWithdrawLimit)\n            dailyWithdrawLimit = _dailyWithdrawLimit;\n    }\n\n    // ""fire the contractor""\n    function returnRemainingEther() onlyClient {\n        if (originalClient.DAOrewardAccount().call.value(this.balance)())\n            isContractValid = false;\n    }\n\n    // Withdraw to the Contractor.\n    //\n    // Withdraw the amount of ether the Contractor has right to according to\n    // the current withdraw limit.\n    // Executing this function before the Offer is signed off by the Client\n    // makes no sense as this contract has no ether.\n    function getDailyPayment() noEther {\n        if (msg.sender != contractor)\n            throw;\n        uint timeSinceLastPayment = now - lastPayment;\n        // Calculate the amount using 1 second precision.\n        uint amount = (timeSinceLastPayment * dailyWithdrawLimit) / (1 days);\n        if (amount > this.balance) {\n            amount = this.balance;\n        }\n        if (contractor.send(amount))\n            lastPayment = now;\n    }\n\n    // Change the client DAO by giving the new DAO's address\n    // warning: The new DAO must come either from a split of the original\n    // DAO or an update via `newContract()` so that it can claim rewards\n    function updateClientAddress(DAO _newClient) onlyClient noEther {\n        client = _newClient;\n    }\n\n    function () {\n        throw; // this is a business contract, no donations\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。DAOの機能を実装しており、芸術的要素は少ない。,
1596963,0x4dd4e7f98d703775a7a914b365dfdbb592a3013b,false,false,,,,TOO_SHORT
1597271,0x3d11dfd91a5ff174363cb26821324e29c09cedb3,false,false,,,,TOO_SHORT
1597277,0xca36e90f1bffe361068bc4b52f7ecf98514cddf6,false,false,,,,TOO_SHORT
1597283,0xc8fe002fcb282164c976bb21e22de6f65ab715d6,false,false,,,,TOO_SHORT
1597388,0xc17f49a0b5bcf5aae96a2c82963226638949e9ab,false,false,,,,TOO_SHORT
1597460,0xa9b0e4c8ea3e04559ee9344a91902ad9dbe43917,false,false,,,,TOO_SHORT
1597502,0x82e3e34416ca3d79240ac31aa996e50127061e41,false,false,,,,TOO_SHORT
1597605,0x8f541ecc294a47d8beab7229352a8d178bbbdf56,false,false,,,,TOO_SHORT
1597699,0x097505ed004990459f2388106dee2bc0a2fecbcc,false,false,,,,TOO_SHORT
1597707,0xd6b6dacce6c75534fd43f42d744a2172832736f3,false,false,,,,TOO_SHORT
1597798,0xb6f7d2d2127a56af7d55cdbd7d327439a9005abf,false,false,,,,TOO_SHORT
1598011,0x6d8d0b8f8a54185716b68286e4a75b7d08d37b8a,false,false,,,,TOO_SHORT
1598021,0xeaba1cdb68c7930b14ba32ad0a572f934f1cdcf6,false,false,,,,TOO_SHORT
1598130,0x9a44d5cfd520fcf097412080b30dbc81a8e17ef6,false,false,,,,TOO_SHORT
1598131,0xa021f834470f9484d2b66cae56b74d833477b600,false,false,,,,TOO_SHORT
1598153,0xfec8d473b3c8fc73cc7c46d563efedcf0c5622b1,false,false,,,,TOO_SHORT
1598198,0x71d40e1bff7c30a36f9a006b8bed09c0158119a8,false,false,,,,TOO_SHORT
1598202,0x64d254726aeac2a5aafdf121c2b048f8b8bc7976,false,false,,,,TOO_SHORT
1598296,0x568c1f3ee3c7f63c20c87438801009709409133a,false,false,,,,TOO_SHORT
1598477,0xfe3e57a8b51bae95ece861a722105b105a11d890,false,false,,,,TOO_SHORT
1598629,0x7a6af59942b1df2089e192532e18efe918863cc3,false,false,,,,TOO_SHORT
1598676,0xe56306160deeb45235f2b98815cc9f3fe485d8ea,false,false,,,,TOO_SHORT
1598679,0x93b5a23c45d38075d42d7ed9fc9b5dbcdbedee97,false,false,,,,TOO_SHORT
1598697,0xdea96e7a6cff4dc5b18b4939f59b54114ecb4f8a,false,false,,,,TOO_SHORT
1598828,0x4047d1c27e6093b363bad9f21ea1180bba0306a3,false,false,,,,TOO_SHORT
1598891,0xe303c09ee473d8c3f7505021ea86cc13bcdfab54,false,false,,,,TOO_SHORT
1598901,0x4662994cd563d95bc27b93f71f4f055bdabf86b1,false,false,,,,TOO_SHORT
1599010,0xbd1a232cb5d1a1b30c3b054c0352f20945105701,false,false,,,,TOO_SHORT
1599030,0xf896d9af62f2576fc81797729b434e31e988c497,false,false,,,,TOO_SHORT
1599106,0x6ef1fa49cc7ad32bf597efe9070aa582b480c9c8,false,false,,,,TOO_SHORT
1599151,0x7d2bede35774bcc7dc1e2a0bbc3ade3e1231edd5,false,false,,,,TOO_SHORT
1599158,0x02bb19175673d0c6a5f1486bed35b19142ad763a,false,false,,,,TOO_SHORT
1599159,0xd10a1f545ced4217fa7eb19bc64d957269ce4256,false,false,,,,TOO_SHORT
1599178,0x1e5d3df2875207819ca703009d3dbe5851f7bf65,false,false,,,,TOO_SHORT
1599320,0xfa8fd83499135348823965f19c8e1c4e9d47607f,false,false,,,,TOO_SHORT
1599407,0xb5e168297b85bcda09382fbcd5b6f8aeb28529e0,false,false,,,,TOO_SHORT
1599513,0x698d2bfa3af0acf21d9c727d86145d7d5d046c7d,false,false,,,,TOO_SHORT
1599542,0xd39f4d0c4b4709701b0946abbc135e8af5d3900e,false,false,,,,TOO_SHORT
1599740,0x0213fa18aeb1845d178b90d7dd2e86c1c65b673f,false,false,,,,TOO_SHORT
1599797,0x58ecec0abe1a668fa307a7a25dddf796f3f44fd2,false,false,,,,TOO_SHORT
1599823,0xd6f8d5a4e7a682a59d09f1c46b8db6b3a7f71bf3,false,false,,,,TOO_SHORT
1599848,0x04dabde58a5a330110f2d27afb8b10c7f8f54695,false,false,,,,TOO_SHORT
1599864,0x610f8333bf7973cbe5310953a5b1a9902cf85af7,false,false,,,,TOO_SHORT
1599892,0x667e3778db593e02c677df6d22a8361fa7f73960,false,false,,,,TOO_SHORT
1599925,0x344e2365d6320518f2ebd6392bb1c8b2825e337e,false,false,,,,TOO_SHORT
1600123,0x7ad37c11d7a145d1821f5d5740f4277b9f5ca3ee,false,false,,,,TOO_SHORT
1600218,0xb1b163c01a716ecc6f77875f943aeb1f8a5fa430,false,false,,,,TOO_SHORT
1600252,0xeb88317d7cf89a5cc91c26531ba76eb75add7301,false,false,,,,TOO_SHORT
1600310,0xde0353ece90484f24b6914f649f0b59ec715685f,false,false,,,,TOO_SHORT
1600528,0x732f1dbacffc6700775ec4a047fe40b409763af6,false,false,,,,TOO_SHORT
1600755,0x08b1271061448c22bb1589bce52109a355a94ed5,false,false,,,,TOO_SHORT
1600841,0xfa92169b957fe7cf930d1db746dbfd231cfbfbd6,false,false,,,,TOO_SHORT
1600907,0x66c95973dadc59995a2ff9290f27acd0ae06b6f4,false,false,,,,TOO_SHORT
1601012,0xa33fbc9c7408a75d29eea49a3933f3718d91a5b0,false,false,,,,TOO_SHORT
1601026,0x9d047ba09b3cc2523ab90640b3c1cbacc2d81de7,false,false,,,,TOO_SHORT
1601095,0x9420010956c8aa1f1c7e6ea4c2dcc7fbfbbc7473,false,false,,,,TOO_SHORT
1601131,0xb955c66ff031cea247ff22be1fdbeae23977d9d7,false,false,,,,TOO_SHORT
1601155,0x7357583fbfec6e98ef7e6f9e45ea21a6032ffa10,false,false,,,,TOO_SHORT
1601183,0x3d9e888911c0914e79671bc02b1e5f71a3fe6512,false,false,,,,TOO_SHORT
1601349,0x3ad870b95962855c2fad5f3e8e689121ec813dc5,false,false,,,,TOO_SHORT
1601629,0xf44003cf9387dafacf8702bc345e30362e8e87c9,false,false,,,,TOO_SHORT
1601634,0x28cc24c2d38ed46c4b727e9a8474d73c2eafe6c3,false,false,,,,TOO_SHORT
1601661,0x9857df45d1b38409af69a90de2724b7c0ebda0ad,false,false,,,,TOO_SHORT
1601817,0xbf6da9911ab99d54ecef7ca26095403df6f08c1d,false,false,,,,TOO_SHORT
1601873,0x173cf471476a7b08b7e4c7ee4ab72cfc4fb05984,false,false,,,,TOO_SHORT
1602030,0xabd91b963f56141ea63b6ab9f2cddb66d1be0aa2,false,false,,,,TOO_SHORT
1602082,0x8b906c0897dcd8f4664082c0a78b07f21d2bcdc5,false,false,,,,TOO_SHORT
1602456,0x0e4354fea22c544b23cc70c04c5b328641f906b2,false,false,,,,TOO_SHORT
1602500,0x37803530f8e829f4aecaac6ac6b53c0343f0bc79,false,false,,,,TOO_SHORT
1602656,0x88fb8a18172eceed7a009ea9a73c2cefb280ecb9,false,false,,,,TOO_SHORT
1602769,0xcc81a6efd218ee4f504b2730f86a9ce5fc40ee5c,false,false,,,,TOO_SHORT
1602826,0x824acaa2db4b35c090a09c1709e607cd2dc03ceb,false,false,,,,TOO_SHORT
1602837,0x9502cd342ba189f40f22d401357bdac6d0a131c4,false,false,,,,TOO_SHORT
1602910,0x17eb30feae8792342d6170e6e02c969ac4899cba,false,false,,,,TOO_SHORT
1603027,0x0d5c764def077830b444daf4d6d239a88f932ea4,false,false,,,,TOO_SHORT
1603079,0x32265632663ae3fc40ebfcafe4462c90deab397f,false,false,,,,TOO_SHORT
1603166,0x2a10991e5a757a0178b31f0471af4d5edb8516f7,false,false,,,,TOO_SHORT
1604030,0xd3b32cb84e406c255772cb982a616f5c66f8bd5e,false,false,,,,TOO_SHORT
1604246,0xe7f79f426318b4e4d8a8cc10145a7cff792e2628,false,false,,,,TOO_SHORT
1604518,0xd52e13ab8167d0ad2586a87b3dab63f297f1027d,false,false,,,,TOO_SHORT
1604581,0x740e852f7d5463a271a426152d36693e74134180,false,false,,,,TOO_SHORT
1604902,0xdee86e683fdf707b55e26b0828f54d5e92b1a7bb,false,false,,,,TOO_SHORT
1605065,0x9f8f7479a37b307ac8726e8018141bf0cc81eb81,false,false,,,,TOO_SHORT
1605088,0xfcad1ff29b464ed7c134d9e27f28e63e39ae3781,false,false,,,,TOO_SHORT
1605121,0xf40dcbfdcc5d2d84512cd700a620357d5fe0d39c,false,false,,,,TOO_SHORT
1605289,0xe0c436d9f9b85a49eb48b34ce18d154dadb3dbbc,false,false,,,,TOO_SHORT
1605364,0x1716f409c2e17052b6f7b813d54923c2d16a5552,false,false,,,,TOO_SHORT
1605402,0xd6d5867a90656f671c8ad4509e07eeec2a289163,false,false,,,,TOO_SHORT
1605970,0x5d45cbc883d618889c0880dbf5d4d0ddee4a3095,false,false,,,,TOO_SHORT
1606012,0x560757a11dea277280127ba17966120798cb84dd,false,false,,,,TOO_SHORT
1606014,0x6cbb1fe7d8d222fc74fd578a76b672558404acb1,false,false,,,,TOO_SHORT
1606041,0xb0cc1efcf284ee6a14b49d57a4de302a84035ba9,false,false,,,,TOO_SHORT
1606084,0xd2f2af507f5b6e5d9e2808bd0d18a72704581045,false,false,,,,TOO_SHORT
1606141,0xb1edecd41b5aea1599b862c00de8752d2c6a1b21,false,false,,,,TOO_SHORT
1606180,0x118e48ebc29816761022824c047202f1c8698d22,false,false,,,,TOO_SHORT
1606202,0xee42123f2fd161c41e349f882e35c3da138e0f50,false,false,,,,TOO_SHORT
1606215,0x8ff46401277551486d5330c9a2e08bc115a80c12,false,false,,,,TOO_SHORT
1606236,0xf412e4f83204c17300a14e34c61a567de22bc860,false,false,,,,TOO_SHORT
1606287,0x50242b2ba357bfa01675ec1f6e8b5588fb796e3b,false,false,,,,TOO_SHORT
1606519,0x8f81d1638430835db929cd2c4b90371b5af7c3ef,false,false,,,,TOO_SHORT
1606597,0x744aecd86c6dd7992064a744f7c39d091f3210fa,false,false,,,,TOO_SHORT
1606626,0xbff88ffa2b23a972ffbcd1380e13c4799044a7fd,false,false,,,,TOO_SHORT
1606830,0xf4655edcb3af98bb058ae96d7af1ea35f7b791f7,false,false,,,,TOO_SHORT
1606880,0x8e6d5bb52fc605d7f9d01e361f57add2c693f064,false,false,,,,TOO_SHORT
1606930,0x9db0ab21e7eef0b7832fb2effc7b9a2b01cddbbe,false,false,,,,TOO_SHORT
1606938,0xcc4228ee7506b0c048f71542a2c54ef052c4cca2,false,false,,,,TOO_SHORT
1606968,0x5084c528550cdea57008b3a539e513b6f2ad1ed3,false,false,,,,TOO_SHORT
1606981,0x376d9c31ffd2b4c11ef382cfaefd153c5467c6c3,false,false,,,,TOO_SHORT
1607059,0xa7dda3277007fe6a5fef28862b09a42328a6f2ca,false,false,,,,TOO_SHORT
1607123,0x44e21e1e3b1e25e54c29b3091f21eb8c19ef0235,false,false,,,,TOO_SHORT
1607210,0xa1d4c99242e4f05a6baea14f75e9ad0267a6387f,false,false,,,,TOO_SHORT
1607241,0x73583b186d278fc3049267c8380252963eb6e862,false,false,,,,TOO_SHORT
1607366,0x0e001a86888c53f32ada2c72f361a47b466dc1af,false,false,,,,TOO_SHORT
1607520,0x02fe6a2626f5feec3311f3f34f4d7a312a0dc3ad,false,false,,,,TOO_SHORT
1607566,0x25fc6a00f5d3a1218446fc39cf291933139a04ec,false,false,,,,TOO_SHORT
1607642,0xeaa4d67f39192c0ac32946b7344b8dc69fd998c0,false,false,,,,TOO_SHORT
1607747,0xfd3635c097058f9564bf15f2efa5b75629310ce5,false,false,,,,TOO_SHORT
1607771,0xc85e7f9be0f0a83b80b681e4366d17d4c8e424ce,false,false,,,,TOO_SHORT
1607772,0x6cf18f748d731ea3c94d61cc65818074f4c7d182,false,false,,,,TOO_SHORT
1607809,0x3fead041ea0a91aff857fe78c02ed013d7497785,false,false,,,,TOO_SHORT
1607815,0xcda62ca46599d6a4ffa155d2fa71a0bbe2e2d65c,false,false,,,,TOO_SHORT
1607970,0xeb35d5d346f58578f553544e2daca7e01bd7a5a8,false,false,,,,TOO_SHORT
1608020,0x53eff03526da9ca172c9dee058cd4286290ca8a7,false,false,,,,TOO_SHORT
1608044,0x134c4f243334ea7f3dd17a04548d65456c17ed7a,false,false,,,,TOO_SHORT
1608307,0x7426b129af1baca4a6144c6f404ab4b1c5613265,false,false,,,,TOO_SHORT
1608392,0xd60cd6cc8e923fbf77eb8bfdc10d138f526a181d,false,false,,,,TOO_SHORT
1608450,0x4a1e5bb73d513f1d708a8989be74ff58315b1b4c,false,false,,,,TOO_SHORT
1608563,0x6ee873ec509f8b5a31dc2ed7b7ae257c18085c22,false,false,,,,TOO_SHORT
1608643,0xb6b8499afc3e6522b564e83b0abd13c8713727c4,false,false,,,,TOO_SHORT
1609137,0xb3353e1009feb883862f25c1ac3006ab11018cd5,false,false,,,,TOO_SHORT
1609456,0x0d9513798b91141c47166f8a76e26bb135886e31,false,false,,,,TOO_SHORT
1609503,0xccb87ec378a1568b6cde63d89b0b1240c8879c13,false,false,,,,TOO_SHORT
1610154,0x50de7fbb815680a3bc9af8261e2819a3ad5344e8,false,false,,,,TOO_SHORT
1610235,0x895c2ecf41b0715087d01c6cd5e3a0414f21cc0a,false,false,,,,TOO_SHORT
1610241,0x013ebc90005d9255e0dfa6bb3f7514e5c46f8f42,false,false,,,,TOO_SHORT
1610534,0x21528245ae40cede82dd0be46324f2d1b8f3dbac,false,false,,,,TOO_SHORT
1610615,0x59801d43a0e28b03a2556e94ef8229d153fb56cd,false,false,,,,TOO_SHORT
1610775,0x685c7f5ad8ad71436e5f2556a4c080b847dfed44,false,false,,,,TOO_SHORT
1610906,0x48bbd212af31d63c5aa53a620c0c0d0f2d7f255a,false,false,,,,TOO_SHORT
1610997,0x6f8cd54e75bc62f28828f0b6fba405cedd348ffc,false,false,,,,TOO_SHORT
1611094,0x0594385b18824d38889fefed3884176562c9d219,false,false,,,,TOO_SHORT
1611263,0xf5e045edbd0c2b166b3c4cd5cac128b1826a11ed,false,false,,,,TOO_SHORT
1611344,0xe72658d02a998bfd5f4dbcf527770bc6e0fc69c0,false,false,,,,TOO_SHORT
1611572,0x8b506b1e40da75e19aff5a55107122308620fd0f,false,false,,,,TOO_SHORT
1611575,0xf03421284bb4435c127d2602f27e9b1bc18699e0,false,false,,,,TOO_SHORT
1611676,0xaa0537df21e717a13a6e0916ff63b7dcd4429e56,false,false,,,,TOO_SHORT
1611733,0x4009805b1b29d00066da0b4c4760491ef3f5c1a6,false,false,,,,TOO_SHORT
1611906,0x93c4ccdbd74cca47e53da27b7283f42160c364f3,false,false,,,,TOO_SHORT
1611914,0xd1cd60e726498ddd21b1f995e985579733a3bbc7,false,false,,,,TOO_SHORT
1612590,0x9a42550b61d39d741bbf6f6af30eba19f8bcb690,false,false,,,,TOO_SHORT
1612733,0xce428d50ed21f6388b4b30a2bbc2bd4829a74e93,false,false,,,,TOO_SHORT
1612784,0x95bddd3f436c93ca4bb8fff2527d76558644d4c9,false,false,,,,TOO_SHORT
1612871,0x6a2f527ba08b63603033d765c9068354ee7888e5,false,false,,,,TOO_SHORT
1613032,0x5d91c8fdb870b640901cb4e07c30e60c1932ca75,false,false,,,,TOO_SHORT
1613066,0x6959ded8187736723d17a43cfdd00bad86a909c4,false,false,,,,TOO_SHORT
1613082,0xa3d420fa5c448596d77f59e93182618883b5975b,false,false,,,,TOO_SHORT
1613169,0x38e03930bd51e06bfec76a1e1618c64e1f3605f2,false,false,,,,TOO_SHORT
1613246,0x60878e56d4cb662ff460b2dd70d5c08f65c848e6,false,false,,,,TOO_SHORT
1613296,0x33571f38b0c457e216e786a07f2859129f51935c,false,false,,,,TOO_SHORT
1613871,0xc395994ed9292ca99b368dc7c01a0aabfe2117b9,false,false,,,,TOO_SHORT
1613919,0xe23c9a9c7e6530c190c03721c03be6482c2f97d7,false,false,,,,TOO_SHORT
1613969,0x17d53325314e2b3749c74594b9daf76350d3d942,false,false,,,,TOO_SHORT
1613997,0x4bf28e04b3a54f4429f3067ebc6e65a4155ad783,false,false,,,,TOO_SHORT
1614044,0xd6861ab67b5da6518006a04156a62c0f9ba8cb17,false,false,,,,TOO_SHORT
1614045,0xf4713c5828b92dac1dc79e0c45a97dad7cbd9510,false,false,,,,TOO_SHORT
1614123,0x2b3496d379c56a13da149642e2367c23677134b2,false,false,,,,TOO_SHORT
1614269,0x848f18629c27f53e4dcea2acca98b103ede54bb0,false,false,,,,TOO_SHORT
1614480,0x7ae5f0792fdb4bbc1408a033272a61243779b0d5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1614480,0x21d65cb553b6faeca96d925dbcac84ec08b2c7d6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1614480,0xa431e586221048e31ce5607185bf53f03d114419,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1614480,0x7e7098e7f21c0838f2c0b9047941d3de715650de,true,false,,,,0x25af8d824b3b078a589e47418a95b4388d1552f4
1614945,0xf1e72be9fdb949717eec60bd797811aab7afb163,false,false,,,,TOO_SHORT
1615469,0x1e8ffb305d744beb70a32268842c3bc7468acd15,false,false,,,,TOO_SHORT
1615673,0x6992224cc2adfadbfd016e66bba55bfc2b87d4c8,false,false,,,,TOO_SHORT
1616518,0x8f494d77655e23f5f06d01d0ca57727d7ef1faea,false,false,,,,TOO_SHORT
1616645,0x2cecb8b9e218221d48208ba9e2f0dd93bc597a63,false,false,,,,TOO_SHORT
1616946,0x8f9b7bec1413f76428c1039d74590d648f6e95eb,false,false,,,,TOO_SHORT
1616980,0xdadd12a87e2ed5b06d1759f6962c6a28b04c6183,false,false,,,,TOO_SHORT
1616988,0x61d9f5d5c25c2f816da919a6d592f8ea9d44c28a,false,false,,,,TOO_SHORT
1616995,0x7f8982821821dfed38e4c9374d61bcf6a7519cc8,false,false,,,,TOO_SHORT
1616996,0x3715aa892b44045c4ed7ca14338728e33dcc4648,false,false,,,,TOO_SHORT
1616997,0x564e2a445b77126bf51a4c806f113b69bc6ad731,false,false,,,,TOO_SHORT
1617007,0x00128214499a1a750678f2b55578484bace0a331,false,false,,,,TOO_SHORT
1617403,0xdbdcc84b28eb5a3e1f5b9ff2b4e8bc6d7af7a651,false,false,,,,TOO_SHORT
1617434,0x4b558116bef434fe7fa4916ee6675fde1c5b462e,false,false,,,,TOO_SHORT
1618068,0x0858759c7921d0a44c0c3e09811039ebaa42099c,false,false,,,,TOO_SHORT
1618162,0xcee0a66d1a53d4a7d70842415c31a4b313cd5257,false,false,,,,TOO_SHORT
1618230,0xf8dc16955af3fc99eb5b37cc68c4d4a9cb06f8ab,false,false,,,,TOO_SHORT
1618232,0x84c4bcada609d4d6726e414fffb145eaee435dba,false,false,,,,TOO_SHORT
1618452,0xcd0de4e0da00e8dc500f9d832850e7ac9ff0ceda,false,false,,,,TOO_SHORT
1618556,0x1bed2e3d8c487c61f0782655d62f9770fe9fa612,false,false,,,,TOO_SHORT
1618820,0x3aff32b2b482b35212747f49000560f7a55cf96c,false,false,,,,TOO_SHORT
1618861,0x06215e8cbe57a0def3ff9da1ecc999e471cfde78,false,false,,,,TOO_SHORT
1619047,0x412d32641e4178fa96193f8760b4834f45c30752,false,false,,,,TOO_SHORT
1619107,0x91ea6c2316c81f00b7236999cb0e5a37fc3410c7,false,false,,,,TOO_SHORT
1619324,0x65394a9e442b95b47a1f51a923a5dda4b811d0ad,false,false,,,,TOO_SHORT
1619433,0xf1d7f3423f681a7a9e0e15d5532db66a9eb0dc9b,false,false,,,,TOO_SHORT
1619471,0x9280a2656fa7d39f8f995d0f38a0d754e1ba1420,false,false,,,,TOO_SHORT
1619537,0xec3305ef436d63508b0094073530a9206867dc29,false,false,,,,TOO_SHORT
1619539,0x6426576e7392e2ee2f13a0977f62d5de80bc92dc,false,false,,,,TOO_SHORT
1619792,0x30cf764ee50bf8655c5956a9a01adcca7fdab1ed,false,false,,,,TOO_SHORT
1619893,0xa87f0426816a2bb84769bea53d9be75f815344f7,false,false,,,,TOO_SHORT
1619969,0xeec6cbcc98aa9b0dbb2520938c054834c61f72fc,false,false,,,,TOO_SHORT
1620007,0x1340bed430c3da4c538999ea0365bd970299f4bf,false,false,,,,TOO_SHORT
1620121,0xec7075e8a3d991eb58b6f7eea97928c723b1338a,false,false,,,,TOO_SHORT
1620126,0x10a5d216b0bb9dd9b78933bfe398e7acbe436d81,false,false,,,,TOO_SHORT
1620136,0x4491c84e08b517fb198279e1a96b2337f06ed462,false,false,,,,TOO_SHORT
1620160,0xd42aedf57232eee02fe0337dcaa76d5f8c6b7213,false,false,,,,TOO_SHORT
1620169,0x139d85298995d92bd58909d4e7b17470a432e73d,false,false,,,,TOO_SHORT
1620342,0xa4e77be98b303e66ec37a616aa0190546ca51552,false,false,,,,TOO_SHORT
1620360,0x9176e6d5fd863a364aaf995449461e48f66f78a8,false,false,,,,TOO_SHORT
1620420,0xd88838359c8ad2fa9577bd3e8bfe1cc49b70ac47,false,false,"contract MPO { \n	uint256 public reading;\n	uint256 public time;\n	address public operator; \n	uint256 shift;\n	string public name =""MP"";\n	string public symbol =""Wh"";\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	mapping (address => uint256) public balanceOf;\n	address[] public listeners;\n	\n	function MPO() {\n		operator=msg.sender;\n		shift=0;\n	}\n	\n	function updateReading(uint256 last_reading,uint256 timeofreading) {		\n		if(msg.sender!=operator) throw;\n		if((timeofreading<time)||(reading>last_reading)) throw;	\n		var oldreading=last_reading;\n		reading=last_reading-shift;\n		time=timeofreading;	\n		balanceOf[this]=last_reading;\n		for(var i=0;i<listeners.length;i++) {\n			balanceOf[listeners[i]]=last_reading;\n			Transfer(msg.sender,listeners[i],last_reading-oldreading);\n		}\n	}\n	\n	function reqisterListening(address a) {\n		listeners.push(a);\n		balanceOf[a]=reading;\n		Transfer(msg.sender,a,reading);\n	}\n	function transferOwnership(address to) {\n		if(msg.sender!=operator) throw;\n		operator=to;\n	}\n	function transfer(address _to, uint256 _value) {\n		/* Function stub required to see tokens in wallet */		\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	function assetMoveInformation(address newmpo,address gridMemberToInform) {\n		if(msg.sender!=operator) throw;\n		/*var gm=GridMember(gridMemberToInform);\n		gm.switchMPO(this,newmpo);\n		*/\n	}\n	\n}\ncontract MPOListener {\n	MPO public mp;\n	\n	function switchMPO(address from, address to) {\n		if(msg.sender!=mp.operator()) throw;\n		if(mp==from) {\n			mp=MPO(to);			\n		}\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1620430,0x706dded765c012b7f532c60c1d08563ba5e9f587,false,false,,,,0xd88838359c8ad2fa9577bd3e8bfe1cc49b70ac47
1620502,0x3f3dc470abcbde229aee2ddae4efba8e984e26e0,false,false,,,,TOO_SHORT
1620596,0xdd95e92dcbc89fc2c9f5f81f9c47e387a4a1d4f4,false,false,,,,TOO_SHORT
1620770,0x0d20b071ed3d72495e19cb2ae9df9fed66293cda,false,false,,,,TOO_SHORT
1620805,0x5daf363941b3a15c6543a9d82dad014ce89dfccd,false,false,,,,0xd88838359c8ad2fa9577bd3e8bfe1cc49b70ac47
1620960,0x63fee5bb1d1496a0dab44c5b9d483aee952ba2fe,false,false,,,,TOO_SHORT
1621196,0x3f61e8754dff8aa7114de88ce73c69180263600c,false,false,,,,TOO_SHORT
1621494,0xdf7e9e3dd5569b6b492e7b653ba6c696c5ed3d0e,false,false,,,,TOO_SHORT
1621856,0x9550cd37ad1ea5276e7f0d12b54c4e8e7b5b2876,false,false,,,,TOO_SHORT
1622218,0x6f1cf1ae92311c2f8b8c6ddd59766f62d53c4a0f,false,false,,,,TOO_SHORT
1622479,0x23041f9f3f618fc87f991f44f5b51624f8027e0b,false,false,,,,TOO_SHORT
1622549,0xe5c4e0e811a69e418b0f96754d93197ca8fb2ae2,false,false,,,,TOO_SHORT
1622833,0xe05ead85d87beddd4d3e5affb81bbb4c3a5507f5,false,false,,,,TOO_SHORT
1622941,0xa34f85c58bf93763083159ed8d13b83dcdfa82b8,false,false,,,,TOO_SHORT
1622956,0xe6c88d2207897ce99264450d7d40f4f0061a8dc7,false,false,,,,TOO_SHORT
1623016,0xcd845e571d03fd46768a9d33aa9c7d7eaa3ff829,false,false,,,,TOO_SHORT
1623028,0xd943d06df234e6ecb6cdd16260f958b07e962c0d,false,false,,,,TOO_SHORT
1623182,0x38f9a4fb39e27d6b9a7babb098703596bb16716a,true,false,,,,0x45e42d659d9f9466cd5df622506033145a9b89bc
1623352,0x9986feff371a0959ca1c18c8e6aa6adb5e4d597e,false,false,,,,TOO_SHORT
1623375,0xffe01e91383ef54f04151b45d6c3c08c3d25d62a,false,false,,,,TOO_SHORT
1623651,0xb013cc233a864405b68c3bdb4ba6baf058942cb7,false,false,,,,TOO_SHORT
1623748,0x6c9bbaddab60c9ac89678fda3fff01713a42cd60,false,false,,,,TOO_SHORT
1623826,0x7ad4387eeacef4fb4e6aa2cb9c44aaf82efe0060,false,false,,,,TOO_SHORT
1623854,0xe5525436cb58d49b1eec3cac9c3240a8eab62c59,false,false,,,,TOO_SHORT
1624124,0x41896ea130a088d3b4e22d639f11cde6277920de,false,false,,,,TOO_SHORT
1624135,0x767211accca8574d835e74cfb30af1dbe7e011d3,true,false,,,,0x838b3606489c5a0e4d97ed113d4aa8d324f4a330
1624137,0x56050a13232be62065d1f92555b8ca8f4091749d,false,false,,,,TOO_SHORT
1624252,0xc6c4a6a67aa6c06370327140aaf4624392a91a18,false,false,,,,TOO_SHORT
1624570,0x3ae5e4cb0751328d3b2643ee819a15f88ebb053f,false,false,,,,TOO_SHORT
1624817,0x853eb47d9f26b653a5ed80e62f06fb7a81cb27e7,false,false,,,,TOO_SHORT
1625086,0x311a8fa988cda6a8d9fcdacb38ed6f7e769da60a,false,false,,,,TOO_SHORT
1625143,0x92abe734424068e4cc0733568c6439ca9d1daa4c,false,false,,,,TOO_SHORT
1625258,0x3a5df5ef5b9dc805488fc1a385e165ea132d9ac3,false,false,,,,TOO_SHORT
1625342,0xece7c4a45023165fdeafddba7fa1d702942a6d04,false,false,,,,TOO_SHORT
1625409,0x6853ae859151fbb08ca618b168b0c3303d285639,false,false,,,,TOO_SHORT
1625418,0x2af977224c71b26e4f7a0a253dc5fa29d4d81a70,false,false,,,,TOO_SHORT
1625545,0x6c192839ed6154c261e6e39398e6603390c187d9,false,false,,,,TOO_SHORT
1625565,0x01bfbb9b1a2abe32ceb0a9f2291e5d7e36e38b20,true,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        mint *= 10 ** _b;\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no ""premine"". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function _transfer(address _to, uint256 _amount) internal returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\ncontract KissBTCCallback {\n    function kissBTCCallback(uint id, uint amount);\n}\n\ncontract ApprovalRecipient {\n    function receiveApproval(address _from, uint256 _amount,\n                             address _tokenContract, bytes _extraData);\n}\n\ncontract KissBTC is usingOraclize, Token {\n    string constant PRICE_FEED =\n        ""json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"";\n    uint constant MAX_AMOUNT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint constant MAX_ETH_VALUE = 10 ether;\n    uint constant MIN_ETH_VALUE = 50 finney;\n    uint constant MAX_KISS_BTC_VALUE = 25000000;\n    uint constant MIN_KISS_BTC_VALUE = 125000;\n    uint constant DEFAULT_GAS_LIMIT = 200000;\n\n    string public standard = ""Token 0.1"";\n    string public name = ""kissBTC"";\n    string public symbol = ""kissBTC"";\n    uint8 public decimals = 8;\n\n    struct Task {\n        bytes32 oraclizeId;\n        bool toKissBTC;\n        address sender;\n        uint value;\n        address callback;\n        uint timestamp;\n    }\n\n    mapping (uint => Task) public tasks;\n    mapping (bytes32 => uint) public oraclizeRequests;\n    uint public exchangeRate;\n    uint public nextId = 1;\n\n    address public owner;\n    uint public timestamp;\n\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    function KissBTC() {\n        owner = msg.sender;\n    }\n\n    // default action is to turn Ether into kissBTC\n    function () {\n        buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\n    }\n\n    function buyKissBTC() {\n        buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\n    }\n\n    function buyKissBTCWithCallback(address callback,\n                                    uint gasLimit) oraclizeAPI\n                                    returns (uint id) {\n        if (msg.value < MIN_ETH_VALUE || msg.value > MAX_ETH_VALUE) throw;\n        if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\n\n        uint oraclizePrice = oraclize.getPrice(""URL"", gasLimit);\n        uint fee = msg.value / 100; // for the contract's coffers\n\n        if (msg.value <= oraclizePrice + fee) throw;\n        uint value = msg.value - (oraclizePrice + fee);\n\n        id = nextId++;\n        bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\n            0,\n            ""URL"",\n            PRICE_FEED,\n            gasLimit\n        );\n        tasks[id].oraclizeId = oraclizeId;\n        tasks[id].toKissBTC = true;\n        tasks[id].sender = msg.sender;\n        tasks[id].value = value;\n        tasks[id].callback = callback;\n        tasks[id].timestamp = now;\n        oraclizeRequests[oraclizeId] = id;\n    }\n\n    function transfer(address _to,\n                      uint256 _amount) noEther returns (bool success) {\n        if (_to == address(this)) {\n            sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\n            return true;\n        } else {\n            return _transfer(_to, _amount);    // standard transfer\n        }\n    }\n\n    function transferFrom(address _from,\n                          address _to,\n                          uint256 _amount) noEther returns (bool success) {\n        if (_to == address(this)) throw;       // not supported;\n        return _transferFrom(_from, _to, _amount);\n    }\n\n    function sellKissBTC(uint256 _amount) returns (uint id) {\n        return sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\n    }\n\n    function sellKissBTCWithCallback(uint256 _amount,\n                                     address callback,\n                                     uint gasLimit) oraclizeAPI\n                                     returns (uint id) {\n        if (_amount < MIN_KISS_BTC_VALUE\n            || _amount > MAX_KISS_BTC_VALUE) throw;\n        if (balances[msg.sender] < _amount) throw;\n        if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\n\n        if (!safeToSell(_amount)) throw;    // we need a bailout\n\n        uint oraclizePrice = oraclize.getPrice(""URL"", gasLimit);\n        uint oraclizePriceKissBTC = inKissBTC(oraclizePrice);\n        uint fee = _amount / 100; // for the contract's coffers\n\n        if (_amount <= oraclizePriceKissBTC + fee) throw;\n        uint value = _amount - (oraclizePriceKissBTC + fee);\n\n        balances[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        Transfer(msg.sender, address(this), _amount);\n\n        id = nextId++;\n        bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\n            0,\n            ""URL"",\n            PRICE_FEED,\n            gasLimit\n        );\n        tasks[id].oraclizeId = oraclizeId;\n        tasks[id].toKissBTC = false;\n        tasks[id].sender = msg.sender;\n        tasks[id].value = value;\n        tasks[id].callback = callback;\n        tasks[id].timestamp = now;\n        oraclizeRequests[oraclizeId] = id;\n    }\n\n    function inKissBTC(uint amount) constant returns (uint) {\n        return (amount * exchangeRate) / 1000000000000000000;\n    }\n\n    function inEther(uint amount) constant returns (uint) {\n        return (amount * 1000000000000000000) / exchangeRate;\n    }\n\n    function safeToSell(uint amount) constant returns (bool) {\n        // Only allow sales when we have an extra 25 % in reserve.\n        return inEther(amount) * 125 < this.balance * 100;\n    }\n\n    function __callback(bytes32 oraclizeId, string result) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        uint _exchangeRate = parseInt(result, 6) * 100;\n        if (_exchangeRate > 0) {\n            exchangeRate = _exchangeRate;\n        }\n\n        uint id = oraclizeRequests[oraclizeId];\n        if (id == 0) return;\n\n        address sender = tasks[id].sender;\n        address callback = tasks[id].callback;\n        if (tasks[id].toKissBTC) {\n            uint freshKissBTC = inKissBTC(tasks[id].value);\n\n            totalSupply += freshKissBTC;\n            balances[sender] += freshKissBTC;\n            Transfer(address(this), sender, freshKissBTC);\n\n            if (callback != 0) {\n                // Note: If the callback throws an exception, everything\n                // will be rolled back and you won't receive any tokens.\n                // You can however invoke retryOraclizeRequest() in that case.\n                KissBTCCallback(callback).kissBTCCallback.\n                    value(0)(id, freshKissBTC);\n            }\n        } else {\n            uint releasedEther = inEther(tasks[id].value);\n\n            sender.send(releasedEther);\n\n            if (callback != 0) {\n                KissBTCCallback(callback).kissBTCCallback.\n                    value(0)(id, releasedEther);\n            }\n        }\n\n        delete oraclizeRequests[oraclizeId];\n        delete tasks[id];\n    }\n\n    function retryOraclizeRequest(uint id) oraclizeAPI {\n        if (tasks[id].oraclizeId == 0) throw;\n\n        uint timePassed = now - tasks[id].timestamp;\n        if (timePassed < 60 minutes) throw;\n\n        // Allow to retry a request to Oraclize if there has been\n        // no reply within the last hour for some reason. Because a\n        // failed callback might have been the problem, we discard those.\n        uint price = oraclize.getPrice(""URL"", DEFAULT_GAS_LIMIT);\n        bytes32 newOraclizeId = oraclize.query_withGasLimit.value(price)(\n            0,\n            ""URL"",\n            PRICE_FEED,\n            DEFAULT_GAS_LIMIT\n        );\n\n        delete oraclizeRequests[tasks[id].oraclizeId];\n        tasks[id].oraclizeId = newOraclizeId;\n        tasks[id].callback = 0;\n        tasks[id].timestamp = now;\n        oraclizeRequests[newOraclizeId] = id;\n    }\n\n    function whitelist(address _spender) returns (bool success) {\n        return approve(_spender, MAX_AMOUNT);\n    }\n\n    function approveAndCall(address _spender,\n                            uint256 _amount,\n                            bytes _extraData) returns (bool success) {\n        approve(_spender, _amount);\n        ApprovalRecipient(_spender).receiveApproval.\n            value(0)(msg.sender, _amount, this, _extraData);\n        return true;\n    }\n\n    function donate() {\n        // Send ether here if you would like to\n        // increase the contract's reserves.\n    }\n\n    function toldYouItWouldWork() onlyowner {\n        if (now - timestamp < 24 hours) throw;  // only once a day\n\n        uint obligations = inEther(totalSupply);\n        if (this.balance <= obligations * 3) throw;\n\n        // Owner can withdraw 1 % of excess funds if the contract\n        // has more than three times its obligations in reserve.\n        uint excess = this.balance - (obligations * 3);\n        uint payment = excess / 100;\n        if (payment > 0) owner.send(payment);\n        timestamp = now;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1625576,0x8194dc0083d43984ba45f2025ccc77a89e4fd2af,true,false,,,,0x01bfbb9b1a2abe32ceb0a9f2291e5d7e36e38b20
1625580,0x6777c314b412f0196aca852632969f63e7971340,true,false,,,,0x01bfbb9b1a2abe32ceb0a9f2291e5d7e36e38b20
1625605,0x71107a8959f1249920cf87dc8c994b9b483d25ef,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        mint *= 10 ** _b;\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\ncontract KissBTC {\n    function transferFrom(address _from, address _to,\n                          uint256 _amount) returns (bool success);\n    function sellKissBTCWithCallback(uint256 _amount, address callback,\n                                     uint gasLimit) returns (uint id);\n}\n\ncontract BitcoinSender is usingOraclize {\n    address constant KISS_BTC = 0x6777c314B412F0196aCA852632969F63e7971340;\n\n    struct StepOne {\n        bool inProcess;\n        string addr;\n    }\n\n    struct StepTwo {\n        bool inProcess;\n        uint amount;\n    }\n\n    mapping (uint => StepOne) stepOneTasks;\n    mapping (bytes32 => StepTwo) stepTwoTasks;\n\n    function sendBitcoin(string _address, uint _amount) {\n        if (!KissBTC(KISS_BTC).transferFrom(msg.sender, this, _amount)) throw;\n        uint id = KissBTC(KISS_BTC).sellKissBTCWithCallback(\n            _amount, this, 300000);\n        stepOneTasks[id].inProcess = true;\n        stepOneTasks[id].addr = _address;\n    }\n\n    function kissBTCCallback(uint id, uint amount) oraclizeAPI {\n        if (msg.sender != KISS_BTC) throw;\n        if (!stepOneTasks[id].inProcess) return;\n\n        uint price = oraclize.getPrice(""URL"");\n        if (price >= amount) return;\n\n        string memory json = strConcat(\n            '{""pair"": ""eth_btc"", ""withdrawal"": ""',\n            stepOneTasks[id].addr,\n            '""}'\n        );\n        bytes32 oraclizeId = oraclize_query(\n            ""URL"",\n            ""json(https://shapeshift.io/shift).deposit"",\n            json\n        );\n        stepTwoTasks[oraclizeId].inProcess = true;\n        stepTwoTasks[oraclizeId].amount = amount - price;\n\n        delete stepOneTasks[id];\n    }\n\n    function __callback(bytes32 oraclizeId, string result) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        if (!stepTwoTasks[oraclizeId].inProcess) return;\n\n        address addr = parseAddr(result);\n        addr.send(stepTwoTasks[oraclizeId].amount);\n\n        delete stepTwoTasks[oraclizeId];\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1625802,0x5b6d2583bd839de41f4bfc4884fbac85123e329d,false,false,,,,TOO_SHORT
1626060,0x2eb17718fe993fa8038365b4df98d29e1ac97be2,false,false,,,,TOO_SHORT
1626255,0x78533b277a4de1a416838f7726aee7980cdf2700,false,false,,,,TOO_SHORT
1626334,0x4fdf6574f88463f848d8a3a5c56e23b427b79abe,false,false,,,,TOO_SHORT
1626446,0x508878789e8535742f68f9e344566f4ca2342982,false,false,,,,TOO_SHORT
1626503,0xfc344e2155c06863dd20296f41189cd8b2bca95c,false,false,,,,TOO_SHORT
1626600,0x46e295a73f74143c5f0557338a3633009b6c0682,false,false,,,,TOO_SHORT
1627302,0xa07f35e930d0167acfd4e61e9b5a979b9ca945b8,false,false,,,,TOO_SHORT
1627303,0x482e7d228ea9e3d4e72d428274a4b31c553f9b19,false,false,,,,TOO_SHORT
1627399,0xa67e18be088c9b908589198d0a594a7c8d11cd0a,false,false,,,,TOO_SHORT
1627923,0x1dc96384025201f82fa08f217d82a57a7bd72ead,false,false,,,,TOO_SHORT
1628249,0x31359a1d01669a007d92d476b486911770a9fd60,false,false,,,,TOO_SHORT
1628894,0x3e52e8dc234b091702277e2a24cccbed9d3b8a02,false,false,,,,TOO_SHORT
1629187,0x90a8ed56e469e16df02151c1c3273de3fc917f6f,false,false,"contract aEthereumlotteryNet {\n	/*\n		aEthereumlotteryNet\n		Coded by: iFA\n		http://a.ethereumlottery.net\n		ver: 1.0.1\n	*/\n	address private owner;\n	uint private collectedFee;\n	bool public contractEnabled = true;\n	uint public ticketPrice = 1 finney; // 0.01 ether\n	uint private feeP = 5; // 5 %\n	uint private drawDelay = 7 days;\n	uint private drawAtLeastTicketCount = 10000;\n	uint private drawAtLeastPlayerCount = 10;\n	uint private placeMultiple  =  10000;\n	uint private place1P    	= 600063; // 60.0063 %\n	uint private place2P    	= 240025; // 24.0025 %\n	uint private place3P    	=  96010; //  9.6010 %\n	uint private place4P    	=  38404; //  3.8404 %\n	uint private place5P    	=  15362; //  1.5362 %\n	uint private place6P    	=   6145; //  0.6145 %\n	uint private place7P    	=   2458; //  0.2458 %\n	uint private place8P    	=    983; //  0.0983 %\n	uint private place9P    	=    393; //  0.0393 %\n	uint private place10P       =    157; //  0.0157 %\n	\n	uint private constant prepareBlockDelay = 5;\n	\n	enum drawStatus_ { Wait, Prepared ,Done }\n	\n	struct players_s {\n		address addr;\n		uint ticketCount;\n	}\n	struct game_s {\n		players_s[] players;\n		uint startDate;\n		uint endDate;\n		uint totalTickets;\n		uint prepareDrawBlock;\n		drawStatus_ drawStatus;\n	}\n	game_s private game;\n	\n	mapping (address => uint) public balances;\n	\n	string constant public Information = ""http://a.ethereumlottery.net"";\n	\n	function Details() constant returns(uint start, uint end, uint tickets, uint players) {\n		start = game.startDate;\n		end = game.endDate;\n		tickets = game.totalTickets;\n		players = game.players.length;\n	}\n	function Prizes() constant returns(bool estimated, uint place1, uint place2, uint place3, \n	uint place4, uint place5, uint place6, uint place7, uint place8, uint place9, uint place10) {\n		uint pot;\n		if (game.totalTickets < drawAtLeastTicketCount) {\n			estimated = true;\n			pot = drawAtLeastTicketCount*ticketPrice*(100-feeP)/100;\n		} else {\n			estimated = false;\n			pot = game.totalTickets*ticketPrice*(100-feeP)/100;\n		}\n		place1 = pot*place1P/placeMultiple/100;\n		place2 = pot*place2P/placeMultiple/100;\n		place3 = pot*place3P/placeMultiple/100;\n		place4 = pot*place4P/placeMultiple/100;\n		place5 = pot*place5P/placeMultiple/100;\n		place6 = pot*place6P/placeMultiple/100;\n		place7 = pot*place7P/placeMultiple/100;\n		place8 = pot*place8P/placeMultiple/100;\n		place9 = pot*place9P/placeMultiple/100;\n		place10 = pot*place10P/placeMultiple/100;\n	}\n	function aEthereumlotteryNet() {\n		owner = msg.sender;\n		createNewDraw();\n	}\n	function () {\n		BuyTickets();\n	}\n	function BuyTickets() OnlyInTime OnlyWhileWait onValidContract {\n		if (msg.value < ticketPrice) { throw; }\n		uint ticketsCount = msg.value / ticketPrice;\n		if (game.totalTickets+ticketsCount >= 255**4) { throw; }\n		if (msg.value > (ticketsCount * ticketPrice)) { if (msg.sender.send(msg.value - (ticketsCount * ticketPrice)) == false) { throw; } }\n		game.totalTickets += ticketsCount;\n		uint a;\n		uint playersid = game.players.length;\n		for ( a = 0 ; a < playersid ; a++ ) {\n			if (game.players[a].addr == msg.sender) {\n				game.players[a].ticketCount += ticketsCount;\n				return;\n			}\n		}\n		game.players.length += 1;\n		game.players[playersid].addr = msg.sender;\n		game.players[playersid].ticketCount = ticketsCount;\n	}\n	function PrepareDraw() external ReadyForPrepare onValidContract {\n	    reFund();\n		if (game.players.length < drawAtLeastPlayerCount && game.totalTickets < drawAtLeastTicketCount) {\n			game.endDate = calcNextDrawTime();\n		} else {\n			game.prepareDrawBlock = block.number + prepareBlockDelay;\n			game.drawStatus = drawStatus_.Prepared;\n		}\n	}\n	event announceWinner(address addr,uint prize);\n	function Draw() external OnlyWhilePrepared ReadyForDraw onValidContract {\n	    reFund();\n		bytes32 WinHash = makeHash();\n		uint a;\n		uint b;\n		uint c;\n		uint d;\n		uint e;\n		uint num;\n		address[10] memory winners;\n		bool next;\n		for ( a = 0 ; a < 10 ; a++ ) {\n			while (true) {\n				next = true;\n				if (b == 8) {\n					WinHash = sha3(WinHash);\n					b = 0;\n				}\n				num = getNum(WinHash,b) % game.totalTickets;\n				d = 0;\n				for ( c = 0 ; c < game.players.length ; c++ ) {\n					d += game.players[c].ticketCount;\n					if (d >= num) {\n						for ( e = 0 ; e < 10 ; e++ ){\n							if (game.players[c].addr == winners[e]) {\n								next = false;\n								break;\n							}\n						}\n						if (next == true) {\n							winners[a] = game.players[c].addr;\n							break;\n						}\n					}\n				}\n				b++;\n				if (next == true) { break; }\n			}\n		}\n		uint fee = game.totalTickets * ticketPrice * feeP / 100;\n		uint pot = game.totalTickets * ticketPrice - fee;\n		collectedFee += fee;\n		balances[winners[0]] += pot * place1P / placeMultiple / 100;\n		balances[winners[1]] += pot * place2P / placeMultiple / 100;\n		balances[winners[2]] += pot * place3P / placeMultiple / 100;\n		balances[winners[3]] += pot * place4P / placeMultiple / 100;\n		balances[winners[4]] += pot * place5P / placeMultiple / 100;\n		balances[winners[5]] += pot * place6P / placeMultiple / 100;\n		balances[winners[6]] += pot * place7P / placeMultiple / 100;\n		balances[winners[7]] += pot * place8P / placeMultiple / 100;\n		balances[winners[8]] += pot * place9P / placeMultiple / 100;\n		balances[winners[9]] += pot * place10P / placeMultiple / 100;\n		announceWinner(winners[0],balances[winners[0]]);\n		announceWinner(winners[1],balances[winners[1]]);\n		announceWinner(winners[2],balances[winners[2]]);\n		announceWinner(winners[3],balances[winners[3]]);\n		announceWinner(winners[4],balances[winners[4]]);\n		announceWinner(winners[5],balances[winners[5]]);\n		announceWinner(winners[6],balances[winners[6]]);\n		announceWinner(winners[7],balances[winners[7]]);\n		announceWinner(winners[8],balances[winners[8]]);\n		announceWinner(winners[9],balances[winners[9]]);\n		if (contractEnabled == true) {\n			createNewDraw();\n		} else {\n			game.drawStatus = drawStatus_.Done;\n		}\n	}\n	function GetPrize() external {\n	    reFund();\n	    if (contractEnabled) { \n            if (balances[msg.sender] == 0) { throw; }\n        	if (msg.sender.send(balances[msg.sender]) == false) { throw; }\n        	balances[msg.sender] = 0;\n	    } else {\n            for ( uint a = 0 ; a < game.players.length ; a++ ) {\n    			if (game.players[a].addr == msg.sender) {\n    			    if (game.players[a].ticketCount > 0) {\n    			        if ( ! msg.sender.send(game.players[a].ticketCount * ticketPrice)) { throw; }\n    			        game.totalTickets -= game.players[a].ticketCount;\n    			        delete game.players[a];\n    			    } else {\n    			        throw;\n    			    }\n    			}\n    		}\n	    }\n	}\n	function OwnerGetFee() external OnlyOwner {\n	    reFund();\n		if (owner.send(collectedFee) == false) { throw; }\n		collectedFee = 0;\n	}\n	function OwnerCloseContract() external OnlyOwner {\n	    reFund();\n	    if (!contractEnabled) { throw; }\n		contractEnabled = false;\n	}\n	function createNewDraw() private {\n		game.startDate = now;\n		game.endDate = calcNextDrawTime();\n		game.players.length = 0;\n		game.totalTickets = 0;\n		game.prepareDrawBlock = 0;\n		game.drawStatus = drawStatus_.Wait;\n	}\n	function calcNextDrawTime() private returns (uint ret) {\n		ret = 1461499200; // 2016.04.24 12:00:00\n		while (ret < now) {\n			ret += drawDelay;\n		}\n	}\n	function makeHash() private returns (bytes32 hash) {\n		for ( uint a = 0 ; a <= prepareBlockDelay ; a++ ) {\n			hash = sha3(hash, block.blockhash(game.prepareDrawBlock - prepareBlockDelay + a));\n		}\n		hash = sha3(hash, game.players.length, game.totalTickets);\n	}\n	function reFund() private { if (msg.value > 0) { if (msg.sender.send(msg.value) == false) { throw; } } }\n	function getNum(bytes32 a, uint i) private returns (uint) { return uint32(bytes4(bytes32(uint(a) * 2 ** (8 * (i*4))))); }\n	modifier onValidContract() { if (!contractEnabled) { throw; } _ }\n	modifier OnlyInTime() { if (game.endDate < now) { throw; } _ }\n	modifier OnlyWhileWait() { if (game.drawStatus != drawStatus_.Wait) { throw; } _ }\n	modifier OnlyWhilePrepared() { if (game.drawStatus != drawStatus_.Prepared) { throw; } _ }\n	modifier ReadyForPrepare() { if (game.endDate > now || game.drawStatus != drawStatus_.Wait) { throw; } _ }\n	modifier ReadyForDraw() { if (game.prepareDrawBlock > block.number) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n}",1,実用的なロトリーコントラクトで、特に芸術的な要素は見られません。,
1629388,0x779d12e84defdbcc79869dfe953e41de524341a8,false,false,,,,TOO_SHORT
1629595,0x45efd60f2821fe0ab39e49e3521cc9bea0a8d18d,false,false,,,,TOO_SHORT
1629609,0x9804a94415db9038302dd6d04caec493a55505ee,false,false,,,,TOO_SHORT
1629614,0x000aa6090a56fdedb43fa5e79a8f90d9ad2577e3,false,false,,,,TOO_SHORT
1629741,0x53c32fdc8c117b975204037f8fd01251b14210ea,false,false,,,,TOO_SHORT
1630210,0x15a92985f5cd3427886fac496d86b66ea0512b45,false,false,,,,TOO_SHORT
1630221,0x44d908db7a3c6fc64ad1d4c95e15b854273c4395,false,false,,,,TOO_SHORT
1630558,0x68d794cdecc92a512dbf5471b08bc058dcab18f1,false,false,,,,TOO_SHORT
1630811,0x886b8005a7bd8e25be7701da4664b638d5367007,false,false,,,,TOO_SHORT
1631014,0xc0b57af2b08eb42e892245dce1a6bae196188254,false,false,,,,TOO_SHORT
1631018,0x6d1903abb591bae2e2fb9ce88c402d057eb37a26,false,false,,,,TOO_SHORT
1631088,0x91a3334c0192bdf2c2edc93ba04530319901fc88,false,false,,,,TOO_SHORT
1631113,0x36dcdcef4fb1f132ae9c1bd04f43803458719343,false,false,,,,TOO_SHORT
1631269,0x6b4ac1cebe33ea2c8d26f602d268f55901e65771,false,false,,,,TOO_SHORT
1631553,0x7de1d8b4639e1be6f36dbd14215b34929080f918,false,false,,,,TOO_SHORT
1631666,0xf2da744bcadc43e05cbef5108b4b4aa237445a16,false,false,,,,TOO_SHORT
1631686,0xd77ae32d55e4233cbb5ab7f349b6e901f0821b6d,false,false,,,,TOO_SHORT
1631765,0x50c5712624b58905c19aee87deca593a2690e3f4,false,false,"contract Docsign\n{\n    //Fire when document hash is added to contract\n    event Added(address indexed _from);\n\n    //Fire when contract is deployed on the blockchain\n    event Created(address indexed _from);\n\n\n    struct Document {\n        uint version;\n        string name;\n        address creator;\n        string hash;\n        uint date;\n    }\n    Document[] public a_document;\n    uint length;\n\n    // Constructor. Can be used to track contract deployment\n    function Docsign() {\n        Created(msg.sender);\n    }\n\n    function Add(uint _version, string _name, string _hash) {\n        a_document.push(Document(_version,_name,msg.sender, _hash, now));\n        Added(msg.sender);\n    }\n    // Get number of element in Array a_document (does not used GAS)\n    function getCount() public constant returns(uint) {\n        return a_document.length;\n    }\n    \n    // fallback function (send back ether if contrat is used as wallet contract)\n    function() { throw; }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1631882,0x44876e1e9d38afcd81ed597e7daa60f4f359ec06,false,false,,,,TOO_SHORT
1632115,0x3ed4b790729be9c37cc12a0abfabbb1f16ddc798,false,false,,,,TOO_SHORT
1632592,0xcd2306488b387654c4a717ef5e5717761eeb0742,false,false,,,,TOO_SHORT
1632689,0x527255aded549bcbacd67b6eb9849aee423a5f98,false,false,,,,TOO_SHORT
1632711,0x69b20320cbaaa052b6b41dc21127669bb281d946,false,false,,,,TOO_SHORT
1632718,0xf4784d85bed37e86ab357fb583b69c552ffe57a4,false,false,,,,TOO_SHORT
1632731,0x90389ef547fdff875d5198f1aca40c4f6abcd784,false,false,,,,TOO_SHORT
1632736,0x9d9ad1ab08c9c901673a39471d14019ce938435f,false,false,,,,TOO_SHORT
1632829,0xec19e40a977020b3811775d813e9a7ed7ad8bb94,false,false,,,,TOO_SHORT
1632866,0x200b2fd75859579ffaee3aa0e5bd4f1d78c0408f,false,false,,,,TOO_SHORT
1633067,0x222bf5c06cf4cb86554e165e6082350a6078735a,false,false,"/**\n * Decentraliced Grid Organization\n * Version: 0.0.1\n * Author: Thorsten Zoerner <me@thorsten-zoerner.com>\n * Donations: btc:1MvghD6TE2nurN4iCUSLdmcCRiwohgCA86 eth:0x697a040b13aefdd9553f3922dcb547be6efd88d2\n * Implementation: Ethereum/Solidity\n */\n\n/**\nBusiness Case / Purpose\n=========================================================================================\nIntroduces a smart contract for members of a power grid to facilitate P2P balancing.\n\n- Implements post delivery balancing with peers\n- Provides tokens per GridMember for clearing\n- Handles simple prioty list for merit order \n- Allow Exchange of Meter Device\n- Allow multiple ""Listeners"" (Push Clients) per MP (according to Smart Meter Gateway Concept)\n\nRequires independend smart meter operator.\n*/\n/*\n[{""constant"":false,""inputs"":[{""name"":""from"",""type"":""address""},{""name"":""to"",""type"":""address""}],""name"":""switchMPO"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""mp"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""}]\n*/\ncontract MPO { \n	uint256 public reading;\n	uint256 public time;\n	address public operator; \n	uint256 shift;\n	string public name =""MP"";\n	string public symbol =""Wh"";\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	mapping (address => uint256) public balanceOf;\n	address[] public listeners;\n	\n	function MPO() {\n		operator=msg.sender;\n		shift=0;\n	}\n	\n	function updateReading(uint256 last_reading,uint256 timeofreading) {		\n		if(msg.sender!=operator) throw;\n		if((timeofreading<time)||(reading>last_reading)) throw;	\n		var oldreading=last_reading;\n		reading=last_reading-shift;\n		time=timeofreading;	\n		balanceOf[this]=last_reading;\n		for(var i=0;i<listeners.length;i++) {\n			balanceOf[listeners[i]]=last_reading;\n			Transfer(msg.sender,listeners[i],last_reading-oldreading);\n		}\n	}\n	\n	function registerListening(address a) {\n		listeners.push(a);\n		balanceOf[a]=reading;\n		Transfer(msg.sender,a,reading);\n	}\n	\n	function unregisterListening(address a) {\n	\n		for(var i=0;i<listeners.length;i++) {\n			if(listeners[i]==a) listeners[i]=0;\n		}\n		\n	}\n	function transferOwnership(address to) {\n		if(msg.sender!=operator) throw;\n		operator=to;\n	}\n	function transfer(address _to, uint256 _value) {\n		/* Function stub required to see tokens in wallet */		\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	function assetMoveInformation(address newmpo,address gridMemberToInform) {\n		if(msg.sender!=operator) throw;\n		/*var gm=GridMember(gridMemberToInform);\n		gm.switchMPO(this,newmpo);\n		*/\n	}\n	\n}\ncontract MPOListener {\n	MPO public mp;\n	\n	function switchMPO(address from, address to) {\n		if(msg.sender!=mp.operator()) throw;\n		if(mp==from) {\n			mp=MPO(to);			\n		}\n	}\n}\ncontract operated {\n    address public operator;\n\n    function operated() {\n        operator = msg.sender;\n    }\n\n    modifier onlyOperator {\n        if (msg.sender != operator) throw;\n        _\n    }\n\n    function transferOperator(address newOperator) onlyOperator {\n        operator = newOperator;\n    }\n}\n\ncontract GridMember is operated,MPOListener {\n		\n	\n	address[] public peers;\n	uint256 public lastreading;\n	string public name;\n	uint256 public actual_feedin=0;\n	uint256 public actual_feedout=0;	\n	uint256 public total_feedin;\n	uint256 public total_feedout;\n	string public symbol =""Wh"";\n	uint256 public managedbalance;\n	bool public feedin;\n	bool public autobalancepeers;\n	bool listening;\n	address public aggregate;\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	mapping (address => uint256) public balanceOf;\n	mapping (address => uint256) public allowance;	\n	\n	mapping (address => uint256) public molist;\n	\n	function GridMember(string membername,uint256 managablebalance,bool directionFeedin,address mpo,address aggregation) {			\n		name=membername;\n		managedbalance=managablebalance;\n		balanceOf[this]=managablebalance;\n		Transfer(msg.sender,this,managablebalance);\n		feedin=directionFeedin;		\n		if(feedin) total_feedin=lastreading; else total_feedout=lastreading;\n		autobalancepeers=false;	\n		mp=MPO(mpo);\n		updateReading(mp.reading());		\n		actual_feedin=0;\n		actual_feedout=0;\n		listening=false;\n		aggregate=aggregation;\n	}\n	\n	function switchMPO(address from, address to) {\n		if(msg.sender!=mp.operator()) throw;\n		updateWithMPO();\n		lastreading=0;\n		super.switchMPO(from,to);\n		updateWithMPO();\n		listening=false;\n	}\n	function registerListening() onlyOperator {\n		mp.registerListening(this);\n		listening=true;\n	}\n	\n	function addPowerSource(address peer,uint256 manageallowed,uint merritorder) onlyOperator {\n		if(merritorder>9) throw;\n		if(feedin) throw;\n 		allowance[peer]=manageallowed;\n		peers.push(peer);\n		molist[peer]=merritorder;\n		\n	} \n	\n	function updateWithMPO() {			\n		updateReading(mp.balanceOf(mp));\n	}\n		\n	function updateReading(uint256 reading) private {	\n		if(getActual()>0) runPeerBalance();\n		if(reading<lastreading) throw;\n		var actual = reading -lastreading;\n		if(feedin) actual_feedin+=actual; else actual_feedout+=actual;		\n		if(feedin) total_feedin+=actual; else total_feedout+=actual;										\n		lastreading=reading;\n		runPeerBalance();\n	}\n	\n	function requestPeerBalance() onlyOperator {\n		updateWithMPO();\n		runPeerBalance();\n		Aggregation a = Aggregation(aggregate);\n		a.doBalanceFor(this);\n		\n	}\n	\n	function runPeerBalance() private {\n		for(var j=0;j<10;j++) {\n			for(var i=0;i<peers.length;i++) {\n				if(molist[peers[i]]==j) {\n				GridMember peer = GridMember(peers[i]);\n				allowance[peer]=getActual();\n				peer.doBalance(this);\n				}\n			}\n		}	\n	}\n	function getActual() returns(uint256) {\n		if(feedin) return actual_feedin; else return actual_feedout;				\n	}\n	\n	function receiveTransfer(uint256 amount) {\n		if(tx.origin!=operator) throw;	\n		if(feedin) actual_feedin-=amount; else actual_feedout-=amount;\n	}\n	function sendToAggregation(uint256 amount) {\n		balanceOf[this]-=amount;\n		balanceOf[aggregate]+=amount;\n		if(feedin) actual_feedin-=amount; else actual_feedout-=amount;\n		Transfer(this,aggregate,amount);\n	}\n	function doBalance(address requester) {		\n		updateWithMPO();\n		if(autobalancepeers) {\n			if((actual_feedin>0)||(actual_feedout>0)) {\n				// Prevent Loop Condition!\n				\n			}				\n		}\n		GridMember peer = GridMember(requester);		\n		\n		if(feedin==peer.feedin()) return;\n		uint256 peer_allowance = peer.allowance(this);\n		uint256 balance_amount=0;\n		//\n		if(feedin) { balance_amount=actual_feedin; } else { balance_amount=actual_feedout; }\n		if(peer_allowance<balance_amount) { balance_amount=peer_allowance; }		\n		if(balanceOf[this]<balance_amount) balance_amount=balanceOf[this];	\n		\n		if((peer.managedbalance()-peer.balanceOf(requester))+peer.getActual()<balance_amount) balance_amount=(peer.managedbalance()-peer.balanceOf(requester))+peer.getActual();\n		\n		if(balance_amount>0) {\n			balanceOf[this]-=balance_amount;\n			balanceOf[requester]+=balance_amount;\n			Transfer(this,requester,balance_amount);\n			if(feedin) { actual_feedin-=balance_amount; 						\n					   } else { actual_feedout-=balance_amount; }\n			peer.receiveTransfer(balance_amount);\n		}		\n	}\n\n	\n	function transfer(address _to, uint256 _value) {\n		/* Function stub required to see tokens in wallet */		\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n   \n}\n\n\ncontract Aggregation {\n	address public owner;\n	address[] public members;\n	uint256 public actual_feedin;\n	uint256 public actual_feedout;\n	uint256 public balance_in;\n	uint256 public balance_out;\n	uint256 public last_balance;\n	uint256 public next_balance;\n	string public name=""Aggregation"";\n	string public symbol=""Wh"";\n	mapping (address => uint256) public balanceOf;\n	mapping (address => uint256) public lastbalancing;\n	\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	function Aggregation() {\n		owner=msg.sender;\n		next_balance=now+3600;\n	}\n	\n	function addGridMember(address gridmember) {\n		if(msg.sender!=owner) throw;\n	\n		members.push(gridmember);\n	}\n	function transfer(address _to, uint256 _value) {\n		/* Function stub required to see tokens in wallet */		\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	\n	function doBalanceFor(address a) {\n		bool found=false;\n		for(var i=0;i<members.length;i++) {\n			if(members[i]==a) found=true; \n		}\n		if(!found) throw;\n		\n		GridMember g = GridMember(a);\n		actual_feedin+=g.actual_feedin();\n		actual_feedout+=g.actual_feedout();\n		// as a member is either feeder or consumer this is not dangerous... :)\n\n		g.sendToAggregation(g.actual_feedin()+g.actual_feedout());\n		lastbalancing[a]=now;\n		\n	}	\n	function doBalance() {\n		if(now<next_balance) throw;\n		for(var i=0;i<members.length;i++) {\n			doBalanceFor(members[i]);			\n		}\n		next_balance=now+3600;\n	}\n}\n// Aggregation Testnet: 0x70F24857194520Fd70a788C6a9D9638bA44a0B85",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。エネルギー管理のための機能的な設計。,
1633238,0x091560e1b77e7e8abdab77d9623e31560ff37a40,false,false,,,,TOO_SHORT
1633611,0xbfdea9ff33fcd4397b4d5e9f19dde657cc414be3,false,false,,,,TOO_SHORT
1633904,0x16d08d0539e02e414d47fdf5d3ecc3b28fe4b200,false,false,,,,TOO_SHORT
1634122,0xc27b730de30c0bdde5ae337e0fabd478d55be43c,false,false,,,,TOO_SHORT
1634314,0xe3b6638f0c1c0fa37282fab6ef9457e457a1e9a8,false,false,"/*\n\nAuthor: psdev\n\np@psdev.io\n\n0x13370CA2e8426a82BcfcCE21C97817A243c521Cf\n\n*/\n\ncontract TokenInterface {\n  function balanceOf(address _owner) constant returns (uint256 balance);\n  function transfer(address _to, uint256 _amount) returns (bool success);\n  function receiveEther() returns(bool);\n}\n\ncontract SellTokens {\n    address constant THE_DAO_ADDRESS = 0xbb9bc244d798123fde783fcc1c72d3bb8c189413;\n\n    TokenInterface public theDao;\n    mapping (address => uint) public allowedFreeExchanges;\n\n    event TransferEvent(address _from, address _to, uint256 _value);\n    event ReturnEvent(uint256 _value);\n    event NotEnoughEthErrorEvent(uint trySend, uint available);\n    event NotEnoughDaoErrorEvent(uint trySend, uint available);\n\n    function SellTokens(){\n        theDao = TokenInterface(THE_DAO_ADDRESS);\n        populateAllowedFreeExchanges();\n    }\n\n    function requestTokensBack() {\n        if (msg.value != 0 || allowedFreeExchanges[msg.sender] == 0) throw;\n        if (!theDao.transfer(msg.sender, allowedFreeExchanges[msg.sender])) throw;\n        allowedFreeExchanges[msg.sender] = 0;\n    }\n\n    function buy100DaoFor1Eth(){\n        var tokens_to_send = msg.value;\n        uint daoBalance = theDao.balanceOf(this);\n        if (tokens_to_send > daoBalance) {\n            NotEnoughDaoErrorEvent(tokens_to_send, daoBalance);\n            throw;\n        }\n        if (msg.value > this.balance) {\n            NotEnoughEthErrorEvent(msg.value, this.balance);\n            throw;\n        }\n\n        // send tokens back to buyer\n        if (!theDao.transfer(msg.sender, tokens_to_send)) throw;\n        TransferEvent(this, msg.sender, tokens_to_send);\n        // send eth from buyer to dao\n        if (!theDao.receiveEther.value(msg.value)()) throw;\n        ReturnEvent(msg.value);\n    }\n\n    // accounts and amounts sent to dao, rounded down & only txn > 100 tokens\n    function populateAllowedFreeExchanges() internal {\n        // from etherscan\n        allowedFreeExchanges[address(0x900b1d91f8931e3e1de3076341accb2f6011214f)] = 4000000000000000000;\n        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 31560000000000000000;\n        allowedFreeExchanges[address(0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13)] = 9900000000000000000;\n        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 1040000000000000000;\n        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 90000000000000000000;\n        allowedFreeExchanges[address(0xdf21fa922215b1a56f5a6d6294e6e36c85a0acfb)] = 49990000000000000000;\n        allowedFreeExchanges[address(0x0a9de66f5fda96a5b40d1ca9cd18bfb298c67d1c)] = 16440000000000000000;\n        allowedFreeExchanges[address(0x946c555081313c5e0986c6cd5f6978257a406237)] = 1000000000000000000;\n        allowedFreeExchanges[address(0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13)] = 295510000000000000000;\n    }\n\n\n\n\n}",1,標準的なトークン販売コントラクトで、特に芸術的な要素は見られません。,
1634402,0x5a48d6b2838c6f7b246783478ae006de2a0f56ce,false,false,,,,TOO_SHORT
1634557,0xc557a5783bc03161ed508e80fd539b6eb1c352f3,false,false,,,,TOO_SHORT
1634672,0x43b352344e5f7ae626ea4639536b828b61e0f9b3,false,false,,,,TOO_SHORT
1635197,0x78e12c2ebd424f9b35cd0dd234aeb0da3c15a8f2,true,false,,,,0x25af8d824b3b078a589e47418a95b4388d1552f4
1635197,0xfc97c51387b417a063e7f25dd1327c7bee7f874f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1635197,0x55888093632769c1b1ea6dcf6cefc81408241cf7,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1635197,0xd94312c8e0a7a8a7340d2019719592a50394ae6f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1635436,0xc3113bcda42b1824c07f8317b40152d6730a6f37,true,false,"contract EtherTreasuryInterface {\n    function withdraw(address _to, uint _value) returns(bool);\n    function withdrawWithReference(address _to, uint _value, string _reference) returns(bool);\n}\n\ncontract MultiAsset {\n    function owner(bytes32 _symbol) constant returns(address);\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract Asset {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\n            return false;\n        }\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\n            return false;\n        }\n        return true;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\n            return false;\n        }\n        return true;\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() returns(bool) {\n        return multiAsset.transfer(multiAsset.owner(symbol), balanceOf(address(this)), symbol);\n    }\n}\n\ncontract Ambi {\n    function getNodeAddress(bytes32) constant returns(address);\n    function addNode(bytes32, address) external returns(bool);    \n    function hasRelation(bytes32, bytes32, address) constant returns(bool);\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract OpenDollar is Asset, AmbiEnabled {\n    uint public txGasPriceLimit = 21000000000;\n    uint public refundGas = 40000;\n    uint public transferCallGas = 21000;\n    uint public transferWithReferenceCallGas = 21000;\n    uint public transferFromCallGas = 21000;\n    uint public transferFromWithReferenceCallGas = 21000;\n    uint public transferToICAPCallGas = 21000;\n    uint public transferToICAPWithReferenceCallGas = 21000;\n    uint public transferFromToICAPCallGas = 21000;\n    uint public transferFromToICAPWithReferenceCallGas = 21000;\n    uint public approveCallGas = 21000;\n    uint public forwardCallGas = 21000;\n    uint public setCosignerCallGas = 21000;\n    EtherTreasuryInterface public treasury;\n    mapping(uint32 => address) public allowedForwards;\n\n    function updateRefundGas() checkAccess(""setup"") returns(uint) {\n        uint startGas = msg.gas;\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\n        if (tx.gasprice > txGasPriceLimit) {\n            return 0;\n        }\n        if (!_refund(1)) {\n            return 0;\n        }\n        refundGas = startGas - msg.gas;\n        return refundGas;\n    }\n\n    function setOperationsCallGas\n        (\n            uint _transfer,\n            uint _transferFrom,\n            uint _transferToICAP,\n            uint _transferFromToICAP,\n            uint _transferWithReference,\n            uint _transferFromWithReference,\n            uint _transferToICAPWithReference,\n            uint _transferFromToICAPWithReference,\n            uint _approve,\n            uint _forward,\n            uint _setCosigner\n        ) checkAccess(""setup"") returns(bool)\n    {\n        transferCallGas = _transfer;\n        transferFromCallGas = _transferFrom;\n        transferToICAPCallGas = _transferToICAP;\n        transferFromToICAPCallGas = _transferFromToICAP;\n        transferWithReferenceCallGas = _transferWithReference;\n        transferFromWithReferenceCallGas = _transferFromWithReference;\n        transferToICAPWithReferenceCallGas = _transferToICAPWithReference;\n        transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference;\n        approveCallGas = _approve;\n        forwardCallGas = _forward;\n        setCosignerCallGas = _setCosigner;\n        return true;\n    }\n\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(""admin"") returns(bool) {\n        if (_txGasPriceLimit == 0) {\n            return false;\n        }\n        treasury = EtherTreasuryInterface(_treasury);\n        txGasPriceLimit = _txGasPriceLimit;\n        if (msg.value > 0 && !address(treasury).send(msg.value)) {\n            throw;\n        }\n        return true;\n    }\n\n    function setForward(bytes4 _msgSig, address _forward) checkAccess(""admin"") returns(bool) {\n        allowedForwards[uint32(_msgSig)] = _forward;\n        return true;\n    }\n\n    function _stringGas(string _string) constant internal returns(uint) {\n        return bytes(_string).length * 75;\n    }\n\n    function _applyRefund(uint _startGas) internal returns(bool) {\n        if (tx.gasprice > txGasPriceLimit) {\n            return false;\n        }\n        uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice;\n        return _refund(refund);\n    }\n\n    function _refund(uint _value) internal returns(bool) {\n        return treasury.withdraw(tx.origin, _value);\n    }\n\n    function _transfer(address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferCallGas;\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, """")) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromCallGas;\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, """")) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPCallGas;\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, """")) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPCallGas;\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, """")) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference);\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromWithReferenceCallGas + _stringGas(_reference);\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _approve(address _spender, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + approveCallGas;\n        if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _setCosignerAddress(address _cosigner) internal returns(bool, bool) {\n        uint startGas = msg.gas + setCosignerCallGas;\n        if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transfer(_to, _value);\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFrom(_from, _to, _value);\n        return success;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferToICAP(_icap, _value);\n        return success;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAP(_from, _icap, _value);\n        return success;\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferWithReference(_to, _value, _reference);\n        return success;\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromWithReference(_from, _to, _value, _reference);\n        return success;\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferToICAPWithReference(_icap, _value, _reference);\n        return success;\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n        return success;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        bool success;\n        (success,) = _approve(_spender, _value);\n        return success;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        bool success;\n        (success,) = _setCosignerAddress(_cosigner);\n        return success;\n    }\n\n    function checkTransfer(address _to, uint _value) constant returns(bool, bool) {\n        return _transfer(_to, _value);\n    }\n\n    function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) {\n        return _transferFrom(_from, _to, _value);\n    }\n\n    function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferToICAP(_icap, _value);\n    }\n\n    function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferFromToICAP(_from, _icap, _value);\n    }\n\n    function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferWithReference(_to, _value, _reference);\n    }\n\n    function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function checkApprove(address _spender, uint _value) constant returns(bool, bool) {\n        return _approve(_spender, _value);\n    }\n\n    function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) {\n        return _setCosignerAddress(_cosigner);\n    }\n\n    function _forward(address _to, bytes _data) internal returns(bool) {\n        uint startGas = msg.gas + forwardCallGas + (_data.length * 50);\n        if (_to == 0x0) {\n            return false;\n        }\n        _to.call.value(msg.value)(_data);\n        return _applyRefund(startGas);\n    }\n\n    function () returns(bool) {\n        return _forward(allowedForwards[uint32(msg.sig)], msg.data);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1635816,0x3483f714439732a8439c0b40f7345d1d30ddd683,false,false,,,,TOO_SHORT
1636020,0x18d58549a3dc6126d62edbce4ad2de8d968e45aa,false,false,,,,TOO_SHORT
1636330,0x83ca83ff078f651e1b69cd70f43ec11b4aa0af2b,false,false,,,,TOO_SHORT
1636668,0x832ed96cc5bf8a7db5d91c0de5b09e54e0f8297b,false,false,,,,TOO_SHORT
1636809,0x094fcd48d3e6e535617e3d8f60929880f00e6695,false,false,,,,TOO_SHORT
1636811,0x9d56ec238714e3096f93779c6535a4cecb5791a7,false,false,,,,TOO_SHORT
1636901,0xa5d3fd35d4402e5bb3ce128570625999f3da7222,false,false,,,,TOO_SHORT
1637050,0x1b76fc9a4d7a5502c654bcda6481e50ba0275f77,false,false,,,,TOO_SHORT
1637449,0xcc4b735eb0efaf4f5d8873ef172720c7bb150419,false,false,,,,TOO_SHORT
1637471,0x96f8c1e09365e1604e8a0fa1a3ef03bd7d8f56de,false,false,,,,TOO_SHORT
1638115,0x2e355c4d59b83989badc5cfa458624b47b0d28b1,false,false,,,,TOO_SHORT
1638589,0x27ac5044a7cc6c4cd75deeadd256415f5ab4505f,false,false,,,,TOO_SHORT
1638852,0x759085cfb092a58334019bff65668e90bd1b6dbc,false,false,,,,TOO_SHORT
1638954,0x29637684c3f99687995ffa0fa55774b61c7b000b,false,false,,,,TOO_SHORT
1639349,0x7aa7d53a821fb6270e46e9b4504f898322800b52,false,false,,,,TOO_SHORT
1639560,0xc24a54d07b85a10b6b7331093c7212c11017f258,false,false,,,,TOO_SHORT
1639650,0xb7dea0e5f1a597805738abf982e8ba05a8179d0c,false,false,,,,TOO_SHORT
1639762,0x2d2c26658366aa7b22afa77b74dea7e5396eeef8,false,false,,,,TOO_SHORT
1639765,0xe9369b4439934b68b3ac89e7bc11df5db2f0e9b7,false,false,,,,TOO_SHORT
1639960,0x2c29d708d8f120f4253d1cb908d43a166e9dfead,false,false,,,,TOO_SHORT
1640131,0x4c9548a11fe1058777de7a03309cf19ade3a1859,false,false,,,,TOO_SHORT
1640262,0xeefa00b5a836686b59f321b48142cffa875211ad,false,false,,,,TOO_SHORT
1640523,0xaf7880f89ddf4df7830d078135c97050cfc419b7,false,false,,,,TOO_SHORT
1640541,0x9eb201c38791aef0415a930cc1622707064eae25,false,false,,,,TOO_SHORT
1640855,0x76c579b5a4d4d66e51416622537d9829aa80ba89,false,false,,,,TOO_SHORT
1641090,0xb8602d311fe865615fb5d2cc3298f0bd99cb4276,false,false,,,,TOO_SHORT
1641094,0xc7cd184f90b4aee2205d1daabc5522c21fd9f3b7,false,false,,,,TOO_SHORT
1641169,0xd8722349ae31888c24f10a6f270953abf7207fa6,false,false,,,,TOO_SHORT
1641323,0xa323d8fc3233d4f043a71457330c64b82d2ac7b0,false,false,,,,TOO_SHORT
1641368,0x7c07f47b95f63bdaa9f0d58b1b829f30711f1905,false,false,,,,TOO_SHORT
1641510,0x10b5b7cf536a1eeff31f7d92075efb6b30310c91,false,false,,,,TOO_SHORT
1641563,0x963c649c2be167cdecdc7b4375d57458356f95f3,false,false,,,,TOO_SHORT
1641828,0x6a6ad2fda21674a63529e4bf7190009d937cca8a,false,false,,,,TOO_SHORT
1642241,0xfcc1f6e66b84dc6e24d8d547e14872ffc6ac76ca,false,false,,,,TOO_SHORT
1642570,0x1d34a8cbe5b6c15ff1cbbf9bab81c42f94253589,false,false,,,,TOO_SHORT
1642624,0x8df6a4e95d077fb6bb36431d4720c4e928a4da28,false,false,,,,TOO_SHORT
1642647,0xce0c745a7da4c39aab29e51b04b43abb7e79dde4,false,false,,,,TOO_SHORT
1642728,0xd4fe7bc31cedb7bfb8a345f31e668033056b2728,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1642728,0xb3fb0e5aba0e20e5c49d252dfd30e102b171a425,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1642728,0xe2c90c19c323866b61d13b47febe9346c8e014b8,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1642728,0xfa554b30b6752446f3c255e0c33319fc35333f0e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1642751,0x3b60de3d2560c26acf8bb51ef1aa28d299cc0b93,false,false,,,,TOO_SHORT
1642933,0x3ad52ae5b3e49eb77c8b1c8924c6c3b09015c341,false,false,,,,TOO_SHORT
1643006,0x99fee4a8655bb64902fb1758a5c03cb1db946dd6,false,false,,,,TOO_SHORT
1643184,0x8b8e16135ba1685ba362f246439e97185e9ef8cc,false,false,,,,TOO_SHORT
1643225,0x8e267c3e5bba0650b35314b62a723a36d48bffd0,false,false,,,,TOO_SHORT
1643252,0xa7a299e9cf74362aa342cc438e9153baedd46811,false,false,,,,TOO_SHORT
1643276,0xd3170986a95164ecb16b2ce47a8bec4dff920fc1,false,false,,,,TOO_SHORT
1643408,0x6e87f79882242d8ec5f44e71bcb01d4708dfafc5,false,false,,,,TOO_SHORT
1643624,0x92f7bff818443910f8189bf1637343c7e73a4d56,false,false,,,,TOO_SHORT
1643685,0x3296c1264bdbb274e4b4954e14d4c4722fb03cd8,false,false,,,,TOO_SHORT
1643692,0x35175d7b64579929ae0c493463b96534dee1a7f8,false,false,,,,TOO_SHORT
1643694,0x5c15497546029487fd8933800451782a6d8b6a88,false,false,,,,TOO_SHORT
1643857,0xd0e22e667dabb67eb220bb85e5c99d8c52d2e449,false,false,,,,TOO_SHORT
1643867,0xc6e3b1c7b75fa1f24e7a65179864435b24cf7864,false,false,,,,TOO_SHORT
1644021,0x2046311cfe4f3d00dd7fb87be78fc823a473c900,false,false,,,,TOO_SHORT
1644126,0x777f64c8bd77a1e50b8e1767cac10409e7b512c1,false,false,,,,TOO_SHORT
1644184,0xd9fe6abdb821a181f3c7eb8264ee4c7ddc48ee91,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1644232,0x0e9550e9d4318fff2a5686adfd04dc570aa5a5eb,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1644322,0xfd2d2af0d3ed16dc80cae68e106bee611b0a58d7,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1644331,0x714d64222dd1bf36822127a609ee796d717104d1,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1644458,0x7ac8e92b4d1a52b1597847c5e4e4609fa2812624,false,false,,,,TOO_SHORT
1644495,0x893d8743e26198b5aa51b02598ada70fb08300a6,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1644616,0x27ba4e581e66234b1de2b2f5bea31985c93542ae,false,false,,,,TOO_SHORT
1645393,0xc9e381f0e63456c50b9096779c6a019ee368fec9,false,false,,,,TOO_SHORT
1645630,0xe681c3893c0e2dd7d46907d2cf8b659c181f3c4b,false,false,,,,TOO_SHORT
1645840,0x4e92e219b506e01878ce20d8e1180afb19e070c4,false,false,,,,TOO_SHORT
1646078,0x4a3ea1a41876114d19bd24024ba595bf5d5c221c,false,false,,,,TOO_SHORT
1646571,0xb430dab4e4ac47a28b3a767a91073ecb66b3586c,false,false,,,,TOO_SHORT
1646578,0x0dc4d8fa0704c0c1fa90b5d901205bc681b356ac,false,false,,,,TOO_SHORT
1646684,0xed46d20e69c3ff529064f1503256b65c9fa743b5,false,false,,,,TOO_SHORT
1646794,0xd7a6a164d272af3ff0cd948d91f6d2db8de2fe8e,false,false,,,,TOO_SHORT
1646801,0x3f2d17ed39876c0864d321d8a533ba8080273ede,false,false,"contract NoxonFund {\n\n    address public owner;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply; //18160ddd for rpc call https://api.etherscan.io/api?module=proxy&data=0x18160ddd&to=0xContractAdress&apikey={eserscan api}&action=eth_call\n    uint256 public Entropy;\n    uint256 public ownbalance; //d9c7041b\n\n	uint256 public sellPrice; //4b750334\n    uint256 public buyPrice; //8620410b\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    \n    \n    /* Initializes cont ract with initial supply tokens to the creator of the contract */\n    function token()  {\n    \n        if (owner!=0) throw;\n        buyPrice = msg.value;\n        balanceOf[msg.sender] = 1;    // Give the creator all initial tokens\n        totalSupply = 1;              // Update total supply\n        Entropy = 1;\n        name = 'noxonfund.com';       // Set the name for display purposes\n        symbol = '? SHARE';             // Set the symbol for display purposes\n        decimals = 0;                 // Amount of decimals for display purposes\n        owner = msg.sender;\n        setPrices();\n    }\n    \n\n    \n     /* Send shares function */\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;    \n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	\n\n    function setPrices() {\n        ownbalance = this.balance; //own contract balance\n        sellPrice = ownbalance/totalSupply;\n        buyPrice = sellPrice*2; \n    }\n    \n    \n   function () returns (uint buyreturn) {\n       \n        uint256 amount = msg.value / buyPrice;                // calculates the amount\n        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance\n       \n        totalSupply += amount;\n        Entropy += amount;\n        \n        Transfer(0, msg.sender, amount);\n        \n        owner.send(msg.value/2);\n        //set next price\n        setPrices();\n        return buyPrice;\n   }\n   \n\n    \n    function sell(uint256 amount) {\n        setPrices();\n        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\n        Transfer(msg.sender, this, amount);                 //return shares to contract\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance\n        msg.sender.send(amount * sellPrice);               // sends ether to the seller\n        setPrices();\n\n    }\n	\n	//All incomse will send using newIncome method\n	event newincomelog(uint amount,string description);\n	function newIncome(\n        string JobDescription\n    )\n        returns (string result)\n    {\n        if (msg.value <= 1 ether/100) throw;\n        newincomelog(msg.value,JobDescription);\n        return JobDescription;\n    }\n    \n    \n    \n    //some democracy\n    \n    uint votecount;\n    uint voteno; \n    uint voteyes;\n    \n    mapping (address => uint256) public voters;\n    \n    function newProposal(\n        string JobDescription\n    )\n        returns (string result)\n    {\n        if (msg.sender == owner) {\n            votecount = 0;\n            newProposallog(JobDescription);\n            return ""ok"";\n        } else {\n            return ""Only admin can do this"";\n        }\n    }\n    \n\n    \n    \n    function ivote(bool myposition) returns (uint result) {\n        votecount += balanceOf[msg.sender];\n        \n        if (voters[msg.sender]>0) throw;\n        voters[msg.sender]++;\n        votelog(myposition,msg.sender,balanceOf[msg.sender]);\n        return votecount;\n    }\n\n    \n    event newProposallog(string description);\n    event votelog(bool position, address voter, uint sharesonhand);\n   \n    \n}",1,標準的なトークン管理と投票機能を持つ実用的なスマートコントラクトです。,
1646806,0x11d727e43fb98bba3fb0283c3973237eaed387a6,false,false,,,,0x88f0a4b91cd59bfdea14e07c03c19e48936224b0
1647067,0xc7272a83cf82ee3b2129736cd41812948c5a76a0,false,false,,,,TOO_SHORT
1647638,0x3eb26b671e4350b85095da8842c6cf48378bcb62,false,false,,,,TOO_SHORT
1647705,0x498be1ef6ea470716a0d4e5f852f690f750ea4b1,false,false,,,,TOO_SHORT
1647739,0x2af8818646b307dbece2b5bbcd0f411d04117fb8,false,false,,,,TOO_SHORT
1647899,0x7888a9e63495f9773a7af673be48468d6b0cca14,false,false,,,,TOO_SHORT
1647902,0x3da1d027bda072bd7b96562545ec5e52974025cc,false,false,,,,TOO_SHORT
1648638,0xce7207da9890fd0d318c5102d9ebccccddcc17ca,false,false,,,,TOO_SHORT
1648837,0x06706dd3f2c9abf0a21ddcc6941d9b86f0596936,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1648837,0x651d05ff05d1fdd7a3688978cc4a77e988a9942a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1648837,0xec1204ec8f4b44f209d60de3853227fb68a9032d,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1648837,0x319f70bab6845585f412ec7724b744fec6095c85,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1648885,0xc6d0a410e5ac439e3c4f6bca648677ef52d785f6,false,false,,,,TOO_SHORT
1648899,0x5196e8916b774da71993157565e762eab6104872,false,false,,,,TOO_SHORT
1648930,0x8182d0eef9f71bf38875e22f2c353195d80506d2,false,false,"contract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		https://d.ethereumlottery.net\n		ver: 1.0.0\n	*/\n	address private owner;\n	uint private constant fee = 5;\n	uint private constant investorFee = 50;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraDifficulty = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant minimumRollDiv = 10;\n	uint private constant difficultyMultipler = 1000000;\n	uint private constant investMinDuration = 1 days;\n	\n    bool public ContractEnabled = true;\n    uint public ContractDisabledBlock;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] investors;\n	\n	string constant public Information = ""https://d.ethereumlottery.net"";\n	\n	function ChanceOfWinning(uint Bet) constant returns(uint Rate) {\n		Rate = getDifficulty(Bet);\n		if (Bet < minimumRollPrice) { Rate = 0; }\n		if (jackpot_/minimumRollDiv < Bet) { Rate = 0; }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = jackpot_/minimumRollDiv;\n	}\n	function Investors(uint id) constant returns(address Owner, uint Investment, uint Balance, bool Live) {\n		if (id < investors.length) {\n			Owner = investors[id].owner;\n			Investment = investors[id].value;\n			Balance = investors[id].balance;\n			Live = investors[id].live;\n		} else {\n			Owner = 0;\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n	}\n	function dEthereumlotteryNet() {\n		owner = msg.sender;\n	}\n	function Invest() OnlyEnabled external {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if (msg.sender.send(value_ % investUnit) == false) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].valid == false) {\n				newInvest(a,msg.sender,value_);\n				return;\n			}\n		}\n		investors.length++;\n		newInvest(investors.length-1,msg.sender,value_);\n	}\n	function newInvest(uint investorsID, address investor, uint value) private {\n		investors[investorsID].owner = investor;\n		investors[investorsID].value = value;\n		investors[investorsID].balance = 0;\n		investors[investorsID].valid = true;\n		investors[investorsID].live = true;\n		investors[investorsID].timestamp = now + investMinDuration;\n		jackpot_ += value;\n		setJackpot();\n	}\n	function GetMyInvestFee() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].owner == msg.sender && investors[a].valid == true) {\n				balance_ = investors[a].balance;\n				investors[a].valid = false;\n			}\n		}\n		if (balance_ > 0) { if (msg.sender.send(balance_) == false) { throw; } }\n	}\n	function CancelMyInvest() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].owner == msg.sender && investors[a].valid == true && investors[a].timestamp < now) {\n				if (investors[a].live == true) {\n					balance_ = investors[a].value + investors[a].balance;\n					jackpot_ -= investors[a].value;\n					delete investors[a];\n				} else {\n					balance_ = investors[a].balance;\n					delete investors[a];\n				}\n			}\n		}\n		setJackpot();\n		if (balance_ > 0) { if (msg.sender.send(balance_) == false) { throw; } }\n	}\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function DoRoll() external {\n		reFund();\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid == true) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if (ContractEnabled == false || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if (value_ > 0) { if (msg.sender.send(value_) == false) { throw; } }\n		if (found == false) { throw; }\n	}\n	event RollEvent(address Player,uint Difficulty, uint Result, uint Number, uint Win);\n	function makeRoll(uint id) private returns(uint win){\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint difficulty_ = getDifficulty(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber * difficultyMultipler % difficulty_ == 0) {\n			win = Jackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n		}\n		RollEvent(msg.sender, difficulty_, bigNumber * difficultyMultipler % difficulty_, bigNumber * difficultyMultipler,win);\n		delete players[msg.sender][id];\n	}\n	function getDifficulty(uint value) private returns(uint){\n		return jackpot_ * difficultyMultipler / value * 100 / investorFee * extraDifficulty / 100;\n	}\n	function investorAddFee(uint value) private {\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live == true) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n			}\n		}\n	}\n	event PrepareRollEvent(address Player, uint Block);\n	function prepareRoll(uint rollID, uint seed) private {\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = msg.value;\n		players[msg.sender][rollID].game = JackpotHits;\n		RollCount++;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber);\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_/minimumRollDiv < msg.value) { throw; }\n		if (jackpot_ == 0) { throw; }\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if (players[msg.sender][a].valid == false) {\n				prepareRoll(a,seed);\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll(players[msg.sender].length-1,seed);\n	}\n	function () {\n		PrepareRoll(0);\n	}\n	function reFund() private { if (msg.value > 0) { if (msg.sender.send(msg.value) == false) { throw; } } }\n	function OwnerCloseContract() external OnlyOwner {\n		reFund();\n		if (ContractEnabled == false) {\n		    if (ContractDisabledBlock < block.number) {\n		        uint balance_ = this.balance;\n		        for ( uint a=0 ; a < investors.length ; a++ ) {\n		            balance_ -= investors[a].balance;\n		        }\n		        if (balance_ > 0) {\n                    if (msg.sender.send(balance_) == false) { throw; }\n		        }\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner {\n		reFund();\n		if (feeValue == 0) { throw; }\n		if (owner.send(feeValue) == false) { throw; }\n		feeValue = 0;\n	}\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if (!ContractEnabled) { throw; } _	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1649024,0x47de341f0792ae29c179266d4d7d9e9ceed00027,false,false,,,,TOO_SHORT
1649325,0xa7d67b546371466f60c92368fd9990e1f82d1bb7,false,false,,,,TOO_SHORT
1649482,0xfae9bdd23f71fe71ea3d70164350aca3cc75c005,false,false,,,,TOO_SHORT
1649740,0x6118d4b0f971311f9583360cf17cba759d778c06,false,false,,,,TOO_SHORT
1649986,0x00b64975173b72e1360be182fc399a6f7c302ab4,false,false,,,,TOO_SHORT
1650156,0xb23eb38d6ae9c90a3f414eafb3931bacd0c993f9,false,false,,,,TOO_SHORT
1650183,0xc3adf6b8d0d9b1c86def75fdd9468195056464f7,false,false,,,,TOO_SHORT
1650385,0x75828a174ce819785da670978ec2c6e9f8a8b4fc,false,false,,,,TOO_SHORT
1650827,0x26163e12f240652102ed4462ade3631b53de5dbf,false,false,,,,TOO_SHORT
1650875,0x0810673c533d7583e9058cc0edb2b7ffe9eeee49,false,false,,,,TOO_SHORT
1650950,0x2e9e2082a42bb27c8eed53843ca772847163801f,false,false,,,,TOO_SHORT
1651161,0xc1e9d197558d11c1215d50c7c03ac7a82174e597,false,false,,,,TOO_SHORT
1651243,0x61f226c834fd39acc495c7ebcf6c9f156d65c174,false,false,,,,TOO_SHORT
1651348,0x9a32a2bf7f614eaaee18ede994b4cb6a4b6a04be,false,false,,,,TOO_SHORT
1651522,0x6632353fa8773d01d237b3985cfaa4ca237ade44,false,false,,,,TOO_SHORT
1651836,0xe6ff66f33465688300533c8b5ecec15e2c3b9f1d,false,false,,,,TOO_SHORT
1651885,0x3f7e071aa577da4c1ffd664cd6f07abaf1757f66,false,false,,,,TOO_SHORT
1652799,0xa3fdac92d82fae23b9eec15db6da9527e834b098,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1652799,0xf4d09861f89785570ab13f1d97f692112c3f42f7,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1652799,0x2a5ed960395e2a49b1c758cef4aa15213cfd874c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1652799,0x779543a0491a837ca36ce8c635d6154e3c4911a6,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1653254,0xb4149be542dfca25e1b203374d408630cba3643c,false,false,,,,TOO_SHORT
1653270,0x1f36f2249ec89266ad4ee4351538148aaebc72e8,false,false,"contract euroteambet {\n\n	struct team {\n		string teamName;\n		mapping(address => uint) bet;\n		uint totalBet;\n	}\n\n	team[] public euroTeams;\n\n	bool winningTeamDefined;\n	uint winningTeam;\n\n	/** Bets close at the opening day of the EuroCup: 10 June 2016 **/\n	uint startCompetitionTime;\n\n	/**  Overall amount bet **/\n	uint public globalBet;\n\n	/** Define the creator and fees collected **/\n	address creator;\n	uint feeCollected;\n\n	/**\n	* Constructor: Defines team and creator\n	*/\n	function euroteambet() {\n		// Define the Teams\n		team memory toCreate;\n		// Post a dummy team to ensure the actual range is from 1 to 24 and not 0 to 23.\n		toCreate.teamName = '';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Albania';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Austria';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Belgium';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Croatia';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Czech Republic';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'England';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'France';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Germany';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Hungary';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Iceland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Italy';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Nothern Ireland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Poland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Portugal';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Republic of Ireland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Romania';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Russia';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Slovakia';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Spain';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Sweden';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Switzerland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Turkey';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Ukraine';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Wales';\n		euroTeams.push(toCreate);\n\n		creator = msg.sender;\n\n		winningTeamDefined = false;\n\n		// Euro Cup starts in 4 days\n		startCompetitionTime = block.timestamp + (60 * 60 * 24) * 4;\n\n	}\n\n\n	event BetFromTransaction(address indexed from, uint value);\n	event CollectFromTransaction(address indexed from, uint value);	\n	event BetClosedNoWinningTeam(address indexed from, uint value);	\n	/**\n	 * Catch-All Function: Un case of transaction received going though a Contract Function\n	 * 1: Check if bets are still open\n	 * 2: Check if the bet is more than 0.1 ETH\n	 * 3: Divided by 1000000000000000 to have an integer (0.016 Eth to 16) and call betOnATeam\n	 *    If the EeasyBet value is not correct (possible value 1 to 24), it will be throw in BetOnAteam function\n	 * 4: Check if the winning team as been defined    \n	 */\n	function () {\n		if (startCompetitionTime >= block.timestamp) {\n			if (msg.value >= 100 finney) {\n				BetFromTransaction(msg.sender, msg.value);\n				betOnATeam((msg.value % 100 finney) / 1000000000000000);\n			} else {\n				msg.sender.send(msg.value);\n				return;\n			}\n		} else if (winningTeamDefined == true) {\n			CollectFromTransaction(msg.sender, msg.value);\n			collectEarnings();\n		} else {\n			BetClosedNoWinningTeam(msg.sender, msg.value);\n			if(msg.value > 0){\n				msg.sender.send(msg.value);\n			}\n			return;\n		}\n	}\n\n	/**\n	 * Used to defined the winner of the Tournament\n	 * 1: The winning team is updated \n	 * 2: All amount invested are gathered in globalBet\n	 * 3: All balances of the winning team updated proportionally to the amount invested\n	 *\n	 * param      {uint  teamWinningName  The identifier of the team winning\n	 */\n	function setWinner(uint teamWinningID) {\n		// Check if the sender is the creator and if the tournament has ended\n		if (msg.sender == creator) {\n			winningTeam = teamWinningID;\n			winningTeamDefined = true;\n		} else {\n			if(msg.value > 0){\n				msg.sender.send(msg.value);\n			}\n			return;\n		}\n	}\n\n\n	event BetOnATeam(address indexed from, uint indexed id, uint value);\n	/**\n	 * Used to bet on the winner of the Tournament\n	 * 1: Check if bets are still open\n	 * 2: Check if the bet is more than 0.1 ETH\n	 * 3: Check if the id of the team is correct (possible value 1 to 24)\n	 * param      {uint}  id      The identifier of the team to bet on\n	 */\n	function betOnATeam(uint id) {\n		if (startCompetitionTime >= block.timestamp && msg.value >= 100 finney && id >= 1 && id <= 24) {\n\n			uint amount = msg.value;\n\n			// Collect 3% Fee\n			feeCollected += (amount * 3 / 100);\n			amount -= (amount * 3 / 100);\n\n			BetOnATeam(msg.sender, id, amount);\n\n			euroTeams[id].bet[msg.sender] += amount;\n			euroTeams[id].totalBet += amount;\n			globalBet += amount;\n		} else {\n			if(msg.value > 0){\n				msg.sender.send(msg.value);\n			}\n			return;\n		}\n	}\n\n	/**\n	* Check earnings for a specific address\n	* \n	* param      address  toCheck  Address to check its earnings \n	* return     uint   Amount earned\n	*/\n	function checkEarnings(address toCheck) returns (uint) {\n		if(msg.value > 0){\n			msg.sender.send(msg.value);\n		}\n\n		if (winningTeamDefined == true) {\n			return (globalBet * (euroTeams[winningTeam].bet[toCheck] / euroTeams[winningTeam].totalBet));\n		} else {\n			return 0;\n		}\n	}\n\n	/**\n	 * Only allowed the withdrawals of the fund once the Winning team is updated\n	 */\n	function collectEarnings() {\n		if(msg.value > 0){\n			msg.sender.send(msg.value);\n		}\n		if (winningTeamDefined == true) {\n			uint earnings = (globalBet * (euroTeams[winningTeam].bet[msg.sender] / euroTeams[winningTeam].totalBet));\n			msg.sender.send(earnings);\n			euroTeams[winningTeam].bet[msg.sender] = 0;\n		} else {\n			return;\n		}\n	}\n\n	/**\n	* Allow the creator of the game to send balance\n	* \n	* param      address  toSend  Address to receive its earnings \n	*/\n	function sendEarnings(address toSend) {\n		if(msg.value > 0){\n			msg.sender.send(msg.value);\n		}\n		if (msg.sender == creator && winningTeamDefined == true) {\n			uint earnings = (globalBet * (euroTeams[winningTeam].bet[toSend] / euroTeams[winningTeam].totalBet));\n			toSend.send(earnings);\n			euroTeams[winningTeam].bet[toSend] = 0;\n		} else {\n			return;\n		}\n	}\n\n	/**\n	* Allow the creator to collect the 3% Fee\n	*/\n	function collectFee() {\n		msg.sender.send(msg.value);\n		if (msg.sender == creator) {\n			creator.send(feeCollected);\n			feeCollected = 0;\n		} else {\n			return;\n		}\n	}\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1653557,0xe0cfa488bb6442d39a4abf844d5876f209f03871,false,false,"contract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		https://d.ethereumlottery.net\n		ver: 2.0.0\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	uint private constant fee = 5;\n	uint private constant investorFee = 50;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 26;\n	\n    bool public ContractEnabled = true;\n    uint public ContractDisabledBlock;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] investors;\n	\n	string constant public Information = ""https://d.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function dEthereumlotteryNet() {\n		owner = msg.sender;\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n	    if (jackpot_ == 0) {\n	        Rate = 0;\n	        Bet = 0;\n	        return;\n	    }\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		if (Value < Bet) {\n		    Rate++;\n		    Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n		    Rate = BestRollRate;\n		    Bet = getRealBet(Rate);\n        }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(uint id) constant returns(address Owner, uint Investment, uint Balance, bool Live) {\n		if (id < investors.length) {\n			Owner = investors[id].owner;\n			Investment = investors[id].value;\n			Balance = investors[id].balance;\n			Live = investors[id].live;\n		} else {\n			Owner = 0;\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() OnlyEnabled external {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if ( ! investors[a].valid) {\n				newInvest(a,msg.sender,value_);\n				return;\n			}\n		}\n		investors.length++;\n		newInvest(investors.length-1,msg.sender,value_);\n	}\n	function GetMyInvestFee() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].owner == msg.sender && ! investors[a].valid) {\n				balance_ = investors[a].balance;\n				investors[a].valid = false;\n			}\n		}\n		if (balance_ > 0) { if ( ! msg.sender.send(balance_)) { throw; } }\n	}\n	function CancelMyInvest() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if ((investors[a].owner == msg.sender && investors[a].valid)) {\n			    if (investors[a].timestamp < now || ! ContractEnabled) {\n    				if (investors[a].live) {\n    					balance_ = investors[a].value + investors[a].balance;\n    					jackpot_ -= investors[a].value;\n    					delete investors[a];\n    				} else {\n    					balance_ = investors[a].balance;\n    					delete investors[a];\n    				}\n			    }\n			}\n		}\n		setJackpot();\n		if (balance_ > 0) { if ( ! msg.sender.send(balance_)) { throw; } }\n	}\n	/* For Players */\n	function DoRoll() external {\n		reFund();\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if ( ! ContractEnabled || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if (value_ > 0) { if (msg.sender.send(value_)) { throw; } }\n		if ( ! found) { throw; }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		uint _rate = getRate(msg.value);\n		uint _realBet = getRealBet(_rate);\n		if (msg.value < _realBet) {\n		    _rate++;\n		    _realBet = getRealBet(_rate);\n		}\n		if (_rate < BestRollRate) { \n		    _rate = BestRollRate;\n		    _realBet = getRealBet(_rate);\n        }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner {\n		reFund();\n		if ( ! ContractEnabled) {\n		    if (ContractDisabledBlock < block.number) {\n		        uint balance_ = this.balance;\n		        for ( uint a=0 ; a < investors.length ; a++ ) {\n		            balance_ -= investors[a].balance;\n		        }\n		        if (balance_ > 0) {\n                    if ( ! msg.sender.send(balance_)) { throw; }\n		        }\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner {\n		reFund();\n		if (feeValue == 0) { throw; }\n		if ( ! owner.send(feeValue)) { throw; }\n		feeValue = 0;\n	}\n	\n	/*\n		Private functions\n	*/\n	function newInvest(uint investorsID, address investor, uint value) private {\n		investors[investorsID].owner = investor;\n		investors[investorsID].value = value;\n		investors[investorsID].balance = 0;\n		investors[investorsID].valid = true;\n		investors[investorsID].live = true;\n		investors[investorsID].timestamp = now + investMinDuration;\n		jackpot_ += value;\n		setJackpot();\n	}\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n		}\n		RollEvent(msg.sender, _rate, bigNumber % _rate, bigNumber ,win);\n		delete players[msg.sender][id];\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function reFund() private { if (msg.value > 0) { if ( ! msg.sender.send(msg.value)) { throw; } } }\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		RollCount++;\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, bet);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1000000 / value * 100 / investorFee * extraRate / 100 / 1000000;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1000000 / ( rate * 1000000 * investorFee / extraRate);\n	}\n	\n	/*\n		Events\n	*/	\n	event RollEvent(address Player, uint Rate, uint Result, uint Number, uint Win);\n	event PrepareRollEvent(address Player, uint Block, uint Bet);\n	\n	/*\n		Modifiders\n	*/\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1653671,0x48d080aec4d59c8ba9b309bccf28faf4a166342d,false,false,,,,TOO_SHORT
1653801,0xbf4bf9e6382b96f173d298575ff006e9fa8eb448,false,false,,,,TOO_SHORT
1653932,0xf4f71b128216d7eedc1ccc63bc7a94c301be08e8,false,false,,,,TOO_SHORT
1653975,0x9c50426be05db97f5d64fc54bf89eff947f0a321,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1653975,0xf186e77a167128bc1eb092f1e1582ba13376badb,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1653975,0x6a4ef59983a0a49fa8db0998f3b27e643f5ac129,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1653975,0x5c6e67ccd5849c0d29219c4f95f1a7a93b3f5dc5,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1654134,0x856f6ab18ad12e97920365911ae3063814fc04e1,false,false,,,,TOO_SHORT
1654227,0x42de3288a215578a0e839c4bdb297f0a813c9499,false,false,,,,TOO_SHORT
1654447,0x647d8792fb8b7d124ca634ebad5b200dc33704ad,true,false,,,,0xc3113bcda42b1824c07f8317b40152d6730a6f37
1654736,0xb0490cecad82fa3247b14efc2cc58530cd71f1fb,false,false,,,,TOO_SHORT
1654758,0x226afcd9d5c1d80cc86fd7ac0072af734c37d3fb,false,false,,,,TOO_SHORT
1655104,0xc91b93528568b16fd0f295a09a320efd7943bd23,true,false,,,,0xc3113bcda42b1824c07f8317b40152d6730a6f37
1655126,0x65c6a77bf78a6aa5bbb2075026ab027b8c920261,true,false,,,,0xc3113bcda42b1824c07f8317b40152d6730a6f37
1655535,0x6932ccbbc37b44c93d506ca69891d859981fa3ee,false,false,,,,TOO_SHORT
1655650,0xe866d19b08ede7882ecc493bdc51e0baedc304e0,false,false,,,,TOO_SHORT
1655754,0x67120e5a0770860d12cbcc98ad0c60a35faed79f,false,false,,,,TOO_SHORT
1655968,0xda31c6c3b342c7ae455f7d27d04a12d8660224ac,false,false,,,,TOO_SHORT
1655980,0xc2db561e46c248715db24466a2a1667e1f186e6e,false,false,,,,TOO_SHORT
1655997,0x597cc90774efed11ead1dd72828768d4563350f5,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public ownerEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    \n    uint constant safeGas = 25000;\n    uint constant oraclizeGasLimit = 150000;\n\n    struct Investor {\n        address user;\n        uint capital;\n    }\n    mapping(uint => Investor) investors; //starts at 1\n    uint public numInvestors = 0;\n    mapping(address => uint) investorIDs;\n    uint public invested = 0;\n    \n    address owner;\n    bool public isStopped;\n\n    struct Bet {\n        address user;\n        uint bet; // amount\n        uint roll; // result\n	uint fee; \n    }\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n    uint public amountWagered = 0;\n    int public profit = 0;\n    int public takenProfit = 0;\n    int public ownerProfit = 0;\n\n    function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\n        \n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n        \n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        ownerEdge = ownerEdgeInitial;\n        divestFee = divestFeeInitial;\n        \n        owner = msg.sender;\n    }\n\n\n    function() {\n        bet();\n    }\n\n    function bet() {\n        if (isStopped) throw;\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", oraclizeGasLimit);\n        if (msg.value < oraclizeFee) throw;\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"", 'BDXJhrVpBJ53o2CxlJRlQtZJKZqLYt5IQe+73YDS4HtNjS5HodbIB3tvfow7UquyAk085VkLnL9EpKgwqWQz7ZLdGvsQlRd2sKxIolNg9DbnfPspGqLhLbbYSVnN8CwvsjpAXcSSo3c+4cNwC90yF4oNibkvD3ytapoZ7goTSyoUYTfwSjnw3ti+HJVH7N3+c0iwOCqZjDdsGQUcX3m3S/IHWbOOQQ5osO4Lbj3Gg0x1UdNtfUzYCFY79nzYgWIQEFCuRBI0n6NBvBQW727+OsDRY0J/9/gjt8ucibHWic0=', oraclizeGasLimit); // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\n            betsKeys.push(myid);\n        } else {\n            throw; // invalid bet size\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n    \n    function minBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", oraclizeGasLimit);\n        return oraclizeFee+minBet;\n    }\n    \n    function safeSend(address addr, uint value) internal {\n        if (!(addr.call.gas(safeGas).value(value)())){\n            ownerProfit += int(value);\n        }\n    }\n  \n    function __callback(bytes32 myid, string result, bytes proof) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        \n        Bet thisBet = bets[myid];\n        if (thisBet.bet>0) {\n            if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\n                uint roll = parseInt(result);\n                if (roll<1 || roll>10000){\n                    safeSend(thisBet.user, thisBet.bet);\n                    return;    \n                }\n\n                bets[myid].roll = roll;\n                \n                int profitDiff;\n                if (roll-1 < pwin) { //win\n                    uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\n                    safeSend(thisBet.user, winAmount);\n                    profitDiff = int(thisBet.bet - winAmount);\n                } else { //lose\n                    safeSend(thisBet.user, 1);\n                    profitDiff = int(thisBet.bet) - 1;\n                }\n                \n                ownerProfit += (profitDiff*int(ownerEdge))/10000;\n                profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\n                \n                amountWagered += thisBet.bet;\n            } else {\n                //bet is too big (bankroll may have changed since the bet was made)\n                safeSend(thisBet.user, thisBet.bet);\n            }\n        }\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint, uint) {\n        if(id<betsKeys.length)\n        {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\n        }\n    }\n\n    function invest() {\n        if (isStopped) throw;\n        \n        if (investorIDs[msg.sender]>0) {\n            rebalance();\n            investors[investorIDs[msg.sender]].capital += msg.value;\n            invested += msg.value;\n        } else {\n            rebalance();\n            uint investorID = 0;\n            if (numInvestors<maxInvestors) {\n                investorID = ++numInvestors;\n            } else {\n                for (uint i=1; i<=numInvestors; i++) {\n                    if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\n                        investorID = i;\n                    }\n                }\n            }\n            if (investorID>0) {\n                if (investors[investorID].capital>0) {\n                    divest(investors[investorID].user, investors[investorID].capital);\n                    investorIDs[investors[investorID].user] = 0;\n                }\n                if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\n                    investors[investorID].user = msg.sender;\n                    investors[investorID].capital = msg.value;\n                    invested += msg.value;\n                    investorIDs[msg.sender] = investorID;\n                } else {\n                    throw;\n                }\n            } else {\n                throw;\n            }\n        }\n    }\n\n    function rebalance() private {\n        if (takenProfit != profit) {\n            uint newInvested = 0;\n            uint initialBankroll = getBankroll();\n            for (uint i=1; i<=numInvestors; i++) {\n                investors[i].capital = getBalance(investors[i].user);\n                newInvested += investors[i].capital;\n            }\n            invested = newInvested;\n            if (newInvested != initialBankroll && numInvestors>0) {\n                ownerProfit += int(initialBankroll - newInvested); //give the rounding error to the first investor\n                invested += (initialBankroll - newInvested);\n            }\n            takenProfit = profit;\n        }\n    }\n\n    function divest(address user, uint amount) private {\n        if (investorIDs[user]>0) {\n            rebalance();\n            if (amount>getBalance(user)) {\n                amount = getBalance(user);\n            }\n            investors[investorIDs[user]].capital -= amount;\n            invested -= amount;\n            \n            uint newAmount = (amount*divestFee)/10000; // take a fee from the deinvest amount\n            ownerProfit += int(newAmount);\n            safeSend(user, (amount-newAmount));\n        }\n    }\n\n    function divest(uint amount) {\n        if (msg.value>0) throw;\n        divest(msg.sender, amount);\n    }\n\n    function divest() {\n        if (msg.value>0) throw;\n        divest(msg.sender, getBalance(msg.sender));\n    }\n\n    function getBalance(address user) constant returns(uint) {\n        if (investorIDs[user]>0 && invested>0) {\n            return investors[investorIDs[user]].capital * getBankroll() / invested;\n        } else {\n            return 0;\n        }\n    }\n\n    function getBankroll() constant returns(uint) {\n        uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\n        if (this.balance < bankroll){\n            log0(""bankroll_mismatch"");\n            bankroll = this.balance;\n        }\n        return bankroll;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors<maxInvestors) {\n            return 0;\n        } else {\n            uint investorID;\n            for (uint i=1; i<=numInvestors; i++) {\n                if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\n                    investorID = i;\n                }\n            }\n            return getBalance(investors[investorID].user);\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\n        return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\n    }\n\n    function stopContract() {\n        if (owner != msg.sender) throw;\n        isStopped = true;\n    }\n  \n    function resumeContract() {\n        if (owner != msg.sender) throw;\n        isStopped = false;\n    }\n    \n    function forceDivestAll() {\n        forceDivestAll(false);\n    }\n    \n    function forceDivestAll(bool ownerTakeChangeAndProfit) {\n        if (owner != msg.sender) throw;\n        for (uint investorID=1; investorID<=numInvestors; investorID++) {\n            divest(investors[investorID].user, getBalance(investors[investorID].user));\n        }\n        if (ownerTakeChangeAndProfit) owner.send(this.balance);\n    }\n    \n    function ownerTakeProfit() {\n        ownerTakeProfit(false);\n    }\n    \n    function ownerTakeProfit(bool takeChange) {\n        if (owner != msg.sender) throw;\n        if (takeChange){\n            uint investorsCapital = 0;\n            for (uint i=1; i<=numInvestors; i++) {\n                investorsCapital += investors[i].capital;\n            }\n            if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\n                owner.send(this.balance);\n                ownerProfit = 0;\n            }\n        } else {\n            owner.send(uint(ownerProfit));\n            ownerProfit = 0;\n        }\n    }\n   \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1656199,0x0a4816509693a59b938eda5779a32e5f22be3673,false,false,,,,TOO_SHORT
1656277,0x03dd37f08c531ff55aaf01f2cc1aa00185596fc5,false,false,,,,TOO_SHORT
1656390,0x778af06e60f608b8cf45878d5549dc2ef1bd8d3e,false,false,,,,TOO_SHORT
1656977,0x10569b48532e53715f56517533cd3aead9f79f07,false,false,,,,TOO_SHORT
1657117,0xa5881e843dd839ed93bf6846fd0778a4e89f9b2c,false,false,,,,TOO_SHORT
1657370,0x669a480e79e0b1e1a7590c23551a1361fb034eed,false,false,,,,TOO_SHORT
1657427,0xfe7c5783d52879ff3dc796ddf4586900716951d7,false,false,,,,TOO_SHORT
1657473,0xd69a7fe2920cf4d74e7b4f81a25cb54a5a4d3fcd,false,false,,,,TOO_SHORT
1657485,0x86c89b4bfd54febe9cb3d2386b308105b887e8e1,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1657485,0xbe8539bfe837b67d1282b2b1d61c3f723966f049,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1657485,0x5eff6a8a76688e65eea8ac396b0e146f0c2ca189,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1657485,0x200450f06520bdd6c527622a273333384d870efb,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1657567,0xecd135fa4f61a655311e86238c92adcd779555d2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1657567,0x6c10d016581bc7c10e79b95fe5e43d700eacfd9d,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1657567,0x9bc8a9b47b567a6c28894b88c27c01b2f79af96f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1657567,0x2c19c7f9ae8b751e37aeb2d93a699722395ae18f,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1657583,0x704ff5aa069388704c0a5e104a8743b0793b0074,false,false,,,,TOO_SHORT
1658345,0xac85a04cda9063d21d2ad864133134c3455fc7c6,false,false,,,,TOO_SHORT
1658435,0xff7ba7db581e9e51c0ad231d89f5a87b89d716d2,false,false,,,,TOO_SHORT
1659011,0xf1385fb24aad0cd7432824085e42aff90886fef5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1659011,0x5881f7910d24131814acd3a8caaef0eac8a69738,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1659011,0x475b8ab2b3940089e70a209e6f448447c4015d16,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1659011,0x6b0c4d41ba9ab8d8cfb5d379c69a612f2ced8ecb,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1659124,0x2333ae3e1020906ad304bae8c731d67c65a7d8a2,false,false,,,,TOO_SHORT
1659144,0x8163e7fb499e90f8544ea62bbf80d21cd26d9efd,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1659144,0x36b9269345a37567d7aec9eb9df63f55002e8139,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1659144,0x570ba1e0626ab181c4980451871c493605e2185e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1659144,0xd1ac8b1ef1b69ff51d1d401a476e7e612414f091,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1659236,0x033558cb3738a83f24523f73f37d1b08d3ac9817,false,false,,,,TOO_SHORT
1659464,0xab7c74abc0c4d48d1bdad5dcb26153fc8780f83e,false,false,,,,TOO_SHORT
1659624,0xef595dc82843cbb278f9dca06a793929b7b06437,false,false,,,,TOO_SHORT
1659864,0x5f18a22f245a815842514fc122b46f48924d05d8,false,false,,,,TOO_SHORT
1660212,0x3c2f0f724b9ec9eea822c921e6a92a5b097839f0,false,false,,,,TOO_SHORT
1660215,0x0204671fe86ee87f3bc389aa6f8145221627411e,false,false,,,,0x597cc90774efed11ead1dd72828768d4563350f5
1660391,0x93f2d8062112b1febc630318f6bf6ac22ae41f3c,false,false,,,,TOO_SHORT
1660395,0x50739060a2c32dc076e507ae1a893aab28ecfe68,false,false,,,,0x597cc90774efed11ead1dd72828768d4563350f5
1660501,0x07effd0b4c2eb91c81aa1c89a894a936be80a68f,false,false,,,,TOO_SHORT
1660646,0xc2d5e5ce3ae775b9beaa6b54ceed5d7241ff38f0,false,false,,,,TOO_SHORT
1660699,0x390d8513ab2025e4db8eb4090aa29e1966aba09a,false,false,,,,TOO_SHORT
1660735,0x13eb99398c5ee5a5f704f686a0a6563b54e9df29,false,false,,,,TOO_SHORT
1660887,0x83cfd2d33bb9ed552a1e4b6af1bc3ea73bdee4f0,false,false,,,,0x597cc90774efed11ead1dd72828768d4563350f5
1661017,0xbd138df5b19e114adfb1d4042f8b7e79d02b6937,false,false,,,,TOO_SHORT
1661021,0x627a0a960c079c21c34f7612d5d230e01b4ad4c7,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1661021,0x53d720f8980f4cd67ca477e8f576895c1c617386,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1661021,0x6d073a27a21f9113213a06e28c89c9b787fa0a69,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1661021,0x51e0ddd9998364a2eb38588679f0d2c42653e4a6,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1661129,0x634216caa0ee0b0b68d6e1988d8b846c4b908cf4,false,false,,,,TOO_SHORT
1661238,0x1b4fb4d0bcb3e80d9314b866aaf15c84eb0f1234,true,false,"/*\nThis file is part of the DAO.\n000000000000000000000000bb9bc244d798123fde783fcc1c72d3bb8c189413\n\nAccount 0xB3267B3B37a1C153Ca574c3A50359f9d1613F95d\ndthPool 0xB256D572885A5246DDbF548F39da57f5f8074b9a\n\nHello all! I just deployed the first DTHPool (Delegate) in the real net.\nThe delegate in this contract is myself. My intention is not to be a stable delegate but to construct a repository of delegates where DTH’s can choose.\nI tested to delegate and undelegate some tokens. I also set up the votes for the proposals made to the DAO until now. \nIf any body wants to delegate me some tokens, he will be wellcome!. You can also check the votes set up and his motivations. \nI'll appreciate any feedback.\nIf any body wants to be a delegate, I’m absolutely open to help him to deploy the contract.\n\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\n\n/*\nBasic, standardized Token contract with no ""premine"". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Public variables of the token, all used for display \n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    string public standard = 'Token 0.1';\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\ncontract tokenRecipient { \n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \n}\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n    \n    /// Allow another contract to spend some tokens in your behalf \n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        tokenRecipient spender = tokenRecipient(_spender);\n        spender.receiveApproval(msg.sender, _value, this, _extraData);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/////////////////////\n// There is a solidity bug in the return parameters that it's not solved\n// when the bug is solved, the import from DAO is more clean.\n// In the meantime, a workaround proxy is defined\n\n// Uncoment this line when error fixed\n// import ""./DAO.sol"";\n\n// Workaround proxy remove when fixed\ncontract DAO {\n    function proposals(uint _proposalID) returns(\n        address recipient,\n        uint amount,\n        uint descriptionIdx,\n        uint votingDeadline,\n        bool open,\n        bool proposalPassed,\n        bytes32 proposalHash,\n        uint proposalDeposit,\n        bool newCurator\n    );\n\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) returns (uint _voteID);\n\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n// End of workaround proxy\n////////////////////\n\n\ncontract DTHPoolInterface {\n\n    // delegae url\n    string public delegateUrl;\n\n    // Max time the tokens can be blocked.\n    // The real voting in the DAO will be called in the last moment in order\n    // to block the tokens for the minimum time. This parameter defines the\n    // seconds before the voting period ends that the vote can be performed\n    uint maxTimeBlocked;\n\n\n    // Address of the delegate\n    address public delegate;\n\n    // The DAO contract\n    address public daoAddress;\n\n    struct ProposalStatus {\n\n        // True when the delegate sets the vote\n        bool voteSet;\n\n        // True if the proposal should ve voted\n        bool willVote;\n\n        // True if the proposal should be accepted.\n        bool suportProposal;\n\n        // True when the vote is performed;\n        bool executed;\n\n        // Proposal votingDeadline\n        uint votingDeadline;\n\n        // String set by the delegator with the motivation\n        string motivation;\n    }\n\n    // Statuses of the diferent proposal\n    mapping (uint => ProposalStatus) public proposalStatuses;\n\n\n    // Index of proposals by oraclizeId\n    mapping (bytes32 => uint) public oraclizeId2proposalId;\n\n    /// @dev Constructor setting the dao address and the delegate\n    /// @param _daoAddress address of the DAO\n    /// @param _delegate adddress of the delegate.\n    /// @param _maxTimeBlocked the maximum time the tokens will be blocked\n    /// @param _delegateName Name of the delegate\n    /// @param _delegateUrl Url of the delegate\n    /// @param _tokenSymbol token  symbol.\n    // DTHPool(address _daoAddress, address _delegate, uint _maxTimeBlocked, string _delegateName, string _delegateUrl, string _tokenSymbol);\n\n\n    /// @notice send votes to this contract.\n    /// @param _amount Tokens that will be transfered to the pool.\n    /// @return Whether the transfer was successful or not\n    function delegateDAOTokens(uint _amount) returns (bool _success);\n\n    /// Returns DAO tokens to the original\n    /// @param _amount that will be transfered back to the owner.\n    /// @return Whether the transfer was successful or not\n    function undelegateDAOTokens(uint _amount) returns (bool _success);\n\n\n    /// @notice This method will be called by the delegate to publish what will\n    /// be his vote in a specific proposal.\n    /// @param _proposalID The proposal to set the vote.\n    /// @param _willVote true If the proposal will be voted.\n    /// @param _supportsProposal What will be the vote.\n    function setVoteIntention(\n        uint _proposalID,\n        bool _willVote,\n        bool _supportsProposal,\n        string _motivation\n    ) returns (bool _success);\n\n    /// @notice This method will be doing the actual voting in the DAO\n    /// for the _proposalID\n    /// @param _proposalID The proposal to set the vote.\n    /// @return _finalized true if this vote Proposal must not be executed again.\n    function executeVote(uint _proposalID) returns (bool _finalized);\n\n\n    /// @notice This function is intended because if some body sends tokens\n    /// directly to this contract, the tokens can be sent to the delegate\n    function fixTokens() returns (bool _success);\n\n\n    /// @notice If some body sends ether to this contract, the delegate will be\n    /// able to extract it.\n    function getEther() returns (uint _amount);\n\n    /// @notice Called when some body delegates token to the pool\n    event Delegate(address indexed _from, uint256 _amount);\n\n    /// @notice Called when some body undelegates token to the pool\n    event Undelegate(address indexed _from, uint256 _amount);\n\n    /// @notice Called when the delegate set se vote intention\n    event VoteIntentionSet(uint indexed _proposalID, bool _willVote, bool _supportsProposal);\n\n    /// @notice Called when the vote is executed in the DAO\n    event VoteExecuted(uint indexed _proposalID);\n\n}\n\ncontract DTHPool is DTHPoolInterface, Token, usingOraclize {\n\n    modifier onlyDelegate() {if (msg.sender != delegate) throw; _}\n\n    // DTHPool(address _daoAddress, address _delegate, uint _maxTimeBlocked, string _delegateName, string _delegateUrl, string _tokenSymbol);\n\n    function DTHPool(\n        address _daoAddress,\n        address _delegate,\n        uint _maxTimeBlocked,\n        string _delegateName,\n        string _delegateUrl,\n        string _tokenSymbol\n    ) {\n        daoAddress = _daoAddress;\n        delegate = _delegate;\n        delegateUrl = _delegateUrl;\n        maxTimeBlocked = _maxTimeBlocked;\n        name = _delegateName;\n        symbol = _tokenSymbol;\n        decimals = 16;\n        oraclize_setNetwork(networkID_auto);\n    }\n\n    function delegateDAOTokens(uint _amount) returns (bool _success) {\n        DAO dao = DAO(daoAddress);\n        if (!dao.transferFrom(msg.sender, address(this), _amount)) {\n            throw;\n        }\n\n        balances[msg.sender] += _amount;\n        totalSupply += _amount;\n        Delegate(msg.sender, _amount);\n        return true;\n    }\n\n    function undelegateDAOTokens(uint _amount) returns (bool _success) {\n        DAO dao = DAO(daoAddress);\n        if (_amount > balances[msg.sender]) {\n            throw;\n        }\n\n        if (!dao.transfer(msg.sender, _amount)) {\n            throw;\n        }\n\n        balances[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        Undelegate(msg.sender, _amount);\n        return true;\n    }\n\n    function setVoteIntention(\n        uint _proposalID,\n        bool _willVote,\n        bool _supportsProposal,\n        string _motivation\n    ) onlyDelegate returns (bool _success) {\n        DAO dao = DAO(daoAddress);\n\n        ProposalStatus proposalStatus = proposalStatuses[_proposalID];\n\n        if (proposalStatus.voteSet) {\n            throw;\n        }\n\n        var (,,,votingDeadline, ,,,,newCurator) = dao.proposals(_proposalID);\n\n        if (votingDeadline < now || newCurator ) {\n            throw;\n        }\n\n        proposalStatus.voteSet = true;\n        proposalStatus.willVote = _willVote;\n        proposalStatus.suportProposal = _supportsProposal;\n        proposalStatus.votingDeadline = votingDeadline;\n        proposalStatus.motivation = _motivation;\n\n        VoteIntentionSet(_proposalID, _willVote, _supportsProposal);\n\n        if (!_willVote) {\n            proposalStatus.executed = true;\n            VoteExecuted(_proposalID);\n        }\n\n        bool finalized = executeVote(_proposalID);\n\n        if ((!finalized)&&(address(OAR) != 0)) {\n            bytes32 oraclizeId = oraclize_query(votingDeadline - maxTimeBlocked +15, ""URL"", """");\n\n            oraclizeId2proposalId[oraclizeId] = _proposalID;\n        }\n\n        return true;\n    }\n\n    function executeVote(uint _proposalID) returns (bool _finalized) {\n        DAO dao = DAO(daoAddress);\n        ProposalStatus proposalStatus = proposalStatuses[_proposalID];\n\n        if (!proposalStatus.voteSet\n            || now > proposalStatus.votingDeadline\n            || !proposalStatus.willVote\n            || proposalStatus.executed) {\n\n            return true;\n        }\n\n        if (now < proposalStatus.votingDeadline - maxTimeBlocked) {\n            return false;\n        }\n\n        dao.vote(_proposalID, proposalStatus.suportProposal);\n        proposalStatus.executed = true;\n        VoteExecuted(_proposalID);\n\n        return true;\n    }\n\n    function __callback(bytes32 oid, string result) {\n        uint proposalId = oraclizeId2proposalId[oid];\n        executeVote(proposalId);\n        oraclizeId2proposalId[oid] = 0;\n    }\n\n    function fixTokens() returns (bool _success) {\n        DAO dao = DAO(daoAddress);\n        uint ownedTokens = dao.balanceOf(this);\n        if (ownedTokens < totalSupply) {\n            throw;\n        }\n        uint fixTokens = ownedTokens - totalSupply;\n\n        if (fixTokens == 0) {\n            return true;\n        }\n\n        balances[delegate] += fixTokens;\n        totalSupply += fixTokens;\n\n        return true;\n    }\n\n    function getEther() onlyDelegate returns (uint _amount) {\n        uint amount = this.balance;\n\n        if (!delegate.call.value(amount)()) {\n            throw;\n        }\n\n        return amount;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1661299,0x6cf299e4878d4ea3333d3a70a806a42c5f718b62,false,false,,,,TOO_SHORT
1661406,0xf28d4570182cb52771dfdee7ccf42f99035f44d7,false,false,,,,TOO_SHORT
1661507,0xb0b4c7aa8b618f438afc3f0e874d933159fcd4ed,false,false,,,,TOO_SHORT
1661558,0xefabec0fd31e0ecdec72ad06eaa5817c270f664f,false,false,,,,TOO_SHORT
1661619,0x24ed9567656ede3683995944b8b1f21ce8057caf,false,false,,,,TOO_SHORT
1661625,0xafb49d41c08d75f3aeed807def9a4e85dd0bca9e,false,false,,,,TOO_SHORT
1661661,0x15342cf221f635ce6c4f188dd244d3059ba821fc,false,false,,,,TOO_SHORT
1661730,0x5843472a0754e52b90cd03623227d23bed40f90b,false,false,,,,TOO_SHORT
1662493,0x8b0092da833791586c854bbc0c693f281c65a462,false,false,,,,TOO_SHORT
1662624,0xa8e3239f8745edb0925154f569ec82a993cb1110,false,false,,,,TOO_SHORT
1662792,0xfe9581a997f45eaa606fc13a3d75fed354742371,false,false,,,,TOO_SHORT
1663249,0x558b4cc0d1d05f50891baa635f179486cec696e6,false,false,,,,TOO_SHORT
1663369,0xc79afd176729f18d80ef587e1ee478932c9b9e37,false,false,,,,TOO_SHORT
1663755,0xa5dc5acd6a7968a4554d89d65e59b7fd3bff0f90,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1663755,0x0e88cb3004930eec11ef27db6a168c41a9b50d49,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1663755,0x751819563a22da1bc5e3f0b4e0ad5ad5ccc9ffea,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1663755,0x9f27daea7aca0aa0446220b98d028715e3bc803d,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1663878,0x82dc93f1fc923d867639c8093a6e280add86f8d4,false,false,,,,TOO_SHORT
1663977,0x24c4d950dfd4dd1902bbed3508144a54542bba94,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1663977,0x7ca6be19a039f7c2ea89d1b23cf485cbb79e788c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1663977,0xbc53e417fa4b711bd51f89062916bc20fb7c45cd,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1663977,0xf0b1aa0eb660754448a7937c022e30aa692fe0c5,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1663979,0xfe1f807d608d3200539aac70dab37e6202b95e17,false,false,,,,TOO_SHORT
1664014,0x0ff30d6de14a8224aa97b78aea5388d1c51c1f00,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1664014,0xe6eba17eac4c82b0ac77c52625bd3717cd85f503,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1664014,0x3b57ecd3f470407094342a3d8cdd0ebe3b7f1dce,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1664014,0x492ea3bb0f3315521c31f273e565b868fc090f17,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1664570,0xbbc7bae8b500c97da993dcd9236ae850fd11737c,false,false,,,,TOO_SHORT
1664734,0x39b15d510c3f13c328e491830b95c518f095031f,false,false,,,,TOO_SHORT
1664791,0xa2ff5eb76eec3ca9083b289bbdd406dd397db726,false,false,,,,TOO_SHORT
1664963,0x6f127d6b963fcf923c8969c44b4caaaa7ec13268,false,false,,,,TOO_SHORT
1665138,0xb9ecee3caa88e1864b8264b18d74a267c79aa2d1,false,false,"contract EthereumRouletteInterface {\n\n  // The owner is responsible for committing and revealing spin results.\n  address public owner;\n  // Funds that are kept in reserve in order to pay off the winners in all revealed spins.\n  // This number increases when new bets are made and decreases when winners collect their\n  // winnings. When all winnings have been collected, this should be 0.\n  uint public locked_funds_for_revealed_spins;\n  // How much time (in seconds) the owner has to reveal the result to a spin after the\n  // first bet has been made.\n  uint public owner_time_limit;\n  // Used to calculate the maximum bet a player can make.\n  uint public fraction;\n  // Maximum bet that a player can make on one of the numbers this spin.\n  uint public max_bet_this_spin;\n  // Contains all spins that happened so far. All spins, except that last two, are\n  // settled. A spin is settled if and only if the spin_result and nonce are revealed by\n  // the owner or owner_took_too_long flag is true. If a spin is settled, then players can\n  // collect their winnings from that spin. It's possible that the last two spins are also\n  // settled if the owner took too long.\n  Spin[] public spins;\n\n  struct Spin {\n    // If owner takes too long (does not respond in time and someone calls the\n    // player_declare_taking_too_long function), owner_took_too_long will be set to true\n    // and all players will be paid out. This represents the total sum that will be paid\n    // out in that case.\n    uint total_payout;\n    // The owner privately computes the sha3 of spin_result + nonce.\n    bytes32 commit_hash;\n    // Should be in [0, 37] range. 0 and 37 represent 0 and 00 on the roulette wheel.\n    uint8 spin_result;\n    // Some random value that the owner generates to make it impossible for someone to\n    // guess the spin_result based on the commit_hash.\n    bytes32 nonce;\n    // Total amount that was bet on a particular number. Used to verify that the amount\n    // bet on a number does not exceed max_bet_this_spin.\n    mapping(uint8 => uint) total_bet_on_number;\n    // Maps player address to a bet on a particular spin_result.\n    mapping(address => mapping(uint8 => Bet)) bets;\n    // This can be set to true if player_declare_taking_too_long is called if the owner is\n    // taking too long. In that case all bets in this round will be winners.\n    bool owner_took_too_long;\n    // Time (in seconds) by which the spin result should be revealed by the owner.\n    uint time_of_latest_reveal;\n  }\n\n  struct Bet {\n    uint amount;\n    // True if this bet was already paid.\n    bool already_paid;\n  }\n\n  // Allows only the owner to call certain functions.\n  modifier onlyOwner {}\n  // Verifies no Ether is sent when calling a function.\n  modifier noEther {}\n  // Verifies that more than 0 Ether is sent when calling a function.\n  modifier etherRequired {}\n\n  // Player makes a bet on a particular spin_result.\n  function player_make_bet(uint8 spin_result) etherRequired;\n\n  // Player calls this function to collect all winnings from a particular spin.\n  function player_collect_winnings(uint spin_num) noEther;\n\n  // If the owner is taking too long to reveal the spin result, player can call this\n  // function. If enough time passed, all bets in the last two spins (which are\n  // unrevealed) will become winners. Player can then call player_collect_winnings.\n  function player_declare_taking_too_long() noEther;\n\n  // Owner reveals the spin_result and nonce for the first unrevealed spin (which is\n  // second last in the spins array). Owner also also adds a new unrevealed spin to the\n  // spins array. All new player bets will be on this new spin after this function is\n  // called.\n  //\n  // The reason why we always have two unrevealed spins (instead of 1) is because of this\n  // function. If there was only 1 unrevealed spin, when the owner tried revealing it,\n  // an attacker would be able to see the spin result in the transaction that the owner\n  // submits and quickly try to place a bet on the spin_result to try to get his\n  // trasaction to be processed before the owner.\n  function owner_reveal_and_commit(uint8 spin_result, bytes32 nonce, bytes32 commit_hash) onlyOwner noEther;\n\n  // Set a new time limit for the owner between commit and reveal.\n  function owner_set_time_limit(uint new_time_limit) onlyOwner noEther;\n\n  // Allows the owner to deposit additional funds into the contract.\n  function owner_deposit() onlyOwner etherRequired;\n\n  // Allows the owner to withdraw the winnings. Makes sure that the owner does not\n  // withdraw any funds that should be paid out to the players.\n  function owner_withdraw(uint amount) onlyOwner noEther;\n\n  // Updates the fraction (has an effect on how large the player bets can be).\n  function owner_set_fraction(uint _fraction) onlyOwner noEther;\n\n  function owner_transfer_ownership(address new_owner) onlyOwner noEther;\n\n  event MadeBet(uint amount, uint8 spin_result, address player_addr);\n  event Revealed(uint spin_number, uint8 spin_result);\n}\n\n\ncontract EthereumRoulette is EthereumRouletteInterface {\n\n  modifier onlyOwner {if (msg.sender != owner) throw; _}\n\n  modifier noEther {if (msg.value > 0) throw; _}\n\n  modifier etherRequired {if (msg.value == 0) throw; _}\n\n  function EthereumRoulette() {\n    owner = msg.sender;\n    fraction = 800;\n    owner_time_limit = 7 days;\n    // The contract must always have 2 unrevealed spins. This is why we commit the first\n    // two spins in the constructor. This means that it's not possible to bet on spin #1.\n    bytes32 first_num_hash = 0x3c81cf7279de81901303687979a6b62fdf04ec93480108d2ef38090d6135ad9f;\n    bytes32 second_num_hash = 0xb1540f17822cbe4daef5f1d96662b2dc92c5f9a2411429faaf73555d3149b68e;\n    spins.length++;\n    spins[spins.length - 1].commit_hash = first_num_hash;\n    spins.length++;\n    spins[spins.length - 1].commit_hash = second_num_hash;\n    max_bet_this_spin = address(this).balance / fraction;\n  }\n\n  function player_make_bet(uint8 spin_result) etherRequired {\n    Spin second_unrevealed_spin = spins[spins.length - 1];\n    if (second_unrevealed_spin.owner_took_too_long\n        || spin_result > 37\n        || msg.value + second_unrevealed_spin.total_bet_on_number[spin_result] > max_bet_this_spin\n        // verify it will be possible to pay the player in the worst case\n        || msg.value * 36 + reserved_funds() > address(this).balance) {\n      throw;\n    }\n    Bet b = second_unrevealed_spin.bets[msg.sender][spin_result];\n    b.amount += msg.value;\n    second_unrevealed_spin.total_bet_on_number[spin_result] += msg.value;\n    second_unrevealed_spin.total_payout += msg.value * 36;\n    if (second_unrevealed_spin.time_of_latest_reveal == 0) {\n      second_unrevealed_spin.time_of_latest_reveal = now + owner_time_limit;\n    }\n    MadeBet(msg.value, spin_result, msg.sender);\n  }\n\n  function player_collect_winnings(uint spin_num) noEther {\n    Spin s = spins[spin_num];\n    if (spin_num >= spins.length - 2) {\n      throw;\n    }\n    if (s.owner_took_too_long) {\n      bool at_least_one_number_paid = false;\n      for (uint8 roulette_num = 0; roulette_num < 38; roulette_num++) {\n        Bet messed_up_bet = s.bets[msg.sender][roulette_num];\n        if (messed_up_bet.already_paid) {\n          throw;\n        }\n        if (messed_up_bet.amount > 0) {\n          msg.sender.send(messed_up_bet.amount * 36);\n          locked_funds_for_revealed_spins -= messed_up_bet.amount * 36;\n          messed_up_bet.already_paid = true;\n          at_least_one_number_paid = true;\n        }\n      }\n      if (!at_least_one_number_paid) {\n        // If at least one number does not get paid, we let the user know when they try to estimate gas.\n        throw;\n      }\n    } else {\n      Bet b = s.bets[msg.sender][s.spin_result];\n      if (b.already_paid || b.amount == 0) {\n        throw;\n      }\n      msg.sender.send(b.amount * 36);\n      locked_funds_for_revealed_spins -= b.amount * 36;\n      b.already_paid = true;\n    }\n  }\n\n  function player_declare_taking_too_long() noEther {\n    Spin first_unrevealed_spin = spins[spins.length - 2];\n    bool first_spin_too_long = first_unrevealed_spin.time_of_latest_reveal != 0\n        && now > first_unrevealed_spin.time_of_latest_reveal;\n    Spin second_unrevealed_spin = spins[spins.length - 1];\n    bool second_spin_too_long = second_unrevealed_spin.time_of_latest_reveal != 0\n        && now > second_unrevealed_spin.time_of_latest_reveal;\n    if (!(first_spin_too_long || second_spin_too_long)) {\n      throw;\n    }\n    first_unrevealed_spin.owner_took_too_long = true;\n    second_unrevealed_spin.owner_took_too_long = true;\n    locked_funds_for_revealed_spins += (first_unrevealed_spin.total_payout + second_unrevealed_spin.total_payout);\n  }\n\n  function () {\n    // Do not allow sending Ether without calling a function.\n    throw;\n  }\n\n  function commit(bytes32 commit_hash) internal {\n    uint spin_num = spins.length++;\n    Spin second_unrevealed_spin = spins[spins.length - 1];\n    second_unrevealed_spin.commit_hash = commit_hash;\n    max_bet_this_spin = (address(this).balance - reserved_funds()) / fraction;\n  }\n\n  function owner_reveal_and_commit(uint8 spin_result, bytes32 nonce, bytes32 commit_hash) onlyOwner noEther {\n    Spin first_unrevealed_spin = spins[spins.length - 2];\n    if (!first_unrevealed_spin.owner_took_too_long) {\n      if (sha3(spin_result, nonce) != first_unrevealed_spin.commit_hash || spin_result > 37) {\n        throw;\n      }\n      first_unrevealed_spin.spin_result = spin_result;\n      first_unrevealed_spin.nonce = nonce;\n      locked_funds_for_revealed_spins += first_unrevealed_spin.total_bet_on_number[spin_result] * 36;\n      Revealed(spins.length - 2, spin_result);\n    }\n    // If owner took too long, the spin result and nonce can be ignored because all payers\n    // won.\n    commit(commit_hash);\n  }\n\n  function owner_set_time_limit(uint new_time_limit) onlyOwner noEther {\n    if (new_time_limit > 2 weeks) {\n      // We don't want the owner to be able to set a time limit of something like 1000\n      // years.\n      throw;\n    }\n    owner_time_limit = new_time_limit;\n  }\n\n  function owner_deposit() onlyOwner etherRequired {}\n\n  function owner_withdraw(uint amount) onlyOwner noEther {\n    if (amount > address(this).balance - reserved_funds()) {\n      throw;\n    }\n    owner.send(amount);\n  }\n\n  function owner_set_fraction(uint _fraction) onlyOwner noEther {\n    if (_fraction == 0) {\n      throw;\n    }\n    fraction = _fraction;\n  }\n\n  function owner_transfer_ownership(address new_owner) onlyOwner noEther {\n    owner = new_owner;\n  }\n\n  function seconds_left() constant returns(int) {\n    // Seconds left until player_declare_taking_too_long can be called.\n    Spin s = spins[spins.length - 1];\n    if (s.time_of_latest_reveal == 0) {\n      return -1;\n    }\n    if (now > s.time_of_latest_reveal) {\n      return 0;\n    }\n    return int(s.time_of_latest_reveal - now);\n  }\n\n  function reserved_funds() constant returns (uint) {\n    // These funds cannot be withdrawn by the owner. This is the amount contract will have\n    // to keep in reserve to be able to pay all players in the worst case.\n    uint total = locked_funds_for_revealed_spins;\n    Spin first_unrevealed_spin = spins[spins.length - 2];\n    if (!first_unrevealed_spin.owner_took_too_long) {\n      total += first_unrevealed_spin.total_payout;\n    }\n    Spin second_unrevealed_spin = spins[spins.length - 1];\n    if (!second_unrevealed_spin.owner_took_too_long) {\n      total += second_unrevealed_spin.total_payout;\n    }\n    return total;\n  }\n\n  function get_hash(uint8 number, bytes32 nonce) constant returns (bytes32) {\n    return sha3(number, nonce);\n  }\n\n  function bet_this_spin() constant returns (bool) {\n    // Returns true if there was a bet placed in the latest spin.\n    Spin s = spins[spins.length - 1];\n    return s.time_of_latest_reveal != 0;\n  }\n\n  function check_bet(uint spin_num, address player_addr, uint8 spin_result) constant returns (uint) {\n    // Returns the amount of ether a player player bet on a spin result in a given spin\n    // number.\n    Spin s = spins[spin_num];\n    Bet b = s.bets[player_addr][spin_result];\n    return b.amount;\n  }\n\n  function current_spin_number() constant returns (uint) {\n    // Returns the number of the current spin.\n    return spins.length - 1;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ルーレットゲームのロジックを実装。,
1665309,0x581e80f0a7eaa45b35bc532f54f5cd186458e410,false,false,,,,TOO_SHORT
1665376,0x29fdeff05db5bd07d731514e53986d9c5aeac35a,false,false,,,,TOO_SHORT
1665438,0x677626b6bd9db13d41fb6f2cd682999b980cf225,false,false,,,,TOO_SHORT
1665439,0x60d537578b2a599bb75602e478d040a59fd4345d,false,false,,,,TOO_SHORT
1665558,0x579a80d909f346fbfb1189493f521d7f48d52238,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1665558,0x2cde844325a529a21a136f16c10d7b1fcc774fbe,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1665558,0x2b0341f517f25f1661e1220d45c7b70eb6a67200,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1665558,0xcc34673c6c40e791051898567a1222daf90be287,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1665757,0xc31b69e5046ca074e2c94bfe1e718c4ff021947a,false,false,,,,TOO_SHORT
1666246,0x93df275c5c499533c33464694dd11811498d1632,false,false,,,,TOO_SHORT
1666381,0x707dd16477f19c652ea9aed8c361c53fe92ac9c9,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1666381,0x4cb31628079fb14e4bc3cd5e30c2f7489b00960c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1666381,0x040325e96c0cd136ad3823199281d01775c8a2ee,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1666381,0xe308bd1ac5fda103967359b2712dd89deffb7973,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1666616,0x67ff70417052d90ffe298a072a991c1688b4a3e9,false,false,,,,TOO_SHORT
1666725,0x84d46cb9bbad1e0eca23da85e7b570c026101794,false,false,,,,TOO_SHORT
1667056,0xe1e3e01bc8d3b6ec06e633dc8ac5bcdb3af08ad2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1667056,0x4fd6ace747f06ece9c49699c7cabc62d02211f75,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1667056,0x636707a0b51197c4d2f36489c29d904c33a9ddf3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1667056,0xac1ecab32727358dba8962a0f3b261731aad9723,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1667194,0x84ee6d708ccf8c699d4214e3efb20f6852f8186e,false,false,,,,TOO_SHORT
1667447,0x00b79a0db974531e2748b1f074021d45f246b4c2,false,false,,,,TOO_SHORT
1667518,0xb248ada01f3f47a15a6d4e426565e07ede1eebee,false,false,,,,TOO_SHORT
1667611,0x6a6db41ad8339d32373896a8b3aea6ca7851bf9b,false,false,,,,TOO_SHORT
1667619,0x8ce9f091a0e43dd9643d096a965b9b8981031ad3,false,false,,,,TOO_SHORT
1667994,0xfc2f59bf5fc74a5fed35e66969487e3ea077bc2f,false,false,,,,TOO_SHORT
1668000,0x80e9b99e3ee609eb2d000da35c700962b91550b3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1668000,0xdecbcfac02cdefafe78c9243a3821b185f47d42f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1668000,0x92d62824c6911dbbac8248f1f93d89f23eab95cc,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1668000,0xb43b92bf8204bd204d6ce0430d14161e0a6d8fbb,true,false,,,,0x25af8d824b3b078a589e47418a95b4388d1552f4
1668114,0xee9980c77ffc8349451b3859eb748213fc492b6f,false,false,,,,TOO_SHORT
1668116,0x5e8e28ac605bfcddb587510872acd29c6f2ac5e1,false,false,,,,TOO_SHORT
1668286,0x3b4bcecdefb2e60d77ab57663b73e1864c4edc3d,false,false,,,,TOO_SHORT
1668303,0xfef645d08fb0fa16015622f0840bef14e5df23ad,false,false,,,,TOO_SHORT
1668770,0x92c325cd3db59e10733fb2342bdf5f9c7c2a3231,false,false,,,,TOO_SHORT
1668800,0x4486a3d68fac6967006d7a517b889fd3f98c102b,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1668800,0x16ad22baed2e80b31fefb6c69f4b1cc1c28e759a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1668800,0x26415d284a67a3587b957c64f390f3380caa8084,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1668800,0x440c59b325d2997a134c2c7c60a8c61611212bad,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1668946,0x25e90771b1c0fb90be336d6df7df63db2cb6db32,false,false,,,,TOO_SHORT
1669017,0x4ebc8650a30df768ae0f3a3769f4f31c74f10b05,false,false,,,,TOO_SHORT
1669703,0xb2e03c8be91bf9157b3287464ec370dd1a33a183,false,false,,,,TOO_SHORT
1669710,0x01d131cae8924b06921e81da19fb5c5754e664d1,false,false,,,,TOO_SHORT
1669890,0x755921f3733af21a0ee10154fa03e5fdf8824b89,false,false,,,,TOO_SHORT
1670146,0x77ca7b50b6cd7e2f3fa008e24ab793fd56cb15f6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1670146,0x1bb40a71fdf5f741536053ab0a8fe9bc749ee33e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1670146,0x2a65aa25770519dc099658526b53d0da34a984ae,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1670146,0x6f6704e5a10332af6672e50b3d9754dc460dfa4d,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1670703,0xb119306fc159fdd3f9da8dfdf888b748aa0ea993,false,false,,,,TOO_SHORT
1670751,0x203feb0ffd04455076602576499afb59c9271305,false,false,,,,TOO_SHORT
1670787,0xc0fb756233803a5b96220d8e5b3856c32f5a42cf,false,false,,,,TOO_SHORT
1670795,0x1591fc0f688c81fbeb17f5426a162a7024d430c2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1670795,0x9be146cf6eb7ecd5fa22464b458e0f618f824bd6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1670795,0xaaef155c801b1c967b1e6c7585b0f777e3ceb83a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1670795,0x6131c42fa982e56929107413a9d526fd99405560,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1670975,0xa5ce88247589ccd1b475e1cfcc8c2dfe61f7f008,false,false,,,,TOO_SHORT
1671090,0x2492606719afa55ee8e8c04ebe065ecfb66d4665,false,false,,,,TOO_SHORT
1671283,0x9bc51baafa6445a0fd4e17669e109af292566d09,false,false,,,,TOO_SHORT
1671384,0xc568f8aa14231163830f323f5a22d5ed81d17790,false,false,,,,TOO_SHORT
1671426,0x849501593b06f76c35c45d06fb388a5f134ee089,false,false,,,,TOO_SHORT
1671750,0x424baf3f2b0a1e14ca023039078d1757022fe71a,false,false,,,,TOO_SHORT
1671881,0xa7478fd25ee8cc13fade4d34e7d58c09eaa060ba,false,false,,,,TOO_SHORT
1671884,0xbf6cdd52d59aa83218f8aee65a7740aa6519492b,false,false,,,,TOO_SHORT
1672233,0xaa7cf983eef1181240cb25320a48a63030a65d7a,false,false,,,,TOO_SHORT
1672234,0xd507d8a87daade43d79e35719e5246efc48f1509,false,false,,,,TOO_SHORT
1672306,0x264ebbbf5453603589f8b22b4df02738350b9533,false,false,,,,TOO_SHORT
1672562,0x980c41e2acf4d39b2f10a37fcccaffc6497db581,false,false,,,,TOO_SHORT
1672837,0xb4e267fe19f071619d4bfd404990663a2780ef43,false,false,,,,TOO_SHORT
1672977,0x950c2ddd0dff1280bed4dae457c0404dfb42c4d3,false,false,,,,TOO_SHORT
1673217,0xc532e64e6cffe66fa6ee717a658ce7a82376b6ad,false,false,,,,TOO_SHORT
1673606,0xa519f61546d3994b3e881a9515167b2c1fe10d8b,false,false,,,,TOO_SHORT
1674304,0x255a8523882610a0a613974dd3054ff1546f6761,false,false,,,,TOO_SHORT
1674340,0xbe3e15daa23d227101f57dc9960150d9f55ea804,false,false,,,,TOO_SHORT
1674370,0xb9637156d330c0d605a791f1c31ba5890582fe1c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1674370,0x06e417390a694dbac3bd5227a06b00b9196ef0e8,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1674370,0x973efdfadc81c79c1a3343e39e69a4624df76dd7,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1674370,0x1ca6abd14d30affe533b24d7a21bff4c2d5e1f3b,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1674379,0x83fb49638c27846a541e8bfed463b85820700a72,false,false,,,,TOO_SHORT
1674581,0xccf582e4e3102ea6b33d001bd804a52fc33d3c31,false,false,,,,TOO_SHORT
1674585,0x51053a30e0243653a6c7daf8e87f5764e97685ee,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\ncontract BitcoinBridge is usingOraclize {\n    string constant SHAPESHIFT_ENDPOINT =\n        ""json(https://shapeshift.io/shift).deposit"";\n\n    struct Task {\n        bytes32 oraclizeId;\n        bytes bitcoinAddress;\n        uint value;\n        uint timestamp;\n    }\n\n    mapping (uint => Task) public tasks;\n    mapping (bytes32 => uint) public oraclizeRequests;\n\n    uint public nextId = 1;\n\n    function queuePayment(bytes bitcoinAddress) oraclizeAPI\n                                                returns (bool successful) {\n        uint oraclizePrice = oraclize.getPrice(""URL"");\n        if (msg.value <= oraclizePrice) throw;\n\n        uint value = msg.value - oraclizePrice;\n\n        uint id = nextId++;\n        string memory json = strConcat(\n            '{""pair"": ""eth_btc"", ""withdrawal"": ""',\n            string(bitcoinAddress),\n            '""}'\n        );\n        bytes32 oraclizeId = oraclize.query2.value(oraclizePrice)(\n            0,\n            ""URL"",\n            SHAPESHIFT_ENDPOINT,\n            json\n        );\n        tasks[id].oraclizeId = oraclizeId;\n        tasks[id].bitcoinAddress = bitcoinAddress;\n        tasks[id].value = value;\n        tasks[id].timestamp = now;\n        oraclizeRequests[oraclizeId] = id;\n\n        return true;\n    }\n\n    function __callback(bytes32 oraclizeId, string result) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n\n        uint id = oraclizeRequests[oraclizeId];\n        if (id == 0) return;\n\n        address addr = parseAddr(result);\n        addr.send(tasks[id].value);\n\n        delete oraclizeRequests[oraclizeId];\n        delete tasks[id];\n    }\n\n    function retryOraclizeRequest(uint id) oraclizeAPI {\n        if (tasks[id].oraclizeId == 0) throw;\n\n        uint timePassed = now - tasks[id].timestamp;\n        if (timePassed < 60 minutes) throw;\n\n        uint oraclizePrice = oraclize.getPrice(""URL"");\n        if (msg.value < oraclizePrice) throw;\n\n        string memory json = strConcat(\n            '{""pair"": ""eth_btc"", ""withdrawal"": ""',\n            string(tasks[id].bitcoinAddress),\n            '""}'\n        );\n        bytes32 newOraclizeId = oraclize.query2.value(oraclizePrice)(\n            0,\n            ""URL"",\n            SHAPESHIFT_ENDPOINT,\n            json\n        );\n\n        delete oraclizeRequests[tasks[id].oraclizeId];\n        tasks[id].oraclizeId = newOraclizeId;\n        tasks[id].timestamp = now;\n        oraclizeRequests[newOraclizeId] = id;\n\n        if (msg.value > oraclizePrice) {\n            msg.sender.send(msg.value - oraclizePrice);\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1674636,0x7b695381541a6ba8297f7e30e24b70f9d007aa77,false,false,,,,TOO_SHORT
1675103,0x5e789c76a4dcdb575c06e18777c098f0565ef2ca,false,false,,,,TOO_SHORT
1675464,0x2300ebe289e4242ab4d56fbf359f6fd1dc1489d2,false,false,,,,TOO_SHORT
1675744,0xb421a3c15a9de03cdb4ba418d46b1995492dfe11,false,false,,,,TOO_SHORT
1675877,0x66f63e47e89d4899cf73d5cf46e0ccf26bf122e3,false,false,,,,TOO_SHORT
1676086,0x8b1c551711a38d60b3cab3def7d64efc91f8d26e,false,false,,,,TOO_SHORT
1676267,0xd42daec85ed04f2a38955f203ac4992c6809f166,false,false,,,,TOO_SHORT
1676954,0x12f11e84278a0943ab36e3ea3545c4023140eb5f,false,false,,,,TOO_SHORT
1676981,0xd646636386df2ae08f545069d91433e702733140,false,false,,,,TOO_SHORT
1677697,0x533d92884c029657e4c3697b5748a015da557619,false,false,,,,TOO_SHORT
1677973,0x7483c1633e878ad4647228f8a56929d728ef6552,false,false,,,,TOO_SHORT
1678131,0x29d0097579014d2679fc7ae772d043b0c153024f,false,false,,,,TOO_SHORT
1678376,0x52683160ae890d55f1a3a40ef023db169e0039b1,false,false,,,,TOO_SHORT
1678861,0x7cfa5786f65756062fa48aadda1721fe10a64334,false,false,,,,TOO_SHORT
1679010,0x72cc1cb848e2552f4cf42ddf26cf75d88e1da589,false,false,,,,TOO_SHORT
1679069,0x7b0d5637b8d7b69b0f401de0e75a94ce0b0f1273,false,false,,,,TOO_SHORT
1679081,0x1f73368ac8717552f7267851797bc6cd216f2a81,false,false,,,,TOO_SHORT
1679256,0x0d5d278952732a53a94ad7aa24b7a3bf0510ee1e,false,false,,,,TOO_SHORT
1679325,0xd3129ba41283c8cf1545e215652ec24d64b26251,false,false,,,,TOO_SHORT
1679346,0x53e36e708c6e9e6c3b18fd78d4eecb293934732f,false,false,,,,TOO_SHORT
1679412,0xd9aef3a1e38a39c16b31d1ace71bca8ef58d315b,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1679412,0x63ed5a272de2f6d968408b4acb9024f4cc208ebf,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1679412,0xfd2b7770661d7040fef75c399b4cb075c77dcd87,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1679412,0xf44f504b24b620363e38fb2f4ba0d8aaebcf409b,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1679547,0xecd9294cc857476766bd677f6dc9363ecfafc358,false,false,,,,TOO_SHORT
1679847,0x65fc58965961d8deb882c26404f04f03f1567d3f,false,false,,,,TOO_SHORT
1680230,0x56c460dbc5dd8f7c8c2ec5d96fc89907c84691ae,false,false,,,,TOO_SHORT
1680252,0x6e318bf527119e40499a05816f11b00a1e16b9da,false,false,,,,TOO_SHORT
1680270,0x64110bf0926c6f256d9bf537eec9c4c314f27af7,false,false,,,,TOO_SHORT
1680319,0xd6bc64c532e2f79298a3e1a0943db506086e49f8,false,false,,,,TOO_SHORT
1680370,0xd1665b6c0b286fddacec59f6733755676d460481,false,false,,,,TOO_SHORT
1680647,0x1d9e61248f88dc60889bb269fcf2244827f3a682,false,false,"contract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		http://d.ethereumlottery.net\n		ver: 2.1.0\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	uint private constant fee = 5;\n	uint private constant investorFee = 50;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 26;\n	\n    bool public ContractEnabled = true;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private ContractDisabledBlock;\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n		uint id;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] private investors;\n	\n	string constant public Information = ""http://d.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function dEthereumlotteryNet() {\n		owner = msg.sender;\n		investors.length = 1;\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n	    if (jackpot_ == 0) {\n	        Rate = 0;\n	        Bet = 0;\n	        return;\n	    }\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		if (Value < Bet) {\n		    Rate++;\n		    Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n		    Rate = BestRollRate;\n		    Bet = getRealBet(Rate);\n        }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		uint InvestorID = getInvestorByAddress(Address);\n		if (InvestorID == 0 || ! investors[InvestorID].valid) {\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n		Investment = investors[InvestorID].value;\n		Balance = investors[InvestorID].balance;\n		Live = investors[InvestorID].live;\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() OnlyEnabled external {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) {\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].timestamp = now + investMinDuration;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		jackpot_ += value_;\n		setJackpot();\n	}\n	function GetMyInvestmentBalance() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].balance == 0) { throw; }\n		if ( ! msg.sender.send( investors[InvestorID].balance )) { throw; }\n		investors[InvestorID].balance = 0;\n	}\n	function CancelMyInvestment() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].timestamp > now && ContractEnabled) { throw; }\n		uint balance_;\n		if (investors[InvestorID].live) {\n			jackpot_ -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		if ( ! msg.sender.send( balance_ )) { throw; }\n		delete investors[InvestorID];\n	}\n	/* For Players */\n	function DoRoll() external noEther {\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, false, true, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if ( ! ContractEnabled || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, true, false, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if ( ! found) { throw; }\n		if (value_ > 0) { if ( ! msg.sender.send(value_)) { throw; } }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		uint _rate = getRate(msg.value);\n		uint _realBet = getRealBet(_rate);\n		if (msg.value < _realBet) {\n		    _rate++;\n		    _realBet = getRealBet(_rate);\n		}\n		if (_rate < BestRollRate) { \n		    _rate = BestRollRate;\n		    _realBet = getRealBet(_rate);\n        }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! ContractEnabled) {\n		    if (ContractDisabledBlock < block.number) {\n				if (playersPot == 0) { throw; }\n				if ( ! msg.sender.send( playersPot )) { throw; }\n				playersPot = 0;\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n			ContractDisabled(ContractDisabledBlock);\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner noEther {\n		if (feeValue == 0) { throw; }\n		if ( ! owner.send(feeValue)) { throw; }\n		feeValue = 0;\n	}\n	\n	/*\n		Private functions\n	*/\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=1 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n			DoRollEvent(msg.sender, win, players[msg.sender][id].id, false, false, false, true, bigNumber, _rate, bigNumber % _rate);\n		} else {\n			DoRollEvent(msg.sender, players[msg.sender][id].value, players[msg.sender][id].id, false, false, true, false, bigNumber, _rate, bigNumber % _rate);\n		}\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=1 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		RollCount++;\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		players[msg.sender][rollID].id = RollCount;\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, players[msg.sender][rollID].value, players[msg.sender][rollID].id);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1000000 / value * 100 / investorFee * extraRate / 100 / 1000000;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1000000 / ( rate * 1000000 * investorFee / extraRate);\n	}\n	function getInvestorByAddress(address Address) internal returns (uint id) {\n		for ( id=1 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return;\n			}\n		}\n		return 0;\n	}\n	\n	/*\n		Events\n	*/	\n	event DoRollEvent(address Player, uint Value, uint RollID, bool Refund, bool LostBet, bool LossRoll, bool WinRoll, uint BigNumber, uint Rate, uint RollResult);\n	event PrepareRollEvent(address Player, uint Block, uint Bet, uint RollID);\n	event ContractDisabled(uint LossAllBetBlockNumber);\n	\n	/*\n		Modifiers\n	*/\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1681227,0xa7e436dd51c1b9b13ed84b11f0bc78fe0cba8125,false,false,,,,TOO_SHORT
1681790,0x58f734cd882240a7e4188156d0cd53baca15ad9a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1682337,0xb4d00646a2980f798fcf7897b2cb0a017868df7b,false,false,,,,TOO_SHORT
1682732,0xccb7f9420f15116f3202764d8120af7f3fadd197,false,false,,,,TOO_SHORT
1682827,0xc02989b49941fe6fe8a35ef49927ff3ffe634d93,false,false,,,,TOO_SHORT
1682967,0x13b984e2f9b73e6d1ba393de8744ff5f0095a748,false,false,,,,TOO_SHORT
1682995,0xc109fd2bd53b50f046bb8c27ee921822eaa3435a,false,false,,,,TOO_SHORT
1683033,0xbcabeb7f6c104d25640563d6eb7d6ddd9074955d,false,false,,,,TOO_SHORT
1683141,0x537daac36de24da0009f48dd03b7af1aa8d82623,false,false,,,,TOO_SHORT
1683412,0x456223b5c084a6f49d07e48529f72e65faa7c771,false,false,,,,TOO_SHORT
1683453,0xda5edfbb8da2cdbcd16be99222c50c5f46031df0,false,false,,,,TOO_SHORT
1683469,0x61ec30a39872dde853083cd104875b268496d10c,false,false,,,,TOO_SHORT
1683498,0x47a49cc34a2d9b9ea38ac5e103491f1a098316fd,false,false,,,,TOO_SHORT
1683843,0x74ea60a3f62b8d61357dff432043a314e21938ab,false,false,,,,TOO_SHORT
1684220,0x7a0e128b4a31922d43ac591886d302e0fbf0cc18,false,false,,,,TOO_SHORT
1684347,0xe2c6f4e37af7ebb21dce1a3ae29b50e192664406,false,false,,,,TOO_SHORT
1684356,0x251cf153374c1f4bad1a3c712f47b05f55f4fd45,false,false,,,,TOO_SHORT
1684559,0xa3b2499fd0dd73487134a9fa1567fbe36ecc568c,false,false,,,,TOO_SHORT
1684587,0xa67782129993eb6f0594036b737bd4491da0f23b,false,false,,,,TOO_SHORT
1684778,0xcc2be29a568cb154a0b0fe6c3b1eae915e7f8e8a,false,false,,,,TOO_SHORT
1684882,0x58b95c9a9d5d26825e70a82b6adb139d3fd829eb,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1684882,0xfc855af0cbccf366e0df60f466dfe7be9de47bb0,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1684882,0xa11c6ccc0145610f1f97fb34beb5349f21be87f5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1684882,0x782495b7b3355efb2833d56ecb34dc22ad7dfcc4,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1684934,0x03832c040aa6638983b566191a4ca30a7fc7f9c3,false,false,,,,TOO_SHORT
1684970,0x722f169fae7dab765087a17fc5b407dff73b3770,false,false,,,,TOO_SHORT
1684972,0x9fb317ad20c13a9251a5045b4e1b7e424c19d866,false,false,,,,TOO_SHORT
1685116,0x7fd022cc8b6e019260627fafa1d9c3afece18cef,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :   \n//   The ROULETH \n//\n//  Play the Roulette on ethereum blockchain !\n//  (or become an investor in the Casino and share the profits/losses.) \n//\n//\n//   website : www.WhySoS3rious.com/Rouleth\n//               with a flashy roulette :) !\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n//\n//\n//  Stake : Variable, check on website for the max bet.\n//  At launch the max stake is 0.05 ETH\n//\n//\n//  How to play ?\n//  1) Simplest (via transactions from your wallet, not an exchange) : \n//  Just send the value you want to bet to the contract and add enough gas \n//  (you can enter the max gas amount of ~4,5Million, any excess is refunded anyways)\n//  This will by default place a bet on number 7\n//  Wait 2 minutes (6 blocks) and send (with enough gas) 1 wei (or any amount, it will be refunded)\n//  This will spin the wheel and you will receive * 35 your bet if you win.\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\n//\n//  2) Advanced (via contract functions, e.g. Mist, cf. tutorial on my website for more details) :\n//  Import the contract in Mist wallet using the code of the ABI (link on my website)\n//  Use the functions (betOnNumber, betOnColor ...) to place any type of bet you want\n//  Provide the appropriate input (ex: check box Red or Black)\n//  add the amount you want to bet.\n//  wait 6 blocks, then use the function spinTheWheel, this will solve the bet.\n//  You can only place one bet at a time before you spin the wheel.\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\n//\n//\n//\n//  Use the website to track your bets and the results of the spins\n//\n//\n//   How to invest ?\n//   Import the contract in Mist Wallet using the code of the ABI (link on my website)\n//   Use the Invest function with an amount >10 Ether (can change, check on my website)\n//   You will become an investor and share the profits and losses of the roulette\n//   proportionally to your investment. There is a 2% fee on investment to help with the server/website\n//   cost and also 2% on profit that go to the developper.\n//   The rest of your investment goes directly to the payroll and 98% of profits are shared between \n//   investors relatively to their share of total. Losses are split similarly.\n//   You can withdraw your funds at any time after the initial lock period (set to 1 week)\n//   To withdraw use the function withdraw and specify the amoutn you want to withdraw in Wei.\n//   If your withdraw brings your investment under 10 eth (the min invest, subject to change)\n//   then you will execute a full withdraw and stop being an investor.\n//   Check your current investor balance in Mist by using the information functions on the left side\n//   If you want to update the balances to the last state (otherwise they are automatically\n//   updated after each invest or withdraw), you can use the function manualUpdateBalances in Mist.\n//   \n//   The casino should be profitable in the long run (with 99% confidence). \n//   The maximum bet allowed has been computed through statistical analysis to yield high confidence \n//   in the long run survival of the casino. The maximum bet is always smaller than the current payroll \n//   of the casino * 35 (max pay multiplier) * casinoStatisticalLimit (statistical sample size that allows \n//   to have enough confidence in survival, set at 20 at start, should increase to 200 when we have more \n//   investors to increase the safety).\n//   \n//   At start there is a limit of 50 investors (can be changed via settings up to 150)\n//   If there is no open position and you want to invest, you can try to buyout a current investor.\n//   To buyout, you have to invest more than any investor whose funds are unlocked (after 1 week grace lock period)\n//   If there are no remaining open position and all investors are under grace period, it is not possible to \n//   become a new investor in the casino.\n//\n//   At any time an investor can add funds to his investment with the withdraw function.\n//   Doing so will refresh the lock period and secure your position.\n//\n//\n//   A provably fair roulette :  note on Random Number Generation.\n//   The roulette result is based on the hash of the 6th block after the player commits his bet.\n//   This guarantees a provably fair roulette with equiprobable results and non predictable\n//   unless someone has more computing power than all the Ethereum Network.\n//   Yet Miners could try to exploit their position in 2 ways.\n//   First they could try to mine 7 blocks in a row (to commit their bet based on result for a sure win),\n//   but this is highly improbable and not predictible.\n//   Second they could commit a bet, then wait 6 blocks and hope that they will be the one forming the \n//   block on which their commited bet depends. If this is the case and the hash they find is not a\n//   winning one, they could decide to not share the block with the network but would lose 5 ether.\n//   To counter this potential miner edge (=base win proba + (miner proba to find block)*base win proba )\n//   we keep wager amounts far smaller than 5 Eth so that the miner prefers to get his block reward than cheat.\n//   Note that a miner could place several bets on the same block to increase his potential profit from dropping a block\n//   For this reason we limit the number of bets per block to 2 at start (configurable later if needed).\ncontract Rouleth\n{\n\n    //Variables, Structure\n    address developer;\n    uint8 blockDelay; //nb of blocks to wait before spin\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\n    uint256 maxGamble; //max gamble value manually set by config\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\n    uint casinoStatisticalLimit;\n    //Current gamble value possibly lower than config (<payroll/(20*35))\n    uint256 currentMaxGamble; \n    //Gambles\n    struct Gamble\n    {\n	address player;\n        bool spinned; //Was the rouleth spinned ?\n	bool win;\n	BetTypes betType; //number/color/dozen/oddeven\n	uint8 input; //stores number, color, dozen or oddeven\n	uint256 wager;\n	uint256 blockNumber; //block of bet -1\n        uint8 wheelResult;\n    }\n    Gamble[] private gambles;\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\n    //Tracking progress of players\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\n    enum Status {waitingForBet, waitingForSpin} Status status; //gamble status\n    mapping (address=>Status) playerStatus; //progress of the player's gamble\n\n    //**********************************************\n    //        Management & Config FUNCTIONS        //\n    //**********************************************\n	function  Rouleth() private //creation settings\n    { \n        developer = msg.sender;\n        blockDelay=6; //delay to wait between bet and spin\n	blockExpiration=200; //delay after which gamble expires\n        maxGamble=50 finney; //0.05 ether as max bet to start (payroll of 35 eth)\n        maxBetsPerBlock=2; // limit of 2 bets per block, to prevent multiple bets per miners (to keep max reward<5ETH)\n        casinoStatisticalLimit=20;\n    }\n	\n    modifier onlyDeveloper() {\n	    if (msg.sender!=developer) throw;\n	    _\n    }\n	\n	function changeDeveloper(address new_dev)\n        noEthSent\n	    onlyDeveloper\n	{\n		developer=new_dev;\n	}\n\n\n    //Activate, Deactivate Betting\n    enum States{active, inactive} States private state;\n	function disableBetting()\n    noEthSent\n	onlyDeveloper\n	{\n            state=States.inactive;\n	}\n	function enableBetting()\n	onlyDeveloper\n        noEthSent\n	{\n            state=States.active;\n	}\n    \n	modifier onlyActive\n    {\n        if (state==States.inactive) throw;\n        _\n    }\n\n         //Change some settings within safety bounds\n	function changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\n	noEthSent\n	onlyDeveloper\n	{\n	        // changes the statistical multiplier that guarantees the long run casino survival\n	        if (newCasinoStatLimit<20) throw;\n	        casinoStatisticalLimit=newCasinoStatLimit;\n	        //Max number of bets per block to prevent miner cheating\n	        maxBetsPerBlock=newMaxBetsBlock;\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\n		if (newMaxGamble<=0 || newMaxGamble>=this.balance/(20*35)) throw; \n		else { maxGamble=newMaxGamble; }\n                //MAX NB of INVESTORS (can only increase and max of 149)\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\n                else { setting_maxInvestors=newMaxInvestor;}\n                //MIN INVEST : \n                setting_minInvestment=newMinInvestment;\n                //Invest LOCK PERIOD\n                if (setting_lockPeriod>5184000) throw; //2 months max\n                setting_lockPeriod=newLockPeriod;\n		        //Delay before roll :\n		if (blockDelay<1) throw;\n		        blockDelay=newBlockDelay;\n                updateMaxBet();\n		if (newBlockExpiration<100) throw;\n		blockExpiration=newBlockExpiration;\n	}\n \n\n    //**********************************************\n    //                 BETTING FUNCTIONS                    //\n    //**********************************************\n\n//***//basic betting without Mist or contract call\n    //activates when the player only sends eth to the contract\n    //without specifying any type of bet.\n    function () \n   {\n       //if player is not playing : bet on 7\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnNumber(7);\n       //if player is already playing, spin the wheel\n       else spinTheWheel();\n    } \n\n    function updateMaxBet() private\n    {\n    //check that maxGamble setting is still within safety bounds\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \n		{ \n			currentMaxGamble=maxGamble;\n                }\n	else\n		{ \n			currentMaxGamble = payroll/(20*35);\n		}\n     }\n\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\n    function checkBetValue() private returns(uint256 playerBetValue)\n    {\n        updateMaxBet();\n		if (msg.value > currentMaxGamble) //if above max, send difference back\n		{\n		    msg.sender.send(msg.value-currentMaxGamble);\n		    playerBetValue=currentMaxGamble;\n		}\n                else\n                { playerBetValue=msg.value; }\n       }\n\n\n    //check number of bets in block (to prevent miner cheating and keep max reward per block <5ETH)\n    modifier checkNbBetsCurrentBlock()\n    {\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\n        else nbBetsCurrentBlock=0;\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\n        _\n    }\n    //check that the player is not playing already (unless it has expired)\n    modifier checkWaitingForBet{\n        //if player is already in gamble\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\n        {\n             //case not expired\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\n             //case expired\n             else\n             {\n                  //add bet to PL and reset status\n                  solveBet(msg.sender, 255, false, 0) ;\n\n              }\n        }\n	_\n	}\n\n    //Possible bet types\n    enum BetTypes{ number, color, parity, dozen, column, lowhigh} BetTypes private initbetTypes;\n\n    function updateStatusPlayer() private\n    expireGambles\n    {\n	playerStatus[msg.sender]=Status.waitingForSpin;\n	gambleIndex[msg.sender]=gambles.length-1;\n     }\n\n//***//bet on Number	\n    function betOnNumber(uint8 numberChosen)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        //check that number chosen is valid and records bet\n        if (numberChosen>36) throw;\n		//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnColor\n	//bet type : color\n	//input : 0 for red\n	//input : 1 for black\n    function betOnColor(bool Red, bool Black)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Red) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Black) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnLow_High\n	//bet type : lowhigh\n	//input : 0 for low\n	//input : 1 for low\n    function betOnLowHigh(bool Low, bool High)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Low) \n        { \n             count+=1; \n             input=0;\n         }\n        if (High) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnOdd_Even\n	//bet type : parity\n     //input : 0 for even\n    //input : 1 for odd\n    function betOnOddEven(bool Odd, bool Even)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Even) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Odd) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n\n//***// function betOnDozen\n//     //bet type : dozen\n//     //input : 0 for first dozen\n//     //input : 1 for second dozen\n//     //input : 2 for third dozen\n    function betOnDozen(bool First, bool Second, bool Third)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\n    }\n\n\n// //***// function betOnColumn\n//     //bet type : column\n//     //input : 0 for first column\n//     //input : 1 for second column\n//     //input : 2 for third column\n    function betOnColumn(bool First, bool Second, bool Third)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\n     }\n\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\n    { \n        uint8 count;\n        uint8 input;\n        if (First) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Second) \n        {\n             count+=1; \n             input=1;\n         }\n        if (Third) \n        {\n             count+=1; \n             input=2;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n    //**********************************************\n    // Spin The Wheel & Check Result FUNCTIONS//\n    //**********************************************\n\n	event Win(address player, uint8 result, uint value_won);\n	event Loss(address player, uint8 result, uint value_loss);\n\n    //check that player has to spin the wheel\n    modifier checkWaitingForSpin{\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\n	_\n	}\n    //Prevents accidental sending of Eth when you shouldn't\n    modifier noEthSent()\n    {\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n\n//***//function to spin\n    function spinTheWheel()\n    checkWaitingForSpin\n    noEthSent\n    {\n        //check that the player waited for the delay before spin\n        //and also that the bet is not expired (200 blocks limit)\n	uint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\n	if (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\n    else\n	{\n	    uint8 wheelResult;\n        //Spin the wheel, Reset player status and record result\n		wheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\n		updateFirstActiveGamble(gambleIndex[msg.sender]);\n		gambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\n        //check result against bet and pay if win\n		checkBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\n	}\n    }\n\nfunction updateFirstActiveGamble(uint bet_id) private\n     {\n         if (bet_id==firstActiveGamble)\n         {   \n              uint index=firstActiveGamble;\n              while (true)\n              {\n                 if (index<gambles.length && gambles[index].spinned){\n                     index=index+1;\n                 }\n                 else {break; }\n               }\n              firstActiveGamble=index;\n              return;\n          }\n }\n	\n//checks if there are expired gambles\nmodifier expireGambles{\n    if (  (gambles.length!=0 && gambles.length-1>=firstActiveGamble ) \n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number && !gambles[firstActiveGamble].spinned )  \n    { \n	solveBet(gambles[firstActiveGamble].player, 255, false, 0);\n        updateFirstActiveGamble(firstActiveGamble);\n    }\n        _\n}\n	\n\n     //CHECK BETS FUNCTIONS private\n     function checkBetResult(uint8 result, BetTypes betType) private\n     {\n          //bet on Number\n          if (betType==BetTypes.number) checkBetNumber(result);\n          else if (betType==BetTypes.parity) checkBetParity(result);\n          else if (betType==BetTypes.color) checkBetColor(result);\n	 else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\n	 else if (betType==BetTypes.dozen) checkBetDozen(result);\n	else if (betType==BetTypes.column) checkBetColumn(result);\n          updateMaxBet(); \n     }\n\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\n     {\n        playerStatus[msg.sender]=Status.waitingForBet;\n        gambles[gambleIndex[player]].spinned=true;\n	uint bet_v = gambles[gambleIndex[player]].wager;\n            if (win)\n            {\n		  gambles[gambleIndex[player]].win=true;\n		  uint win_v = multiplier*bet_v;\n                  player.send(win_v);\n                  lossSinceChange+=win_v-bet_v;\n		  Win(player, result, win_v);\n             }\n            else\n            {\n		Loss(player, result, bet_v);\n                profitSinceChange+=bet_v;\n            }\n\n      }\n\n\n     // checkbeton number(input)\n    // bet type : number\n    // input : chosen number\n     function checkBetNumber(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result==gambles[gambleIndex[msg.sender]].input)\n	    {\n                  win=true;  \n             }\n             solveBet(msg.sender, result,win,35);\n     }\n\n\n     // checkbet on oddeven\n    // bet type : parity\n    // input : 0 for even, 1 for odd\n     function checkBetParity(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\n	    {\n                  win=true;                \n             }\n             solveBet(msg.sender,result,win,2);\n        \n     }\n	\n     // checkbet on lowhigh\n     // bet type : lowhigh\n     // input : 0 low, 1 high\n     function checkBetLowhigh(uint8 result) private\n     {\n            bool win;\n            //win\n		 if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\n			 || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\n			 ) )\n	    {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n     }\n\n     // checkbet on color\n     // bet type : color\n     // input : 0 red, 1 black\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\n      function checkBetColor(uint8 result) private\n      {\n             bool red;\n             //check if red\n             for (uint8 k; k<18; k++)\n             { \n                    if (red_list[k]==result) \n                    { \n                          red=true; \n                          break;\n                    }\n             }\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n       }\n\n     // checkbet on dozen\n     // bet type : dozen\n     // input : 0 first, 1 second, 2 third\n     function checkBetDozen(uint8 result) private\n     { \n            bool win;\n            //win on first dozen\n     		 if ( result!=0 &&\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\n     			||\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\n                    ||\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\n     	    {\n                   win=true;                \n             }\n             solveBet(msg.sender,result,win,3);\n     }\n\n     // checkbet on column\n     // bet type : column\n     // input : 0 first, 1 second, 2 third\n      function checkBetColumn(uint8 result) private\n      {\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,3);\n      }\n\n\n//INVESTORS FUNCTIONS\n\n\n//total casino payroll\n    uint256 payroll;\n//Profit Loss since last investor change\n    uint256 profitSinceChange;\n    uint256 lossSinceChange;\n//investor struct array (hard capped to 150)\n    uint8 setting_maxInvestors = 50;\n    struct Investor\n    {\n	    address investor;\n	    uint256 time;\n    }	\n	Investor[150] private investors ;\n    //Balances of the investors\n    mapping (address=>uint256) balance; \n    //Investor lockPeriod\n    //lock time to avoid invest and withdraw for refresh only\n    //also time during which you cannot be outbet by a new investor if it is full\n    uint256 setting_lockPeriod=604800 ; //1 week in sec\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\n    //if full and unlocked position, indicates the cheapest amount to outbid\n    //otherwise cheapestUnlockedPosition=255\n    uint8 cheapestUnlockedPosition; \n    uint256 minCurrentInvest; \n    //record open position index\n    // =255 if full\n    uint8 openPosition;\n	\n    event newInvest(address player, uint invest_v);\n\n\n     function invest()\n     {\n          // check that min 10 ETH is sent (variable setting)\n          if (msg.value<setting_minInvestment) throw;\n          // check if already investor\n          bool alreadyInvestor;\n          // reset the position counters to values out of bounds\n          openPosition=255;\n          cheapestUnlockedPosition=255;\n          minCurrentInvest=10000000000000000000000000;//\n          // update balances before altering the investor shares\n          updateBalances();\n          // loop over investor's array to find if already investor, \n          // or openPosition and cheapest UnlockedPosition\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\n          { \n               //captures an index of an open position\n               if (investors[k].investor==0) openPosition=k; \n               //captures if already an investor \n               else if (investors[k].investor==msg.sender)\n               {\n                    investors[k].time=now; //refresh time invest\n                    alreadyInvestor=true;\n                }\n               //captures the index of the investor with the min investment (after lock period)\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\n               {\n                    cheapestUnlockedPosition=k;\n                    minCurrentInvest=balance[investors[k].investor];\n                }\n           }\n           //case New investor\n           if (alreadyInvestor==false)\n           {\n                    //case : investor array not full, record new investor\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\n                    //case : investor array full\n                    else\n                    {\n                         //subcase : investor has not outbid or all positions under lock period\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\n                         //subcase : investor outbid, record investor change and refund previous\n                         else\n                         {\n                              address previous = investors[cheapestUnlockedPosition].investor;\n                              if (previous.send(balance[previous])==false) throw;\n                              balance[previous]=0;\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\n                          }\n                     }\n            }\n          //add investment to balance of investor and to payroll\n\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\n          uint256 netInvest=msg.value - maintenanceFees;\n          newInvest(msg.sender, netInvest);\n          balance[msg.sender]+=netInvest; //add invest to balance\n          payroll+=netInvest;\n          //send maintenance fees to developer \n          if (developer.send(maintenanceFees)==false) throw;\n          updateMaxBet();\n      }\n\n//***// Withdraw function (only after lockPeriod)\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\n    // if your withdraw brings your balance under the min investment required,\n    // your balance is fully withdrawn\n	event withdraw(address player, uint withdraw_v);\n	\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\n    noEthSent\n    {\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\n        updateBalances();\n	//check that amount requested is authorized  \n	if (amountToWithdrawInWei>balance[msg.sender]) throw;\n        //retrieve investor ID\n        uint8 investorID=255;\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\n        {\n               if (investors[k].investor==msg.sender)\n               {\n                    investorID=k;\n                    break;\n               }\n        }\n           if (investorID==255) throw; //stop if not an investor\n           //check if investment lock period is over\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\n           //if balance left after withdraw is still above min investment accept partial withdraw\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\n           {\n               balance[msg.sender]-=amountToWithdrawInWei;\n               payroll-=amountToWithdrawInWei;\n               //send amount to investor (with security if transaction fails)\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\n	       withdraw(msg.sender, amountToWithdrawInWei);\n           }\n           else\n           //if amountToWithdraw=0 : user wants full withdraw\n           //if balance after withdraw is < min invest, withdraw all and delete investor\n           {\n               //send amount to investor (with security if transaction fails)\n               uint256 fullAmount=balance[msg.sender];\n               payroll-=fullAmount;\n               balance[msg.sender]=0;\n               if (msg.sender.send(fullAmount)==false) throw;\n               //delete investor\n               delete investors[investorID];\n   	       withdraw(msg.sender, fullAmount);\n            }\n          updateMaxBet();\n     }\n\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\n\n	function manualUpdateBalances()\n	expireGambles\n	noEthSent\n	{\n	    updateBalances();\n	}\n    function updateBalances() private\n    {\n         //split Profits\n         uint256 profitToSplit;\n         uint256 lossToSplit;\n         if (profitSinceChange==0 && lossSinceChange==0)\n         { return; }\n         \n         else\n         {\n             // Case : Global profit (more win than losses)\n             // 2% fees for developer on global profit (if profit>loss)\n             if (profitSinceChange>lossSinceChange)\n             {\n                profitToSplit=profitSinceChange-lossSinceChange;\n                uint256 developerFees=profitToSplit*2/100;\n                profitToSplit-=developerFees;\n                if (developer.send(developerFees)==false) throw;\n             }\n             else\n             {\n                lossToSplit=lossSinceChange-profitSinceChange;\n             }\n         \n         //share the loss and profits between all invest \n         //(proportionnaly. to each investor balance)\n         uint totalShared;\n             for (uint8 k=0; k<setting_maxInvestors; k++)\n             {\n                 address inv=investors[k].investor;\n                 if (inv==0) continue;\n                 else\n                 {\n                       if (profitToSplit!=0) \n                       {\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\n                           balance[inv]+=profitShare;\n                           totalShared+=profitShare;\n                       }\n                       if (lossToSplit!=0) \n                       {\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\n                           balance[inv]-=lossShare;\n                           totalShared+=lossShare;\n                           \n                       }\n                 }\n             }\n          // update payroll\n          if (profitToSplit !=0) \n          {\n              payroll+=profitToSplit;\n              balance[developer]+=profitToSplit-totalShared;\n          }\n          if (lossToSplit !=0) \n          {\n              payroll-=lossToSplit;\n              balance[developer]-=lossToSplit-totalShared;\n          }\n          profitSinceChange=0; //reset Profit;\n          lossSinceChange=0; //reset Loss ;\n          \n          }\n     }\n     \n     \n     //INFORMATION FUNCTIONS\n     \n     function checkProfitLossSinceInvestorChange() constant returns(uint profit, uint loss)\n     {\n        profit=profitSinceChange;\n        loss=lossSinceChange;\n        return;\n     }\n\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\n    {\n          balanceInWei=balance[investor];\n          return;\n     }\n\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\n    {\n          investor=investors[index].investor;\n          endLockPeriod=investors[index].time+setting_lockPeriod;\n          return;\n    }\n	\n\n	function investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\n	{\n		if (openPosition!=255) open_position=true;\n		if (cheapestUnlockedPosition!=255) \n		{\n			unlocked_position=true;\n			buyout_amount=minCurrentInvest;\n		}\n		investLockPeriod=setting_lockPeriod;\n		return;\n	}\n	\n	function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\n	{\n	    maxBet=currentMaxGamble;\n	    blockDelayBeforeSpin=blockDelay;\n	    return ;\n	}\n	\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\n    {\n          player_status=playerStatus[player];\n          bettype=gambles[gambleIndex[player]].betType;\n          input=gambles[gambleIndex[player]].input;\n          value=gambles[gambleIndex[player]].wager;\n          result=gambles[gambleIndex[player]].wheelResult;\n          wheelspinned=gambles[gambleIndex[player]].spinned;\n          win=gambles[gambleIndex[player]].win;\n		blockNb=gambles[gambleIndex[player]].blockNumber;\n		  return;\n     }\n\n} //end of contract",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1685407,0xf69d873d7f5e8988d4abb76e3f5d3d0e2b0f807a,false,false,,,,TOO_SHORT
1685450,0x5fab5855c46a3039245acbcbb01fa34ebd98a013,false,false,,,,TOO_SHORT
1685867,0xa7fc74acfdf533192e55dd06e18626681fd33a6e,false,false,,,,TOO_SHORT
1685930,0xc18f58b495d8631c42bcac772a5b54bfe20fee0c,false,false,,,,TOO_SHORT
1685976,0xe609851bb24437127812aab67a208dc5def6b81d,false,false,,,,TOO_SHORT
1686127,0xecae6888e3ea6a2a8dbf95500a1f74dd27c3b54e,false,false,"contract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		http://d.ethereumlottery.net\n		ver: 2.1.1\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	uint private constant fee = 5;\n	uint private constant investorFee = 50;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 26;\n	\n    bool public ContractEnabled = true;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private ContractDisabledBlock;\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n		uint id;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] private investors;\n	\n	string constant public Information = ""http://d.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function dEthereumlotteryNet() {\n		owner = msg.sender;\n		investors.length = 1;\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n	    if (jackpot_ == 0) {\n	        Rate = 0;\n	        Bet = 0;\n	        return;\n	    }\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		while (Value < Bet) {\n		    Rate++;\n		    Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n		    Rate = BestRollRate;\n		    Bet = getRealBet(Rate);\n        }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		uint InvestorID = getInvestorByAddress(Address);\n		if (InvestorID == 0 || ! investors[InvestorID].valid) {\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n		Investment = investors[InvestorID].value;\n		Balance = investors[InvestorID].balance;\n		Live = investors[InvestorID].live;\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() OnlyEnabled external {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) {\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].timestamp = now + investMinDuration;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		jackpot_ += value_;\n		setJackpot();\n	}\n	function GetMyInvestmentBalance() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].balance == 0) { throw; }\n		if ( ! msg.sender.send( investors[InvestorID].balance )) { throw; }\n		investors[InvestorID].balance = 0;\n	}\n	function CancelMyInvestment() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].timestamp > now && ContractEnabled) { throw; }\n		uint balance_;\n		if (investors[InvestorID].live) {\n			jackpot_ -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		if ( ! msg.sender.send( balance_ )) { throw; }\n		delete investors[InvestorID];\n	}\n	/* For Players */\n	function DoRoll() external noEther {\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, false, true, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if ( ! ContractEnabled || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, true, false, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if ( ! found) { throw; }\n		if (value_ > 0) { if ( ! msg.sender.send(value_)) { throw; } }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		uint _rate;\n		uint _realBet;\n		(_rate, _realBet) = ChanceOfWinning(msg.value);\n		if (_realBet > msg.value) { throw; }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! ContractEnabled) {\n		    if (ContractDisabledBlock < block.number) {\n				if (playersPot == 0) { throw; }\n				if ( ! msg.sender.send( playersPot )) { throw; }\n				playersPot = 0;\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n			ContractDisabled(ContractDisabledBlock);\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner noEther {\n		if (feeValue == 0) { throw; }\n		if ( ! owner.send(feeValue)) { throw; }\n		feeValue = 0;\n	}\n	\n	/*\n		Private functions\n	*/\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=1 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n			DoRollEvent(msg.sender, win, players[msg.sender][id].id, false, false, false, true, bigNumber, _rate, bigNumber % _rate);\n		} else {\n			DoRollEvent(msg.sender, players[msg.sender][id].value, players[msg.sender][id].id, false, false, true, false, bigNumber, _rate, bigNumber % _rate);\n		}\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=1 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		RollCount++;\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		players[msg.sender][rollID].id = RollCount;\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, players[msg.sender][rollID].value, players[msg.sender][rollID].id);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1 ether / value * 100 / investorFee * extraRate / 100 / 1 ether;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1 ether / ( rate * 1 ether * investorFee / extraRate);\n	}\n	function getInvestorByAddress(address Address) internal returns (uint id) {\n		for ( id=1 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return;\n			}\n		}\n		return 0;\n	}\n	\n	/*\n		Events\n	*/	\n	event DoRollEvent(address Player, uint Value, uint RollID, bool Refund, bool LostBet, bool LossRoll, bool WinRoll, uint BigNumber, uint Rate, uint RollResult);\n	event PrepareRollEvent(address Player, uint Block, uint Bet, uint RollID);\n	event ContractDisabled(uint LossAllBetBlockNumber);\n	\n	/*\n		Modifiers\n	*/\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,実用的な構造を持つ標準的なスマートコントラクトで、芸術的要素は特に見られません。,
1686208,0x42d63ee9f5c6f955c4d1bbaf2350966c84ce2212,false,false,,,,TOO_SHORT
1686230,0xdd84fdc3d41d187d857b6bf922bffaf0fc19a178,false,false,,,,TOO_SHORT
1686274,0x542d9b4ddcf3ff953bb86e76b58e3814f1185d66,false,false,,,,TOO_SHORT
1686287,0x6180e941eb1a261f21add0e8f5490734f4ed21b0,false,false,,,,TOO_SHORT
1686294,0x7896901f61e038515a8d99c216e7dedc42047edf,false,false,,,,TOO_SHORT
1686458,0x9a79e1bb60422656eea1056751020a3d2f956150,false,false,,,,TOO_SHORT
1686501,0x98bad473491b3330859e4f449c2c50efdc5d3169,false,false,,,,TOO_SHORT
1686566,0xa9f07ce42e6bcbef6dac561c7e8307b2342bab8e,false,false,,,,TOO_SHORT
1686630,0xb82d010dbc871101067636521da3a5797c897bd1,false,false,,,,TOO_SHORT
1686663,0x626b831fa0b018ef4028ed06fef2e036ab428c6d,false,false,,,,TOO_SHORT
1686678,0xd268ee7734c263530a146e16ce42860bf82dc2e2,false,false,,,,TOO_SHORT
1686784,0x25b9e155af80795abd21e1ca245d2e34088993d1,false,false,,,,TOO_SHORT
1687323,0xd397852ab4c94461612b1b7764111849b9ebb316,false,false,,,,TOO_SHORT
1687350,0xfe5541a9bd59b15c70cac9d83e2610f527bc9346,false,false,,,,TOO_SHORT
1687367,0x6dfaa563d04a77aff4c4ad2b17cf4c64d2983dc8,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :   \n//   The ROULETH \n//\n//  Play the Roulette on ethereum blockchain !\n//  (or become an investor in the Casino and share the profits/losses.) \n//\n//\n//   website : www.WhySoS3rious.com/Rouleth\n//               with a flashy roulette :) !\n//\n//   check latest contract version on website\n//   V 1.0.2\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n//\n//\n//  Stake : Variable, check on website for the max bet.\n//  At launch the max stake is 0.05 ETH\n//\n//\n//  How to play ?\n//  1) Simplest (via transactions from your wallet, not an exchange) : \n//  Just send the value you want to bet to the contract and add enough gas \n//  (you can enter the max gas amount of ~4,5Million, any excess is refunded anyways)\n//  This will by default place a bet on number 7\n//  Wait 2 minutes (6 blocks) and send (with enough gas) 1 wei (or any amount, it will be refunded)\n//  This will spin the wheel and you will receive * 35 your bet if you win.\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\n//\n//  2) Advanced (via contract functions, e.g. Mist, cf. tutorial on my website for more details) :\n//  Import the contract in Mist wallet using the code of the ABI (link on my website)\n//  Use the functions (betOnNumber, betOnColor ...) to place any type of bet you want\n//  Provide the appropriate input (ex: check box Red or Black)\n//  add the amount you want to bet.\n//  wait 6 blocks, then use the function spinTheWheel, this will solve the bet.\n//  You can only place one bet at a time before you spin the wheel.\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\n//\n//\n//\n//  Use the website to track your bets and the results of the spins\n//\n//\n//   How to invest ?\n//   Import the contract in Mist Wallet using the code of the ABI (link on my website)\n//   Use the Invest function with an amount >10 Ether (can change, check on my website)\n//   You will become an investor and share the profits and losses of the roulette\n//   proportionally to your investment. There is a 2% fee on investment to help with the server/website\n//   cost and also 2% on profit that go to the developper.\n//   The rest of your investment goes directly to the payroll and 98% of profits are shared between \n//   investors relatively to their share of total. Losses are split similarly.\n//   You can withdraw your funds at any time after the initial lock period (set to 1 week)\n//   To withdraw use the function withdraw and specify the amoutn you want to withdraw in Wei.\n//   If your withdraw brings your investment under 10 eth (the min invest, subject to change)\n//   then you will execute a full withdraw and stop being an investor.\n//   Check your current investor balance in Mist by using the information functions on the left side\n//   If you want to update the balances to the last state (otherwise they are automatically\n//   updated after each invest or withdraw), you can use the function manualUpdateBalances in Mist.\n//   \n//   The casino should be profitable in the long run (with 99% confidence). \n//   The maximum bet allowed has been computed through statistical analysis to yield high confidence \n//   in the long run survival of the casino. The maximum bet is always smaller than the current payroll \n//   of the casino * 35 (max pay multiplier) * casinoStatisticalLimit (statistical sample size that allows \n//   to have enough confidence in survival, set at 20 at start, should increase to 200 when we have more \n//   investors to increase the safety).\n//   \n//   At start there is a limit of 50 investors (can be changed via settings up to 150)\n//   If there is no open position and you want to invest, you can try to buyout a current investor.\n//   To buyout, you have to invest more than any investor whose funds are unlocked (after 1 week grace lock period)\n//   If there are no remaining open position and all investors are under grace period, it is not possible to \n//   become a new investor in the casino.\n//\n//   At any time an investor can add funds to his investment with the withdraw function.\n//   Doing so will refresh the lock period and secure your position.\n//\n//\n//   A provably fair roulette :  note on Random Number Generation.\n//   The roulette result is based on the hash of the 6th block after the player commits his bet.\n//   This guarantees a provably fair roulette with equiprobable results and non predictable\n//   unless someone has more computing power than all the Ethereum Network.\n//   Yet Miners could try to exploit their position in 2 ways.\n//   First they could try to mine 7 blocks in a row (to commit their bet based on result for a sure win),\n//   but this is highly improbable and not predictible.\n//   Second they could commit a bet, then wait 6 blocks and hope that they will be the one forming the \n//   block on which their commited bet depends. If this is the case and the hash they find is not a\n//   winning one, they could decide to not share the block with the network but would lose 5 ether.\n//   To counter this potential miner edge (=base win proba + (miner proba to find block)*base win proba )\n//   we keep wager amounts far smaller than 5 Eth so that the miner prefers to get his block reward than cheat.\n//   Note that a miner could place several bets on the same block to increase his potential profit from dropping a block\n//   For this reason we limit the number of bets per block to 2 at start (configurable later if needed).\ncontract Rouleth\n{\n\n    //Variables, Structure\n    address developer;\n    uint8 blockDelay; //nb of blocks to wait before spin\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\n    uint256 maxGamble; //max gamble value manually set by config\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\n    uint casinoStatisticalLimit;\n    //Current gamble value possibly lower than config (<payroll/(20*35))\n    uint256 currentMaxGamble; \n    //Gambles\n    struct Gamble\n    {\n	address player;\n        bool spinned; //Was the rouleth spinned ?\n	bool win;\n	BetTypes betType; //number/color/dozen/oddeven\n	uint8 input; //stores number, color, dozen or oddeven\n	uint256 wager;\n	uint256 blockNumber; //block of bet -1\n        uint8 wheelResult;\n    }\n    Gamble[] private gambles;\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\n    //Tracking progress of players\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\n    enum Status {waitingForBet, waitingForSpin} Status status; //gamble status\n    mapping (address=>Status) playerStatus; //progress of the player's gamble\n\n    //**********************************************\n    //        Management & Config FUNCTIONS        //\n    //**********************************************\n	function  Rouleth() private //creation settings\n    { \n        developer = msg.sender;\n        blockDelay=6; //delay to wait between bet and spin\n	blockExpiration=200; //delay after which gamble expires\n        maxGamble=50 finney; //0.05 ether as max bet to start (payroll of 35 eth)\n        maxBetsPerBlock=2; // limit of 2 bets per block, to prevent multiple bets per miners (to keep max reward<5ETH)\n        casinoStatisticalLimit=20;\n    }\n	\n    modifier onlyDeveloper() {\n	    if (msg.sender!=developer) throw;\n	    _\n    }\n	\n	function changeDeveloper(address new_dev)\n        noEthSent\n	    onlyDeveloper\n	{\n		developer=new_dev;\n	}\n\n\n    //Activate, Deactivate Betting\n    enum States{active, inactive} States private state;\n	function disableBetting()\n    noEthSent\n	onlyDeveloper\n	{\n            state=States.inactive;\n	}\n	function enableBetting()\n	onlyDeveloper\n        noEthSent\n	{\n            state=States.active;\n	}\n    \n	modifier onlyActive\n    {\n        if (state==States.inactive) throw;\n        _\n    }\n\n         //Change some settings within safety bounds\n	function changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\n	noEthSent\n	onlyDeveloper\n	{\n	        // changes the statistical multiplier that guarantees the long run casino survival\n	        if (newCasinoStatLimit<20) throw;\n	        casinoStatisticalLimit=newCasinoStatLimit;\n	        //Max number of bets per block to prevent miner cheating\n	        maxBetsPerBlock=newMaxBetsBlock;\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\n		if (newMaxGamble<=0 || newMaxGamble>=this.balance/(20*35)) throw; \n		else { maxGamble=newMaxGamble; }\n                //MAX NB of INVESTORS (can only increase and max of 149)\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\n                else { setting_maxInvestors=newMaxInvestor;}\n                //MIN INVEST : \n                setting_minInvestment=newMinInvestment;\n                //Invest LOCK PERIOD\n                if (setting_lockPeriod>5184000) throw; //2 months max\n                setting_lockPeriod=newLockPeriod;\n		        //Delay before roll :\n		if (blockDelay<1) throw;\n		        blockDelay=newBlockDelay;\n                updateMaxBet();\n		if (newBlockExpiration<100) throw;\n		blockExpiration=newBlockExpiration;\n	}\n \n\n    //**********************************************\n    //                 BETTING FUNCTIONS                    //\n    //**********************************************\n\n//***//basic betting without Mist or contract call\n    //activates when the player only sends eth to the contract\n    //without specifying any type of bet.\n    function () \n   {\n       //if player is not playing : bet on 7\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnNumber(7);\n       //if player is already playing, spin the wheel\n       else spinTheWheel();\n    } \n\n    function updateMaxBet() private\n    {\n    //check that maxGamble setting is still within safety bounds\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \n		{ \n			currentMaxGamble=maxGamble;\n                }\n	else\n		{ \n			currentMaxGamble = payroll/(20*35);\n		}\n     }\n\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\n    function checkBetValue() private returns(uint256 playerBetValue)\n    {\n        updateMaxBet();\n		if (msg.value > currentMaxGamble) //if above max, send difference back\n		{\n		    msg.sender.send(msg.value-currentMaxGamble);\n		    playerBetValue=currentMaxGamble;\n		}\n                else\n                { playerBetValue=msg.value; }\n       }\n\n\n    //check number of bets in block (to prevent miner cheating and keep max reward per block <5ETH)\n    modifier checkNbBetsCurrentBlock()\n    {\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\n        else nbBetsCurrentBlock=0;\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\n        _\n    }\n    //check that the player is not playing already (unless it has expired)\n    modifier checkWaitingForBet{\n        //if player is already in gamble\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\n        {\n             //case not expired\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\n             //case expired\n             else\n             {\n                  //add bet to PL and reset status\n                  solveBet(msg.sender, 255, false, 0) ;\n\n              }\n        }\n	_\n	}\n\n    //Possible bet types\n    enum BetTypes{ number, color, parity, dozen, column, lowhigh} BetTypes private initbetTypes;\n\n    function updateStatusPlayer() private\n    expireGambles\n    {\n	playerStatus[msg.sender]=Status.waitingForSpin;\n	gambleIndex[msg.sender]=gambles.length-1;\n     }\n\n//***//bet on Number	\n    function betOnNumber(uint8 numberChosen)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        //check that number chosen is valid and records bet\n        if (numberChosen>36) throw;\n		//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnColor\n	//bet type : color\n	//input : 0 for red\n	//input : 1 for black\n    function betOnColor(bool Red, bool Black)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Red) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Black) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnLow_High\n	//bet type : lowhigh\n	//input : 0 for low\n	//input : 1 for low\n    function betOnLowHigh(bool Low, bool High)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Low) \n        { \n             count+=1; \n             input=0;\n         }\n        if (High) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnOdd_Even\n	//bet type : parity\n     //input : 0 for even\n    //input : 1 for odd\n    function betOnOddEven(bool Odd, bool Even)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Even) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Odd) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n\n//***// function betOnDozen\n//     //bet type : dozen\n//     //input : 0 for first dozen\n//     //input : 1 for second dozen\n//     //input : 2 for third dozen\n    function betOnDozen(bool First, bool Second, bool Third)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\n    }\n\n\n// //***// function betOnColumn\n//     //bet type : column\n//     //input : 0 for first column\n//     //input : 1 for second column\n//     //input : 2 for third column\n    function betOnColumn(bool First, bool Second, bool Third)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\n     }\n\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\n    { \n        uint8 count;\n        uint8 input;\n        if (First) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Second) \n        {\n             count+=1; \n             input=1;\n         }\n        if (Third) \n        {\n             count+=1; \n             input=2;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n    //**********************************************\n    // Spin The Wheel & Check Result FUNCTIONS//\n    //**********************************************\n\n	event Win(address player, uint8 result, uint value_won);\n	event Loss(address player, uint8 result, uint value_loss);\n\n    //check that player has to spin the wheel\n    modifier checkWaitingForSpin{\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\n	_\n	}\n    //Prevents accidental sending of Eth when you shouldn't\n    modifier noEthSent()\n    {\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n\n//***//function to spin\n    function spinTheWheel()\n    checkWaitingForSpin\n    noEthSent\n    {\n        //check that the player waited for the delay before spin\n        //and also that the bet is not expired (200 blocks limit)\n	uint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\n	if (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\n    else\n	{\n	    uint8 wheelResult;\n        //Spin the wheel, Reset player status and record result\n		wheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\n		gambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\n        //check result against bet and pay if win\n		checkBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\n		updateFirstActiveGamble(gambleIndex[msg.sender]);\n	}\n    }\n\nfunction updateFirstActiveGamble(uint bet_id) private\n     {\n         if (bet_id==firstActiveGamble)\n         {   \n              uint index;\n              if (firstActiveGamble!=0) index=firstActiveGamble-1;\n              while (true)\n              {\n                 if (index<gambles.length && gambles[index].spinned)\n                 {\n                     index=index+1;\n                 }\n                 else {break; }\n               }\n              firstActiveGamble=index;\n              return;\n          }\n }\n	\n//checks if there are expired gambles\nmodifier expireGambles{\n    if (  (gambles.length!=0 && gambles.length-1>=firstActiveGamble ) \n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number && !gambles[firstActiveGamble].spinned )  \n    { \n	solveBet(gambles[firstActiveGamble].player, 255, false, 0);\n        updateFirstActiveGamble(firstActiveGamble);\n    }\n        _\n}\n	\n\n     //CHECK BETS FUNCTIONS private\n     function checkBetResult(uint8 result, BetTypes betType) private\n     {\n          //bet on Number\n          if (betType==BetTypes.number) checkBetNumber(result);\n          else if (betType==BetTypes.parity) checkBetParity(result);\n          else if (betType==BetTypes.color) checkBetColor(result);\n	 else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\n	 else if (betType==BetTypes.dozen) checkBetDozen(result);\n	else if (betType==BetTypes.column) checkBetColumn(result);\n          updateMaxBet(); \n     }\n\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\n     {\n        playerStatus[msg.sender]=Status.waitingForBet;\n        gambles[gambleIndex[player]].spinned=true;\n	uint bet_v = gambles[gambleIndex[player]].wager;\n            if (win)\n            {\n		  gambles[gambleIndex[player]].win=true;\n		  uint win_v = multiplier*bet_v;\n                  player.send(win_v);\n                  lossSinceChange+=win_v-bet_v;\n		  Win(player, result, win_v);\n             }\n            else\n            {\n		Loss(player, result, bet_v);\n                profitSinceChange+=bet_v;\n            }\n\n      }\n\n\n     // checkbeton number(input)\n    // bet type : number\n    // input : chosen number\n     function checkBetNumber(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result==gambles[gambleIndex[msg.sender]].input)\n	    {\n                  win=true;  \n             }\n             solveBet(msg.sender, result,win,35);\n     }\n\n\n     // checkbet on oddeven\n    // bet type : parity\n    // input : 0 for even, 1 for odd\n     function checkBetParity(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\n	    {\n                  win=true;                \n             }\n             solveBet(msg.sender,result,win,2);\n        \n     }\n	\n     // checkbet on lowhigh\n     // bet type : lowhigh\n     // input : 0 low, 1 high\n     function checkBetLowhigh(uint8 result) private\n     {\n            bool win;\n            //win\n		 if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\n			 || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\n			 ) )\n	    {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n     }\n\n     // checkbet on color\n     // bet type : color\n     // input : 0 red, 1 black\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\n      function checkBetColor(uint8 result) private\n      {\n             bool red;\n             //check if red\n             for (uint8 k; k<18; k++)\n             { \n                    if (red_list[k]==result) \n                    { \n                          red=true; \n                          break;\n                    }\n             }\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n       }\n\n     // checkbet on dozen\n     // bet type : dozen\n     // input : 0 first, 1 second, 2 third\n     function checkBetDozen(uint8 result) private\n     { \n            bool win;\n            //win on first dozen\n     		 if ( result!=0 &&\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\n     			||\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\n                    ||\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\n     	    {\n                   win=true;                \n             }\n             solveBet(msg.sender,result,win,3);\n     }\n\n     // checkbet on column\n     // bet type : column\n     // input : 0 first, 1 second, 2 third\n      function checkBetColumn(uint8 result) private\n      {\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,3);\n      }\n\n\n//INVESTORS FUNCTIONS\n\n\n//total casino payroll\n    uint256 payroll;\n//Profit Loss since last investor change\n    uint256 profitSinceChange;\n    uint256 lossSinceChange;\n//investor struct array (hard capped to 150)\n    uint8 setting_maxInvestors = 50;\n    struct Investor\n    {\n	    address investor;\n	    uint256 time;\n    }	\n	Investor[150] private investors ;\n    //Balances of the investors\n    mapping (address=>uint256) balance; \n    //Investor lockPeriod\n    //lock time to avoid invest and withdraw for refresh only\n    //also time during which you cannot be outbet by a new investor if it is full\n    uint256 setting_lockPeriod=604800 ; //1 week in sec\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\n    //if full and unlocked position, indicates the cheapest amount to outbid\n    //otherwise cheapestUnlockedPosition=255\n    uint8 cheapestUnlockedPosition; \n    uint256 minCurrentInvest; \n    //record open position index\n    // =255 if full\n    uint8 openPosition;\n	\n    event newInvest(address player, uint invest_v);\n\n\n     function invest()\n     {\n          // check that min 10 ETH is sent (variable setting)\n          if (msg.value<setting_minInvestment) throw;\n          // check if already investor\n          bool alreadyInvestor;\n          // reset the position counters to values out of bounds\n          openPosition=255;\n          cheapestUnlockedPosition=255;\n          minCurrentInvest=10000000000000000000000000;//\n          // update balances before altering the investor shares\n          updateBalances();\n          // loop over investor's array to find if already investor, \n          // or openPosition and cheapest UnlockedPosition\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\n          { \n               //captures an index of an open position\n               if (investors[k].investor==0) openPosition=k; \n               //captures if already an investor \n               else if (investors[k].investor==msg.sender)\n               {\n                    investors[k].time=now; //refresh time invest\n                    alreadyInvestor=true;\n                }\n               //captures the index of the investor with the min investment (after lock period)\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\n               {\n                    cheapestUnlockedPosition=k;\n                    minCurrentInvest=balance[investors[k].investor];\n                }\n           }\n           //case New investor\n           if (alreadyInvestor==false)\n           {\n                    //case : investor array not full, record new investor\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\n                    //case : investor array full\n                    else\n                    {\n                         //subcase : investor has not outbid or all positions under lock period\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\n                         //subcase : investor outbid, record investor change and refund previous\n                         else\n                         {\n                              address previous = investors[cheapestUnlockedPosition].investor;\n                              if (previous.send(balance[previous])==false) throw;\n                              balance[previous]=0;\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\n                          }\n                     }\n            }\n          //add investment to balance of investor and to payroll\n\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\n          uint256 netInvest=msg.value - maintenanceFees;\n          newInvest(msg.sender, netInvest);\n          balance[msg.sender]+=netInvest; //add invest to balance\n          payroll+=netInvest;\n          //send maintenance fees to developer \n          if (developer.send(maintenanceFees)==false) throw;\n          updateMaxBet();\n      }\n\n//***// Withdraw function (only after lockPeriod)\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\n    // if your withdraw brings your balance under the min investment required,\n    // your balance is fully withdrawn\n	event withdraw(address player, uint withdraw_v);\n	\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\n    noEthSent\n    {\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\n        updateBalances();\n	//check that amount requested is authorized  \n	if (amountToWithdrawInWei>balance[msg.sender]) throw;\n        //retrieve investor ID\n        uint8 investorID=255;\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\n        {\n               if (investors[k].investor==msg.sender)\n               {\n                    investorID=k;\n                    break;\n               }\n        }\n           if (investorID==255) throw; //stop if not an investor\n           //check if investment lock period is over\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\n           //if balance left after withdraw is still above min investment accept partial withdraw\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\n           {\n               balance[msg.sender]-=amountToWithdrawInWei;\n               payroll-=amountToWithdrawInWei;\n               //send amount to investor (with security if transaction fails)\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\n	       withdraw(msg.sender, amountToWithdrawInWei);\n           }\n           else\n           //if amountToWithdraw=0 : user wants full withdraw\n           //if balance after withdraw is < min invest, withdraw all and delete investor\n           {\n               //send amount to investor (with security if transaction fails)\n               uint256 fullAmount=balance[msg.sender];\n               payroll-=fullAmount;\n               balance[msg.sender]=0;\n               if (msg.sender.send(fullAmount)==false) throw;\n               //delete investor\n               delete investors[investorID];\n   	       withdraw(msg.sender, fullAmount);\n            }\n          updateMaxBet();\n     }\n\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\n\n	function manualUpdateBalances()\n	expireGambles\n	noEthSent\n	{\n	    updateBalances();\n	}\n    function updateBalances() private\n    {\n         //split Profits\n         uint256 profitToSplit;\n         uint256 lossToSplit;\n         if (profitSinceChange==0 && lossSinceChange==0)\n         { return; }\n         \n         else\n         {\n             // Case : Global profit (more win than losses)\n             // 2% fees for developer on global profit (if profit>loss)\n             if (profitSinceChange>lossSinceChange)\n             {\n                profitToSplit=profitSinceChange-lossSinceChange;\n                uint256 developerFees=profitToSplit*2/100;\n                profitToSplit-=developerFees;\n                if (developer.send(developerFees)==false) throw;\n             }\n             else\n             {\n                lossToSplit=lossSinceChange-profitSinceChange;\n             }\n         \n         //share the loss and profits between all invest \n         //(proportionnaly. to each investor balance)\n         uint totalShared;\n             for (uint8 k=0; k<setting_maxInvestors; k++)\n             {\n                 address inv=investors[k].investor;\n                 if (inv==0) continue;\n                 else\n                 {\n                       if (profitToSplit!=0) \n                       {\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\n                           balance[inv]+=profitShare;\n                           totalShared+=profitShare;\n                       }\n                       if (lossToSplit!=0) \n                       {\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\n                           balance[inv]-=lossShare;\n                           totalShared+=lossShare;\n                           \n                       }\n                 }\n             }\n          // update payroll\n          if (profitToSplit !=0) \n          {\n              payroll+=profitToSplit;\n              balance[developer]+=profitToSplit-totalShared;\n          }\n          if (lossToSplit !=0) \n          {\n              payroll-=lossToSplit;\n              balance[developer]-=lossToSplit-totalShared;\n          }\n          profitSinceChange=0; //reset Profit;\n          lossSinceChange=0; //reset Loss ;\n          \n          }\n     }\n     \n     \n     //INFORMATION FUNCTIONS\n     \n     function checkProfitLossSinceInvestorChange() constant returns(uint profit, uint loss)\n     {\n        profit=profitSinceChange;\n        loss=lossSinceChange;\n        return;\n     }\n\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\n    {\n          balanceInWei=balance[investor];\n          return;\n     }\n\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\n    {\n          investor=investors[index].investor;\n          endLockPeriod=investors[index].time+setting_lockPeriod;\n          return;\n    }\n	\n\n	function investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\n	{\n		if (openPosition!=255) open_position=true;\n		if (cheapestUnlockedPosition!=255) \n		{\n			unlocked_position=true;\n			buyout_amount=minCurrentInvest;\n		}\n		investLockPeriod=setting_lockPeriod;\n		return;\n	}\n	\n	function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\n	{\n	    maxBet=currentMaxGamble;\n	    blockDelayBeforeSpin=blockDelay;\n	    return ;\n	}\n\n	function getFirstActiveDuel() constant returns(uint _firstActiveGamble)\n	{\n            _firstActiveGamble=firstActiveGamble;\n	    return ;\n	}\n\n	\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\n    {\n          player_status=playerStatus[player];\n          bettype=gambles[gambleIndex[player]].betType;\n          input=gambles[gambleIndex[player]].input;\n          value=gambles[gambleIndex[player]].wager;\n          result=gambles[gambleIndex[player]].wheelResult;\n          wheelspinned=gambles[gambleIndex[player]].spinned;\n          win=gambles[gambleIndex[player]].win;\n	blockNb=gambles[gambleIndex[player]].blockNumber;\n	  return;\n     }\n\n} //end of contract",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。コメントが多く、機能説明が詳細。,
1687434,0xca06ac9f33f48b03b6816fea1106d4ae57aedf58,false,false,,,,TOO_SHORT
1687462,0xa9b17566fceeb728df5e0bcb7fc7aa5991061e03,false,false,,,,TOO_SHORT
1687465,0xd15560f49f01f1fe986040d01dbede0ab9a9da10,false,false,,,,TOO_SHORT
1687740,0x071aaaeaa4d2b662bb4061058c5bbc1cf967fcf6,false,false,,,,TOO_SHORT
1687761,0x8554bb112a703bd3c608b63719a19ea773a59b87,false,false,,,,TOO_SHORT
1687846,0x69d7eae2671102d7d0b0561b64fd5ecbf32e33ac,false,false,,,,TOO_SHORT
1687964,0x7f6a81c973469772f2ca6d416e4cea9e64a1e41c,false,false,,,,TOO_SHORT
1689032,0x39a6ea9fab4af5886af68062c0eb34a6128d76c2,false,false,,,,TOO_SHORT
1689813,0x880775a3e89ea806c8dd5eb757330d59243a7741,false,false,,,,TOO_SHORT
1689869,0xbc843d116c946e00f5e949dce4f569ada5731bb7,false,false,,,,TOO_SHORT
1689924,0x7c80899e996e159cef1ed5c9f8c1dfda71f8abc7,false,false,,,,TOO_SHORT
1689952,0x0c70378883c0314adbee6f5f05fe166053d07eb1,false,false,,,,TOO_SHORT
1690199,0x3ce3c6302c53ec34a6668d2ed7ac7a92c6b73755,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1690199,0xc4bbd073882dd2add2424cf47d35213405b01324,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1690199,0xc378d8c48b327f9359392d761d6ab707a79555a6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1690199,0x542a9515200d14b68e934e9830d91645a980dd7a,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1690428,0x324835ed5d140d828272d58cddf6a362a73d5f0b,false,false,,,,TOO_SHORT
1690451,0x050e84d8598996332c93ef884ef1031b8fb5c294,false,false,,,,TOO_SHORT
1690831,0xd2b812d2bde9041baf272c477a1ef189b5714844,false,false,,,,TOO_SHORT
1690860,0xdb78cdc6ddd5338ac9759815433f7a54f6fc9a5d,false,false,,,,TOO_SHORT
1690877,0x770c05084be62f1dd13b21d8321a9fbe5484078e,false,false,,,,TOO_SHORT
1691049,0x2acafd4be474f1bc75745e558ed699c50db6895d,false,false,,,,TOO_SHORT
1691175,0x28771585ef35a582aa31a352a078119cab1c0208,false,false,,,,TOO_SHORT
1691232,0xfde6c92dd07ffa62a844b7300a056c6ee1ed7d80,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1691232,0x99f862a4899fab62d6881fbfa318de648f6d18a3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1691232,0x6966ab0d485353095148a2155858910e0965b6f9,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1691232,0x5c8536898fbb74fc7445814902fd08422eac56d0,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1691531,0xaffe80b2581ed9a7b01f519f1e1a6b5ca7d226c8,false,false,,,,TOO_SHORT
1691699,0xc60191a58d4a041a656cdf94e7868b84e51819d2,false,false,,,,TOO_SHORT
1691736,0x5e147dbdf6d116641b313434cca927258ddacdc5,false,false,,,,TOO_SHORT
1691768,0xe9a8becfdd16494e10cc45bc05a95357ec4708d2,false,false,,,,TOO_SHORT
1691931,0x41ab24b3ed466d83e8707db9d6c9b12a43d6e09e,false,false,,,,TOO_SHORT
1692141,0xefe4cae7720495ee100eeba47c6fe07ac79f3a47,false,false,,,,TOO_SHORT
1692447,0xc27c62268a21fcede5420121ce82478db3c103c1,false,false,,,,TOO_SHORT
1692522,0xcc6e4f3fa08a746b67f78042d76212b29a8714e6,false,false,,,,TOO_SHORT
1692810,0xd2940a2d777affbeda7ad54afa3e6b133a21bc7a,false,false,,,,TOO_SHORT
1693648,0x6cff89d7b6fb92db84cffa08c921c82faca80bdc,false,false,,,,TOO_SHORT
1693763,0xa3acf3a1e16b1d7c315e23510fdd7847b48234f6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1693763,0xc355ae07097309093ec074b42c96347dfbdba077,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1693763,0x6d2a231d2edaaf2dccf7d0f750ed3c7957c99c5e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1693763,0x1975bd06d486162d5dc297798dfc41edd5d160a7,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1693947,0xa46af150ad36d1a5e33973fcc8946d21db94ac4c,false,false,,,,TOO_SHORT
1694175,0x5b5e4014b0ca9b20b3b682e2e6a35104de6074d8,false,false,,,,TOO_SHORT
1694252,0x9082b706e4bb25a2495ade9f661ad6cfa85b385f,false,false,,,,TOO_SHORT
1694388,0x5d0cdf68e83f2006f0c890925beb309651f622b7,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1694645,0xb685b6d2e6a34b321c9dd5081373db735d2a3507,false,false,,,,TOO_SHORT
1694934,0x81f681b522e4c7fbedcb536ea3893299c6d7b222,false,false,,,,TOO_SHORT
1695231,0x934f6593da5fc56aa1d69a399c8a8ad024da4a80,false,false,,,,0x597cc90774efed11ead1dd72828768d4563350f5
1695528,0x1cb044181ab1c93043aa92670c1af50113b7c99c,false,false,,,,TOO_SHORT
1695670,0xe709c6c933bda30963274d5bdd1e556c655c59fe,false,false,"contract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\n//token contract used as reward\ncontract token {\n    mapping (address => uint256) public totalInvestmentOf;\n    function transfer(address receiver, uint amount){  }\n    function updateInvestmentTotal(address _to, uint256 _value){ }\n    function burnUnsoldCoins(address _removeCoinsFrom){ }\n}\n\ncontract Crowdsale is owned {\n    uint public amountRaised;\n    //20160 minutes (two weeks)\n    uint public deadline;\n    //1 token for 1 ETH week 1\n    uint public price = 1 ether;\n    //address of token used as reward\n    token public tokenReward;\n    Funder[] public funders;\n    event FundTransfer(address backer, uint amount, bool isContribution);\n    //crowdsale is open\n    bool crowdsaleClosed = false;\n    //countdown to week two price increase\n    uint weekTwoPriceRiseBegin = now + 10080 * 1 minutes;\n    //refund any remainders\n    uint remainderRefund;\n    uint amountAfterRefund;\n    //80/20 split\n    uint bankrollBeneficiaryAmount;\n    uint etherollBeneficiaryAmount;\n    //80% sent here at end of crowdsale\n    address public beneficiary;\n    //20% to etheroll\n    address etherollBeneficiary = 0x5de92686587b10cd47e03b71f2e2350606fcaf14;\n\n    //data structure to hold information about campaign contributors\n    struct Funder {\n        address addr;\n        uint amount;\n    }\n\n    //owner\n    function Crowdsale(\n        address ifSuccessfulSendTo,\n        uint durationInMinutes,\n        //uint etherCostOfEachToken,\n        token addressOfTokenUsedAsReward\n    ) {\n        beneficiary = ifSuccessfulSendTo;\n        deadline = now + durationInMinutes * 1 minutes;\n        //price = price;\n        tokenReward = token(addressOfTokenUsedAsReward);\n    }\n\n\n\n    function () {\n        //crowdsale period is over\n        if(now > deadline) crowdsaleClosed = true;\n        if (crowdsaleClosed) throw;\n        uint amount = msg.value;\n\n        //refund if value sent is below token price\n        if(amount < price) throw;\n\n        //week 1 price\n        if(now < weekTwoPriceRiseBegin){\n            //return any ETH in case of remainder\n            remainderRefund = amount % price;\n            if(remainderRefund > 0){\n                //quietly refund any spare change\n                msg.sender.send(remainderRefund);\n                amountAfterRefund = amount-remainderRefund;\n                tokenReward.transfer(msg.sender, amountAfterRefund / price);\n                amountRaised += amountAfterRefund;\n                funders[funders.length++] = Funder({addr: msg.sender, amount: amountAfterRefund});\n                tokenReward.updateInvestmentTotal(msg.sender, amountAfterRefund);\n                FundTransfer(msg.sender, amountAfterRefund, true);\n            }\n\n            //same but no remainder\n            if(remainderRefund == 0){\n                 amountRaised += amount;\n                 tokenReward.transfer(msg.sender, amount / price);\n                 funders[funders.length++] = Funder({addr: msg.sender, amount: amount});\n                 tokenReward.updateInvestmentTotal(msg.sender, amount);\n                 FundTransfer(msg.sender, amount, true);\n            }\n        }\n\n        //week 2 price\n        if(now >= weekTwoPriceRiseBegin){\n            //price rise in week two\n            //1 token for 1.5ETH\n            if(price == 1 ether){price = (price*150)/100;}\n            //tokenReward.transfer(msg.sender, amount / price, amount);\n            //return any ETH in case of remainder\n            remainderRefund = amount % price;\n            if(remainderRefund > 0){\n                //quietly refund any spare change\n                msg.sender.send(remainderRefund);\n                amountAfterRefund = amount-remainderRefund;\n                tokenReward.transfer(msg.sender, amountAfterRefund / price);\n                amountRaised += amountAfterRefund;\n                funders[funders.length++] = Funder({addr: msg.sender, amount: amountAfterRefund});\n                tokenReward.updateInvestmentTotal(msg.sender, amountAfterRefund);\n                FundTransfer(msg.sender, amountAfterRefund, true);\n            }\n\n            //same but no remainder\n            if(remainderRefund == 0){\n                 tokenReward.transfer(msg.sender, amount / price);\n                 amountRaised += amount;\n                 funders[funders.length++] = Funder({addr: msg.sender, amount: amount});\n                 tokenReward.updateInvestmentTotal(msg.sender, amount);\n                 FundTransfer(msg.sender, amount, true);\n            }\n        }\n    }\n\n    //modifier for only after end of crowdsale\n    modifier afterDeadline() { if (now >= deadline) _ }\n\n    //modifier for only after week 1 price rise\n    modifier afterPriceRise() { if (now >= weekTwoPriceRiseBegin) _ }\n\n    /*checks if the time limit has been reached and ends the campaign\n    anybody can call this after the deadline\n    80% of funds sent to final etheroll bankroll SC\n    20% of funds  sent to an address for etheroll salaries*/\n    function checkGoalReached() afterDeadline {\n        //house bankroll receives 80%\n        bankrollBeneficiaryAmount = (amountRaised*80)/100;\n        beneficiary.send(bankrollBeneficiaryAmount);\n        FundTransfer(beneficiary, bankrollBeneficiaryAmount, false);\n        //etheroll receives 20%\n        etherollBeneficiaryAmount = (amountRaised*20)/100;\n        etherollBeneficiary.send(etherollBeneficiaryAmount);\n        FundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);\n        etherollBeneficiary.send(this.balance); // send any remaining balance to etherollBeneficiary anyway\n        //burn any remaining unsold coins\n        //tokenReward.burnUnsoldCoins();\n        crowdsaleClosed = true;\n    }\n\n    //update token price week two\n    //this does happen automatically when someone purchases tokens week 2\n    //but nice to update for users\n    function updateTokenPriceWeekTwo() afterPriceRise {\n        //funky price updates\n        if(price == 1 ether){price = (price*150)/100;}\n    }\n\n    function burnCoins(address _removeCoinsFrom)\n        onlyOwner\n    {\n        tokenReward.burnUnsoldCoins(_removeCoinsFrom);\n    }\n\n    //in case of absolute emergency\n    //returns all funds to investors\n    //divestment schedule is better in the beneficiary contract as no gas limit concerns\n    function returnFunds()\n        onlyOwner\n    {\n        for (uint i = 0; i < funders.length; ++i) {\n          funders[i].addr.send(funders[i].amount);\n          FundTransfer(funders[i].addr, funders[i].amount, false);\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1695700,0x6ecdda806caeaa6bd91a7516f3af31bd2e193d57,false,false,,,,TOO_SHORT
1695711,0xcb1f93cf68269ebac4e617316dbe601e78e25223,false,false,,,,TOO_SHORT
1695715,0x2eeb74444fa1294f90fbbc8c93ce1f8f461e8c7f,false,false,,,,TOO_SHORT
1695758,0xd7226644a00de9ad61c670fffd3e19558fbcd706,false,false,,,,TOO_SHORT
1695800,0xebc1683316e11d64b553bca9ffae07e414d6b844,false,false,,,,TOO_SHORT
1695878,0xe518a2a9dcff56e9acd3e6a1bb168252b240f371,false,false,,,,TOO_SHORT
1696075,0x4ca04d31e4f744387312ee651dafe6e2f8ad0548,false,false,,,,TOO_SHORT
1696645,0x9ef8c14cfb92745440f337686aa88bb08ce62394,false,false,,,,TOO_SHORT
1696720,0x73a3c6aa216b2a46b993f414ee6278e827fa1fef,false,false,,,,TOO_SHORT
1696831,0xc956e1efc944fd25d2de09808d1ba1264aee160c,false,false,,,,TOO_SHORT
1696849,0x8d51d52fa2f6d60a0a0593314b46f48bf26dbb4b,false,false,,,,TOO_SHORT
1696948,0x41fc65daaafb413630baac1258c08ef5c249b293,false,false,,,,TOO_SHORT
1696996,0xea9e156f742dd6cd481d8e30a35678dbcd9f906f,false,false,,,,TOO_SHORT
1697058,0x93c85cc5f4da3b46ccb8e023c8d0c457e8cc4886,false,false,,,,TOO_SHORT
1697229,0x41630d32e2ac53420ca53f5c510e112406039fe2,false,false,,,,TOO_SHORT
1697247,0x3c02a7bc0391e86d91b7d144e61c2c01a25a79c5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1697247,0xb72286f12bdb4333335dfa31773bed19263c04d2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1697247,0x8f284b2aee3aee3b0b8f03ba6df3ef34d39e4744,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1697247,0xe4ae1efdfc53b73893af49113d8694a057b9c0d1,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1697442,0xc277a077d98b32a72ab8d8d346ad489a8c96a526,false,false,,,,TOO_SHORT
1697526,0x5763d67c64c6e4b1528d4c751d96ec19e870492e,false,false,,,,TOO_SHORT
1697763,0x5bed23689bab594e18c773e3e633e07e19719908,false,false,,,,TOO_SHORT
1697831,0x8760f6077ea2dd7e6551c6080d237be3eadbc827,false,false,,,,TOO_SHORT
1698007,0xa00cb8c84e504546b0ad3436d5eb72f3bf885e33,false,false,,,,TOO_SHORT
1698012,0x2b777fbc9c0225b24731a3169a2ef1816c4fd340,false,false,,,,TOO_SHORT
1698182,0xf17290750913b6f215abcda19ac62c21685d55b7,false,false,,,,TOO_SHORT
1698323,0x36604bee9a403943a330960419a19b0aa15873fd,false,false,,,,TOO_SHORT
1698394,0x73bc323db96c1fbded9c7c6148e9a11b4051faba,false,false,,,,TOO_SHORT
1698402,0xbc6189d1244d078f9f75984fc361337a376136ce,false,false,,,,TOO_SHORT
1698403,0xceaeb481747ca6c540a000c1f3641f8cef161fa7,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1698403,0xce9952628ddd87ac661a27bd4938c9c6472b8de5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1698403,0x9436bd4a95906fae7cec0ee829342dced0d7e354,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1698403,0x9ea779f907f0b315b364b0cfc39a0fde5b02a416,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1698530,0x552130433004198598e3aeaf3c9d0eeaeb12b8ca,false,false,,,,TOO_SHORT
1698558,0xbfe56a116a296ce8d415374e44645cd4707998d4,false,false,,,,TOO_SHORT
1698582,0xfb0edd6e1aa4f37e0e6b56d96b5ae6de372dc845,false,false,,,,TOO_SHORT
1698587,0xef5f5faad2b519675acea8d532ca34e9b08462d5,false,false,,,,TOO_SHORT
1698839,0xc264a042ae44b7d20037f46ce425207803124b30,false,false,,,,TOO_SHORT
1698874,0x02cfffec00f3ed9d159d470606159421b0a75584,false,false,,,,TOO_SHORT
1698905,0xd26865f3a4676c76bb9eba975069f43542df1b0d,false,false,,,,TOO_SHORT
1698925,0x02268047f5c77a6a533619773474d1a6e510443f,false,false,"contract Creator {\n    function newContract(bytes data) public returns (address) {\n        address theNewContract;\n        uint s = data.length;\n\n        assembly {\n            calldatacopy(mload(0x40), 68, s)\n            theNewContract := create(callvalue, mload(0x40), s)\n        }\n\n        return theNewContract;\n    }\n}",1,低レベルのアセンブリを使用した実用的なコントラクト作成機能。,
1698946,0xd208177bdc5a012732c3d7a1d91e767d8b05fa48,false,false,,,,TOO_SHORT
1699123,0xb52042c8ca3f8aa246fa79c3feaa3d959347c0ab,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1699123,0xc8c23cf5cee91a0f47ac17263d8f719c4e416325,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1699123,0xe73ecabe72f610830b58b70fcc3938b8de4bb2f3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1699123,0x3ba4d81db016dc2890c81f3acec2454bff5aada5,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1699233,0x4edf67144b350c7fa5d38a07e7392ded271daa5f,false,false,,,,TOO_SHORT
1699327,0x9c2e6de424943c61bc1af2ff424d13c6c794ba50,false,false,,,,TOO_SHORT
1699416,0x950be48b7a00bf18569e1f93551143c43a893b1c,false,false,,,,TOO_SHORT
1699973,0xdf35e0a41d4571904922fbb6c71e171270775aad,false,false,,,,TOO_SHORT
1700261,0x6e5c1b58ad1ffee6da1acb0e0b50c9a366abe430,false,false,,,,TOO_SHORT
1700380,0x7c125d7f8e7690b31225d42d3cf868a6b72c1b15,false,false,,,,TOO_SHORT
1700442,0x5706414a954e4efc12fb88424b90ff54003f10a4,false,false,,,,TOO_SHORT
1700579,0xe3fd3c44bdad07e04e8cdbd64e747a3439a444ca,false,false,,,,TOO_SHORT
1700598,0x9ae433a727601f8874d18d4037846efa8f5c98ae,false,false,,,,TOO_SHORT
1700688,0xfdbb93abe41dfc81ca13e76a7d6cd52b6bf739b2,false,false,,,,TOO_SHORT
1700689,0x44133e9f49e62d1a9ccd136da3a867a359229efc,false,false,,,,TOO_SHORT
1700690,0xc01012202cad0652666d958f54ddc1a989b56331,false,false,,,,TOO_SHORT
1700728,0x3826b8e25be7273efcaa04a7835a86777ce5ec9c,false,false,,,,TOO_SHORT
1700757,0x4f52c18b2bd467b9d46c35e5bbc5684123d46dc5,false,false,,,,TOO_SHORT
1700765,0x52dd963097633bf1534674c30452b16b02f2acc7,false,false,,,,TOO_SHORT
1700872,0xb5e5666dd8b76182f037258db1073a8cee7aee0c,false,false,,,,TOO_SHORT
1701257,0x46549ddc931484f42b3839012d9f343cd777481d,false,false,,,,TOO_SHORT
1701263,0x95b313bdd12ccb52c3bf34320d7559e4dc9770ab,false,false,,,,TOO_SHORT
1701300,0x7ee39560c512aa0d567618f109dd1bc4be9d8fa1,false,false,,,,TOO_SHORT
1701421,0x2cc2a712d593960c02177cfb1794eac8dc02f329,false,false,,,,TOO_SHORT
1701549,0xd5dd5a997e7631e7981ebd17866696deb0a87114,false,false,,,,TOO_SHORT
1701640,0x4863226780fe7c0356454236d3b1c8792785748d,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1701640,0xf081275db7a434ce8f381794dfd922df245d3b3b,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1701640,0x72cb5bd2581401f039e51decb5a74d84247b4e38,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1701640,0x52c5317c848ba20c7504cb2c8052abd1fde29d03,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1701682,0xf90dd7d8f724df65d93d8fca3ca5639cb5b1ec03,false,false,,,,TOO_SHORT
1701871,0xf907dd0b9d56bdb7789790c7f7e293e01fbd5ba7,false,false,,,,TOO_SHORT
1701895,0x5f8d213d4b709fc6a35da4b64451a31ac3c3a0b8,false,false,,,,TOO_SHORT
1701944,0xbe77a2003354a8340d8c74de5de2f58851a32904,false,false,,,,TOO_SHORT
1701960,0x5823f4f51a06fc4aff326b08c487c49671b239fe,false,false,,,,TOO_SHORT
1701980,0xb3c54b7fe118c8dd2880e23e5b005edcdc486e74,false,false,,,,TOO_SHORT
1701985,0xf154b7a62c2ca19e93f3b1109fc4cacdc17f9feb,false,false,,,,TOO_SHORT
1702263,0x292052d85855f5daf10601e34903fe9516373a38,false,false,,,,TOO_SHORT
1702452,0xea120e280f4ec7c936311c21c434f74fc607497a,false,false,,,,TOO_SHORT
1702741,0x580114cbeb41c62f55ff55ca9e6f028ceb92ae91,false,false,"contract RandomInterface {\n	function getRandom() returns (bytes32 hash) {}\n}\ncontract WinnerDBInterface {\n	function Winners(uint id) constant returns(uint date, address addr, uint value, uint rate, uint bet)  {}\n	function newWinner(uint date, address addr, uint value, uint rate, uint bet) external returns (bool) {}\n}\ncontract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		http://d.ethereumlottery.net\n		ver: 2.2.1\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	address private winnersDB;\n	address private randomAddr;\n	uint private constant fee = 5;\n	uint private constant investorFee = 70;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 100;\n	\n    bool public ContractEnabled = true;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private ContractDisabledBlock;\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n		uint id;\n		uint sumInvest;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] private investors;\n	\n	string constant public Information = ""http://d.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function dEthereumlotteryNet(address _winnersDB, address _oldcontract, address _randomAddr) {\n		owner = msg.sender;\n		investors.length++;\n		winnersDB = _winnersDB;\n		randomAddr = _randomAddr;\n		if (_oldcontract != 0x0) {\n			RollCount = dEthereumlotteryNet( _oldcontract ).RollCount();\n			JackpotHits = dEthereumlotteryNet( _oldcontract ).JackpotHits();\n		}\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n	    if (jackpot_ == 0) {\n	        Rate = 0;\n	        Bet = 0;\n	        return;\n	    }\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		while (Value < Bet) {\n		    Rate++;\n		    Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n		    Rate = BestRollRate;\n		    Bet = getRealBet(Rate);\n        }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		uint InvestorID = getInvestorByAddress(Address);\n		if (InvestorID == 0 || ! investors[InvestorID].valid) {\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n		Investment = investors[InvestorID].value;\n		Balance = investors[InvestorID].balance;\n		Live = investors[InvestorID].live;\n	}\n	function Winners(uint id) constant returns(uint date, address addr, uint value, uint rate, uint bet)  {\n		return WinnerDBInterface(winnersDB).Winners(id);\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() external OnlyEnabled noContract {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) {\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].timestamp = now + investMinDuration;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		jackpot_ += value_;\n		setJackpot();\n	}\n	function GetMyInvestmentBalance() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].balance == 0) { throw; }\n		if ( ! msg.sender.send( investors[InvestorID].balance )) { throw; }\n		investors[InvestorID].balance = 0;\n	}\n	function CancelMyInvestment() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].timestamp > now && ContractEnabled) { throw; }\n		uint balance_;\n		if (investors[InvestorID].live) {\n			jackpot_ -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		if ( ! msg.sender.send( balance_ )) { throw; }\n		delete investors[InvestorID];\n	}\n	/* For Players */\n	function DoRoll() external noEther noContract {\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, false, true, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if ( ! ContractEnabled || players[msg.sender][a].sumInvest != jackpot_ || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, true, false, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if ( ! found) { throw; }\n		if (value_ > 0) { if ( ! msg.sender.send(value_)) { throw; } }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		uint _rate;\n		uint _realBet;\n		(_rate, _realBet) = ChanceOfWinning(msg.value);\n		if (_realBet > msg.value) { throw; }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! ContractEnabled) {\n		    if (ContractDisabledBlock < block.number) {\n				if (playersPot == 0) { throw; }\n				if ( ! msg.sender.send( playersPot )) { throw; }\n				playersPot = 0;\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n			ContractDisabled(ContractDisabledBlock);\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner noEther {\n		if (feeValue == 0) { throw; }\n		if ( ! owner.send(feeValue)) { throw; }\n		feeValue = 0;\n	}\n	\n	/*\n		Private functions\n	*/\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber == 0 || _rate == 0) { return; }\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=1 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n			WinnerDBInterface( winnersDB ).newWinner(now, msg.sender, win, _rate, players[msg.sender][id].value);\n			DoRollEvent(msg.sender, win, players[msg.sender][id].id, false, false, false, true, bigNumber, _rate, bigNumber % _rate);\n		} else {\n			DoRollEvent(msg.sender, players[msg.sender][id].value, players[msg.sender][id].id, false, false, true, false, bigNumber, _rate, bigNumber % _rate);\n		}\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=1 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		RollCount++;\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed, RandomInterface(randomAddr).getRandom(), address(seed).balance);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		players[msg.sender][rollID].id = RollCount;\n		players[msg.sender][rollID].sumInvest = jackpot_;	\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, players[msg.sender][rollID].value, players[msg.sender][rollID].id);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1 ether / value * 100 / investorFee * extraRate / 100 / 1 ether;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1 ether / ( rate * 1 ether * investorFee / extraRate);\n	}\n	function getInvestorByAddress(address Address) internal returns (uint id) {\n		for ( id=1 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return;\n			}\n		}\n		return 0;\n	}\n	\n	/*\n		Events\n	*/	\n	event DoRollEvent(address Player, uint Value, uint RollID, bool Refund, bool LostBet, bool LossRoll, bool WinRoll, uint BigNumber, uint Rate, uint RollResult);\n	event PrepareRollEvent(address Player, uint Block, uint Bet, uint RollID);\n	event ContractDisabled(uint LossAllBetBlockNumber);\n	\n	/*\n		Modifiers\n	*/\n	modifier noContract() {if (tx.origin != msg.sender) { throw; } _ }\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1702775,0xb54bd32edffa7064ec53192f62b3e3d04cceff5a,false,false,,,,TOO_SHORT
1702816,0x4d765592d18d89a1c8a629a13a44fa95adbfbcab,false,false,,,,TOO_SHORT
1703124,0x17d93e3af7e263181b109778ccee882103ca832a,false,false,,,,TOO_SHORT
1703174,0xd6addb93e767fa656a85bd7ab87102cb95ff2770,false,false,,,,TOO_SHORT
1703344,0x6f076ed309270d188aec5726f86cde7bca3b9d87,false,false,,,,TOO_SHORT
1703354,0x3843dd9417a86a7173e1edbe16cbd9a4fcc8d763,false,false,,,,TOO_SHORT
1703437,0xd252c24cd22fab334edd51074cee49fddada7a1f,false,false,,,,TOO_SHORT
1703438,0x297229d8d86f4077262a753d3ecba13e88441264,false,false,,,,TOO_SHORT
1703455,0x18ccbeaea3cfcc6df7ead150e55188cd55356253,false,false,,,,TOO_SHORT
1703618,0x7f0fd8fa402d56dca1f4baa9bf3880721c274d53,false,false,,,,0x597cc90774efed11ead1dd72828768d4563350f5
1703625,0x110c11de11cce962604c28bb05bbc399cbaa7bda,false,false,,,,0x597cc90774efed11ead1dd72828768d4563350f5
1703671,0xcb88488b64feb32d9088b435d1300c800a9e8b23,false,false,,,,TOO_SHORT
1703673,0xcf7cba701ded5c4d8e588e64f70b6ba1c17ea277,false,false,,,,0x597cc90774efed11ead1dd72828768d4563350f5
1703801,0x46a82b2e1ba1ab9b2ea040e761f94669ef2bf2e7,false,false,,,,TOO_SHORT
1703922,0x0c93bfe0b8d9822d3edd326e655584984c3fc052,false,false,,,,TOO_SHORT
1704099,0xf1bb82f191d240b3c8bb2de57679398d269c3049,false,false,,,,TOO_SHORT
1704220,0x764a544bbae7603c1418b2b9e1cf760ac4eccc67,false,false,,,,TOO_SHORT
1704228,0x9d309db34885d39b7f58fca6f00e65bfd4abd0e2,false,false,,,,TOO_SHORT
1704232,0x8e85e898a2aa4c921fab0a6932eca9cf8a9070d6,false,false,,,,TOO_SHORT
1704529,0x5f9f3392e9f62f63b8eac0beb55541fc8627f42c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1704529,0x5ec74fb91576dfde767dd43b332731eb6abfc6fe,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1704529,0x6b6c02fa6a9dd14b0c06ee998d7f89beeae7ad64,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1704529,0x5d2b2e6fcbe3b11d26b525e085ff818dae332479,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1704771,0xe4e61488f66872d6c5ade7c746d6241b9941c359,false,false,,,,TOO_SHORT
1704795,0xe502694726f09c840dcc6526b63591e162794da7,false,false,,,,TOO_SHORT
1704826,0x8cda2aef6243d0ab7cb7c73976290376a1e8f5a2,false,false,,,,TOO_SHORT
1705110,0xf46ae1d5b3e87de0fb44661b75fb8f1785043b0a,false,false,,,,TOO_SHORT
1705120,0x0cd61df2fae9a5c3e54966136a482a4aff90e2c5,false,false,,,,TOO_SHORT
1705169,0x269a3c6f6ee58a0b3b0ac60b6ff55a9c06c27c3f,false,false,,,,TOO_SHORT
1705284,0x8c17d28918aeab519768740375895c831de026b4,false,false,,,,TOO_SHORT
1705493,0x9d1db71534e8a43eda40df599defcdd13abf9714,false,false,,,,TOO_SHORT
1705499,0x0e0d7fcb60d71bf845908eade612bf1d8fcf6030,false,false,,,,TOO_SHORT
1705526,0xfb5557d71a58dd83d3205e65db6a0cdde8e0a6a9,false,false,,,,TOO_SHORT
1705538,0x87a7fa2d51da916dc21973e170c8dabd36a3fb6f,false,false,,,,TOO_SHORT
1705571,0x40a80c885c7eaae8559c82da531a905e336754c7,false,false,,,,TOO_SHORT
1705626,0xa9224a4c2edf524edf535fb4544c9e03961ff054,false,false,,,,TOO_SHORT
1705751,0x1d1acd9513bee050b2a54689aca88cb9a1ad3aaa,false,false,,,,TOO_SHORT
1705813,0xb9c5d5e9a1b1a0f4d4a2878a55068dc5a4e3d06b,false,false,,,,TOO_SHORT
1705900,0xc51b8d50990d914ba24125dce84412ea75b4340f,false,false,,,,TOO_SHORT
1705904,0x104e326692b88e5fd12a4231f5f966ee323d53a5,false,false,,,,TOO_SHORT
1706197,0xef8b04406f1039d8dc455bcbf5717213db33d8d0,false,false,,,,TOO_SHORT
1706200,0x865a7009826ec068786a1675b58155cef9d9e8f2,false,false,,,,TOO_SHORT
1706309,0x65507d047a76562f70f3287eed6d6a71ab4ef246,false,false,,,,TOO_SHORT
1706319,0x93e9c2e3986f5d7b40885d929ee3cd55873fbbd5,false,false,,,,TOO_SHORT
1706808,0x11c84fd909c11f2c348d9f90006b648e7d09033d,false,false,,,,TOO_SHORT
1707025,0xc441e9d5ee17ee2b43bfecc8cd444ed1c4b802c2,false,false,,,,TOO_SHORT
1707125,0xb2c5919f6c93be5c71d6fd8e99aab037adb099b0,false,false,,,,TOO_SHORT
1707151,0x2fae3ee24c155c9e0c7f2d2dd5da7b1396fe2f76,false,false,,,,TOO_SHORT
1707182,0xeb04e1545a488a5018d2b5844f564135211d3696,false,false,,,,TOO_SHORT
1707209,0x15a5f1917ff7e1e95677f0f34d4147153e0a97cb,false,false,,,,TOO_SHORT
1707213,0x9aa008f65de0b923a2a4f02012ad034a5e2e2192,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1707213,0x99e298f802491db23a8572cd42f7eb0c7a4a506e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1707213,0x00f143a6b1daff46a7ffd58f64ca9077aa03ce96,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1707213,0x057b56736d32b86616a10f619859c6cd6f59092a,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1707239,0x2c76f260707672e240dc639e5c9c62efafb59867,false,false,,,,TOO_SHORT
1707297,0x6306f81cee49e87fbb6a89aa33c4abfe71347ca5,false,false,,,,TOO_SHORT
1707432,0x00d04bf108a8a493feef618ec2bb4503aa5495ff,false,false,,,,TOO_SHORT
1707824,0x39e57ea4e4fba0effe7fd4b49b6f7fe762196af1,false,false,,,,TOO_SHORT
1708075,0x2c630ee7bbb2a46d5adf4815a8e8d172f4ba38a2,false,false,,,,TOO_SHORT
1708142,0xcccaf891070607ab6c1ce2aa22f74daf8529ff48,false,false,,,,TOO_SHORT
1708238,0xee25b43c134c20b7a7f051e78eba6334fcaf638f,false,false,,,,TOO_SHORT
1708246,0xe34f4bd4b05e0a40295daf48c2562c377338ea05,false,false,,,,0x580114cbeb41c62f55ff55ca9e6f028ceb92ae91
1708539,0x11c673f97a1d20a8b2a865a771befa183e1b8fb8,false,false,,,,TOO_SHORT
1708621,0x2dbc5845c5def96f468c5a1173f4cc4c4ba15a6e,false,false,,,,TOO_SHORT
1708635,0xba9aebad8be7f38d6d1b40efc28fba077cdb8d5e,false,false,,,,TOO_SHORT
1708637,0xb88491db7373d9049a5013edbc750045fe4c06ea,false,false,,,,TOO_SHORT
1709011,0x59cd46fcf4d76629ef6bb9c3406f279a91eff119,false,false,,,,TOO_SHORT
1709016,0x8b6d8ba245d7010658da854e71f85cdb3e293caf,false,false,,,,TOO_SHORT
1709069,0xd2fd2620d8e2a68d4e945ec354d4a887c595ad6f,false,false,,,,TOO_SHORT
1709070,0x4fa802324e929786dbda3b8820dc7834e9134a2a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1709070,0xca38fa14e456a355021a3891f6b3057b4302de69,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1709070,0x78064e35d14092fca945fa800a1ace33b14c170b,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1709070,0x35a051a0010aba705c9008d7a7eff6fb88f6ea7b,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1709075,0xe6bee87da330abd3ebf1a54115d5de06fa44e047,false,false,,,,TOO_SHORT
1709107,0xc489e9d8c996ed068c9ae97179fcfc7413b4bd61,false,false,,,,TOO_SHORT
1709136,0x32049561b3decc3384dff816c0befc1829d7d030,false,false,,,,TOO_SHORT
1709510,0x6b62670487d17c8e448d57f345a49d88c746388b,false,false,,,,TOO_SHORT
1709572,0x4b8e1ad58657f8b4b036ad12afbcef54d24ac9ba,false,false,"contract BasicSign {\n\n    event Created(\n        address indexed from,\n        uint256 id\n    );\n    event Signed(\n        address indexed from,\n        uint256 docId,\n        uint8 singId,\n        bytes16 signType,\n        bytes sign\n    );\n\n    address owner;\n    mapping (uint256 => Document) public documents;\n\n    struct Document {\n        address organizer;\n        Sign[] signs;\n    }\n\n    struct Sign {\n        address signer;\n        bytes16 signType;\n        bytes   sign;\n    }\n\n    function SimpleSign() {\n        owner = msg.sender;\n    }\n\n    function createDocument(uint256 nonce) returns (uint256 docId) {\n        docId = generateId(nonce);\n        if (documents[docId].organizer != 0) throw;\n        documents[docId].organizer = msg.sender;\n        Created(msg.sender, docId);\n    }\n\n    function removeDocument(uint256 docId) {\n        Document doc = documents[docId];\n        if (doc.organizer != msg.sender) throw;\n        delete documents[docId];\n    }\n\n    function addSignature(uint256 docId, bytes16 _type, bytes _sign) {\n        Document doc = documents[docId];\n        if (doc.organizer != msg.sender) throw;\n        if (doc.signs.length >= 0xFF) throw;\n        uint idx = doc.signs.push(Sign(msg.sender, _type, _sign));\n        Signed(msg.sender, docId, uint8(idx), _type, _sign);\n    }\n\n    function getDocumentDetails(uint256 docId) returns (address organizer, uint count) {\n        Document doc = documents[docId];\n        organizer = doc.organizer;\n        count = doc.signs.length;\n    }\n\n    function getSignsCount(uint256 docId) returns (uint) {\n        return documents[docId].signs.length;\n    }\n\n    function getSignDetails(uint256 docId, uint8 signId) returns (address, bytes16) {\n        Document doc = documents[docId];\n        Sign s = doc.signs[signId];\n        return (s.signer, s.signType);\n    }\n\n    function getSignData(uint256 docId, uint8 signId) returns (bytes) {\n        Document doc = documents[docId];\n        Sign s = doc.signs[signId];\n        return s.sign;\n    }\n\n    function generateId(uint256 nonce) returns (uint256) {\n        return uint256(sha3(msg.sender, nonce));\n    }\n\n    function () {\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1709614,0x841f4d4015bfa24749ffa64dbf844d303e6f2ddd,false,false,,,,TOO_SHORT
1709659,0x177fe666c8c34a32f7c65ad5603ac635a16bacd4,false,false,,,,TOO_SHORT
1709831,0xda2ac70e46a206a1942fe39bc676552e00ed2e20,false,false,,,,TOO_SHORT
1709937,0x2405b44be8f705afed8625cf9d67131cdfdf7135,false,false,,,,TOO_SHORT
1709997,0x5f1d6c3937a945f8e97e5af2e5394406b41ab50e,false,false,,,,TOO_SHORT
1710163,0xeaf0e07cc80152d945961c38df5a6e41db684739,false,false,,,,TOO_SHORT
1710201,0x996d1a59b9e18b19f3b50c285b81e94998b86255,false,false,,,,TOO_SHORT
1710367,0xccd805d6d24915a2f1a16873254f948a62fc38b0,false,false,,,,TOO_SHORT
1710427,0x0acb507408f30e1985878d497180e871de216480,false,false,,,,TOO_SHORT
1710561,0xf4865be3d28cdb7d3d9f42d6bc57e0fe6a98e1c0,false,false,,,,TOO_SHORT
1710641,0xcf4d7f0de47fdc46eddac9bba2d4b060393ce575,false,false,,,,TOO_SHORT
1710707,0x1802d3fcf2ff456d57f481d76cbf2d65cfe7bd35,false,false,,,,TOO_SHORT
1710763,0xe28a4ca9ba2d243188ff64229586de3f9b0f3ebf,false,false,,,,TOO_SHORT
1710971,0x13ad6e271aa652e5c1289a50b658492a067d58ea,false,false,,,,TOO_SHORT
1711101,0xb422cb66ad33a7c486784fef2ab3a4d04c003fc1,false,false,,,,TOO_SHORT
1711231,0x6be83d36dac7217fea6f39540011b459fa3dd474,false,false,,,,TOO_SHORT
1711290,0x451b07a2a1ebee67dcbacf3abe9c2bbf1fb16b1b,false,false,,,,TOO_SHORT
1711528,0xdf71ebe073a227142ca056f817b84b155c5ba85b,false,false,,,,TOO_SHORT
1711532,0xcff9e570d9ab07dea29a88b583a61414a69f6761,false,false,,,,TOO_SHORT
1711559,0x23332cc74c80a7bfe1a4c64efe1153913b991219,false,false,,,,TOO_SHORT
1711802,0x4092532d0dc079b10baeb20d6354efb7b5512c9e,false,false,,,,TOO_SHORT
1711865,0xe36506ab3cac9eeb1a29d815ce99e6e3e1e4f13c,false,false,,,,TOO_SHORT
1711990,0xae94aa731d1b9daa89e1ba0956e66872f79ba5c0,false,false,,,,TOO_SHORT
1712465,0x53bfa103bb9fb192b081728e3d58ad635a5d7f2d,false,false,,,,TOO_SHORT
1712729,0xfebf278f34e8e19baa7cf9062dfed7d6874295c2,false,false,,,,TOO_SHORT
1712785,0x103f61182f99cd44c5afe1ed02a3fc247c3219bf,false,false,,,,TOO_SHORT
1712787,0xe8889aa8fa5f6239c09a20305ae34c1d249dd13c,false,false,,,,TOO_SHORT
1713173,0x5749af93484569c7e9fc8897887c5706ffdfc7c2,false,false,,,,TOO_SHORT
1713184,0xf5b8a77050b98255fbde71dff6a538fe25b2d574,false,false,,,,TOO_SHORT
1713216,0xefcc150ef25c32c7802df7d3d24f8ef6bd03057e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1713216,0x906bd362b96c033d0942474e2c506b5ec92bb28c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1713216,0x12e626b0eebfe86a56d633b9864e389b45dcb260,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1713216,0xbcf899e6c7d9d5a215ab1e3444c86806fa854c76,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1713290,0xf32a14e6435e08c5d355bfba38453f54149ca893,false,false,,,,TOO_SHORT
1713317,0xa02e0502b6ddb48bd18ee399934adc93be08be15,false,false,,,,TOO_SHORT
1713385,0x7e0f3253f09c7af6ce0bf507825a8708101ff624,false,false,,,,TOO_SHORT
1713463,0x01fe82a32c84aa2d9060125bf8339173e0383c93,false,false,,,,TOO_SHORT
1713514,0xa3a577ed80536b52ee8ff33e88af7a009bd307d9,false,false,,,,TOO_SHORT
1713572,0xec8e57756626fdc07c63ad2eafbd28d08e7b0ca5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1713572,0x6a352689f159cb7ea76fab42c85fb12c633597e6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1713572,0x2aa7fe9c7bbf607a223b814714d64545c7aa4f44,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1713572,0xa2f1ccba9395d7fcb155bba8bc92db9bafaeade7,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1713581,0xac94825b2f61fb89a983f8beafda89977d4d6ec9,false,false,,,,TOO_SHORT
1713845,0xf1a6f5a322ae325db647e8e617957e40a56fbd0c,false,false,,,,TOO_SHORT
1713988,0xe1993a06a6a1dbb49c14b777df52e1f495ad519c,false,false,,,,TOO_SHORT
1714062,0x0a823c4a43e511ec2f8f39ce15799fe45a2e8163,false,false,,,,TOO_SHORT
1714193,0xd4a48c12766edbea57c09172eb378d8518bef850,false,false,,,,TOO_SHORT
1714205,0x39af719b1ea6b64503803544f37c558442a238f4,false,false,,,,TOO_SHORT
1714209,0xe54a14ae07e03275a2e79928f0ce880bc0178447,false,false,,,,TOO_SHORT
1714264,0xf19de125043c6dc6ac1b47b3a7c65944d6e0e7cd,false,false,,,,TOO_SHORT
1714383,0xcac92beec5137e926ec22fe16b37e06db0118f91,false,false,,,,TOO_SHORT
1714399,0x07f5c1e1bc2c93e0402f23341973a0e043f7bf8a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1714399,0xa5ee336d54267cb6ce5ed642de84d545a5b9f1be,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1714399,0xdd6ab5b1e6f6460c12bbe70f5aa38601743823e0,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1714399,0x4deb0033bb26bc534b197e61d19e0733e5679784,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1714482,0x3e41a79056132818a191ec21d1fb77fae8467e21,false,false,,,,TOO_SHORT
1714694,0x4601d32d2f9fa4d66893ccc2f8bcaf102edbb218,false,false,,,,TOO_SHORT
1714707,0x39b7776be37160722f526429659ebc31dc82cfef,false,false,,,,TOO_SHORT
1714773,0x4eb9679e496f9b2460f75c49426ca8943d589fe3,false,false,,,,TOO_SHORT
1714840,0x7b164a0c032351470d4fe8c4dcbadf61aac3bac1,false,false,,,,TOO_SHORT
1714880,0xd3685a26f93c1596c82523dfe25adf5f31497aeb,false,false,,,,TOO_SHORT
1715269,0x217d0a929cf99c786f8fce4bea43581c22d7f1f1,false,false,,,,TOO_SHORT
1715426,0x6a1f5cd1776fef2cfebd0731deda4ba9e62c0e51,false,false,,,,TOO_SHORT
1715441,0xdeaea39f26747fb4a7f8b8f5bbf6951a1b4e2239,false,false,,,,TOO_SHORT
1715461,0x05730f4151f376f4b4bb4b20ec99e70c8d7a4136,false,false,,,,TOO_SHORT
1715593,0x102b179331f4dfacb970b0508844e88f707b9a05,false,false,,,,TOO_SHORT
1715623,0x4cfe875ee34adda1cb35eafc2690f729aae5675a,false,false,,,,TOO_SHORT
1715645,0x4028fe79d8f2f437b27c20f3a0db3095f46011c3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1715645,0x29d8122e9d6d452416fa0ae2d75c9c453dbaf640,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1715645,0x6231b6d0d5e77fe001c2a460bd9584fee60d409b,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1715645,0xd164b088bd9108b60d0ca3751da4bceb207b0782,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1715730,0xc75b8a4057bba2a425ab4c3631ef5e859be11a0f,false,false,,,,TOO_SHORT
1715787,0x85a53bc0d20ee81753fdde1812f59cae52c6c916,false,false,,,,TOO_SHORT
1715824,0x0154664e4643167436d7c51212747754f71b7eca,false,false,,,,TOO_SHORT
1715908,0xfe0382228723fa0fca2bd4baec73d20852c8fa9b,false,false,,,,TOO_SHORT
1715972,0x9d5bb128c8876bfc51b2a945d38736aa241f4c14,false,false,,,,TOO_SHORT
1716003,0xede5fe0f7c13f6b09ebfebd68f9e556d4570adab,false,false,,,,TOO_SHORT
1716046,0x4fc29fb3ab17c519b1db1e1e0f16a3553aac2668,false,false,,,,TOO_SHORT
1716277,0xce7a4eecdfebbfdaa2bd36cafcb6544f25e8ad4e,false,false,,,,TOO_SHORT
1716284,0x65b5a724997bd0ab03a0c6d70ce62f1882490f11,false,false,,,,TOO_SHORT
1716289,0xfc42e1ea240ecf9ecb3b0ed2b6594b0ba40acd5e,false,false,,,,TOO_SHORT
1716573,0xf8e72683b6274ac466ec883c1ac8883944773213,false,false,,,,TOO_SHORT
1716612,0x190dafc68444205987386f7e947f26c6cf69729a,false,false,,,,TOO_SHORT
1716618,0xcda14f49705270255413585f523b9024ad0bd423,false,false,,,,TOO_SHORT
1716664,0xaea689c56453751bde25b7d133706c627267d457,false,false,,,,TOO_SHORT
1716683,0x9b4b1c06e2d35c6af15ed76a5623d130cefecb1f,false,false,,,,TOO_SHORT
1716694,0x337b7d63794cb2ef247602cdd8bdd83343b4a3ec,false,false,,,,TOO_SHORT
1716755,0x8f13a1d43408b6434dd10e161361386f3952d665,false,false,"contract StackyGame {\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees;\n    uint public balance = 0;\n\n    address public owner;\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function Doubler() {\n        owner = msg.sender;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n        // Maximum of 1 ether allowed\n        if (msg.value > 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n\n      	// add a new participant to array\n        uint idx = participants.length;\n        participants.length += 1;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value;\n        \n        // collect fees and update contract balance\n        if (idx != 0) {\n            collectedFees += msg.value * 1 / 20;\n            balance += msg.value;\n        } else {\n            // first participant has no one above him,\n            // so it goes all to fees\n            collectedFees += msg.value;\n        }\n\n	    // if there are enough ether on the balance we can pay out to an earlier participant\n        if (balance > participants[payoutIdx].amount * 2) {\n            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 20);\n            participants[payoutIdx].etherAddress.send(transactionAmount);\n\n            balance -= participants[payoutIdx].amount * 2;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1716804,0x03c76937e5ad1b2d1fabc6a38921203172a51c8e,false,false,,,,TOO_SHORT
1716814,0x853b85b199c13a1923b5f78fb1c2fe661ae23b9f,false,false,,,,TOO_SHORT
1716822,0xcf61f542d5c1b47d9dfae6c9cc34a71fdff87cea,false,false,,,,TOO_SHORT
1716826,0xce7e2d5e85fd396a5851ec5f9e84e982c484b3e1,false,false,,,,TOO_SHORT
1716886,0xca9a3464b281882d216d396bf893732a0e65885d,false,false,,,,TOO_SHORT
1717023,0x6d44748c72522baa7f7cf2a950aff35338d2dc4b,false,false,,,,TOO_SHORT
1717050,0x3f8ff7c741cf2313671d2b4012579861521d2134,false,false,,,,TOO_SHORT
1717078,0x12eb05705f9b76076e9a3eab56791443270cde9f,false,false,,,,TOO_SHORT
1717101,0x1b055445e61d309c8d1fe88aafa369a0c358b061,false,false,,,,TOO_SHORT
1717166,0x2f0f6c865fc62e5e32ca945c88c26e89e2ab3cac,false,false,,,,TOO_SHORT
1717319,0x6a13d5c43c0b3467f361051429908403a326a6a1,false,false,,,,TOO_SHORT
1717415,0x4e469d144b79e634a6b3826351d021b72ebb0eb3,false,false,,,,TOO_SHORT
1717429,0x9b265e3ce9256ad0a3460950f84d5d40c2a3ba86,false,false,,,,TOO_SHORT
1717486,0x1f24dd94a080ccbe6857090b12685fa263c6344d,false,false,,,,TOO_SHORT
1717509,0x2e1af854139256e749a13bb70cf5524b70b961a1,false,false,,,,TOO_SHORT
1717560,0x7db01e354b3b92e23c578ab49f1f8a3d3ef99703,false,false,,,,TOO_SHORT
1717615,0xad7bd30943111b365c9cc7b82bc2cb644f786301,false,false,,,,TOO_SHORT
1717706,0xf1864704d748a5b2b221f691636bc77bcc5ab0ca,false,false,,,,TOO_SHORT
1717751,0x86d1a0f9640fd1fddbc300233767a902e1568031,false,false,,,,TOO_SHORT
1717907,0xe5544a2a5fa9b175da60d8eec67add5582bb31b0,true,false,"// Most of the code taken from\n// https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/StandardToken.sol\n\ncontract TokenInterface {\n\n    /// @return total amount of tokens\n    function totalSupply() constant returns (uint256 supply) {}\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract HashToken is TokenInterface {\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n\n    bytes32 public prev_hash;\n    uint public max_value;\n\n    // Meta info\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    \n    function HashToken() {\n        prev_hash = sha3(block.blockhash(block.number));\n        max_value = 2 ** 255;\n        // Meta info\n        name = 'HashToken';\n        decimals = 16;\n        symbol = 'HTK';\n    }\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    event Mint(address indexed minter);\n\n    function mint(bytes32 value) {\n        if (uint(sha3(value, prev_hash)) > max_value) {\n            throw;\n        }\n        balances[msg.sender] += 10 ** 16;\n        prev_hash = sha3(block.blockhash(block.number), prev_hash);\n        // increase the difficulty\n        max_value -=  max_value / 100;\n        Mint(msg.sender);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1718069,0x0b8b64547500cf9ea9d06dba8c395294e92e913f,false,false,,,,TOO_SHORT
1718201,0x4380fc84e9c6d7b020a0f279621d56e355b120bb,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1718201,0xe7678e5f5fe83611bdc1b2cbac471f1cd7675ef3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1718201,0x5dc28b15dffed94048d73806ce4b7a4612a1d48f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1718201,0x0101f3be8ebb4bbd39a2e3b9a3639d4259832fd9,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1718234,0x6322ee50b0412c119047f28a20d7bedf6a8f6c3c,false,false,,,,TOO_SHORT
1718287,0x705d26b635ee256b0d6c6b9dcbe8e20185f16d1b,false,false,,,,TOO_SHORT
1718288,0x7da65d8f6a1c023e93c06cd1ac05a9a554cef303,false,false,,,,TOO_SHORT
1718298,0x94620b791efdeac84493f06c2f2dbec792e980f1,false,false,,,,TOO_SHORT
1718379,0xdad0a76a51232911dc88ec3cfda0909e12595246,false,false,,,,TOO_SHORT
1718380,0x54645e5d610be59e81994877829a8ae6dbcb2085,false,false,,,,TOO_SHORT
1718411,0xcdf0e81bc59ad7a678118e35ab17caf2caa15f73,false,false,,,,TOO_SHORT
1718497,0xad3ecf23c0c8983b07163708be6d763b5f056193,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1718497,0x1d29edb6997993a16c5086733cfd735d01df787c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1718497,0x914d1b8b43e92723e64fd0a06f5bdb8dd9b10c79,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1718497,0x304a554a310c7e546dfe434669c62820b7d83490,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1718518,0x2825e9c0e7e4a9f31b6f8fbd5ce15c73a2d887d2,false,false,,,,TOO_SHORT
1718519,0xb9a6fd371e712762317ea675ee4fe649f46c7b6e,false,false,,,,TOO_SHORT
1718628,0xdb845a97dfc9ce8fca01ec494415ec9322069bba,false,false,,,,TOO_SHORT
1718672,0x628242cf80b81baa34cebc80011ad96c9a4b6718,false,false,,,,TOO_SHORT
1718896,0xbffbd66fb0c1f43364f4115648ced878f719019e,false,false,,,,TOO_SHORT
1718902,0x8e37b6cacb50db1711ed5129bd7970b2f3abea27,false,false,,,,TOO_SHORT
1719036,0xa06379184ce6f1a466cad07c96becee235da3001,false,false,,,,TOO_SHORT
1719077,0x005f5cee7a43331d5a3d3eec71305925a62f34b6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1719077,0x9485e6ee97deea2c2e871caa3ecd5daa35773aed,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1719077,0xc1a254be960f74cadc40d9956bd99ae4d9a88824,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1719077,0x9fcd2deaff372a39cc679d5c5e4de7bafb0b1339,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1719105,0x5fea3c9f572541ccda49ed553172ea2bc7ede36b,false,false,,,,TOO_SHORT
1719117,0x44ba4d64ab588de6a5614467872c9c04061730c1,false,false,,,,TOO_SHORT
1719132,0x29d01e3d2e23203f4f8e4812006e23e8c45adfa4,false,false,,,,TOO_SHORT
1719236,0x2272800b3ac6aca03a757d4a8823cd48ea01db95,false,false,,,,TOO_SHORT
1719256,0xe199d0455cba92d6fd16e2ff58a7ff7287dc26e4,false,false,,,,TOO_SHORT
1719257,0x52b123b46093b9503bb8df554d1ec52412c7ffd6,false,false,,,,TOO_SHORT
1719490,0x3ad9d9fc14938ae4862d7309a14b5c464ac874b8,false,false,,,,TOO_SHORT
1719529,0x85a7c6c148c2e44a5aa5eb530d184bd10511403c,false,false,,,,TOO_SHORT
1719702,0x050f4af457250560b42a427517f94c9f6ed96119,false,false,,,,TOO_SHORT
1719737,0x0ef3a5eab1c7b6d401a4d856e8e04373c5a8cad4,false,false,,,,TOO_SHORT
1719759,0xf84a1ba483d91af087db40866660d8ec40cddb9e,false,false,,,,TOO_SHORT
1719805,0xe3b7144976cee42681e3d2e38266b0cd7bfb6914,false,false,,,,TOO_SHORT
1719809,0xf54a42c4347b6a8a715e1f589e6471869266d61a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1719809,0x97f43a37f595ab5dd318fb46e7a155eae057317a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1719809,0x0d2abdb104cde145215ff72281834dce4a64a7ca,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1719809,0x0737a6b837f97f46ebade41b9bc3e1c509c85c53,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1719815,0x4c2539aa14c93ec063155817104a1cd420b6d5ca,false,false,,,,TOO_SHORT
1719903,0xfba7ef249214364002d20a67f12bf5151438d955,false,false,,,,TOO_SHORT
1719941,0xad0857999ceb73fab2d48bc4744cd49e16ff3518,false,false,,,,TOO_SHORT
1719946,0x5e0edad82402e1cdc92b4045bf011ad7e2e3da06,false,false,,,,TOO_SHORT
1720158,0xd131637d5275fd1a68a3200f4ad25c71a2a9522e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720158,0x8f61ae9d3cbc026301d1a6b78e7ecd6e11692caf,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720158,0x42ec4c15a7e7555f20758c843a462e7943b84b25,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720158,0x0e0da70933f4c7849fc0d203f5d1d43b9ae4532d,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720248,0xd1dd6cb0ebc508f34672cdc17d288914b112c73c,false,false,,,,TOO_SHORT
1720256,0x47e7aa56d6bdf3f36be34619660de61275420af8,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720256,0x0ff0ecbe6ed1ef0e8c23f9a86ed4766eb3307da8,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720256,0x906d09a3dca31f1461b2a66926517e57ffc591f4,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720256,0xbc07118b9ac290e4622f5e77a0853539789effbe,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720329,0x61f61f8ac296e67cc9b76be4ad5207ca2b226e5d,false,false,,,,TOO_SHORT
1720456,0x2e819b83f689d55fa177f00c2a25d1f4eb0a35bd,false,false,,,,TOO_SHORT
1720648,0x8d9edb3054ce5c5774a420ac37ebae0ac02343c6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720648,0xec8350879109b409cc4e5a4bd56fab916bc6190e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720648,0x62aaae3254a512658fa87f535b05c91925870446,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720648,0x9da397b9e80755301a3b32173283a91c0ef6c87e,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720719,0x6ba7e3b9c8935e8c48dc7520ffcc4a76c4dbe73e,false,false,,,,TOO_SHORT
1720794,0xa1d36f8488295b5d2ab3fb06676f0cad471678f3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720794,0xa82f360a8d3455c5c41366975bde739c37bfeb8a,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720794,0xc2f867c10be26b33e23d5d1ed1e6519e74993fe1,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720794,0x1cba23d343a983e9b5cfd19496b9a9701ada385f,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1720807,0xaaef8b92241edbf80850f82d94420875b740f90e,false,false,,,,TOO_SHORT
1720813,0x35a6667eabf7a6f94cfe207ff3a95701d91f61a8,false,false,,,,TOO_SHORT
1720824,0xd0d4cf10a24f4e21954c0f8d847cfa0960e8b0ac,false,false,,,,TOO_SHORT
1720864,0xdbd10a3eca46fea4eefde1e70198936ef7213ea3,false,false,,,,TOO_SHORT
1720880,0xd1ea99bd1ae8ae9fb81ec97d791423e25e2f4ca2,false,false,,,,TOO_SHORT
1720911,0x26a64fc3924eadbbce84d91adf1a6ab1dbbd4fd8,false,false,,,,TOO_SHORT
1720920,0xcbc67e9910e62b126d3e9b8201ca44b78be37098,false,false,,,,TOO_SHORT
1721095,0xfb6b34e39ff2c2dd8e1e59e73a96f0e710629faf,false,false,,,,TOO_SHORT
1721193,0x9c6ac03d7059bac2f786d46754efc3dbfc35c526,false,false,,,,TOO_SHORT
1721267,0xc48738b8d0de9a98cd5b5ab55ba5d1735c2da5f3,false,false,,,,TOO_SHORT
1721276,0xc0023e4aef4573afdccff9c620b027ab8daf36a1,false,false,,,,TOO_SHORT
1721529,0xf5c0dfd22ad629cd9a95dcd32a32dd391af3e23b,false,false,,,,TOO_SHORT
1721681,0x76646bee834a3273b19e4a88a87bdf79eb6e3fea,false,false,,,,TOO_SHORT
1721769,0x5d22425eafc0a87221810544de9fc4d74d739151,false,false,,,,TOO_SHORT
1721773,0xbb8276cb8a0e68d3a29c1116f306b32e74673402,false,false,,,,TOO_SHORT
1721822,0x8972ff39180bee9cb983a4246baa6ec821d62f1c,false,false,,,,TOO_SHORT
1721978,0x2e57a4ac4a14b719ad498a59272527e77b997086,false,false,,,,TOO_SHORT
1722036,0x86fa1fc73d392ad6b2e3b4b610e6a0f95fa180f5,false,false,,,,TOO_SHORT
1722148,0x937452b864a4f2bfa7f07e3a1db7de720d0a8613,false,false,,,,TOO_SHORT
1722295,0x6e89304a241483b6fc38777d80948adeb17b93a2,false,false,,,,TOO_SHORT
1722340,0x032747313c4e914b5fce356ab8dc4df551972dcd,false,false,"//\n// This file is part of TrustEth.\n// Copyright (c) 2016 Jacob Dawid <jacob@omg-it.works>\n//\n// TrustEth is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// TrustEth is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public\n// License along with TrustEth.\n// If not, see <http://www.gnu.org/licenses/>.\n//\n\ncontract TrustEth {\n    // A registered transaction initiated by the seller.\n    struct Transaction {\n      // Supplied by the seller (Step 1).\n      uint sellerId; // The seller id of the seller who initiated this transaction and is about to receive the payment.\n      uint amount; // The amount to pay to the seller for this transaction.\n\n      // Filled out by the contract when transaction has been paid (Step 2).\n      address paidWithAddress; // The address of the buyer issueing the payment.\n      bool paid; // Flag that states this transaction has already been paid.\n   \n      // Rating supplied by the buyer (Step 3, optional).\n      uint ratingValue; // Seller rating supplied by buyer.\n      string ratingComment; // Comment on this transaction supplied by the buyer.\n      bool rated; // Flag that states this transaction has already been rated.\n    }\n\n    // A registered seller on this contract.\n    // Registered sellers can put up transactions and can be rated\n    // by those who paid the transactions.\n    struct Seller {\n      // Seller information\n      address etherAddress; // The sellers ether address.\n      uint[] ratingIds; // The ids of the rating linked with this seller.\n      uint[] transactionIds; // The ids of transactions linked with this seller.\n      \n      // Statistics about the seller\n      uint averageRating; // Average value of ratings.\n      uint transactionsPaid; // How many transactions have been paid?\n      uint transactionsRated; // How many transactions have been rated?\n    }\n\n    Transaction[] public transactions; // All transactions.\n    Seller[] public sellers; // All sellers\n\n    // This mapping makes it easier to loopkup the seller that belongs to a certain address.\n    mapping (address => uint) sellerLookup;\n\n    // The sole contract owner.\n    address public owner;\n\n    // Configured fees.\n    uint public registrationFee;\n    uint public transactionFee;\n\n    // Only owner administration flag.\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // Administrative functions.\n    function TrustEth() {\n      owner = msg.sender;\n      \n      // Index 0 is a marker for invalid ids.\n      sellers.length = 1;\n      transactions.length = 1;\n\n      // Initialize fees.\n      registrationFee = 1 ether;\n      transactionFee = 50 finney;\n    }\n\n    function retrieveFunds() onlyowner {\n      owner.send(this.balance);\n    }\n\n    function adjustRegistrationFee(uint fee) onlyowner {\n      registrationFee = fee;\n    }\n\n    function adjustTransactionFee(uint fee) onlyowner {\n      transactionFee = fee;\n    }\n\n    function setOwner(address _owner) onlyowner {\n      owner = _owner;\n    }\n\n    // Fallback function, do not accepts payments made directly to this contract address.\n    function() {\n      throw;\n    }\n\n    // Make a donation and acknowledge our development efforts. Thank you!\n    function donate() {\n      // That's awesome. Thank you.\n      return;\n    }\n\n    // Register your seller address for a small fee to prevent flooding and\n    // and recurring address recreation.\n    function register() {\n      // Retrieve the amount of ethers that have been sent along.\n      uint etherPaid = msg.value;\n      \n      if(etherPaid < registrationFee) { throw; }\n\n      // Create a new seller.\n      uint sellerId = sellers.length;\n      sellers.length += 1;\n\n      // Store seller details and bind to address.\n      sellers[sellerId].etherAddress = msg.sender;\n      sellers[sellerId].averageRating = 0;\n\n      // Save sellerId in lookup mapping.\n      sellerLookup[msg.sender] = sellerId;\n    }\n\n\n    // Workflow\n\n    // As a seller, put up a transaction.\n    function askForEther(uint amount) {\n      // Lookup the seller.\n      uint sellerId = sellerLookup[msg.sender];\n\n      // Check whether the seller is a registered seller.\n      if(sellerId == 0) { throw; }\n      \n      // Create a new invoice.\n      uint transactionId = transactions.length;\n      transactions.length += 1;\n\n      // Fill out seller info.\n      transactions[transactionId].sellerId = sellerId;\n      transactions[transactionId].amount = amount;\n\n      // -> Pass transactionId to customer now.\n    }\n\n    // As a buyer, pay a transaction.\n    function payEther(uint transactionId) {\n      // Bail out in case the transaction id is invalid.      \n      if(transactionId < 1 || transactionId >= transactions.length) { throw; }\n\n      // Retrieve the amount of ethers that have been sent along.\n      uint etherPaid = msg.value;\n      uint etherAskedFor = transactions[transactionId].amount;\n      uint etherNeeded = etherAskedFor + transactionFee;\n\n      // If the amount of ethers does not suffice to pay, bail out :(      \n      if(etherPaid < etherNeeded) { throw; }\n\n      // Calculate how much has been overpaid.\n      uint payback = etherPaid - etherNeeded;\n      // ..and kindly return the payback :)\n      msg.sender.send(payback);\n\n      // Now take the remaining amount and send to the seller.\n      sellers[transactions[transactionId].sellerId].etherAddress.send(etherAskedFor);\n      // Rise transactions paid counter.\n      sellers[transactions[transactionId].sellerId].transactionsPaid += 1;\n\n      // Overpaid ethers send back, seller has been paid, now we're done.\n      // Mark the transaction as finished.\n\n      // Flag the invoice as paid.\n      transactions[transactionId].paid = true;\n      // Save the payers address so he is eligible to rate.\n      transactions[transactionId].paidWithAddress = msg.sender;\n    \n      // -> Now the transaction can be rated by the address that has paid it.\n    }\n\n    // As a buyer, rate a transaction.\n    function rate(uint transactionId, uint ratingValue, string ratingComment) {\n      // Only the address that has paid the transaction may rate it.\n      if(transactions[transactionId].paidWithAddress != msg.sender) { throw; }\n      // Bail out in case the transaction id is invalid.        \n      if(transactionId < 1 || transactionId >= transactions.length) { throw; }\n      // Oops, transaction has already been rated!\n      if(transactions[transactionId].rated) { throw; }\n      // Oops, transaction has not been paid yet and cannot be rated!\n      if(!transactions[transactionId].paid) { throw; }\n      // Rating range is from 1 (incl.) to 10 (incl.).\n      if(ratingValue < 1 || ratingValue > 10) { throw; }\n\n      transactions[transactionId].ratingValue = ratingValue;\n      transactions[transactionId].ratingComment = ratingComment;\n      transactions[transactionId].rated = true;\n      \n      uint previousTransactionCount = sellers[transactions[transactionId].sellerId].transactionsRated;\n      uint previousTransactionRatingSum = sellers[transactions[transactionId].sellerId].averageRating * previousTransactionCount;\n\n      sellers[transactions[transactionId].sellerId].averageRating = (previousTransactionRatingSum + ratingValue) / (previousTransactionCount + 1);\n      sellers[transactions[transactionId].sellerId].transactionsRated += 1;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1722391,0x4ed65e408439a7f6459b5cfbd364f373bd6ed5f7,false,false,"contract PRNG_Challenge {\n\n    // PRIVATE VARIABLES\n    address private admin;\n    uint256 private constant min_value = 100 finney; // 0.1 ETH\n    \n    // PUBLIC VARIABLES\n    uint256 public constant lucky_number = 108435827775939881852079940206236050880764931249577763315065068000725104274235;\n    uint256 public last_number;\n    uint256 public attempts;\n    address public winner;\n    \n    // EVENTS\n    event Attempt(address Participant, uint256 Number);\n    event Winner(address Winner_Address, uint256 Amount);\n\n    // CONSTRUCTOR\n    function PRNG_Challenge()\n        private\n    {\n        admin = msg.sender;\n        last_number = 0;\n        attempts = 0;\n        winner = 0;\n    }\n\n    // MODIFIERS\n    modifier only_min_value() {\n        if (msg.value < min_value) throw;\n        _\n    }\n    modifier only_no_value() {\n        if (msg.value != 0)  throw;\n        _\n    }\n    modifier only_admin() {\n        if (msg.sender != admin) throw;\n        _\n    }\n    modifier not_killed() {\n        if (winner != 0) throw;\n        _\n    }\n    \n    // CHALLENGE\n    function challenge()\n        private\n    {\n        address participant = msg.sender;\n        uint64 shift_32 = uint64(4294967296); // Shift by 32 bit\n        uint32 hash32 = uint32(sha3(msg.value,participant,participant.balance,block.blockhash(block.number-1),block.timestamp,block.number)); // Entropy\n        uint64 hash64 = uint64(hash32)*shift_32 + uint32(sha3(hash32));\n        uint96 hash96 = uint96(hash64)*shift_32 + uint32(sha3(hash64));\n        uint128 hash128 = uint128(hash96)*shift_32 + uint32(sha3(hash96));\n        uint160 hash160 = uint160(hash128)*shift_32 + uint32(sha3(hash128));\n        uint192 hash192 = uint192(hash160)*shift_32 + uint32(sha3(hash160));\n        uint224 hash224 = uint224(hash192)*shift_32 + uint32(sha3(hash192));\n        uint256 hash256 = uint256(hash224)*shift_32 + uint32(sha3(hash224));\n        if (hash256 == lucky_number) {\n            Winner(participant, this.balance);\n            if (!participant.send(this.balance)) throw;\n            winner = participant;\n        }\n        last_number = hash256;\n        attempts++;\n        Attempt(participant, last_number);\n    }\n    \n    // KILL\n    function admin_kill()\n        public\n        not_killed()\n        only_admin()\n        only_no_value()\n    {\n        if (!admin.send(this.balance)) throw;\n        winner = admin;\n    }\n    \n    // DEFAULT FUNCTION\n    function()\n        public\n        not_killed()\n        only_min_value()\n    {\n        challenge();\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1722500,0x5b2a5ed90f07065f8d9dd346611b3f38b7630d84,false,false,,,,TOO_SHORT
1722635,0x3cc5e71a33f08445e3935109db7dedd83b9a248d,false,false,,,,TOO_SHORT
1722749,0x9768c6e1f43f4e6473134016aada2e9ebb7b9b85,false,false,,,,TOO_SHORT
1722834,0xdffcaa922091d4910cac042bb799971e2d2936bf,false,false,,,,TOO_SHORT
1722839,0x3e6f92fc3a6d56fdc91c851669b2f6bd67a64ea5,false,false,,,,TOO_SHORT
1722870,0x38d4e95de3511026e822f337fe94043882e57af8,false,false,,,,TOO_SHORT
1722898,0xc5c89d72c5b5aaf520dfe993d53dadc71636198d,false,false,,,,TOO_SHORT
1722994,0xdb1eab417bbd50721b6b8423dd433138cbc0f49a,false,false,,,,TOO_SHORT
1722996,0x85fdc336c3d20039b1facd71420c6aaab5d4ea1e,false,false,,,,TOO_SHORT
1723276,0x9c0e4c5af0faf62d3f33a59b14b787242e2b775b,false,false,,,,TOO_SHORT
1723370,0x683c53084d997e6056c555f85f031f8317e26c2b,false,false,"/* \nMicroDAO V0.0.2 - <me@thorsten-zoerner.com>\n===========================================================\nSimplified DAO allowing to do initial funding.\n- Funders are able to specify how long to keep funds in.\n- If funding is not closed by this time fundes returned\n- Close funding is a manual taken by the director\n\nSingle Director\n- Has the possibility to file SpendingRequest\n- allowed to change fundamental parameters\n- allowed to move directorship forward\n- deadman switch prevents lost DAO.\n\nEach Spending needs to be approved by share holders (Vote)\n- spendings have a time to vote\n- spendings require to be executed in a given number of days\n\n- Checked for recursive withdraw bug (DAO Hack) \n*/\n\ncontract SpendingRequest {\n	string public name=""SpendingRequest 4 MicroDAO"";\n	 address public creator;\n	 string public description;\n	 uint256 public request_until;\n	 uint256 public vote_until;\n		\n	 option[] public  options;\n 	 address public dao;\n	 mapping(address=>bool) public voted;\n	 bool public voting_started;\n	 bool public executed;\n	 address public result_payto;\n	 uint256 public result_amount;\n	 uint256 public result_votes;\n	\n	struct option {\n		string description;\n		address payout_to;\n		uint256 eth_amount;		\n		uint256 votes_pro;\n		uint256 votes_veto;\n	}\n	\n	function SpendingRequest () {\n		creator=msg.sender;\n	}\n	\n	function setDescription(string _description) {\n		if(voting_started) throw;\n		description=_description;		\n	}\n	\n	function setDAO(address _dao) {\n		if(msg.sender!=creator) throw;\n		if(voting_started) throw;\n 		if(dao!=0) throw;\n		MicroDAO d = MicroDAO(_dao);\n		if(d.balanceOf(creator)<1) throw;\n		dao=_dao;		\n	}\n	\n	function execute(){\n		if(vote_until>now) return;\n		if(request_until<now) return;\n		if((msg.sender!=dao)&&(msg.sender!=creator)) throw;\n		for(var i=0;i<options.length;i++) {\n			if(options[i].votes_pro-options[i].votes_veto>result_votes) {\n				result_payto=options[i].payout_to;\n				result_amount=options[i].eth_amount;\n				if(options[i].votes_veto>options[i].votes_pro) result_votes=0; else \n				result_votes=options[i].votes_pro-options[i].votes_veto;\n			}\n		}\n		executed=true;		\n	}\n	\n	function vote(uint256 option,bool veto) {		\n		if(voted[msg.sender]) throw;\n		if(now<vote_until) throw;\n		voting_started=true;\n		MicroDAO d = MicroDAO(dao);\n		if(!veto) options[option].votes_pro+=d.balanceOf(msg.sender);	else options[option].votes_veto+=d.balanceOf(msg.sender);\n		\n		d.blockTransfer(msg.sender,vote_until);\n	}\n	function setRequestUntil(uint8 days_from_now) {\n		if(msg.sender!=creator) throw;\n		if(voting_started) throw;\n		request_until=now+(86400*days_from_now);		\n	}\n	function setVotetUntil(uint8 days_from_now) {\n		if(msg.sender!=creator) throw;\n		if(voting_started) throw;\n		vote_until=now+(86400*days_from_now);		\n	}\n	function addOption(string _description,address _payout_to,uint256 _amount) {\n		if(msg.sender!=creator) throw;\n		if(voting_started) throw;\n		options.push(option(_description,_payout_to,_amount,0,0));\n	}	\n}\ncontract MicroDAO\n{\n	string public directorNode;\n	address public director;\n	string public directorName;\n	string public directorJurisdication;\n	bool public initialFunding;	\n	uint256 public sharesRaised;\n	uint public lockInDays;	\n	string public name =""MicroDAO"";\n	string public symbol =""E/"";\n	uint256 public fundingGoal;\n	uint256 public balanceFinney;\n	uint256 public directorLockUntil;\n	uint256 public directorLockDays;\n	uint256 public directorTransferShareRequired;\n	mapping (address => uint256) public balanceOf;		\n	mapping (address => uint256) public fundsExpire;\n	mapping (address => uint256) public blockedtransfer;\n	\n	\n	address[] public funders;\n	SpendingRequest[]  public allowances;\n	struct booking {\n		uint256 time;\n		uint256 funding;\n		uint256 spending;\n		address counterpart;\n		string text;\n	}\n	booking[] public bookings;\n	\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	\n	function MicroDAO() {\n		initialFunding=true;\n		director=msg.sender;	\n		directorLockUntil=now+(86400*30);		\n	}\n	function setDirectorNode(string node) {\n		if(msg.sender!=director) throw;\n		directorNode=node;\n		directorLockUntil=now+(86400*directorLockDays);\n	} \n	\n	function blockTransfer(address a,uint256 until) {\n		bool found=false;\n		for(var i=0;((i<allowances.length)&&(found==false));i++) {\n			if(allowances[i]==msg.sender) found=true;\n		}\n		if(found) {\n			if(blockedtransfer[a]>until) {\n				blockedtransfer[a]=until;\n			}\n		}\n	}\n	\n	function setDirectorLock(uint256 number_of_days,uint256 requiredShares) {\n		if(msg.sender!=director) throw; \n		if(requiredShares>sharesRaised) throw;\n		if(number_of_days>365) number_of_days=365;\n		\n		\n		directorLockDays=number_of_days;\n		directorTransferShareRequired=requiredShares;\n	}\n	\n	function transferDirector(address director) {\n		// Dead Director check ...		\n		if(msg.sender==director) {\n			director=director;\n			directorName="""";\n			directorJurisdication="""";\n			initialFunding=true;\n		} else if((now>directorLockUntil)&&(balanceOf[msg.sender]>directorTransferShareRequired)) {\n			director=msg.sender;\n			directorName="""";\n			directorJurisdication="""";\n			initialFunding=true;\n		}\n	}\n	function setdirectorName(string name) {\n		if(msg.sender!=director) throw;\n		if(!initialFunding) throw;\n		directorName=name;\n	}\n	\n	function setFundingGoal(uint256 goal) {\n		if(msg.sender!=director) throw;\n		fundingGoal=goal;\n	}\n	\n	function setInitialLockinDays(uint number_of_days) {\n		if(msg.sender!=director) throw;\n		lockInDays=number_of_days;\n	}\n	\n	\n	function setJurisdication(string juri) {\n		if(msg.sender!=director) throw;\n		if(!initialFunding) throw;\n		directorJurisdication=juri;\n	}\n	\n	function addSpendingRequest(address spendingRequest) {\n		if(msg.sender!=director) throw;	\n		SpendingRequest s = SpendingRequest(spendingRequest);		\n		if(s.executed()) throw;\n		if(s.vote_until()<now) throw; \n		allowances.push(s);		\n	}\n	\n	function executeSpendingRequests() {\n		for(var i=0;i<allowances.length;i++) {\n			SpendingRequest s =SpendingRequest(allowances[i]);\n			if(!s.executed()) {\n				if((s.vote_until()<now)&&(s.request_until()>now)) {\n					s.execute();\n					directorLockUntil=now+(86400*directorLockDays);\n					if(s.result_amount()>0) {\n						if(s.result_payto()!=0) {\n							s.result_payto().send(s.result_amount()*1 ether);\n							bookings.push(booking(now,0,s.result_amount()*1 ether,s.result_payto(),""Executed SpendingRequest""));\n						}\n					}\n				}\n			}\n		}\n	}\n	\n	function myFundsExpireIn(uint256 number_of_days) {\n		var exp=now+(86400*number_of_days);\n		if(exp>fundsExpire[msg.sender]) fundsExpire[msg.sender]=exp; else throw;\n	}\n		\n	function closeFunding() {\n		if(msg.sender!=director) throw;\n		initialFunding=false;		\n		checkExpiredfunds();		\n	}\n	\n	function checkExpiredfunds() {\n		if(!initialFunding) return;\n		for(var i=0;i<funders.length;i++) {\n			if((fundsExpire[funders[i]]>0)&&((fundsExpire[funders[i]]<now))) {\n				var amount=balanceOf[funders[i]]*1 finney;				\n				Transfer(funders[i],this,balanceOf[funders[i]]);\n				sharesRaised-=balanceOf[funders[i]];\n				balanceOf[funders[i]]=0;\n				funders[i].send(amount);				\n			}\n		}\n	}\n	\n	function transfer(address _to, uint256 _value) {\n		if(blockedtransfer[msg.sender]>now) throw;\n		if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n		if(balanceOf[_to]==0) {\n			funders.push(_to);\n		}\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	\n	function() {	\n		 var funding_type=""Incomming"";			\n			var finneys=msg.value/1 finney;\n			if(initialFunding) {\n				\n				if(balanceOf[msg.sender]==0) {\n					funders.push(msg.sender);\n				}		\n				if(msg.value<100 finney) throw;\n				\n				fundsExpire[msg.sender]=now+(lockInDays*86400);\n				balanceOf[msg.sender]+=finneys;\n				Transfer(this,msg.sender,finneys);\n				sharesRaised+=finneys;\n				funding_type=""Initial Funding"";\n			}\n			bookings.push(booking(now,msg.value,0,msg.sender,funding_type));\n			balanceFinney=this.balance/1 finney;\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1723401,0x4851d069d64964c1afffd3b8a60a9dfd215ea362,false,false,,,,TOO_SHORT
1723804,0xad951be7ff90580d539c6b3eec899aec57e400a7,false,false,,,,TOO_SHORT
1723826,0xc919e9ba27bb93cdb2e64f02762df0d1b6a0d836,false,false,,,,TOO_SHORT
1724090,0x5da0a0a878f36cac1f4dc6e649f381a87805143e,false,false,,,,TOO_SHORT
1724380,0x5977999d63be7db8cca9e8e3a9f8c8862abefdfc,false,false,,,,TOO_SHORT
1724523,0x2764d164f1d02c6afd7afbee4747505e23fdc442,false,false,,,,TOO_SHORT
1724878,0x2df7beac163b4f9fd8fa3b8eb84dae17f5cd82bc,false,false,,,,TOO_SHORT
1725215,0x6d6c27058b6f97743d66ca97dfaa16a637ad26f5,false,false,,,,TOO_SHORT
1725239,0x1920e39e607bc4d9c1ed74187eff353993d9fc20,false,false,,,,TOO_SHORT
1725585,0x840038b9c0c1ec4974d444bc42fb77f897992f78,false,false,,,,TOO_SHORT
1725661,0x52272e3763ca53eace0c47efe0d541a355564c92,false,false,,,,TOO_SHORT
1725847,0x861cad8aa8e298575f5bd9b07a379d385571cc4f,false,false,,,,TOO_SHORT
1725980,0x0c9690feb294f07f9eb10f025395f9ab1ba68b51,false,false,,,,TOO_SHORT
1726184,0xfdc27687ff92a9a72c9aab9a284679b55790bb2f,false,false,,,,TOO_SHORT
1726251,0xacad7a2c3d920dd379809a566ea53da0a7b2b58e,false,false,,,,TOO_SHORT
1726282,0xecf25a7d7d8ebcc22a6bd2909b36d5905bfbb457,false,false,,,,TOO_SHORT
1726565,0xf7c79c978612f8248a3f4cf4b66cf1b1c82fd647,false,false,,,,TOO_SHORT
1726984,0x8897b411d58bead34c3c71514ff90ebd3a82a397,false,false,,,,TOO_SHORT
1726996,0x84a2e18fb71a640a6bf5506cf87a136f495e41a2,false,false,,,,TOO_SHORT
1727280,0xb8c6daa2a231dc7088fb41531a5bd29d79b02d35,false,false,,,,TOO_SHORT
1727318,0xb5d0e18263f8d8bc99b4f6fcc797ce3c6f1bd532,false,false,,,,TOO_SHORT
1727430,0x655f01313bb55c04e8ed36a5098984f3f3de57bc,false,false,"contract RNG {\n    mapping (address => uint) nonces;\n    uint public last;\n    function RNG() { }\n    function RandomNumber() returns(uint) {\n        return RandomNumberFromSeed(uint(sha3(block.number))^uint(sha3(now))^uint(msg.sender)^uint(tx.origin));\n    }\n    function RandomNumberFromSeed(uint seed) returns(uint) {\n        nonces[msg.sender]++;\n        last = seed^(uint(sha3(block.blockhash(block.number),nonces[msg.sender]))*0x000b0007000500030001);\n        GeneratedNumber(last);\n        return last;\n    }\n    event GeneratedNumber(uint random_number);\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1727467,0x40b803a9abce16f50f36a77ba41180eb90023925,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1727467,0xaa67165f85949d6d73db62b774235fa736ee5de6,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1727467,0x86067efb0781fae9a6f62c38d508550574957900,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1727467,0x5524c55fb03cf21f549444ccbecb664d0acad706,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1727533,0xaed5a41450b38fc0ea0f6f203a985653fe187d9c,false,false,"contract RNG {\n    mapping (address => uint) nonces;\n    uint public last;\n    function RNG() { }\n    function RandomNumber() returns(uint) {\n        return RandomNumberFromSeed(uint(sha3(block.number))^uint(sha3(now))^uint(msg.sender)^uint(tx.origin));\n    }\n    function RandomNumberFromSeed(uint seed) returns(uint) {\n        nonces[msg.sender]++;\n        last = seed^(uint(sha3(block.blockhash(block.number),nonces[msg.sender]))*0x000b0007000500030001);\n        GeneratedNumber(last);\n        return last;\n    }\n    event GeneratedNumber(uint random_number);\n    event RandomNumberGuessed(uint random_number, address guesser);\n    function Guess(uint _guess) returns (bool) {\n        if (RandomNumber() == _guess) {\n            if (!msg.sender.send(this.balance)) throw;\n            RandomNumberGuessed(_guess, msg.sender);\n            return true;\n        }\n        return false;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1727538,0x0de29d9172471051e5970ac3d46682e1661510a2,false,false,,,,TOO_SHORT
1727749,0x7808c648650416a82267b854b51a744b16a3f609,false,false,,,,TOO_SHORT
1727845,0x10dbd4a835f603b3290f154db4ad5b51824561f5,false,false,,,,TOO_SHORT
1727959,0x63681ee8d699b32671ffc07b71948c1cef9dfdf4,false,false,,,,TOO_SHORT
1728009,0x06d917c61c9e3583585c8fc392f2204f2d8c498e,false,false,,,,TOO_SHORT
1728103,0x15ab8ede871ea0110e5a94b8524953ce35489e58,false,false,,,,TOO_SHORT
1728159,0xf14848641167345580a847d1646f7fc40f9f6cc8,false,false,,,,TOO_SHORT
1728196,0x8c133e0c5aee8dd1cb3c069c1086321db5cbb19f,false,false,,,,TOO_SHORT
1728478,0x16a178b0a1dca63dba678cbd3675a5c07c1a0df8,false,false,,,,TOO_SHORT
1728479,0x94f9a8c4ce8860efc5e29a03e9302f7805ea1d30,false,false,,,,TOO_SHORT
1728486,0x65f6080e9d7984bf12e0c716d55654f344d1f2b6,false,false,,,,TOO_SHORT
1728600,0x23b75c2f6791eef49c69684db4c6c1f93bf49a50,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1728600,0x8ea02c914cd247da87717c763e92cd20d44efccc,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1728600,0x1ca0f352b6acf032efb79cd00d1bec22128af790,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1728600,0x21c7fdb9ed8d291d79ffd82eb2c4356ec0d81241,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1728724,0x27b137a85656544b1ccb5a0f2e561a5703c6a68f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1728724,0xbe8d4701afb4fdb7a30a92f8e32f09cad185c019,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1728724,0xb383d330326f9e370eada557ad4fce6963b55af5,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1728724,0x9c15b54878ba618f494b38f0ae7443db6af648ba,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1728781,0x9a5444ab39473092dd43dcdbc735d37bd102ddc5,false,false,,,,TOO_SHORT
1728816,0xf1b0a018bfd6d63c520f6fa28eb9d318ed0ad843,false,false,,,,TOO_SHORT
1728867,0x969de3b86a64c3b2a35e7ff16c0a007084b7de53,false,false,,,,TOO_SHORT
1729083,0xa6bf2931379380d582a282b40202ae5b12a0f6ba,false,false,,,,TOO_SHORT
1729084,0x9265b1aab3a8424dd6028263f13fb735ffceb379,false,false,,,,TOO_SHORT
1729229,0xcde86569ee0c998f201964377ce54785cf6aa493,false,false,,,,TOO_SHORT
1729258,0x305c165b24980cf996e5ea848fe3a90260631287,false,false,,,,TOO_SHORT
1729306,0x4c1dad49630aed36e84349cc32cecf63419cda49,false,false,,,,TOO_SHORT
1729576,0x61872ab73f242940c4cb7fdc9cb86dbeb7bee20b,false,false,,,,TOO_SHORT
1729723,0x6b78e5e51534df54398dade2dd61387e07c5ab73,false,false,,,,TOO_SHORT
1730564,0x7dacea65de63bee283754687e5bbb36c9d8f9b08,false,false,,,,TOO_SHORT
1730795,0xe9da19ec1c3fa8a7a39e6b4abe51eb16aed936d3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1730795,0xadf80daec7ba8dcf15392f1ac611fff65d94f880,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1730795,0x65933251b9bad005f6ccc7530a6490395b8df660,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1730795,0xacd87e28b0c9d1254e868b81cba4cc20d9a32225,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1730957,0xcfc7bbd6b8ef2a081fb66013e6d43b61211bdd02,false,false,,,,TOO_SHORT
1731183,0x607332aae234994c250f166a4493862aabbddd38,false,false,,,,TOO_SHORT
1731625,0xdc1031d0614351e793e43b3afa8ed6698bbe9b7b,false,false,,,,TOO_SHORT
1731698,0x645e82d3737293628e50494e7db488a8c625b27b,false,false,,,,TOO_SHORT
1731810,0x26086f327503aa043e98b5db92bac33d4d33586b,false,false,,,,TOO_SHORT
1732011,0x4a4d6ef1b48c104dc463615646882edfed1c0546,false,false,,,,TOO_SHORT
1732109,0xb924a985f1b9f8d8d254431c93f5b4c9dc7de031,false,false,,,,TOO_SHORT
1732364,0xb94e237da5c3cd7a6696ef2080feb99dff58768e,false,false,,,,TOO_SHORT
1732408,0x17802f43a0137c506ba92291391a8a8f207f487d,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1732408,0x0bf4315220c938d59229de19b6c2a8b4144cda36,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1732408,0x3f2dffe22d23e4a9124c5b13258ec3044481d997,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1732408,0xfe24cdd8648121a43a7c86d289be4dd2951ed49f,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1732657,0x00b7793ad81a3876ce4eb72ac8cc9a297d02c653,false,false,,,,TOO_SHORT
1732729,0x0783fe78726c195a04940a21a1f4a4cad4cff6a2,false,false,,,,TOO_SHORT
1732810,0xd1062fca8c117f38c357d2950abbc891d7f2140e,false,false,,,,0xb8869c5f264739dde064941c372c551ec47aab44
1732827,0xd2c42f687844c2ed99978775371e12e308317b09,false,false,,,,TOO_SHORT
1732829,0x86af3e9626fce1957c82e88cbf04ddf3a2ed7915,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1732829,0xc4c67529e8f91394f5f705feb74c51d3c69c2746,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1732829,0x8594bcddf141b733af386b840a636e38fb1d7abe,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1732829,0x253488078a4edf4d6f42f113d1e62836a942cf1a,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1732907,0x632fbfdcab1a83e37a9809b9d837d5f573801878,false,false,,,,TOO_SHORT
1732908,0x982c34d4fe5d98ac8effef7924e33cc4e3d25888,false,false,,,,TOO_SHORT
1732989,0x43050983d1ebb0a9f2e48feac8827ccd981b6ba4,false,false,,,,TOO_SHORT
1733148,0x00455a042fba2d2dfb892ca2248e2c670a571f35,false,false,,,,TOO_SHORT
1733297,0x8e5918cc51482b9c77b96509ce567454f30b3345,false,false,,,,TOO_SHORT
1733413,0x80b0b26b90d8f2612c6926a302d39d782b45074c,false,false,,,,TOO_SHORT
1733553,0x38cf74e8b67567a337b1e2aa9195fb41ec08d673,false,false,,,,TOO_SHORT
1733790,0x3446d82d71a32cd2b2a98b728a7d1ea13536d2af,false,false,,,,TOO_SHORT
1733996,0x68303ecbcd55f5dbb7251af77d9e91019a7ff9ee,false,false,,,,TOO_SHORT
1734030,0x81cabec5b3bc30cd5c4f6ccdba8492e7fabf3715,false,false,,,,TOO_SHORT
1734048,0xdd740a7858f2cc6bef18092cf04bfca59989ebb4,false,false,,,,TOO_SHORT
1734278,0x6aa3005eb67b875005a33eeac44b81c05f0625a7,false,false,,,,TOO_SHORT
1734305,0x6e7f56201a8c53fae080a22fa652e2df9ebeaa80,false,false,,,,TOO_SHORT
1734329,0x4de2372fbfda6a27ab9a1429c22041f53c6d8f0b,false,false,contract storadge {\n    event log(string description);\n	function save(\n        string mdhash\n    )\n    {\n        log(mdhash);\n    }\n},1,標準的なイベントログ機能を持つシンプルなスマートコントラクト。,
1734373,0xce1555c4fc4ddc2d87183d1a36e0a410e565624d,false,false,,,,0x4de2372fbfda6a27ab9a1429c22041f53c6d8f0b
1734430,0xa2c4fa82de60df89968977d109598ee9816c5ee8,false,false,,,,TOO_SHORT
1734604,0xe45013e20e8286fae8d611365056d3fd89b7c344,false,false,,,,TOO_SHORT
1734694,0x9a4fe7ad305ae59fc1337948a494f08a510e64b0,false,false,,,,TOO_SHORT
1734695,0x6ebdbb1cc79cc512da4696b47bdab6538c73d60c,false,false,,,,TOO_SHORT
1734811,0x890c315682d15bf59e24769ade3242e6e72b4472,false,false,,,,TOO_SHORT
1734812,0xbcd00e580000cd3c260e48e2617b32d624426235,false,false,,,,TOO_SHORT
1734834,0xd66e310ec34d289f25af55c082095ef83223c93b,false,false,,,,TOO_SHORT
1735080,0xca544e5c4687d109611d0f8f928b53a25af72448,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1735080,0x1dfebe4e457cb5fc0ea5789e7c4719b2f4bf1be4,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1735080,0x559874c56172f22be29e33ed42510fcfcb184c30,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1735080,0xf14c14075d6c4ed84b86798af0956deef67365b5,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1735142,0xd818350cae2002758d2339fe8ac605e9053c8987,false,false,,,,TOO_SHORT
1735258,0xda25af2977ed174d8fd568b99ebd52ff8e228c4a,false,false,,,,TOO_SHORT
1735544,0x6d8406f9361e0942514e36965c696dae175565ee,false,false,,,,TOO_SHORT
1735861,0x7a52e5b8e289640294a2c181b59acef7526b4f84,false,false,,,,TOO_SHORT
1736048,0x115fe158f4623eafe65058215ef96c100bdad594,false,false,,,,TOO_SHORT
1736270,0x4bd57ef9015475532f35d8137d9fe1844a4d4932,false,false,,,,TOO_SHORT
1736369,0x040f19cf2800a8667af11084b134bf9e940998e7,false,false,,,,TOO_SHORT
1736370,0x56b426dc5908010030b7082a1a16dc578a421577,false,false,,,,TOO_SHORT
1736372,0x641405014f27f9ba29d94948517d8de3391a7c00,false,false,,,,TOO_SHORT
1736374,0x23ac8aa3e1b28750059261635630d67a5dd8a83c,false,false,,,,TOO_SHORT
1736375,0x6e0dd092039dc641eb3398e5a56d47aaf5b67d55,false,false,,,,TOO_SHORT
1736377,0x1af186e5be9ecbaf24147fdf99ba657825388f6f,false,false,,,,TOO_SHORT
1736851,0x89dc17a17bda390901c2be1ba1aace14436397cc,false,false,,,,TOO_SHORT
1736908,0x34fe1d7efe62a423b92c67c4b505bde28fc085fe,false,false,,,,TOO_SHORT
1736990,0x811ab7df75f19ddb0ef6a2e3dd17541499d909ba,false,false,,,,TOO_SHORT
1737156,0xad045ff8220fd9b21cba2ab94b6476aacd2c0c0c,false,false,,,,TOO_SHORT
1737235,0x0e075c7383901e9003a6b056427915582a6d819b,false,false,,,,TOO_SHORT
1737478,0xdb2f5d78779cb44c9b096809ffa04f2e1d50166c,false,false,,,,TOO_SHORT
1737542,0xbe79292e029668f1f621c05c79f194db0ddfd79d,false,false,,,,TOO_SHORT
1737659,0xbe7912dd8594f968f60a31e746818260d39280ed,false,false,,,,TOO_SHORT
1737661,0xba2695d1a7837193764a0b1dceb9dc4242bb03bb,false,false,,,,TOO_SHORT
1737859,0xd5158e9d06116e9f38fb4258f12a12414d93a109,false,false,,,,TOO_SHORT
1738120,0x769153f55b2860127885b2017b9ef4a761cfc5d3,false,false,,,,TOO_SHORT
1738251,0x009a6c49f4162e5abf85ac01b8c8b0130aec3b2c,false,false,,,,TOO_SHORT
1738259,0x1c2b1a054aed89161b79a3b6e12279a8db9bfa95,false,false,,,,TOO_SHORT
1738352,0x99d2896070b5eb03603b61fada033b8b4a796ba1,false,false,,,,TOO_SHORT
1738514,0x709691ea33c5e6555dda67412590abf3a92c2317,false,false,,,,TOO_SHORT
1738524,0xbccc852f2a6e5a708f9ef49b9745462e16b1e75b,false,false,,,,TOO_SHORT
1738538,0x05b3634f78cdedc0c8a47014222d150daf1e6668,false,false,,,,TOO_SHORT
1738567,0xc5fff24bf55a9621eeef6083669134f4e9004da0,false,false,,,,TOO_SHORT
1738627,0x465f8fe7c3673881784857e15aaf47f6adfc8347,false,false,,,,TOO_SHORT
1738886,0xc1b448e4e1df434680bb1658dc4fa1dd2d173e3a,false,false,,,,TOO_SHORT
1738946,0x0b2c96fef968a033aec3d89f5539ad676b6c2163,false,false,,,,TOO_SHORT
1739260,0x230a1750986d93c352580a35b02be56e6e7212cd,false,false,,,,TOO_SHORT
1739296,0x103fbc4a24a498b0d2f3344722663aadafc44e88,false,false,,,,TOO_SHORT
1739337,0xbf3776aea58bfe86ff0f2f6b4ca8f211250a96ce,false,false,,,,TOO_SHORT
1739380,0x1ef04c1a3175ce6f1adc676a9f31eaf8ffad509b,false,false,,,,TOO_SHORT
1739412,0x6710cb91f5cfb63f46a793468e62acc336bb90b6,false,false,,,,TOO_SHORT
1739874,0x29b9da10da6774caf011f9d4ab50d0cd84f11d6f,false,false,,,,TOO_SHORT
1739878,0xb2c6f0dfbb716ac562e2d85d6cb2f8d5ee87603e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1739878,0x9c632ecb1d3ebec119429ad32c71aaa60be5b045,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1739878,0x56b96fb9bf75470bf3fc40554c9f0cbd54b20a62,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1739878,0x6d87578288b6cb5549d5076a207456a1f6a63dc0,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1739930,0x4c30e11b30432cd465a4917a39c119e70bdc2a86,false,false,,,,TOO_SHORT
1740168,0x566bc7570a9cd6dffdf9fff7c4b068bfe47f94ba,false,false,,,,TOO_SHORT
1740359,0x1da0703b76c2ee402af622bef4ee93a437431809,false,false,,,,TOO_SHORT
1740418,0xb850ee329fa818669156916f8d2af51005c6ad39,false,false,,,,TOO_SHORT
1740479,0x0365cc946c9b9e64e5df48e8529e283d40e3fd3e,false,false,,,,TOO_SHORT
1740602,0x1241b6767b2595694766b24c294e5aff28cfef43,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1740656,0x116354ceff98d4522b5be400362a633169ea1bad,false,false,,,,TOO_SHORT
1740686,0xf55dfb9f2f09dda7c4c5142f95348af4a8b36789,false,false,,,,TOO_SHORT
1740703,0x7104504f15ff554539e1f58ea0bc0b9fda953d41,false,false,,,,TOO_SHORT
1740707,0x6b93552904a5920e67950605816d1becffdd65e4,false,false,,,,TOO_SHORT
1740763,0x87dfb4c8cc15ad9c94e3136d30e90c358b785a41,false,false,,,,TOO_SHORT
1740803,0xad5967ec3677eb1d92b28dccb1ed197a1ee3de66,false,false,,,,TOO_SHORT
1740823,0xe0d50a45f54d01e62722c721169ca22953274e7d,false,false,,,,TOO_SHORT
1740875,0x71b13e461fec7debcd856a398a86ee86525cdc73,false,false,,,,TOO_SHORT
1741010,0x8559428976f8803fc1e82316ee25f0da317ffc16,false,false,,,,TOO_SHORT
1741192,0xb2875fcdb230eb9eda70c76aa5ee34688e37a0be,false,false,,,,TOO_SHORT
1741638,0xd7d25572c3f858dfa83aa921efc800ba17ec7e34,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1742116,0xa63cda3005c56fd001cc3c4bb92d5361670a0794,false,false,,,,TOO_SHORT
1742282,0x3b5af30c768d3c7069d58be83204a6624a5f7a60,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1742576,0x4e6a095a85278273fc00d4b0c96d15d72b970dcd,false,false,,,,TOO_SHORT
1742577,0x46819ac37961b2445fe63ddaf9eb9897a756c63e,false,false,,,,TOO_SHORT
1742578,0x19c084d8a6ad7016bba1c9e222866a8afee10b77,false,false,,,,TOO_SHORT
1742580,0x019d494f8e5a872f2fd7e5229a11e9578bd97095,false,false,,,,TOO_SHORT
1742743,0x37173eea36d163aba1a324e0e959ea837f047719,false,false,,,,TOO_SHORT
1743047,0x38e1df230d1793a43fe294ca07c40a3b0bc42474,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1743241,0x914bda6e66ddf7ec816620526de497d60d7248a7,false,false,,,,TOO_SHORT
1743242,0x02e01e9a73ed2cb24b32628c935256e455b0a078,false,false,"/*\n\nLast contributor before the deadline gets all ether, stored in the contract!\nTry your luck!\n\nvar raceAddress = ""0x02e01e9a73ed2cb24b32628c935256e455b0a078 "";\nvar raceftwContract = web3.eth.contract([{""constant"":false,""inputs"":[],""name"":""getCurrentWinner"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""claimReward"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""getDisclaimer"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""getRaceEndBlock"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""inputs"":[],""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""newWinner"",""type"":""address""}],""name"":""LastContributorChanged"",""type"":""event""}]);\nvar raceftw = raceftwContract.at(raceAddress);\n\nconsole.log(""current winner: "", raceftw.getCurrentWinner.call());\nconsole.log(""race ends at block: "", raceftw.getRaceEndBlock.call(), "" current block:"", eth.blockNumber);\nconsole.log(""current balance: "", web3.fromWei(eth.getBalance(raceAddress), ""ether""));\n\n\n\n//To participate in the race:\neth.sendTransaction({from:<your address>, to:""0x02e01e9a73ed2cb24b32628c935256e455b0a078 "", value:web3.toWei(10, ""finney""), gas:50000});\n\n//The winner can claim their reward by sending the following transaction:\nraceftw.claimReward.sendTransaction({from:<your address>, gas:50000})\n\n*/\ncontract RaceFTW {\n    \n    /* Disclaimer */\n    string disclaimer = ""Copyright (c) 2016 \""The owner of this contract\"" \nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \""Software\""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."";\n    \n    function getDisclaimer() returns (string) {\n        return disclaimer;\n    }\n    \n    address lastContributor;\n    uint fixedContribution = 10 finney;\n    \n    uint raceEnds = 0;\n    \n    // number of blocks. roughly 3 months at the contract creation blocks rate\n    uint RACE_LENGTH = 555555;\n    \n    event LastContributorChanged(address newWinner);\n    \n    function RaceFTW () {\n        raceEnds = block.number + RACE_LENGTH;\n    }\n    \n    function getRaceEndBlock() returns (uint) {\n        return raceEnds;\n    }\n    \n    function getCurrentWinner() returns (address) {\n        return lastContributor;\n    }\n    \n    function () {\n        //refund if the race ended\n        if (block.number > raceEnds) {\n            throw;\n        }\n        //refund if sent amount not equal to 1 finney\n        if (msg.value != fixedContribution) {\n            throw;\n        }\n        //raise event if needed\n        if (lastContributor != msg.sender) {\n            LastContributorChanged(msg.sender);\n        }\n        \n        //change the last contributor\n        lastContributor = msg.sender;\n    }\n    \n    \n    function claimReward() {\n        //only lastContributor can claim\n        if (msg.sender != lastContributor) {\n            throw;\n        }\n        //refund if race is not over yet\n        if (block.number < raceEnds) {\n            throw;\n        }\n        if (this.balance > 0) {\n            lastContributor.send(this.balance);\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1743681,0xf7b528d0e7261900eff56eb60af855f16eb11d28,false,false,,,,TOO_SHORT
1743754,0x34b7ba07901335e3c97acfa03865b48bfb4ac0ea,false,false,,,,TOO_SHORT
1744032,0x6b88a13f0cd0aca4eb5f02afdce5d428a3bf61e0,false,false,,,,TOO_SHORT
1744663,0x66057c158fcfb2c6a27cacf241a76739d5a4db2b,false,false,,,,TOO_SHORT
1744689,0x66e44de9eb2588a7e61f41f1391c96c813371461,false,false,,,,TOO_SHORT
1744840,0xcbb9d3703e651b0d496cdefb8b92c25aeb2171f7,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1744840,0x0c6583906aa10b4185b7eea5fe4cdbf86d808cd0,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1744840,0xa78055948c93d41f48d703cfab2f0eddc02da042,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1744840,0xaeeb8ff27288bdabc0fa5ebb731b6f409507516c,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1744929,0xd9f102045400942675a4e5ba691a01aed1a6d8f0,false,false,,,,TOO_SHORT
1744930,0xa03b93d83ee6a8e5e0113e9e62ec000aafe2cb09,false,false,,,,TOO_SHORT
1745188,0x2b3455ec7fedf16e646268bf88846bd7a2319bb2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745188,0xdfae41db0fc7dc52fffba9d9a1b2a33f5fd16d49,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745188,0x677f73acafbdc962bd55aaa43fafd0af91dc28ce,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745188,0xaccc230e8a6e5be9160b8cdf2864dd2a001c28b6,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745234,0x93dde9ae214199186390e2a90512252b871be418,false,false,,,,TOO_SHORT
1745274,0x0a9c64cb1bdad84bf0e851d400d73de79c55d4cc,false,false,,,,TOO_SHORT
1745366,0xd343b217de44030afaa275f54d31a9317c7f441e,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745366,0x0180f371d0208795aee7a68a5d71a8ebd9fc6f5b,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745366,0x67b40f9bd4cfb4d4ec0bd18896b862d2e898e025,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745366,0x4613f3bca5c44ea06337a9e439fbc6d42e501d0a,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745399,0x69ae48b0a2cdf376a127efe7032706e8c6446edf,false,false,,,,TOO_SHORT
1745445,0x5fce2e18eab7fc0c7ca25dd280de7ec0a4c96046,false,false,,,,TOO_SHORT
1745465,0x32304cdbe41fe4f1c48b08356414a52957d22d3b,false,false,"contract BTCRelay {\n    function getBlockHeader(int blockHash) returns (bytes32[3]);\n    function getLastBlockHeight() returns (int);\n    function getBlockchainHead() returns (int);\n    function getFeeAmount(int blockHash) returns (int);\n}\n\n\ncontract BlockhashFetch {\n\n  BTCRelay relay;\n  mapping(int => int) blockHashes; //Cache blockhashes\n\n  function BlockhashFetch(address _relay){\n    relay = BTCRelay(_relay);\n  }\n\n\n  function getPrevHash(int currentHash) returns (int parentHash, uint fee){\n\n    if(blockHashes[currentHash] != 0) return (blockHashes[currentHash], 0);\n\n    fee = uint(relay.getFeeAmount(currentHash));\n\n    if(fee > this.balance) return (0,0);\n    bytes32 head = relay.getBlockHeader.value(fee)(currentHash)[2];\n    bytes32 temp;\n\n    assembly {\n        let x := mload(0x40)\n        mstore(x,head)\n        temp := mload(add(x,0x04))\n    }\n\n    for(int i; i<32; i++){\n      parentHash = parentHash | int(temp[uint(i)]) * (0x100**i);\n    }\n\n    blockHashes[currentHash] = int(parentHash);\n  }\n\n  function getBlockHash (int blockHeight) returns (bytes32, uint totalFee){\n    int highestBlock = relay.getLastBlockHeight();\n    int currentHash = relay.getBlockchainHead();\n    if(blockHeight > highestBlock) return (0x0, 0);\n\n    for(int i; i < highestBlock - blockHeight; i++){\n      if(currentHash == 0) return (0x0,totalFee);\n      uint fee;\n      (currentHash, fee) = getPrevHash(currentHash);\n      totalFee += fee;\n    }\n\n    return (bytes32(currentHash), totalFee);\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1745577,0x039d369776af3b60eba49f440e8cb412c095c839,false,false,,,,TOO_SHORT
1745607,0xa785b74949fbfd39f1d64ca90ca1fd4e806ef418,false,false,,,,TOO_SHORT
1745654,0xfbf5d9c773dc1bf5553c462b44a925abd8cd47ce,false,false,,,,TOO_SHORT
1745707,0x3f383c4a62cc309814132d5b899790496eb8c5af,false,false,,,,TOO_SHORT
1745726,0x5cdc7859c1ba5ecad3b6281d4085422c096abf4b,false,false,,,,TOO_SHORT
1745766,0x3f103dc9c0fb1679c63a2e9f3932179d5de54b40,false,false,,,,TOO_SHORT
1745777,0xa2d4035389aae620e36bd828144b2015564c2702,false,false,,,,TOO_SHORT
1745810,0xc2ed0fa408b93ab7aa0a538af9a0a33443221a0c,false,false,,,,TOO_SHORT
1745898,0xdbe9b615a3ae8709af8b93336ce9b477e4ac0940,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745898,0xf0614c46e0dcb2d0899f12df202867c5f5b441a4,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745898,0x929fb9c6331156e85c202ba5b8f20296fb738ed3,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1745898,0xb136707642a4ea12fb4bae820f03d2562ebff487,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1746019,0xc6d7c287676e021f03434c1bc8fdddc155b3c0e5,false,false,,,,TOO_SHORT
1746062,0xf86e7aeeddb23a2e35302698b08a6015d0da967d,false,false,,,,TOO_SHORT
1746073,0x95d5b689e7f7a93bf0ba30d8f7f53a9747598fee,false,false,,,,TOO_SHORT
1746075,0xe235ba06b3474e0145fdb69e9f95a8f1d9e8ec62,false,false,,,,TOO_SHORT
1746130,0x25321c08f77ff5a42519da0242bff7e7b40e2f87,false,false,,,,TOO_SHORT
1746155,0x7602b46df5390e432ef1c307d4f2c9ff6d65cc97,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1746155,0x982d3a863bbff8c4ef2f2df47b9b7980d3b475f1,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1746155,0x890f3b8489b4f182928c1f507b0c38325035f525,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1746155,0xf4c64518ea10f995918a454158c6b61407ea345c,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1746156,0xad6252ce132e18e546d06dc96d356ef3c617e485,false,false,,,,TOO_SHORT
1746389,0xd9e3f401f253210b7b7a7da141cca461a1405bfe,false,false,,,,TOO_SHORT
1746506,0x34df76d101416e5d84b1496709b39782e5ec6509,false,false,,,,TOO_SHORT
1746555,0xa184e095fde619dfd4bf569cbf0b9343a2b8097e,false,false,,,,TOO_SHORT
1746566,0xe93b7c5e203ae887ac9510dc4d9d60fbd61bf41d,false,false,,,,TOO_SHORT
1746638,0x56aac7de8b239deb85cb7f1bb7f46d2639c6ecc6,false,false,,,,TOO_SHORT
1746689,0xd367287faf15415b616c9cb16395d85cc111a01f,false,false,,,,TOO_SHORT
1746703,0x06b98e2698995cbb38d286bf166b6e8e39d3a929,false,false,,,,TOO_SHORT
1746998,0xbb285d23963e41efe5e27b8f94010ef1030d6df9,false,false,,,,TOO_SHORT
1747009,0xda2fef9e4a3230988ff17df2165440f37e8b1708,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1747009,0xb0ef4832a764cfed5a7fb2a9a1ceed87ac185dcd,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1747009,0xb39265b255ae063041980fb6af345ee5eb9e44df,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1747009,0x84ef4b2357079cd7a7c69fd7a37cd0609a679106,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1747345,0xfc0628d33661661e2438059500722680d6b1da1d,false,false,,,,TOO_SHORT
1747437,0xc37c5ed5a7ae0b87f2b0b329c9e0e451c9fab7c7,false,false,,,,TOO_SHORT
1747616,0x62b8b1b7e704700b67f9b0adea77dbd477a942d0,false,false,,,,TOO_SHORT
1747652,0xe37490e8dcd23fb969a4834d6fa3e5df6af529ab,false,false,,,,TOO_SHORT
1747841,0x4d2fd887b24df7473f383916b4dab3ef7dc8e08d,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1747841,0x0971dc09c500a600c7c9492ae5631635b2fc5aa2,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1747841,0xba53667d4021da9501ddc5ce8adc64698dee523c,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1748075,0x4b9829cc6767db2f8f8f0685a01ebf2842eee36e,false,false,,,,TOO_SHORT
1748159,0xbc3eac5435d146e7bdca20144d52bab6ab503af0,false,false,,,,TOO_SHORT
1748304,0x7bda1f89a10281d82e0ddc53ac112314e17cd3d1,false,false,,,,TOO_SHORT
1748317,0x6aa178640b4180858e7e28ea4f1a7bbe1a7c8807,false,false,,,,TOO_SHORT
1748618,0x0b3402413dc649b8bda15e85d2243b0ccde9067d,false,false,,,,TOO_SHORT
1748619,0x98442832d2dcb2a3819e0e35bae34bffcdf06d61,false,false,,,,TOO_SHORT
1749165,0x59c4ebeccd3849e197d01e0727acd290fef233a2,false,false,,,,TOO_SHORT
1749193,0xa613df14b38c00392defd55f591f903656c72644,false,false,,,,TOO_SHORT
1749214,0x9b76c818fcf59678a1c6fb3aab23906ea7e1ba44,false,false,,,,TOO_SHORT
1749241,0x73e674f0e6aadf0d6d123217ef671a64f797c8f4,false,false,,,,TOO_SHORT
1749258,0x4ee8404d2e1289aec51f18deb5b4521b9d6aa09f,false,false,,,,TOO_SHORT
1749279,0x7fdbec3cb6fc7fe088f390387df5a2ca98b581bd,false,false,,,,TOO_SHORT
1749562,0x92ec2114acacfabb5e5e89aee5d4d08f0d30b09f,false,false,,,,TOO_SHORT
1749563,0xb9769d5ec8680ffb410529304111d019fe025bda,false,false,,,,TOO_SHORT
1749564,0xe285f4b7d5e2824d72d9802add565f7584e6e909,false,false,,,,TOO_SHORT
1749579,0x64999cb4c45b09035b81be6c6157892598e9448d,false,false,,,,TOO_SHORT
1749619,0xc164639017f371ac4949167953a101786456500c,false,false,,,,TOO_SHORT
1749621,0xfbdca4d2f1bbed4624f0b78ead69e92b63c08f57,false,false,,,,TOO_SHORT
1749630,0xe1f5ac904d0df077ae2b509c89737117cfa7618c,false,false,,,,TOO_SHORT
1749636,0x8207b5c1256d9aa18fd4a0d0cdabefa1af7524ad,false,false,,,,TOO_SHORT
1749671,0x3dc9f88540b28f07ab37471cdd96c8c9a4e5cf4d,false,false,,,,TOO_SHORT
1749704,0x6787021197943f756339a33fec300745aa883226,false,false,,,,TOO_SHORT
1749705,0x2cd8767d883e7e0e0142b4e9a50cb3859fbca5bc,false,false,,,,TOO_SHORT
1749739,0x176407eb16ad1a50c4a61c832dc608de94ed081c,false,false,,,,TOO_SHORT
1749832,0xbba702f8aff66ea75cde1fe0b717fc2d5de19ba0,false,false,,,,TOO_SHORT
1749880,0x0acc32dcbc8fae2492fc6a5fc2ec1b1f7736585b,false,false,,,,TOO_SHORT
1750043,0xf4e5a954125a6793601c2612cd509bbf7bb8be61,false,false,,,,TOO_SHORT
1750194,0xba284d4ca1b48e76f5c4196e4ae3e5200142f6f0,false,false,,,,TOO_SHORT
1750195,0xf95abbc78e0ec7e47b2b5047d70f1e6c4814f0b5,false,false,,,,TOO_SHORT
1750400,0x8969d3ca8f6987a528c2dc3d8dccd1e7dc8fe7f5,false,false,,,,TOO_SHORT
1750460,0x16ee1734ecabc38ecfadca64d9c856169ada6c49,false,false,,,,TOO_SHORT
1750594,0x6b7228b552b5c4cefd95bc7153a6ed67303b0d74,false,false,,,,TOO_SHORT
1750867,0x97743d48a2224bf693cfccc45566e7ffa1c59373,false,false,,,,TOO_SHORT
1750905,0x7ca66ea8159fc6b3c56cf2af454e61dabd4ebd43,false,false,,,,TOO_SHORT
1750980,0xf168b9d0e972dc34db088b07db71a688daacd1de,false,false,,,,TOO_SHORT
1751208,0x158c3b479418aa757272caccdca06d2888fab79a,false,false,,,,TOO_SHORT
1751575,0xd37eb96f62efba6490e917131501c648c36adf07,false,false,,,,TOO_SHORT
1751725,0x1d6fe5dc0c84b843e5243ffea7fe9a4ce1e8f353,false,false,,,,TOO_SHORT
1751781,0xe5489ed3557405984520baf9f1e18eb41f851f92,false,false,,,,TOO_SHORT
1751782,0xda8255233ddce12c3014c43cee72a427a51cbb2c,false,false,,,,TOO_SHORT
1751783,0xcb4c4805dcd534de1efe28632819477f5b87419b,false,false,,,,TOO_SHORT
1751842,0xbc1d82856a163108d7ba3972a435238f9f7ee487,false,false,,,,TOO_SHORT
1751988,0x4c2c74401bc58252d96e16d9f803c4ca88cb61fd,false,false,,,,TOO_SHORT
1752242,0xf99f0eed8d88eaa0a686ca8a594b58d2ea3a4c2b,false,false,,,,TOO_SHORT
1752255,0x91d4eb55541798f74af6f751658d486de8be4f3b,false,false,,,,TOO_SHORT
1752304,0x05f13220c4df384f2e14f3fb143ebf9a2dfcd733,false,false,,,,TOO_SHORT
1752383,0xfbfad9c0176679175357b3a6a814620cfcb5e934,false,false,,,,TOO_SHORT
1752412,0x601c790eee5c73c401037564237f0890f229d036,false,false,,,,TOO_SHORT
1752430,0x7173ac3ee0821ae2d584a8734bb88e6af4f5a906,false,false,,,,TOO_SHORT
1752437,0xae30d140366752f653a1f64a33cdba7218e1af6a,false,false,,,,TOO_SHORT
1752444,0x7a472d251da11c127970350c95af2f9d869b51c4,false,false,,,,TOO_SHORT
1752446,0x55c7b63e778413475207e6c756140cbdcd78a7c7,false,false,,,,TOO_SHORT
1752453,0x8b1665e1ad32a11d008193d3c5bce9ae018eeeaa,false,false,,,,TOO_SHORT
1752455,0x3f35710f13385c6a7d620b31c40304d948291f9a,false,false,,,,TOO_SHORT
1752696,0x2d85bc37a7fd98f4b7ea65cc92066e708590e848,false,false,,,,TOO_SHORT
1752772,0xf9e999d2b90f91bf0a45299d9aa8ed77cfbea0a3,false,false,,,,TOO_SHORT
1752807,0x7f5401e252c0dcc42bfc4d16bc6d5ba3e9a7fd59,false,false,,,,TOO_SHORT
1753100,0x070b489e350a831150985f01b8d860c540f4dd3b,false,false,,,,TOO_SHORT
1753130,0x4e86883ee537dd4f4180c38d1da1bac8cdb01c11,false,false,,,,TOO_SHORT
1753211,0x7e35e41e0153e5a3a42919d44c1529a1bed78e5b,false,false,,,,TOO_SHORT
1753691,0x1882e0a0d5095ca750fe6b266346b159b09a869b,false,false,,,,TOO_SHORT
1753958,0x567fafca24f6bbb9941dc1b1628b3d4d89e35746,false,false,,,,TOO_SHORT
1753974,0x64317bf25b10760dd8014f1116fa9415bded9afd,false,false,,,,TOO_SHORT
1754099,0x65c657cae338ca33fa1705083759a9f84943482e,false,false,,,,TOO_SHORT
1754824,0xf2aa17a85c0064bdb1720bfd998471ee59ceac77,false,false,,,,TOO_SHORT
1755253,0xfaba04d7fb1cbe733541d714412fe82d6528cfff,false,false,,,,TOO_SHORT
1755292,0x8a806fed2e6ad81fb22ac6403e8d974977b655fd,false,false,,,,TOO_SHORT
1755355,0x2d2b140d89eb79ba510cd578e6385e9458687b2c,false,false,,,,TOO_SHORT
1755549,0x244c07a387db63812cc815601c2dcb0d2217f5f8,false,false,,,,TOO_SHORT
1755580,0x057916660f0645e53da9ced5ce795735900cce72,false,false,,,,TOO_SHORT
1755639,0xb1ed1536a372ab7e692a80164f8c2cf574b859c8,false,false,,,,TOO_SHORT
1755659,0xd8c22e66eba7fb838d37910ec890a0276466eba0,false,false,,,,TOO_SHORT
1755847,0xb1626f74178c9badd8dbc3c6902d4110e8ec6360,false,false,,,,TOO_SHORT
1755866,0x4eb31b6487df5432ab11c0ced2516ac1645e4662,false,false,,,,TOO_SHORT
1756060,0xab042b41ed9912714bdd455decfe6300748facee,false,false,,,,TOO_SHORT
1756228,0xeb062ee0e2510757e630e55afb7beb8d384bf1e8,false,false,,,,TOO_SHORT
1756441,0xfc2a9214b578084e1327a7c37f86464b80e6fa45,false,false,,,,TOO_SHORT
1756532,0x183e5b47dcdcdd6d94fdaeef867f4e3f9ad509d3,false,false,,,,TOO_SHORT
1756813,0x41ccb332a188e501f4f3b4af440293f46cff8a58,false,false,,,,TOO_SHORT
1756850,0xcdbc3a797059fac68087cf6a8999d9c7091512f6,false,false,,,,TOO_SHORT
1757102,0x5a5eff38da95b0d58b6c616f2699168b480953c9,false,false,"// A life-log, done for Charlyn Greeff, born 18 April 2016 @ 15h30 (1460993400)\n//    Mother: Mirana Hotz, 16 December 1977 (251078400)\n//    Father: Jaco Greeff, 11 June 1973 (108604800)\n//\n// version: 1.0.0\n// source: https://github.com/jacogr/ethcontracts/tree/master/src/LifeLog\n\ncontract CharlyLifeLog {\n  // allow a maximum 20% withdrawal at any time\n  uint private constant MAX_WITHDRAW_DIV = 5; // 100/20\n\n  // allow one withdrawal every 6 months/180 days\n  uint private constant WITHDRAW_INTERVAL = 180 days;\n\n  // all the actual events that can be created\n  event LogDonation(address indexed by, uint loggedAt, uint amount);\n  event LogWithdrawal(address indexed by, uint loggedAt, uint amount);\n  event LogPersonNew(address indexed by, uint loggedAt, uint index);\n  event LogPersonUpdate(address indexed by, uint loggedAt, uint index, string field);\n  event LogWhitelistAdd(address indexed by, uint loggedAt, address addr);\n  event LogWhitelistRemove(address indexed by, uint loggedAt);\n  event LogEvent(address indexed by, uint loggedAt, uint when, string description);\n\n  // a structure describing a person\n  struct Person {\n    bool active;\n    uint activatedAt;\n    uint deactivatedAt;\n    int dateOfBirth;\n    int dateOfDeath;\n    string name;\n    string relation;\n  }\n\n  // next time whitelist address is allowed to get some funds\n  uint public nextWithdrawal = now + WITHDRAW_INTERVAL;\n\n  // totals of received and withdrawn amounts\n  uint public totalDonated = 0;\n  uint public totalWithdrawn = 0;\n\n  // people in the life of ([0] == 'self')\n  Person[] public people;\n\n  // donations received\n  mapping(address => uint) public donations;\n\n  // whitelisted modifier accounts\n  mapping(address => bool) public whitelist;\n\n  // modifier to allow only the whitelisted addresses\n  modifier isOnWhitelist {\n    // if not in the whitelist, throw error\n    if (!whitelist[msg.sender]) {\n      throw;\n    }\n\n    // if any value attached, don't accept it\n    if (msg.value > 0) {\n      throw;\n    }\n\n    // original code executes in here\n    _\n  }\n\n  // construct a lifelog for this specific person\n  function CharlyLifeLog(string name, int dateOfBirth) {\n    // creator should go on the whitelist\n    whitelist[msg.sender] = true;\n\n    // add the first person\n    personAdd(name, dateOfBirth, 0, 'self');\n\n    // any donations?\n    if (msg.value > 0) {\n      donate();\n    }\n  }\n\n  // log an event\n  function log(string description, uint _when) public isOnWhitelist {\n    // infer timestamp or use specified\n    uint when = _when;\n    if (when == 0) {\n      when = now;\n    }\n\n    // create the event\n    LogEvent(msg.sender, now, when, description);\n  }\n\n  // add a specific person\n  function personAdd(string name, int dateOfBirth, int dateOfDeath, string relation) public isOnWhitelist {\n    // create the event\n    LogPersonNew(msg.sender, now, people.length);\n\n    // add the person\n    people.push(\n      Person({\n        active: true,\n        activatedAt: now,\n        deactivatedAt: 0,\n        dateOfBirth: dateOfBirth,\n        dateOfDeath: dateOfDeath,\n        name: name,\n        relation: relation\n      })\n    );\n  }\n\n  // activate/deactivate a specific person\n  function personUpdateActivity(uint index, bool active) public isOnWhitelist {\n    // set the flag\n    people[index].active = active;\n\n    // activate/deactivate\n    if (active) {\n      // create the event\n      LogPersonUpdate(msg.sender, now, index, 'active');\n\n      // make it so\n      people[index].activatedAt = now;\n      people[index].deactivatedAt = 0;\n    } else {\n      // create the event\n      LogPersonUpdate(msg.sender, now, index, 'inactive');\n\n      // make it so\n      people[index].deactivatedAt = now;\n    }\n  }\n\n  // update a person's name\n  function personUpdateName(uint index, string name) public isOnWhitelist {\n    // create the event\n    LogPersonUpdate(msg.sender, now, index, 'name');\n\n    // update\n    people[index].name = name;\n  }\n\n  // update a person's relation\n  function personUpdateRelation(uint index, string relation) public isOnWhitelist {\n    // create the event\n    LogPersonUpdate(msg.sender, now, index, 'relation');\n\n    // update\n    people[index].relation = relation;\n  }\n\n  // update a person's DOB\n  function personUpdateDOB(uint index, int dateOfBirth) public isOnWhitelist {\n    // create the event\n    LogPersonUpdate(msg.sender, now, index, 'dateOfBirth');\n\n    // update\n    people[index].dateOfBirth = dateOfBirth;\n  }\n\n  // update a person's DOD\n  function personUpdateDOD(uint index, int dateOfDeath) public isOnWhitelist {\n    // create the event\n    LogPersonUpdate(msg.sender, now, index, 'dateOfDeath');\n\n    // update\n    people[index].dateOfDeath = dateOfDeath;\n  }\n\n  // add a whitelist address\n  function whitelistAdd(address addr) public isOnWhitelist {\n    // create the event\n    LogWhitelistAdd(msg.sender, now, addr);\n\n    // update\n    whitelist[addr] = true;\n  }\n\n  // remove a whitelist address\n  function whitelistRemove(address addr) public isOnWhitelist {\n    // we can only remove ourselves, double-validate failsafe\n    if (msg.sender != addr) {\n      throw;\n    }\n\n    // create the event\n    LogWhitelistRemove(msg.sender, now);\n\n    // remove\n    whitelist[msg.sender] = false;\n  }\n\n  // withdraw funds as/when needed\n  function withdraw(uint amount) public isOnWhitelist {\n    // the maximum we are allowed to take out right now\n    uint max = this.balance / MAX_WITHDRAW_DIV;\n\n    // see that we are in range and the timing matches\n    if (amount > max || now < nextWithdrawal) {\n      throw;\n    }\n\n    // update the event log with the action\n    LogWithdrawal(msg.sender, now, amount);\n\n    // set the next withdrawal date/time & totals\n    nextWithdrawal = now + WITHDRAW_INTERVAL;\n    totalWithdrawn += amount;\n\n    // send and throw if not ok\n    if (!msg.sender.send(amount)) {\n      throw;\n    }\n  }\n\n  // accept donations from anywhere and give credit\n  function donate() public {\n    // there needs to be something here\n    if (msg.value == 0) {\n      throw;\n    }\n\n    // update the event log with the action\n    LogDonation(msg.sender, now, msg.value);\n\n    // store the donation\n    donations[msg.sender] += msg.value;\n    totalDonated += msg.value;\n  }\n\n  // fallback is a donation\n  function() public {\n    donate();\n  }\n}",2,個人の人生を記録する詩的な要素があり、実用性と芸術性が融合しています。,
1757168,0xf74e43ddbfaaa6d2675aca4560f6cff5f91754fe,false,false,,,,TOO_SHORT
1757615,0x4dc8b9ab48a00f7f13733b695cfc5fd56ae7566b,false,false,,,,TOO_SHORT
1757659,0xd23f2a638a4efd008341005fa3982f73e34165d2,false,false,,,,TOO_SHORT
1757923,0xff08adfb4921adf4abbe13f4b9acdbcd9eb500f2,false,false,,,,TOO_SHORT
1757977,0x45b13e58966318f420afd7ae546f2a8466b64e60,false,false,,,,TOO_SHORT
1758084,0x4b72b8720c1ac721836bd115f248ab45a736197e,false,false,,,,TOO_SHORT
1758271,0x6538e3808c90b0ea9c0eef6666e66c6148c9c853,false,false,,,,TOO_SHORT
1758707,0x0a8ac6436a1b0ed172389b12cc1b03edf9c5249d,false,false,,,,TOO_SHORT
1758797,0xb9d6233cf24fec6f0cac7c5750f116141684389f,false,false,,,,TOO_SHORT
1758894,0x0f801a15e59ef7bc4a40046ce5ca9be951d7261b,false,false,,,,TOO_SHORT
1758895,0xe900d58106dd82d5a498e133ceb47b0f763fc536,false,false,,,,TOO_SHORT
1758953,0x1e15e53dac12912d9faeddb9ce1dd43c23e37be8,false,false,,,,TOO_SHORT
1759266,0x96c71f86432a6918805016d10e94c43e0fcd753c,false,false,,,,TOO_SHORT
1759705,0x08a5206684075c94352be156643aebbd27e25ce6,false,false,,,,TOO_SHORT
1760769,0x3c053ba021697a8eac04df95c5553bf65584fdbc,false,false,,,,TOO_SHORT
1761067,0x3127e4115b605f54079182d431247bda3b77a1c4,false,false,,,,TOO_SHORT
1761256,0xe94774134235822dc7ceb793a32a32401a4198b7,false,false,,,,TOO_SHORT
1761443,0xd50f4d24c15712acdb7bc7d25d85e8244bea605f,false,false,,,,TOO_SHORT
1761495,0x21b2dc5d425930adfe91be51a8e4776bd65a854f,false,false,,,,TOO_SHORT
1761716,0x024e7fd09ff8ebfb4fd6c6aacee459c77779668e,false,false,,,,TOO_SHORT
1761896,0x31634d82fd3aead1bc0f6e92c67b6286c9622b6b,false,false,,,,TOO_SHORT
1762138,0x0ed1859929113f399950d4b74fa3d24f894fd9ec,false,false,,,,TOO_SHORT
1762235,0xe9bee66b3ea084d74747cbe8259d24dc92830f8b,false,false,,,,TOO_SHORT
1762276,0x8a4702e40acc780d18e871737f0a80b06d5949fc,false,false,,,,TOO_SHORT
1762326,0x7200ef7acc58da7882ab6cf09b4fb1fde6c8c56c,false,false,,,,TOO_SHORT
1762381,0xe815e7d94d7de883883332a5fd0ef1018580dbdd,false,false,,,,TOO_SHORT
1762395,0xb1cf5f186e912f90034018d7e773092e860069eb,false,false,,,,TOO_SHORT
1762424,0x873132b05aba2c3f524198c504d55908ad966d80,false,false,,,,TOO_SHORT
1762538,0xca4b07e8ef70156606586335bd3ed4dddacc71d5,false,false,,,,TOO_SHORT
1762628,0x497c072e39d3c05360195916e3888af46a0b8e1c,false,false,,,,TOO_SHORT
1762664,0xf40187a37fc69ceb39da842a6669ddeb751955de,false,false,,,,TOO_SHORT
1762694,0x42eb9067dbf342cd2438643dad6df70786ff0c46,false,false,,,,TOO_SHORT
1762700,0xd739742e14a7fb3ecebf6e3db11daf1edfc00092,false,false,,,,TOO_SHORT
1762806,0x19deca96d5bc005a3fd3d67c751c1602f182fa74,false,false,,,,TOO_SHORT
1762840,0xed6717bf492290aeb03f1e0306b6c072d9da5c44,false,false,,,,TOO_SHORT
1762854,0x92ed5180ca8672fc29bca2947b4e1ae5cbdeafdd,false,false,,,,TOO_SHORT
1762913,0x984f7ace0cfd1307380641ac2dcee3c848cba0d9,false,false,,,,TOO_SHORT
1762946,0xa18d1154db460e3c641b25ed2f45220273c72854,false,false,,,,TOO_SHORT
1762951,0xd05c38d2f8fd5ff40e6c293bdfa17d0f376e1c07,false,false,,,,TOO_SHORT
1762960,0x317d92408016cef491a39dfc17ea62de5aa47375,false,false,,,,TOO_SHORT
1762976,0x2d4f5717d92aaaa7502ed0137cef0ffe564a0170,false,false,,,,TOO_SHORT
1763065,0xffa40870ca19a7178075294420232a8f9785977e,false,false,,,,TOO_SHORT
1763087,0x0bbca130903ecaa98f4600c0f891b0429794881d,false,false,,,,TOO_SHORT
1763089,0x38dfeb52e835c4eb2e27df63567ac3c7f6386f95,false,false,,,,TOO_SHORT
1763091,0xe31c72d1cb8b043411cfe374639df6ef032fbea1,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1763116,0xad35ea75006516caf6c3adf9cae3b62d60d848fd,false,false,,,,TOO_SHORT
1763145,0x568b6a04a866b98264ba9ca9bd6ed445b8d6bee3,false,false,,,,TOO_SHORT
1763213,0xd7ede57a2504f7acb846a22ad3c6413d50af2df7,false,false,,,,TOO_SHORT
1763217,0x0fb3f137276848aa5d06a3ffe209fe0e09698329,false,false,,,,TOO_SHORT
1763243,0x7deb0dc1cac185b50a8abf97198820b740f57018,false,false,,,,TOO_SHORT
1763252,0xb7ed165a41044ddbc8d79e23070de173de85391f,false,false,,,,TOO_SHORT
1763261,0xf8646d30430f0f9e11d11b8b5646c7fbff35cf75,false,false,,,,TOO_SHORT
1763291,0xa4b857de95106dc29c87e7dee79a71642cff4194,false,false,,,,TOO_SHORT
1763295,0xf6b6336bb78c6c0a09c9be7f2615937bb6da9790,false,false,,,,TOO_SHORT
1763303,0x0ceb830ccaa1529778e14d3c2d73e58f8a638a3d,false,false,,,,TOO_SHORT
1763309,0x1f37eecf596714217e8a40e46063d0b77d2f2b52,false,false,,,,TOO_SHORT
1763317,0xf89f5760a6017016a27768a2ac436c7472c0f300,false,false,,,,TOO_SHORT
1763320,0xaa0aeedfb4393015cfcfebaeb2c719057b6c5d8b,false,false,,,,TOO_SHORT
1763329,0x3ec70ecee33db9fc57dddb2b4bc1e69246dcb5ce,false,false,,,,TOO_SHORT
1763378,0xddcb49c8cd9bc9e344557bee79a7113a647538b9,false,false,,,,TOO_SHORT
1763382,0x3a1c35e9168d028c079958fcb5f79c157b7a2155,false,false,,,,TOO_SHORT
1763424,0x766d0f2f74d36f62bf146b47a21fcc709f503e1e,false,false,,,,TOO_SHORT
1763456,0x33bf8819475025febf70ee8db36c86090b980dc6,false,false,,,,TOO_SHORT
1763486,0xe7328817fa1efd39bb7b008e1e0c91dc639e58a4,false,false,,,,TOO_SHORT
1763590,0xc7f614c44943b50e1ec4b576a75a46d297f13139,false,false,,,,TOO_SHORT
1763667,0xbd04bb1138b570b5d9b57d57b96ae0f10f3c3ece,false,false,,,,TOO_SHORT
1763716,0x1e9c42111d591da0f544dfe0d3225966db1fab67,false,false,,,,TOO_SHORT
1763760,0x24c8ff36322dc6c3b5cae956475ef3f081137cac,false,false,,,,TOO_SHORT
1763847,0xb172c5cf07ef139899cf82bfc60bb9637bea0d42,false,false,,,,TOO_SHORT
1763852,0x45c979255cfa86ecaaa6c54da1f6e740345f9b0d,false,false,,,,TOO_SHORT
1763856,0xed887ad9dc29b626ea85a49aacdeaff322cd361e,false,false,,,,TOO_SHORT
1763860,0x5735cd05594c610aeba223c352ecf6d1f524fec0,false,false,,,,TOO_SHORT
1763891,0x5277143188c3b2a36e7adf1702229ad591f55d6f,false,false,,,,TOO_SHORT
1763901,0x5af6695d77568b8d7ae424be705339c70464866b,false,false,,,,TOO_SHORT
1763902,0x0dc1807f18d96fca002284c709445dc3947e6459,false,false,,,,TOO_SHORT
1763932,0x16720400d99de846b2491c6f0ec80ba091e47553,false,false,,,,TOO_SHORT
1763946,0x3ac2ffd12ba00dbe75856c5f5c9366b2cdbaeb6a,false,false,,,,TOO_SHORT
1764036,0x58dacf44e8b7b8494184181dfc60647ffcc17c46,false,false,,,,TOO_SHORT
1764041,0x7142a9908d866ca14ab6fac9338ed7601f39aa96,false,false,,,,TOO_SHORT
1764243,0xb0cd2778aca006b5abce975d0a65a61d17202894,false,false,,,,TOO_SHORT
1764248,0x64f52cd45c61618f22b3475f44869baedd9f01b4,false,false,,,,TOO_SHORT
1764257,0xe47c42607c44dd42d4804be240cc9271b0d2a518,false,false,,,,TOO_SHORT
1764261,0x0ad68c5b9871b7e0d2fa76ad3a230bd8a110ec9f,false,false,,,,TOO_SHORT
1764308,0xa6a8c4beaf3211657dc079beff904c2d958b4a81,false,false,,,,TOO_SHORT
1764336,0x025ce027f763ce179a0ce755437e54ebe284763c,false,false,,,,TOO_SHORT
1764407,0xe16fde0fff80f12681510a481341c1712b64f946,false,false,,,,TOO_SHORT
1764558,0x2d6a3cadb661a4e5a9c495e9dfd29b879b87bedc,false,false,,,,TOO_SHORT
1764606,0x4452bb0f875b89fef82acbe8e2d8b699a6dd91c9,false,false,,,,TOO_SHORT
1764664,0xbe20d1053c250ad21923852050b1fe24c989d8e6,false,false,,,,TOO_SHORT
1764665,0xdf8487b29dbf56614c5f07b8c76c95a00866b176,false,false,,,,TOO_SHORT
1764668,0xab911548420a2a77ddb81914070686bb470f2644,false,false,,,,TOO_SHORT
1764675,0xa4cd75ea6d6cc66cca95dabb28223b4d6c9a10cb,false,false,,,,TOO_SHORT
1764679,0x24db6cad870b45822ba77251a58d7f543c8ba602,false,false,,,,TOO_SHORT
1764704,0xb32d6cdc9212e4442d002403866f77dc45a73011,false,false,,,,TOO_SHORT
1764774,0xcc5b1e3b249497db440d93a511b52faacc6a42b9,false,false,,,,TOO_SHORT
1764812,0xc857d9cb9b79dae9ff2d7f99d2e388aff041e172,false,false,,,,TOO_SHORT
1764856,0xea97a68bd45cbf60cd4f6a7813560066c881f58f,false,false,,,,TOO_SHORT
1764948,0xc7b3f35c051719bce5bc15d7a12453035cd86ce3,false,false,,,,TOO_SHORT
1764955,0x45e6c7faa331fc687e14f4e62937241738c1a21a,false,false,,,,TOO_SHORT
1765066,0x7426a190051e9afe8597ae0538a4866c9fe2bdc0,false,false,,,,TOO_SHORT
1765117,0x0ca5609ae33f2203f6a82298ca4112224cd48f26,false,false,,,,TOO_SHORT
1765168,0xb6ad92c5a3ac5c5bcbf4cf98ba8dbf6edccd0ded,false,false,,,,TOO_SHORT
1765181,0xad4d22e70e151588eff39ac21f689ab020e51038,false,false,,,,TOO_SHORT
1765228,0xc2a8b8a98fbbe2ef9b4eacf28d8c9f42809d54c0,false,false,,,,TOO_SHORT
1765232,0xca932fdb066a77d79ff4ef5d7dd454deda8abde6,false,false,,,,TOO_SHORT
1765294,0xcc62dbc026a7ff7902661bddfe1b365bbad99877,false,false,,,,TOO_SHORT
1765323,0xbf5e84f76b7c272d1c09286cc96bfe18bffa41cf,false,false,,,,TOO_SHORT
1765542,0x9ac96217d2612ffe2514e92ad701c7992288c3db,false,false,,,,TOO_SHORT
1765819,0xf3ebb014a78735c22a1d4a1922aea261ebc244ca,false,false,,,,TOO_SHORT
1765877,0x60fee70dfcb3a625f98387c4a4ab6d0b91cb9f21,false,false,,,,TOO_SHORT
1766123,0x7ad95de54f496172073a48c4fc70921f9a976aee,false,false,,,,TOO_SHORT
1766132,0x512670d02f92df54144644f2488669d955ff2385,false,false,,,,TOO_SHORT
1766266,0x0978f2f5b95ec72747dc2a2b354d45d423d344d8,false,false,,,,TOO_SHORT
1766347,0x1af14451606f9070aca31fdcdb7ce32602b7a8ce,false,false,,,,TOO_SHORT
1766375,0xec3fa7ab76f1aea3ae232ea3520a10c8e7d41b4d,false,false,,,,TOO_SHORT
1766513,0x90df677c09759c5c34181cc1b61be3acbab8cb15,false,false,,,,TOO_SHORT
1766708,0x00f89f64d9ba8f4b2defa2d7c837ad664a4199b0,false,false,,,,TOO_SHORT
1766721,0x358e128b66aa0523f16a1a744814d16da6798491,false,false,,,,TOO_SHORT
1766871,0x70f91640361788062160aaec3e8f16837cc12273,false,false,,,,TOO_SHORT
1766881,0x400ca60b4524b20504dd3bd76a4cfb0ee05f6c42,false,false,,,,TOO_SHORT
1766993,0x3adf5250585b60392e0fa614cba72e9c4c68a70f,false,false,,,,TOO_SHORT
1767043,0xc3b033499f01a268f0b64843ee74ab2db2e4ba0b,false,false,,,,TOO_SHORT
1767088,0xe046bbd6a427b48302410a43e1f8c5a924c93483,false,false,,,,TOO_SHORT
1767130,0x414381f06c637b6eae0b92fbe5e3097e41aa1065,false,false,,,,TOO_SHORT
1767167,0x98bf8f243be2bd112e96575a5e1d1c77dce1ceb9,false,false,,,,TOO_SHORT
1767226,0xa5713ea0c7f9d45e42227d24e88cb47db5f0c8d0,false,false,,,,TOO_SHORT
1767229,0x6adec75681ee5b85f4f6369a73250714eb126720,false,false,,,,TOO_SHORT
1767372,0x5f9ddba695c50d29e07547029044555c81d0bd78,false,false,,,,TOO_SHORT
1767480,0xa794f7ca101cae4d51a751c93177836728ef9f66,false,false,,,,TOO_SHORT
1767522,0x487eb6bde94680a0286c80a6682e35827160fcd9,false,false,,,,TOO_SHORT
1767523,0x64a3c611aa1d617db4092db4a1e1556dec1fe320,false,false,,,,TOO_SHORT
1767531,0xdb3c17b477682b6c8f5379120da4614aed35b0db,false,false,,,,TOO_SHORT
1767541,0xf73a05a9e5bdcb405545c5d92f9ccaa82fe7f890,false,false,,,,TOO_SHORT
1767552,0x5e7b39b09c557f0e2546912ada939680bec68f75,false,false,,,,TOO_SHORT
1767618,0xf692179da8ef5113e202fcd94066127d2f05fe05,false,false,,,,TOO_SHORT
1767789,0x1594499de282cff5539e9e37c5e2547b9c475572,false,false,,,,TOO_SHORT
1767838,0x5b5759344eb1f9769a469f8adba650d36efb3279,false,false,,,,TOO_SHORT
1767855,0xaadfe28b61cb56ff987c8b4fd532ebeac4de45be,false,false,,,,TOO_SHORT
1767916,0xefc357f16eb51e18e2a23c8979bcb8509744eff0,false,false,,,,TOO_SHORT
1767972,0xe3cfb83b06421e4bd9e027023a8ac59a66ef15d3,false,false,,,,TOO_SHORT
1768166,0x1e10587e64d5693e842effe6d69a30288ff81b08,false,false,,,,TOO_SHORT
1768214,0xc968e913441f8c600338280ae4a0ef2883939fc2,false,false,,,,TOO_SHORT
1768272,0xa357710fc955f18faae2a76157c5c41e58fe9385,false,false,,,,TOO_SHORT
1768403,0x7632de8349398671f244bef2f20b134d720d83d6,false,false,,,,TOO_SHORT
1768569,0x15e670a872d1bf65e97e270a791600f87cf59af6,false,false,,,,TOO_SHORT
1768579,0x6d24d5c79a28be15307a6af700b28630b4d64e4d,false,false,,,,TOO_SHORT
1768594,0x8968e2f8419c1f5aacad2b98189534558f38304d,false,false,,,,TOO_SHORT
1768598,0xe5a7007e5574cf7456d3595933026c79dd2c4ff4,false,false,,,,TOO_SHORT
1768623,0xe8db0b56532d2599f90578f01fda9128d8bf37fd,false,false,,,,TOO_SHORT
1768666,0x43889774bd4a20eccdff562eb213bd7e025008d4,false,false,,,,TOO_SHORT
1768687,0xbb75b8929b235bc81b6bb60b5366e6881e493259,false,false,,,,TOO_SHORT
1768764,0x090cc9597cc6964bfa3bdd202f48fa2f3a77da74,false,false,,,,TOO_SHORT
1769032,0xf1392abeac4cd9ffffe72afbdaef2c5e450a6df2,false,false,,,,TOO_SHORT
1769061,0x62ffca8b13eaa12549895bc583024cc9d53b7e61,false,false,,,,TOO_SHORT
1769255,0xef638b4305b8a1620f4e0e562e127f1181ae16d2,false,false,,,,TOO_SHORT
1769306,0x983fa1bed0d73c85e5ac3b772005f90b69a27363,false,false,,,,TOO_SHORT
1769592,0x6f43481693277ff0b4c0dd0bb575ff968bc053fc,false,false,,,,TOO_SHORT
1769595,0x3456c92d77395d90ad2fb32e384fbd3af2b9e12a,false,false,,,,TOO_SHORT
1769614,0xd94660fce13e9752f8b9f3cdb962199e9674e1ba,false,false,,,,TOO_SHORT
1769700,0x708225f4b4190f9b4ff4c992252cefc89ace068e,false,false,,,,TOO_SHORT
1769802,0xdc03cc58331ebda81a6681d2193d48f2eb178d5a,false,false,,,,TOO_SHORT
1769921,0x4f78a0428f3b45440b330c810c3b856384e696d4,false,false,,,,TOO_SHORT
1769928,0x120ab840ac05831f1aae8b48f8e54759db763002,false,false,,,,TOO_SHORT
1769939,0xca7973b4050d7af564dca4547d246e3e4e49bcc0,false,false,,,,TOO_SHORT
1769940,0x851032929c7a96c2394e6f5939fd355ba5debaf2,false,false,,,,TOO_SHORT
1770006,0x63e92676a82fe94da430830efee5418f9b629547,false,false,,,,TOO_SHORT
1770034,0x22a304466320a81a383c5589664f0ef9b4acdfbb,false,false,,,,TOO_SHORT
1770103,0xf9c7829a84ada42f5f5554cfb05421d40ced6dd7,false,false,,,,TOO_SHORT
1770200,0x9b5d5d8d4db45a2f21d9c4c767c2526600b8d3fc,false,false,,,,TOO_SHORT
1770260,0xa683761720422c1cc0e29374c4320809a8bf5a33,false,false,,,,TOO_SHORT
1770289,0x06f9fc346700500be4de30c6035f19c6471aab78,false,false,,,,TOO_SHORT
1770316,0x95af2a723041dc2b6e829e53f57352e676b40269,false,false,,,,TOO_SHORT
1770395,0xa342c40e917cb4e65e7dc801d71a238828c962e4,false,false,,,,TOO_SHORT
1770470,0xf3d271a338bf0c6b3d5cf20ee0df25d445c3818d,false,false,,,,TOO_SHORT
1770640,0xbda59d06750ba17819b7358a27c8973cedde4d19,false,false,,,,TOO_SHORT
1770654,0xea7e73b090ea3c4f050c7f2058036998c1e3d2af,false,false,,,,TOO_SHORT
1770710,0xb68fe1f386369e33655be7a249b5068833296abb,false,false,,,,TOO_SHORT
1770717,0x9dfab413f8c0c0165e27fdf069421b49c4e7fecc,false,false,,,,TOO_SHORT
1770738,0x552684ae80bcb57166ccb2615eb9adcb1cb5e43c,false,false,,,,TOO_SHORT
1770933,0x9ce543f8611cd3279ff79a106d2e8e70d01bb6e9,false,false,,,,TOO_SHORT
1771128,0xbb35617c4e82aa9b22a82315a6ca3441c9875390,false,false,,,,TOO_SHORT
1771129,0x5393c150f32cd3443f5fb4082a0d264dec73f233,false,false,,,,TOO_SHORT
1771130,0xb4545672485a6f3f5e89eab4e4eb728146ebfa19,false,false,,,,TOO_SHORT
1771279,0x95e9151e2d4e3f213990bb2cd75d4dc553126740,false,false,,,,TOO_SHORT
1772175,0x8c04339585be91652d8c627153c2d4a045f0d834,false,false,,,,TOO_SHORT
1772241,0x9b2f4729c78e3b226fa1cd02d30e78d0ee0039ba,false,false,,,,TOO_SHORT
1772301,0x973b57ec74c7a1c27b7520d69d578d4444d6e6e7,false,false,,,,TOO_SHORT
1772307,0x9e45af8161530a485c4017466d6fe00a1b199eec,false,false,,,,TOO_SHORT
1772694,0xf23525be43621d29897122b9c8f6fc2478404317,false,false,,,,TOO_SHORT
1772709,0x7b0e2d71fec31de07ba7bc9ee3621d219ce81b3d,false,false,,,,TOO_SHORT
1772949,0xf271efe6f9c890e8283269e457e07837e9313f0b,false,false,,,,TOO_SHORT
1772966,0x6a271ddf6b427ed8258a4cb4a54b81399221fea2,false,false,,,,TOO_SHORT
1773356,0xb69f50064f322d130b0e153790aee12ddc36dbd5,false,false,,,,TOO_SHORT
1773684,0x758988e5d131dd9d7ebe3c06d271fef502a3dadc,false,false,,,,TOO_SHORT
1773833,0xc9658ba0f00281e492f446a50ee0bfab4dd32cd6,false,false,,,,TOO_SHORT
1773886,0x3f5e0a6724e289b44bb9358058b27e66eeec5a23,false,false,,,,TOO_SHORT
1774142,0x73f1e362465de68f5d88bc3d5761688617ffa16e,false,false,,,,TOO_SHORT
1774197,0x1ab66badde9dea285fbde77394bb3a843da46910,false,false,,,,TOO_SHORT
1774339,0xe94d2c0d93a6660312a0cb12603545322563c4c5,false,false,,,,TOO_SHORT
1774503,0x65daf1bd4d567d904c88b56fdd7bd9d98edfa267,false,false,,,,TOO_SHORT
1774652,0xa0c66c2fbd70b4dff56798a824cdc94e300bd180,false,false,,,,TOO_SHORT
1774743,0x7afbb3b790ac473ad6bbe71d00f283f5c88de921,false,false,,,,TOO_SHORT
1775230,0x997091c3acf7fe9cb57d2df4f1ea353064aadcfe,false,false,,,,TOO_SHORT
1775305,0x83a4d675fadc7d8ce2c393f873afc172068a1da1,false,false,,,,TOO_SHORT
1775468,0xc72052f587b0870eaf78593eaf345418a9b8da7d,false,false,,,,TOO_SHORT
1775520,0x4e872a3b15384c11f230ddcf914ed3424aa9982a,false,false,,,,TOO_SHORT
1775565,0x0a437f81c619fc38a90d144faa6a42078374a601,false,false,,,,TOO_SHORT
1775834,0x819abe52095d9aaf3e8c286b1d2183a27044ca25,false,false,,,,TOO_SHORT
1775885,0xf78de3fb2a18935cec1340b12e5fac42bf5dfc1a,false,false,,,,TOO_SHORT
1775891,0x246e06eab57b5fdf6c003c3a57e92dd33c8521b2,false,false,,,,TOO_SHORT
1775967,0x599ab89ae35a5da3bf11eb8478f89099ac06d989,false,false,,,,TOO_SHORT
1775997,0x3d0a54111a1b3af30d5de539360bc87f0beaa6bc,false,false,,,,TOO_SHORT
1776053,0x1a2705d17c202b7a24f037893d0cef9ce6ff4d93,false,false,,,,TOO_SHORT
1776089,0x146bcf09fac419e37567a5efc737ffb976aed802,false,false,,,,TOO_SHORT
1776143,0x0f3a4ed6ba210fab0a9b086ec23524cbb86e22f7,false,false,,,,TOO_SHORT
1776275,0x8344d857f291086496f093536fee7254947a3c78,false,false,,,,TOO_SHORT
1776387,0x9e16edce43c4d929bb85978d176716e4e47b1526,false,false,,,,TOO_SHORT
1776409,0x25e6757e2c7d6e8d91e49c8b745fd89360bc0501,false,false,,,,TOO_SHORT
1776418,0x34f248ac5b443df489876e97effe1387e5a2d9d3,false,false,,,,TOO_SHORT
1776490,0x87e42b95f598ed0cbb3c5ce493cdce9ed5ec143a,false,false,,,,TOO_SHORT
1776535,0x168b9f17b2f675037778cf386a09556069c6cde3,false,false,,,,TOO_SHORT
1776579,0x362e6900b4b0e9255469108084766cf43f5f8951,false,false,,,,TOO_SHORT
1776590,0xae1c6feb82c95ff067bb82e80e62bf1ffc243665,false,false,,,,TOO_SHORT
1776663,0xe3e1924cda8a63a02487a02e52be1b5f018e297d,false,false,,,,TOO_SHORT
1776664,0x2adf21cf3166fdcce2d9208307ebb4fc1356bb84,false,false,,,,TOO_SHORT
1776665,0xc7c1879cd76e7a178710ea3b880527103ed6e128,false,false,,,,TOO_SHORT
1777072,0x56dd0ed716d3b35490cea3426c986f8a691b9e8e,false,false,,,,TOO_SHORT
1777235,0x4cbe419cd33939371650cd2a941f8e9c61b5c7d1,false,false,,,,TOO_SHORT
1777353,0x51873226be14dd5c77b7621e3892307dfd646eb8,false,false,,,,TOO_SHORT
1777591,0x327f9d86e1ed0e245e8a0f472bc929503711b787,false,false,,,,TOO_SHORT
1778082,0x2c69437d09f6b35055b17842e74aabbf5b6244ee,false,false,,,,TOO_SHORT
1778400,0xf272f53d35d37d680502549b66bdc8dc43c0078d,false,false,,,,TOO_SHORT
1779734,0x9674cda3ea48beaadf7176be91b0afd2799c80f1,false,false,,,,TOO_SHORT
1779829,0xc98c92963238356256027dc2d49a1f19e72845cf,false,false,,,,TOO_SHORT
1779880,0x22760695e8726c1c51264481ffa1779bb756c58f,false,false,,,,TOO_SHORT
1779961,0xbefc521190952b4840f1e9ca52ee7fb3a1ec65ce,false,false,,,,TOO_SHORT
1780208,0x92d0e3ad411843a2d148bb746d673fb550db043e,false,false,,,,TOO_SHORT
1780213,0x10a59fb9bb0db68919732f1551c06eae2f8b23f5,false,false,,,,TOO_SHORT
1780260,0x2a43483c33eaf723e43658089580a8f8ca4da17f,false,false,,,,TOO_SHORT
1780267,0xece75e9042a39e992a4db57422990f0867aaa556,false,false,,,,TOO_SHORT
1780334,0xb85233739c8ddefdc0c69d947d094004ab36b6d7,false,false,,,,TOO_SHORT
1780415,0x9ce0a7d921d0239d24c04e092a386a99e2dc239d,false,false,,,,TOO_SHORT
1780437,0xcc66e857efe4c28570d416b0f10e18ab78ff31ae,false,false,,,,TOO_SHORT
1780576,0xffb9bec15564250983411443ff481ca2b84447c0,false,false,,,,TOO_SHORT
1780612,0x51aa37749186143e65fdf3573bb9b4a28876538b,false,false,,,,TOO_SHORT
1780712,0xca64a59a2330dcf4e74b5fc932a59e33e393cdb6,false,false,,,,TOO_SHORT
1780785,0x50ceb28f1e4808f68b38d05c0eda28f203918034,false,false,,,,TOO_SHORT
1780786,0x6f02f7dd75e642677fd74e716c6670fff98eb8ec,false,false,,,,TOO_SHORT
1780787,0xe961a16f1d5bc475b3fd718a363ec7eee25b2f80,false,false,,,,TOO_SHORT
1780788,0x382fc7b3be4c8c3591784c26a497011b52c6227d,false,false,,,,TOO_SHORT
1780789,0x978a287ff0e13936bf29f2e1e12f4c74a516359f,false,false,,,,TOO_SHORT
1780791,0xf73630304fe65ed1d478958c63218059d06112c1,false,false,,,,TOO_SHORT
1780889,0x8a6599b6c89bff4404eab513f8bacaf6f08fbdb7,false,false,,,,TOO_SHORT
1780940,0xe16de91861315d77c38db557dd787145c05acdf7,false,false,,,,TOO_SHORT
1780968,0x9db3f00bb831d2c49ca876162346ff0005342613,false,false,,,,TOO_SHORT
1781154,0xe1529c352844e9eaa33d956a6d7d9cb772db2735,false,false,,,,TOO_SHORT
1781202,0x0554c6ae3f9efb142ca153f0dd64c6499643293a,false,false,,,,TOO_SHORT
1781252,0xd4e92330cdb807c3ae6878706238b820525c3ab6,false,false,,,,TOO_SHORT
1781276,0x02f023e99db72101303aee7fff3cea1e0bd1d18f,false,false,,,,TOO_SHORT
1781301,0xc4da66dd593350a184bf820b28d5f8b8ce035651,false,false,,,,TOO_SHORT
1781416,0xb77ccd94b3c6088ba0780abc7eb76dc4624642ca,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1781845,0x578494786ba08829f3149dce3d70732a3e5cdb98,false,false,,,,TOO_SHORT
1781940,0x69f0ead4ea0adc2b50a2318e606b2ac558d3df54,false,false,,,,TOO_SHORT
1781946,0x151de4ee5f6909e3caf1ccc643746d80f4721c1a,false,false,,,,TOO_SHORT
1781961,0xdc4bcd908c22cd0365349994cef5fbc5d112b308,false,false,,,,TOO_SHORT
1782007,0xb68d2c8468b6d9a8fd9c46d7376c12e6bb1894c1,false,false,,,,TOO_SHORT
1782069,0x53325828eddecdc4378acb9d2d116ba6b38bd35a,false,false,"contract RandomInterface {\n	function getRandom() returns (bytes32 hash) {}\n}\ncontract WinnerDBInterface {\n	function Winners(uint id) constant returns(uint date, address addr, uint value, uint rate, uint bet) {}\n	function newWinner(uint date, address addr, uint value, uint rate, uint bet) external returns (bool) {}\n}\ncontract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		http://d.ethereumlottery.net\n		ver: 2.2.2\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	address private winnersDB;\n	address private randomAddr;\n	uint private constant fee = 5;\n	uint private constant investorFee = 70;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 100;\n	\n	bool public ContractEnabled = true;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private ContractDisabledBlock;\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n		uint id;\n		uint sumInvest;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] private investors;\n	\n	string constant public Information = ""http://d.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function dEthereumlotteryNet(address _winnersDB, address _randomAddr, bool _oldContract, address _oldContractAddress) {\n		owner = msg.sender;\n		winnersDB = _winnersDB;\n		randomAddr = _randomAddr;\n		if (_oldContract && _oldContractAddress != 0x0) {\n			RollCount = dEthereumlotteryNet( _oldContractAddress ).RollCount();\n			JackpotHits = dEthereumlotteryNet( _oldContractAddress ).JackpotHits();\n		}\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n		if (jackpot_ == 0) {\n			Rate = 0;\n			Bet = 0;\n			return;\n		}\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		while (Value < Bet) {\n			Rate++;\n			Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n			Rate = BestRollRate;\n			Bet = getRealBet(Rate);\n		}\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		var (found, InvestorID) = getInvestorByAddress(Address);\n		if (found == false || ! investors[InvestorID].valid) {\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n			return;\n		}\n		Investment = investors[InvestorID].value;\n		Balance = investors[InvestorID].balance;\n		Live = investors[InvestorID].live;\n	}\n	function Winners(uint id) constant returns(uint date, address addr, uint value, uint rate, uint bet) {\n		return WinnerDBInterface(winnersDB).Winners(id);\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() external OnlyEnabled noContract {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) {\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].timestamp = now + investMinDuration;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		jackpot_ += value_;\n		setJackpot();\n	}\n	function GetMyInvestmentBalance() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		uint _balance = investors[InvestorID].balance;\n		if (_balance == 0) { throw; }\n		investors[InvestorID].balance = 0;\n		if ( ! msg.sender.send( _balance )) { throw; }\n	}\n	function CancelMyInvestment() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].timestamp > now && ContractEnabled) { throw; }\n		uint balance_;\n		if (investors[InvestorID].live) {\n			jackpot_ -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		delete investors[InvestorID];\n		if ( ! msg.sender.send( balance_ )) { throw; }\n	}\n	/* For Players */\n	function DoRoll() external noEther {\n		uint value_;\n		bool found;\n		bool subFound;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n				subFound = false;\n				if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n					uint feeValue_ = players[msg.sender][a].value/2;\n					feeValue += feeValue_;\n					investorAddFee(players[msg.sender][a].value - feeValue_);\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, false, true, false, false, 0, 0, 0);\n					subFound = true;\n				}\n				if ( ! ContractEnabled || players[msg.sender][a].sumInvest != jackpot_ || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, true, false, false, false, 0, 0, 0);\n					subFound = true;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					subFound = true;\n				}\n				if (subFound) {\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if ( ! found) { throw; }\n		if (value_ > 0) { if ( ! msg.sender.send(value_)) { throw; } }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled noContract {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		var (_rate, _realBet) = ChanceOfWinning(msg.value);\n		if (_realBet > msg.value) { throw; }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! ContractEnabled) {\n			if (ContractDisabledBlock < block.number) {\n				if (playersPot == 0) { throw; }\n				uint _value = playersPot;\n				playersPot = 0;\n				if ( ! msg.sender.send( _value )) { throw; }\n			}\n		} else {\n			ContractEnabled = false;\n			ContractDisabledBlock = block.number+rollLossBlockDelay;\n			ContractDisabled(ContractDisabledBlock);\n			feeValue += extraJackpot_;\n			extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner noEther {\n		if (feeValue == 0) { throw; }\n		uint _value = playersPot;\n		feeValue = 0;\n		if ( ! owner.send(_value)) { throw; }\n	}\n	\n	/*\n		Private functions\n	*/\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber == 0 || _rate == 0) { return; }\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n			WinnerDBInterface( winnersDB ).newWinner(now, msg.sender, win, _rate, players[msg.sender][id].value);\n			DoRollEvent(msg.sender, win, players[msg.sender][id].id, false, false, false, true, bigNumber, _rate, bigNumber % _rate);\n		} else {\n			DoRollEvent(msg.sender, players[msg.sender][id].value, players[msg.sender][id].id, false, false, true, false, bigNumber, _rate, bigNumber % _rate);\n		}\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		RollCount++;\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed, RandomInterface(randomAddr).getRandom(), address(seed).balance);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		players[msg.sender][rollID].id = RollCount;\n		players[msg.sender][rollID].sumInvest = jackpot_;	\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, players[msg.sender][rollID].value, players[msg.sender][rollID].id);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1 ether / value * 100 / investorFee * extraRate / 100 / 1 ether;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1 ether / ( rate * 1 ether * investorFee / extraRate);\n	}\n	function getInvestorByAddress(address Address) internal returns (bool found, uint id) {\n		for ( id=0 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return (true, id);\n			}\n		}\n		return (false, 0);\n	}\n	\n	/*\n		Events\n	*/	\n	event DoRollEvent(address Player, uint Value, uint RollID, bool Refund, bool LostBet, bool LossRoll, bool WinRoll, uint BigNumber, uint Rate, uint RollResult);\n	event PrepareRollEvent(address Player, uint Block, uint Bet, uint RollID);\n	event ContractDisabled(uint LossAllBetBlockNumber);\n	\n	/*\n		Modifiers\n	*/\n	modifier noContract() {if (tx.origin != msg.sender) { throw; } _ }\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1782686,0x54e323f7272047769a730e0846bfdec744fd5cbf,false,false,,,,TOO_SHORT
1782886,0x53e73eefa47068555febd9afc240b2b462c15d56,false,false,,,,TOO_SHORT
1782942,0x9888ae94bf42bc74a014b7780257b3766f1dab3c,false,false,,,,TOO_SHORT
1783830,0x611721c32de7d74ef3f3da350a260332c5b3aac4,false,false,,,,TOO_SHORT
1783958,0x1b937c3aa9a3189d3f415df47f9f68221b012479,false,false,,,,TOO_SHORT
1784289,0xfb97684312c6422bea2e0f08b3b58463f7e85401,false,false,,,,TOO_SHORT
1784785,0x42fbf81a9a95906619e5a86079701608eafaa148,false,false,,,,TOO_SHORT
1784869,0x391e2e8e831344c28a4146e4102c3fa3fe7e0509,false,false,,,,TOO_SHORT
1785174,0x22f83d39a2148dd389ed4c7a9280f57d5c8679da,false,false,"contract Emailer {\n    /* Define variable owner of the type address*/\n    address owner;\n	event Sent(address from, uint256 price, string to, string body);\n	\n    function Emailer() { \n        owner = msg.sender; \n    }\n    function kill() { \n		suicide(owner); \n    }\n	function withdraw(uint256 _amount){\n		owner.send(_amount);\n	}\n    function SendEmail(string _Recipient, string _Message) { \n        Sent(msg.sender, msg.value, _Recipient, _Message);\n    }    \n}",1,基本的な機能を持つ実用的なスマートコントラクトで、特に芸術的要素はありません。,
1785178,0x3ef10f84df0e9286db1ed5116291d14182ef5b97,false,false,,,,TOO_SHORT
1785290,0xe25a0c5a9213e958a2c6f79ad2d1b1acf518ddfc,false,false,"contract bbb{\n    /* Define variable owner of the type address*/\n    address owner;\n	event EmailSent(address Sender, uint256 PricePaid, string EmailAddress, string Message);\n	\n    function bbb() { \n        owner = msg.sender; \n    }\n    function Kill() { \n		if(msg.sender==owner){\n			suicide(owner); \n		}		\n    }\n	function Withdraw(uint256 AmountToWithdraw){\n		owner.send(AmountToWithdraw);\n	}\n    function SendEmail(string EmailAddress, string Message) { \n        EmailSent(msg.sender, msg.value, EmailAddress, Message);\n    }    \n}",1,基本的な機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。,
1785301,0xa9659531a174390b6921ffd540365bbb02297f10,false,false,,,,0xe25a0c5a9213e958a2c6f79ad2d1b1acf518ddfc
1785368,0x8197a236bd44b2173ce44b09d1c417cba150ad25,false,false,,,,0xe25a0c5a9213e958a2c6f79ad2d1b1acf518ddfc
1785960,0xba2a29b99e72c31994812764cf49a9de6b696754,false,false,,,,TOO_SHORT
1786005,0x9bc85747c18ba0b16fa4c824a98c53ea6ac71ac0,false,false,,,,TOO_SHORT
1786046,0x2368c7859efd49cd088c9d2b5bb54bba6ff726a7,false,false,,,,TOO_SHORT
1786144,0xa367ee93028456f9dd02eea94973df844bdf85ac,false,false,,,,TOO_SHORT
1786198,0xfeb91fb99440362eb93e3dcf7b06622bee44e611,false,false,,,,TOO_SHORT
1786260,0xb9d15f3891a9d919e42a8b2e777811ac38e06a81,false,false,,,,TOO_SHORT
1786365,0x75a9508f23c7d62dc5e6b0a9c925abaf1c325b0f,false,false,,,,TOO_SHORT
1786547,0xdb29efd9de4880fe2adf369b0c68b4335cbea3fb,false,false,,,,TOO_SHORT
1786684,0x4afdbb3dab3229ca059c1cf08de7c96496c785f5,false,false,,,,TOO_SHORT
1786705,0x3ecffad2055695d8fbb993faec629415f5bca991,false,false,,,,TOO_SHORT
1786714,0x1ed900fb1528dd94d33b41a3a500bac6301b5576,false,false,,,,TOO_SHORT
1786970,0x6e73728c242a60fff0a32f5a2ac1172859c987a2,false,false,,,,TOO_SHORT
1787069,0xf3b3ffa2053f7daa9db22886d7f8faadb5a629fb,false,false,,,,TOO_SHORT
1787111,0x425361e3c95ae33f33f01b3d5bc0e90a5ba65c6b,false,false,,,,TOO_SHORT
1787205,0x92de9ebbce2fbc79c1222d9a79b8f2a82717aa34,false,false,,,,TOO_SHORT
1787317,0x40b39f3406a49220cd38e1a7f3b56a95fbc9176c,false,false,,,,TOO_SHORT
1787343,0x74992a80eaf63cc248c3963eac30fae8fd9865d2,false,false,,,,TOO_SHORT
1787526,0x8257b6ed0571b128ca48d1c53fe69dacf7a99894,false,false,,,,TOO_SHORT
1787581,0xf1c80b1feb5e6526f5f0877e59a867d2ad458d9a,false,false,,,,TOO_SHORT
1787654,0x4558cbca404323a7b711c438a75faae3bff98d40,false,false,,,,TOO_SHORT
1788006,0xd77c717b04d056902e6304c9be464d12aefb9db6,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\n\n\n    \n\n\n\n\n\n\ncontract Ethereum_twelve_bagger is usingOraclize\n{\n\n 							//declares global variables\nstring hexcomparisonchr;\nstring A;\nstring B;\n\nuint8 lotteryticket;\naddress creator;\nint lastgainloss;\nstring lastresult;\nstring K;\nstring information;\n  \n \naddress player;\nuint8 gameResult;\nuint128 wager; \n mapping (bytes32=>uint) bets;\nmapping (bytes32 => address) gamesPlayer;\n \n\n   function  Ethereum_twelve_bagger() private \n    { \n        creator = msg.sender; 								\n    }\n\n    function Set_your_game_number_between_1_15(string Set_your_game_number_between_1_15)			//sets game number\n {\n	player=msg.sender;\n    	A=Set_your_game_number_between_1_15;\n	wager =uint128(msg.value);\n	\n	lastresult = ""Waiting for a lottery number from Wolfram Alpha"";\n	lastgainloss = 0;\n	B=""The new right lottery number is not ready yet"";\n	information = ""The new right lottery number is not ready yet"";\n	testWager();\n	\n	WolframAlpha();\n}\n\n     	 \n	 \n	\n\n\n    \n\n    function WolframAlpha() private {\n	if (wager == 0) return;		//if wager is 0, abort \n        oraclize_setNetwork(networkID_testnet);\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n     	bytes32 myid =  oraclize_query(0,""WolframAlpha"", ""random number between 1 and 15"");\n	bets[myid] = wager;\n	gamesPlayer[myid] = player;\n    }\n\n 	    function __callback(bytes32 myid, string result, bytes proof) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n	\n        B = result;\n	\n	wager=uint128(bets[myid]);\n	player=gamesPlayer[myid];\n	test(A,B);\n	returnmoneycreator(gameResult,wager);\n	return;\n        \n}\n \nfunction test(string A,string B) private\n{ \ninformation =""The right lottery number is now ready. One Eth is 10**18 Wei."";\nK=""K"";\nbytes memory test = bytes(A);\nbytes memory kill = bytes(K);\n	 if (test[0]==kill[0] && player == creator)			//Creator can kill contract. Contract does not hold players money.\n	{\n		suicide(creator);} \n \n    	\n    \n\n\nif (equal(A,B))\n{\nlastgainloss =(12*wager);\n	    	lastresult = ""Win!"";\n	    	player.send(wager * 12);  \n\ngameResult=0;\nreturn;}\nelse \n{\nlastgainloss = int(wager) * -1;\n	    	lastresult = ""Loss"";\n	    	gameResult=1;\n	    									// Player lost. Return nothing.\n	    	return;\n\n\n \n	}\n}\n\n\n \nfunction testWager() private\n{if((wager * 12) > this.balance) 					// contract has to have 12*wager funds to be able to pay out. (current balance includes the wager sent)\n    	{\n    		lastresult = ""Bet is larger than games's ability to pay"";\n    		lastgainloss = 0;\n    		player.send(wager); // return wager\n		gameResult=0;\n		wager=0;\n		B=""Bet is larger than games's ability to pay"";\n		information =""Bet is larger than games's ability to pay"";\n    		return;\n}\n\nelse if (wager < 100000000000000000)					// Minimum bet is 0.1 eth \n    	{\n    		lastresult = ""Minimum bet is 0.1 eth"";\n    		lastgainloss = 0;\n    		player.send(wager); // return wager\n		gameResult=0;\n		wager=0;\n		B=""Minimum bet is 0.1 eth"";\n		information =""Minimum bet is 0.1 eth"";\n    		return;\n}\n\n\n\n\n	else if (wager == 0)\n    	{\n    		lastresult = ""Wager was zero"";\n    		lastgainloss = 0;\n		gameResult=0;\n    		// nothing wagered, nothing returned\n    		return;\n    	}\n}\n\n\n\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\n    /// @return a negative number if `_a` is smaller, zero if they are equal\n    /// and a positive numbe if `_b` is smaller.\n    function compare(string A, string B) private returns (int) {\n        bytes memory a = bytes(A);\n        bytes memory b = bytes(B);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n    /// @dev Compares two strings and returns true iff they are equal.\n    function equal(string A, string B) private returns (bool) \n       {\n        return compare(A, B) == 0;\n}\n\nfunction returnmoneycreator(uint8 gameResult,uint wager) private		//If game has over 50 eth, contract will send all additional eth to owner\n	{\n	if (gameResult==1&&this.balance>50000000000000000000)\n	{creator.send(wager);\n	return; \n	}\n \n	else if\n	(\n	gameResult==1&&this.balance>20000000000000000000)				//If game has over 20 eth, contract will send œ of any additional eth to owner\n	{creator.send(wager/2);\n	return; }\n	}\n \n/**********\nfunctions below give information about the game in Ethereum Wallet\n **********/\n \n 	function Results_of_the_last_round() constant returns (uint players_bet_in_Wei, string last_result,string Last_player_s_lottery_ticket,address last_player,string The_right_lottery_number,int Player_s_gain_or_Loss_in_Wei,string info)\n    { \n   	last_player=player;	\n	Last_player_s_lottery_ticket=A;\n	The_right_lottery_number=B;\n	last_result=lastresult;\n	players_bet_in_Wei=wager;\n	Player_s_gain_or_Loss_in_Wei=lastgainloss;\n	info = information;\n	\n \n    }\n\n \n    \n   \n	function Game_balance_in_Ethers() constant returns (uint balance, string info)\n    { \n        info = ""Choose number between 1 and 15. Win pays wager*12. Minimum bet is 0.1 eth. Maximum bet is game balance/12. Game balance is shown in full Ethers."";\n    	balance=(this.balance/10**18);\n\n    }\n    \n   \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1788026,0x6d2e9321eb16a6ff1d3b2582d29adafed7df185d,false,false,,,,TOO_SHORT
1788170,0xd7e6703b524cf7b33dcbbf77f214cec7fbeda645,false,false,,,,TOO_SHORT
1788439,0x991288bee6dddae93aae0f401610038b9e06c0cb,false,false,,,,TOO_SHORT
1788481,0x3f8117247184f08beec4fdcf405978405c92b5f1,false,false,,,,TOO_SHORT
1788485,0x27dd0726400e871f53118f353653a8b561e18787,false,false,,,,TOO_SHORT
1788538,0xc5b06e71ed9bbd5a8d973fdb25c6165e554f8af6,false,false,,,,TOO_SHORT
1788640,0xf7d02347d055bd3a1fd66a7f187c4453fb6882aa,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\n\ncontract Ethereum_twelve_bagger is usingOraclize\n{\n\n 							//declares global variables\nstring hexcomparisonchr;\nstring A;\nstring B;\n\nuint8 lotteryticket;\naddress creator;\nint lastgainloss;\nstring lastresult;\nstring K;\nstring information;\n  \n \naddress player;\nuint8 gameResult;\nuint128 wager; \n mapping (bytes32=>uint) bets;\nmapping (bytes32 => address) gamesPlayer;\n \n\n   function  Ethereum_twelve_bagger() private \n    { \n        creator = msg.sender; 								\n    }\n\n    function Set_your_game_number_between_1_15(string Set_your_game_number_between_1_15)			//sets game number\n {\n	player=msg.sender;\n    	A=Set_your_game_number_between_1_15;\n	wager =uint128(msg.value);\n	\n	lastresult = ""Waiting for a lottery number from Wolfram Alpha"";\n	lastgainloss = 0;\n	B=""The new right lottery number is not ready yet"";\n	information = ""The new right lottery number is not ready yet"";\n	testWager();\n	\n	WolframAlpha();\n}\n\n     	 \n	 \n	\n\n\n    \n\n    function WolframAlpha() private {\n	if (wager == 0) return;		//if wager is 0, abort \n        \n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n     	bytes32 myid =  oraclize_query(0,""WolframAlpha"", ""random number between 1 and 15"");\n	bets[myid] = wager;\n	gamesPlayer[myid] = player;\n    }\n\n 	    function __callback(bytes32 myid, string result, bytes proof) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n	\n        B = result;\n	\n	wager=uint128(bets[myid]);\n	player=gamesPlayer[myid];\n	test(A,B);\n	returnmoneycreator(gameResult,wager);\n	return;\n        \n}\n \nfunction test(string A,string B) private\n{ \ninformation =""The right lottery number is now ready. One Eth is 10**18 Wei."";\nK=""K"";\nbytes memory test = bytes(A);\nbytes memory kill = bytes(K);\n	 if (test[0]==kill[0] && player == creator)			//Creator can kill contract. Contract does not hold players money.\n	{\n		suicide(creator);} \n \n    	\n    \n\n\nif (equal(A,B))\n{\nlastgainloss =(12*wager);\n	    	lastresult = ""Win!"";\n	    	player.send(wager * 12);  \n\ngameResult=0;\nreturn;}\nelse \n{\nlastgainloss = int(wager) * -1;\n	    	lastresult = ""Loss"";\n	    	gameResult=1;\n	    									// Player lost. Return nothing.\n	    	return;\n\n\n \n	}\n}\n\n\n \nfunction testWager() private\n{if((wager*12) > this.balance) 					// contract has to have 12*wager funds to be able to pay out. (current balance includes the wager sent)\n    	{\n    		lastresult = ""Bet is larger than games's ability to pay"";\n    		lastgainloss = 0;\n    		player.send(wager); // return wager\n		gameResult=0;\n		wager=0;\n		B=""Bet is larger than games's ability to pay"";\n		information =""Bet is larger than games's ability to pay"";\n    		return;\n}\n\nelse if (wager < 100000000000000000)					// Minimum bet is 0.1 eth \n    	{\n    		lastresult = ""Minimum bet is 0.1 eth"";\n    		lastgainloss = 0;\n    		player.send(wager); // return wager\n		gameResult=0;\n		wager=0;\n		B=""Minimum bet is 0.1 eth"";\n		information =""Minimum bet is 0.1 eth"";\n    		return;\n}\n\n\n\n\n	else if (wager == 0)\n    	{\n    		lastresult = ""Wager was zero"";\n    		lastgainloss = 0;\n		gameResult=0;\n    		// nothing wagered, nothing returned\n    		return;\n    	}\n}\n\n\n\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\n    /// @return a negative number if `_a` is smaller, zero if they are equal\n    /// and a positive numbe if `_b` is smaller.\n    function compare(string A, string B) private returns (int) {\n        bytes memory a = bytes(A);\n        bytes memory b = bytes(B);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n    /// @dev Compares two strings and returns true iff they are equal.\n    function equal(string A, string B) private returns (bool) \n       {\n        return compare(A, B) == 0;\n}\n\nfunction returnmoneycreator(uint8 gameResult,uint wager) private		//If game has over 50 eth, contract will send all additional eth to owner\n	{\n	if (gameResult==1&&this.balance>50000000000000000000)\n	{creator.send(wager);\n	return; \n	}\n \n	else if\n	(\n	gameResult==1&&this.balance>20000000000000000000)				//If game has over 20 eth, contract will send œ of any additional eth to owner\n	{creator.send(wager/2);\n	return; }\n	}\n \n/**********\nfunctions below give information about the game in Ethereum Wallet\n **********/\n \n 	function Results_of_the_last_round() constant returns (uint players_bet_in_Wei, string last_result,string Last_player_s_lottery_ticket,address last_player,string The_right_lottery_number,int Player_s_gain_or_Loss_in_Wei,string info)\n    { \n   	last_player=player;	\n	Last_player_s_lottery_ticket=A;\n	The_right_lottery_number=B;\n	last_result=lastresult;\n	players_bet_in_Wei=wager;\n	Player_s_gain_or_Loss_in_Wei=lastgainloss;\n	info = information;\n	\n \n    }\n\n \n    \n   \n	function Game_balance_in_Ethers() constant returns (uint balance, string info)\n    { \n        info = ""Choose number between 1 and 15. Win pays wager*12. Minimum bet is 0.1 eth. Maximum bet is game balance/12. Game balance is shown in full Ethers."";\n    	balance=(this.balance/10**18);\n\n    }\n    \n   \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1788678,0x256efe4d0907e75bed2099e0f90deb5cc4d7f557,false,false,,,,TOO_SHORT
1788760,0x56beee2930fb15587791071d047899c8be868b14,false,false,,,,TOO_SHORT
1788878,0x1ecdab1fb83dbf14ed118df2347a51a176f4ae41,false,false,,,,TOO_SHORT
1788970,0x0ff3f829580abbb45b25cd5234c3d174569dd204,false,false,,,,TOO_SHORT
1788971,0x917569b94096f8ae5d0d84a8855f10b140091263,false,false,,,,TOO_SHORT
1789016,0xdd97c46e34f67e40c1232b13745df14be3af09d6,false,false,,,,TOO_SHORT
1789087,0x80ddae5251047d6ceb29765f38fed1c0013004b7,false,false,"contract Lottery {\n    event GetBet(uint betAmount, uint blockNumber, bool won); \n\n    struct Bet {\n        uint betAmount;\n        uint blockNumber;\n        bool won;\n    }\n\n    address private organizer;\n    Bet[] private bets;\n\n    // Create a new lottery with numOfBets supported bets.\n    function Lottery() {\n        organizer = msg.sender;\n    }\n    \n    // Fallback function returns ether\n    function() {\n        throw;\n    }\n    \n    // Make a bet\n    function makeBet() {\n        // Won if block number is even\n        // (note: this is a terrible source of randomness, please don't use this with real money)\n        bool won = (block.number % 2) == 0; \n        \n        // Record the bet with an event\n        bets.push(Bet(msg.value, block.number, won));\n        \n        // Payout if the user won, otherwise take their money\n        if(won) { \n            if(!msg.sender.send(msg.value)) {\n                // Return ether to sender\n                throw;\n            } \n        }\n    }\n    \n    // Get all bets that have been made\n    function getBets() {\n        if(msg.sender != organizer) { throw; }\n        \n        for (uint i = 0; i < bets.length; i++) {\n            GetBet(bets[i].betAmount, bets[i].blockNumber, bets[i].won);\n        }\n    }\n    \n    // Suicide :(\n    function destroy() {\n        if(msg.sender != organizer) { throw; }\n        \n        suicide(organizer);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1789114,0x152c5bf14898d0f7da8bdfd44e18d8e3e2e2707a,false,false,,,,TOO_SHORT
1789143,0x850577bba64ed69160430b0ee4e93bc9da04b023,false,false,,,,TOO_SHORT
1789517,0xdcd4e7415f126e45caa7896377a45c74840bc0aa,false,false,,,,TOO_SHORT
1789587,0x08f8b978848fd1d0e10c1a3b7065ea7cbacb09a3,false,false,,,,TOO_SHORT
1789671,0xd588b586d61c826a0e87919b3d1a239206d58bf2,false,false,"// Ethereum Name Registrar as it should be!\n//\n// Written by Alexandre Naverniouk\n// twitter @AlexNa\n\n\ncontract EtherId {\n\nuint constant MAX_PROLONG = 2000000; // Maximum number of blocks to prolong the ownership. About one year.\n\nuint public n_domains = 0;      // total number of registered domains\nuint public root_domain = 0;    // name of the first domain in the linked list\naddress contract_owner = 0; //\n\nstruct Id {                     // Id record. Double linked list. Allows to delete ID\n    uint value;\n    uint next_id;\n    uint prev_id;\n}\n\nstruct Domain {                 // Domain record. Linked list. \n    address owner;              // Owner of the domain\n    uint expires;               // Expiration block namber\n    uint price;                 // Sale price ( 0 - not for sale )\n    address transfer;           // Address of the new owner\n    uint next_domain;           // Makes linked list for scanning\n    uint root_id;               // Name of the first ID in the list\n    mapping (uint => Id) ids;   // Map of the ID's\n}\n\nmapping (uint => Domain) domains; // Map of the domains\n\nfunction EtherId()\n{\n    contract_owner = msg.sender;\n}\n\nevent DomainChanged( address indexed sender, uint domain, uint id ); // Fired every time the registry is changed\n\nfunction getId( uint domain, uint id ) constant returns (uint v, uint next_id, uint prev_id )\n{\n    Id i = domains[domain].ids[id]; \n\n    v = i.value;\n    next_id = i.next_id;\n    prev_id = i.prev_id;\n}\n\nfunction getDomain( uint domain ) constant returns \n    (address owner, uint expires, uint price, address transfer, uint next_domain, uint root_id )\n{\n    Domain d = domains[ domain ];\n    \n    owner = d.owner;\n    expires = d.expires;\n    price = d.price;\n    transfer = d.transfer;\n    next_domain = d.next_domain;\n    root_id = d.root_id;    \n}\n\n\nfunction changeDomain( uint domain, uint expires, uint price, address transfer ) \n{\n    uint money_used = 0;            // How much was spent here\n\n    if( expires > MAX_PROLONG )     // Not prolong for too long\n    {\n        expires = MAX_PROLONG;\n    }\n    \n    if( domain == 0 ) throw;        // Prevents creating 0 domain\n\n    Domain d = domains[ domain ];\n\n    if( d.owner == 0 )              // 0 means the domain is not yet registered\n    { \n        d.owner = msg.sender;       // Simple calim\n        d.price = price;\n        d.transfer = transfer;\n        d.expires = block.number + expires;\n        \n        d.next_domain = root_domain;// Put the new domain into the linked list\n        root_domain = domain;\n        \n        //****************************************************************************\n        //*** SPECIAL CODE FOR TRANSFERING FIRST 32301 DOMAINS INTO THE NEW CONTRACT\n        if( msg.sender == contract_owner && n_domains < 32301 && transfer != 0 ) { \n            d.owner = transfer; // immediately transfer the ownership to the old owner\n            d.transfer = 0;\n        }\n        //****************************************************************************\n        \n        \n        n_domains = n_domains + 1;\n        DomainChanged( msg.sender, domain, 0 );\n    }\n    else                            // The domain already has an owner\n    {\n        if( d.owner == msg.sender || block.number > d.expires ) { // If it is yours or expired, you have all rights to change\n            d.owner = msg.sender;   // Possible change of the ownershp if expired\n            d.price = price;\n            d.transfer = transfer;\n            d.expires = block.number + expires;\n            DomainChanged( msg.sender, domain, 0 );\n        }\n        else                        // Not yours and not expired\n        {\n            if( d.transfer != 0 ) { // The new owner is specified and ...\n                if( d.transfer == msg.sender && msg.value >= d.price ) // ... it is you and enought money \n                {\n                    if( d.price > 0 ) \n                    { \n                        if( address( d.owner ).send( d.price ) ) // The money goes to the owner\n                        {\n                            money_used = d.price;   // remember how much spent\n                        }\n                        else throw; // problem with send()\n                    }\n\n                    d.owner = msg.sender;   // Change the ownership\n                    d.price = price;        // New price\n                    d.transfer = transfer;  // New transfer\n                    d.expires = block.number + expires; //New expiration\n                    DomainChanged( msg.sender, domain, 0 );\n                }\n            } \n            else  // not set for transfer, but...\n            {\n                if( d.price > 0 &&  msg.value >= d.price ) // ... on sale, and enough money\n                {\n                    if( address( d.owner ).send( d.price ) ) // The money goes to the owner\n                    {\n                        money_used = d.price; // remember how much spent\n                    }\n                    else throw; // problem with send()\n\n                    d.owner = msg.sender;   // Change the ownership\n                    d.price = price;        // New price\n                    d.transfer = transfer;  // New transfer\n                    d.expires = block.number + expires; // New expiration\n                    DomainChanged( msg.sender, domain, 0 );\n                }\n            }\n        }\n    }\n    \n    if( msg.value > money_used ) // If transaction has more money than was needed\n    {\n        if( !msg.sender.send( msg.value - money_used ) ) throw; // We do not need your leftover\n    }\n}\n\nfunction changeId( uint domain, uint name, uint value ) {\n\n    if( domain == 0 ) throw;        // Prevents creating 0 domain\n    if( name == 0 ) throw;          // Prevents creating 0 id\n    \n    Domain d = domains[ domain ];\n\n    if( d.owner == msg.sender )     // Only owner can change the ID\n    {\n        Id id = d.ids[ name ];\n\n        if( id.value == 0 ) {       // 0 means the ID was not found\n            if( value != 0 ) {      // Only add non zero values\n                id.value = value;   \n                id.next_id = d.root_id; // Put into the head of the list\n                // id.prev_id = 0;  // 0 is the default, no need to assign\n                \n                if( d.root_id != 0 ) \n                {\n                    d.ids[ d.root_id ].prev_id = name; // link the next ID back\n                }\n\n                d.root_id = name;   \n                DomainChanged( msg.sender, domain, name );\n            }\n        }\n        else                        // The ID was found\n        {\n            if( value != 0 )        // Simple change of the value\n            {\n                id.value = value;\n                DomainChanged( msg.sender, domain, name );\n            }\n            else                    // Deleting the ID\n            {\n                if( id.prev_id != 0 ) // Modify the double linked list\n                {\n                    d.ids[ id.prev_id ].next_id = id.next_id;   \n                }\n                else\n                {\n                    d.root_id = id.next_id;\n                }\n\n                if( id.next_id != 0 )\n                {\n                    d.ids[ id.next_id ].prev_id = id.prev_id;   \n                }\n                \n                id.prev_id = 0;   // Clear the storage\n                id.next_id = 0;   \n                id.value = 0;   \n                DomainChanged( msg.sender, domain, name );\n            }\n        }\n    }\n    \n    if( msg.value > 0 ) // If transaction has any money...\n    {\n        if( !msg.sender.send( msg.value ) ) throw; // ... it is a mistake, so send it back\n    }\n}\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ドメイン管理のための機能が中心。,
1789844,0xa3cf8a67daf0e40263026bfa757b2d3b4502ad4c,false,false,,,,TOO_SHORT
1789884,0x49070eea3d19f41f79920bbe670904b03e4bc96d,false,false,,,,TOO_SHORT
1790002,0x9a9ac653dcfea681d53c6a36b4050971e4952a50,false,false,,,,TOO_SHORT
1790019,0x40e8af4545415d850ea7083f75d250c81da90e44,false,false,,,,TOO_SHORT
1790174,0x5156deea2f8ba184f6050f602b6b10c75e53f518,false,false,,,,TOO_SHORT
1790398,0xa377a584c011f0bb714b22c602c0cf77ff8c9077,false,false,,,,TOO_SHORT
1790489,0x88a5599bf21d367993ea450e1e98a990610d63f6,false,false,,,,TOO_SHORT
1790985,0x35b090fd84e6b24050cc5fa542588a8eb12493ff,false,false,,,,TOO_SHORT
1791110,0x5d86b4d6c8d256f060796308a48e2257f43ef23d,false,false,,,,TOO_SHORT
1791224,0x1c4b56b8b31c0a8e8f3ca626c23a89a8eff4d25c,false,false,,,,TOO_SHORT
1791472,0x865b00c91055ddc20a172ecd2b65381dbaf19dbd,false,false,,,,TOO_SHORT
1791549,0x814ab6f574a80c03ecef7d2842a9793f46763a42,false,false,,,,TOO_SHORT
1791805,0x2a14071cd7fa3f3510b590495b75b38a80f8c77e,false,false,,,,TOO_SHORT
1791829,0x9cf4a037616247928da6be4d23b30cbbfe194f31,false,false,,,,TOO_SHORT
1792000,0xf511525294aedbe68371132b35ca325c430d62a4,false,false,,,,TOO_SHORT
1792116,0x7d11a8518cbc6560e36cbc23b788d415b9982404,false,false,"contract Soleau {\n\n  uint price = 0.001 ether;\n  struct Record {\n    address holder;\n    bool exists; \n    uint createdAt; /* Time */ \n    uint createdIn; /* Block number */\n  }\n  mapping (string => Record) _records;\n\n  function record(string hash) returns (bool success, bool already, uint theBlock) {\n    if (msg.value < price) {\n      success = false;\n      msg.sender.send(msg.value); /* We're nice, we refund */\n      return;\n    } /* Else we keep the money but there is currently no way to use\n	 it: it is locked in the contract for ever */\n    if (_records[hash].exists) {\n      success = true;\n      already = true;\n      theBlock = _records[hash].createdIn;\n    } else {\n      _records[hash].exists = true;\n      _records[hash].holder = msg.sender;\n      _records[hash].createdAt = now;\n      _records[hash].createdIn = block.number;\n      success = true;\n      already = false;\n      theBlock = _records[hash].createdIn;\n    }\n  }\n\n  function get(string hash) constant returns (bool success, uint theBlock, uint theTime, address holder) {\n    if (_records[hash].exists) {\n      success = true;\n      theBlock = _records[hash].createdIn;\n      theTime = _records[hash].createdAt;\n      holder = _records[hash].holder;\n    } else {\n      success = false;\n    }\n  }\n\n  /* No fallback function */\n  function () {\n    throw;\n  }\n  \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1792129,0x0e3f9442725fa6a09dab0485a3e21f163c64f80c,false,false,,,,TOO_SHORT
1792593,0x0f33c60125e07c913afcf48ee2ada5da3707af43,false,false,,,,TOO_SHORT
1792827,0x667d68d8855b849fc9afd88854293789fc63f989,false,false,,,,TOO_SHORT
1792868,0xa782e28a912ef9c44cbf827f8a3fefc3a8cb85e0,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :   \n//   The ROULETH \n//\n//  Play the Roulette on ethereum blockchain !\n//  (or become an investor in the Casino and share the profits/losses.) \n//\n//\n//   Full GUI on website with all info to play : \n//                   \n//                  www.Rouleth.com\n//\n//\n//   All documentation on playing and investing are on the website.\n//\n//   News : www.reddit.com/r/Rouleth\n//   twitter : https://twitter.com/TheRouleth\n//\n//   Github : https://github.com/Bunjin/Rouleth\n//\n//   check latest contract version on website\n//   V 1.2\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n//\n//\n//  Stake : Variable, check on website for the max bet.\n\ncontract Rouleth\n{\n\n    //Variables, Structure\n    address developer;\n    uint8 blockDelay; //nb of blocks to wait before spin\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\n    uint256 maxGamble; //max gamble value manually set by config\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\n    uint casinoStatisticalLimit;\n    //Current gamble value possibly lower than config (<payroll/(casinoStatisticalLimit*35))\n    uint256 currentMaxGamble; \n    //Gambles\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \n    struct Gamble\n    {\n	address player;\n        bool spinned; //Was the rouleth spinned ?\n	bool win;\n	//Possible bet types\n        BetTypes betType;\n	uint8 input; //stores number, color, dozen or oddeven\n	uint256 wager;\n	uint256 blockNumber; //block of bet -1\n        uint8 wheelResult;\n    }\n    Gamble[] private gambles;\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\n    //Tracking progress of players\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; //records current status of player\n\n    //**********************************************\n    //        Management & Config FUNCTIONS        //\n    //**********************************************\n    function  Rouleth() private //creation settings\n    { \n        developer = msg.sender;\n        blockDelay=2; //delay to wait between bet and spin\n	blockExpiration=200; //delay after which gamble expires\n        maxGamble=500 finney; //configurable max bet\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\n        casinoStatisticalLimit=20;\n    }\n	\n    modifier onlyDeveloper() \n    {\n	if (msg.sender!=developer) throw;\n	_\n    }\n	\n    function changeDeveloper(address new_dev)\n    noEthSent\n    onlyDeveloper\n    {\n	developer=new_dev;\n    }\n\n\n    //Activate, Deactivate Betting\n    enum States{active, inactive} States private state;\n	\n    function disableBetting()\n    noEthSent\n    onlyDeveloper\n    {\n        state=States.inactive;\n    }\n    function enableBetting()\n    onlyDeveloper\n    noEthSent\n    {\n        state=States.active;\n    }\n    \n    modifier onlyActive\n    {\n        if (state==States.inactive) throw;\n        _\n    }\n\n    //Change some settings within safety bounds\n    function changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\n    noEthSent\n    onlyDeveloper\n	{\n	        // changes the statistical multiplier that guarantees the long run casino survival\n	        if (newCasinoStatLimit<10) throw;\n	        casinoStatisticalLimit=newCasinoStatLimit;\n	        //Max number of bets per block to prevent miner cheating\n	        maxBetsPerBlock=newMaxBetsBlock;\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\n		if (newMaxGamble<=0) throw; \n		else { maxGamble=newMaxGamble; }\n                //MAX NB of INVESTORS (can only increase and max of 149)\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\n                else { setting_maxInvestors=newMaxInvestor;}\n                //MIN INVEST : \n                setting_minInvestment=newMinInvestment;\n                //Invest LOCK PERIOD\n                if (setting_lockPeriod>90 days) throw; //3 months max\n                setting_lockPeriod=newLockPeriod;\n		//Delay before roll :\n		if (blockDelay<1) throw;\n		blockDelay=newBlockDelay;\n                updateMaxBet();\n		if (newBlockExpiration<50) throw;\n		blockExpiration=newBlockExpiration;\n	}\n \n\n    //**********************************************\n    //                 BETTING FUNCTIONS                    //\n    //**********************************************\n\n//***//basic betting without Mist or contract call\n    //activates when the player only sends eth to the contract\n    //without specifying any type of bet.\n    function () \n   {\n       //if player is not playing : bet on Red\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnColor(true,false);\n       //if player is already playing, spin the wheel\n       else spinTheWheel();\n    } \n\n    function updateMaxBet() private\n    {\n    //check that maxGamble setting is still within safety bounds\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \n		{ \n			currentMaxGamble=maxGamble;\n                }\n	else\n		{ \n			currentMaxGamble = payroll/(casinoStatisticalLimit*35);\n		}\n     }\n\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\n    function checkBetValue() private returns(uint256 playerBetValue)\n    {\n        updateMaxBet();\n		if (msg.value > currentMaxGamble) //if above max, send difference back\n		{\n			if (msg.sender.send(msg.value-currentMaxGamble)==false) throw;\n		    playerBetValue=currentMaxGamble;\n		}\n                else\n                { playerBetValue=msg.value; }\n         return;\n       }\n\n\n    //check number of bets in block (to prevent miner cheating)\n    modifier checkNbBetsCurrentBlock()\n    {\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\n        else nbBetsCurrentBlock=0;\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\n        _\n    }\n    //check that the player is not playing already (unless it has expired)\n    modifier checkWaitingForBet{\n        //if player is already in gamble\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\n        {\n             //case not expired\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\n             //case expired\n             else\n             {\n                  //add bet to PL and reset status\n                  solveBet(msg.sender, 255, false, 0) ;\n\n              }\n        }\n	_\n	}\n\n    function updateStatusPlayer() private\n    expireGambles\n    {\n	playerStatus[msg.sender]=Status.waitingForSpin;\n	gambleIndex[msg.sender]=gambles.length;\n     }\n\n//***//bet on Number	\n    function betOnNumber(uint8 numberChosen)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        updateStatusPlayer();\n        //check that number chosen is valid and records bet\n        if (numberChosen>36) throw;\n        //adapts wager to casino limits\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\n    }\n\n//***// function betOnColor\n	//bet type : color\n	//input : 0 for red\n	//input : 1 for black\n    function betOnColor(bool Red, bool Black)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        updateStatusPlayer();\n        uint8 count;\n        uint8 input;\n        if (Red) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Black) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\n    }\n\n//***// function betOnLow_High\n	//bet type : lowhigh\n	//input : 0 for low\n	//input : 1 for low\n    function betOnLowHigh(bool Low, bool High)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        updateStatusPlayer();\n        uint8 count;\n        uint8 input;\n        if (Low) \n        { \n             count+=1; \n             input=0;\n         }\n        if (High) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\n    }\n\n//***// function betOnOdd_Even\n	//bet type : parity\n     //input : 0 for even\n    //input : 1 for odd\n    function betOnOddEven(bool Odd, bool Even)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        updateStatusPlayer();\n        uint8 count;\n        uint8 input;\n        if (Even) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Odd) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\n    }\n\n\n//***// function betOnDozen\n//     //bet type : dozen\n//     //input : 0 for first dozen\n//     //input : 1 for second dozen\n//     //input : 2 for third dozen\n    function betOnDozen(bool First, bool Second, bool Third)\n    {\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\n    }\n\n\n// //***// function betOnColumn\n//     //bet type : column\n//     //input : 0 for first column\n//     //input : 1 for second column\n//     //input : 2 for third column\n    function betOnColumn(bool First, bool Second, bool Third)\n    {\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\n     }\n\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    { \n        updateStatusPlayer();\n        uint8 count;\n        uint8 input;\n        if (First) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Second) \n        {\n             count+=1; \n             input=1;\n         }\n        if (Third) \n        {\n             count+=1; \n             input=2;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\n    }\n\n    //**********************************************\n    // Spin The Wheel & Check Result FUNCTIONS//\n    //**********************************************\n\n	event Win(address player, uint8 result, uint value_won);\n	event Loss(address player, uint8 result, uint value_loss);\n\n    //check that player has to spin the wheel\n    modifier checkWaitingForSpin{\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\n	_\n	}\n    //Prevents accidental sending of Eth when you shouldn't\n    modifier noEthSent()\n    {\n        if (msg.value>0) \n		{\n				if (msg.sender.send(msg.value)==false) throw;\n		}\n        _\n    }\n\n//***//function to spin\n    function spinTheWheel()\n    noEthSent\n    checkWaitingForSpin\n    {\n        //check that the player waited for the delay before spin\n        //and also that the bet is not expired\n	uint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\n	if (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\n        else\n	{\n	    uint8 wheelResult;\n            //Spin the wheel, Reset player status and record result\n	    wheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\n	    gambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\n            //check result against bet and pay if win\n	    checkBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\n	    updateFirstActiveGamble();\n	}\n    }\n\n//update pointer of first gamble not spinned\nfunction updateFirstActiveGamble() private\n     {\n              for (uint k=firstActiveGamble; k<=firstActiveGamble+50; k++) \n              //limit the update to 50 to cap the gas cost and share the work among users\n              {\n                 if (k>=gambles.length || !gambles[k].spinned)\n                 {\n                    firstActiveGamble=k;\n                    break; \n                 }\n              }\n }\n	\n//checks if there are expired gambles\nmodifier expireGambles{\n    if (  gambles.length!=0 && gambles.length-1>=firstActiveGamble \n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number \n          && !gambles[firstActiveGamble].spinned )  \n    { \n	solveBet(gambles[firstActiveGamble].player, 255, false, 0); //expires\n    }\n        updateFirstActiveGamble(); //update pointer\n        _\n}\n	\n\n     //CHECK BETS FUNCTIONS private\n     function checkBetResult(uint8 result, BetTypes betType) private\n     {\n          //bet on Number\n          if (betType==BetTypes.number) checkBetNumber(result);\n          else if (betType==BetTypes.parity) checkBetParity(result);\n          else if (betType==BetTypes.color) checkBetColor(result);\n	 else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\n	 else if (betType==BetTypes.dozen) checkBetDozen(result);\n	else if (betType==BetTypes.column) checkBetColumn(result);\n          updateMaxBet(); \n     }\n\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\n     {\n        playerStatus[player]=Status.waitingForBet;\n        gambles[gambleIndex[player]].spinned=true;\n	uint bet_v = gambles[gambleIndex[player]].wager;\n            if (win)\n            {\n                  if (player!=gambles[gambleIndex[player]].player) throw; //security failcheck\n		  gambles[gambleIndex[player]].win=true;\n		  uint win_v = multiplier*bet_v;\n                  lossSinceChange+=win_v-bet_v;\n		  Win(player, result, win_v);\n				if (player.send(win_v)==false) throw;\n             }\n            else\n            {\n		Loss(player, result, bet_v);\n                profitSinceChange+=bet_v;\n            }\n\n      }\n\n\n     // checkbeton number(input)\n    // bet type : number\n    // input : chosen number\n     function checkBetNumber(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result==gambles[gambleIndex[msg.sender]].input)\n	    {\n                  win=true;  \n             }\n             solveBet(msg.sender, result,win,36);\n     }\n\n\n     // checkbet on oddeven\n    // bet type : parity\n    // input : 0 for even, 1 for odd\n     function checkBetParity(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\n	    {\n                  win=true;                \n             }\n             solveBet(msg.sender,result,win,2);\n        \n     }\n	\n     // checkbet on lowhigh\n     // bet type : lowhigh\n     // input : 0 low, 1 high\n     function checkBetLowhigh(uint8 result) private\n     {\n            bool win;\n            //win\n		 if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\n			 || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\n			 ) )\n	    {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n     }\n\n     // checkbet on color\n     // bet type : color\n     // input : 0 red, 1 black\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\n      function checkBetColor(uint8 result) private\n      {\n             bool red;\n             //check if red\n             for (uint8 k; k<18; k++)\n             { \n                    if (red_list[k]==result) \n                    { \n                          red=true; \n                          break;\n                    }\n             }\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n       }\n\n     // checkbet on dozen\n     // bet type : dozen\n     // input : 0 first, 1 second, 2 third\n     function checkBetDozen(uint8 result) private\n     { \n            bool win;\n            //win on first dozen\n     		 if ( result!=0 &&\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\n     			||\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\n                    ||\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\n     	    {\n                   win=true;                \n             }\n             solveBet(msg.sender,result,win,3);\n     }\n\n     // checkbet on column\n     // bet type : column\n     // input : 0 first, 1 second, 2 third\n      function checkBetColumn(uint8 result) private\n      {\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,3);\n      }\n\n\n//INVESTORS FUNCTIONS\n\n\n//total casino payroll\n    uint256 payroll;\n//Profit Loss since last investor change\n    uint256 profitSinceChange;\n    uint256 lossSinceChange;\n//investor struct array (hard capped to 150)\n    uint8 setting_maxInvestors = 50;\n    struct Investor\n    {\n	    address investor;\n	    uint256 time;\n    }	\n	\n    Investor[250] private investors ;\n    //Balances of the investors\n    mapping (address=>uint256) balance; \n    //Investor lockPeriod\n    //lock time to avoid invest and withdraw for refresh only\n    //also time during which you cannot be outbet by a new investor if it is full\n    uint256 setting_lockPeriod=30 days ;\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\n    //if full and unlocked position, indicates the cheapest amount to outbid\n    //otherwise cheapestUnlockedPosition=255\n    uint8 cheapestUnlockedPosition; \n    uint256 minCurrentInvest; \n    //record open position index\n    // =255 if full\n    uint8 openPosition;\n	\n    event newInvest(address player, uint invest_v);\n\n\n     function invest()\n     {\n          // check that min 10 ETH is sent (variable setting)\n          if (msg.value<setting_minInvestment) throw;\n          // check if already investor\n          bool alreadyInvestor;\n          // reset the position counters to values out of bounds\n          openPosition=255;\n          cheapestUnlockedPosition=255;\n          minCurrentInvest=1000000000 ether;\n          // update balances before altering the investor shares\n          updateBalances();\n          // loop over investor's array to find if already investor, \n          // or openPosition and cheapest UnlockedPosition\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\n          { \n               //captures an index of an open position\n               if (investors[k].investor==0) openPosition=k; \n               //captures if already an investor \n               else if (investors[k].investor==msg.sender)\n               {\n                    investors[k].time=now; //refresh time invest\n                    alreadyInvestor=true;\n                }\n               //captures the index of the investor with the min investment (after lock period)\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\n               {\n                    cheapestUnlockedPosition=k;\n                    minCurrentInvest=balance[investors[k].investor];\n                }\n           }\n           //case New investor\n           if (alreadyInvestor==false)\n           {\n                    //case : investor array not full, record new investor\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\n                    //case : investor array full\n                    else\n                    {\n                         //subcase : investor has not outbid or all positions under lock period\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\n                         //subcase : investor outbid, record investor change and refund previous\n                         else\n                         {\n                              address previous = investors[cheapestUnlockedPosition].investor;\n                              balance[previous]=0;\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\n                              if (previous.send(balance[previous])==false) throw;\n                          }\n                     }\n            }\n          //add investment to balance of investor and to payroll\n\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\n          uint256 netInvest=msg.value - maintenanceFees;\n          newInvest(msg.sender, netInvest);\n          balance[msg.sender]+=netInvest; //add invest to balance\n          payroll+=netInvest;\n          //send maintenance fees to developer \n          if (developer.send(maintenanceFees)==false) throw;\n          updateMaxBet();\n      }\n\n//***// Withdraw function (only after lockPeriod)\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\n    // if your withdraw brings your balance under the min investment required,\n    // your balance is fully withdrawn\n	event withdraw(address player, uint withdraw_v);\n	\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\n    noEthSent\n    {\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\n        updateBalances();\n	//check that amount requested is authorized  \n	if (amountToWithdrawInWei>balance[msg.sender]) throw;\n        //retrieve investor ID\n        uint8 investorID=255;\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\n        {\n               if (investors[k].investor==msg.sender)\n               {\n                    investorID=k;\n                    break;\n               }\n        }\n           if (investorID==255) throw; //stop if not an investor\n           //check if investment lock period is over\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\n           //if balance left after withdraw is still above min investment accept partial withdraw\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\n           {\n               balance[msg.sender]-=amountToWithdrawInWei;\n               payroll-=amountToWithdrawInWei;\n               //send amount to investor (with security if transaction fails)\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\n	       withdraw(msg.sender, amountToWithdrawInWei);\n           }\n           else\n           //if amountToWithdraw=0 : user wants full withdraw\n           //if balance after withdraw is < min invest, withdraw all and delete investor\n           {\n               //send amount to investor (with security if transaction fails)\n               uint256 fullAmount=balance[msg.sender];\n               payroll-=fullAmount;\n               balance[msg.sender]=0;\n               //delete investor\n               delete investors[investorID];\n               if (msg.sender.send(fullAmount)==false) throw;\n   	       withdraw(msg.sender, fullAmount);\n            }\n          updateMaxBet();\n     }\n\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\n\n	function manualUpdateBalances()\n	expireGambles\n	noEthSent\n	onlyDeveloper\n	{\n	    updateBalances();\n	}\n    function updateBalances() private\n    {\n         //split Profits\n         uint256 profitToSplit;\n         uint256 lossToSplit;\n         if (profitSinceChange==0 && lossSinceChange==0)\n         { return; }\n         \n         else\n         {\n             // Case : Global profit (more win than losses)\n             // 2% fees for developer on global profit (if profit>loss)\n             if (profitSinceChange>lossSinceChange)\n             {\n                profitToSplit=profitSinceChange-lossSinceChange;\n                uint256 developerFees=profitToSplit*2/100;\n                profitToSplit-=developerFees;\n                if (developer.send(developerFees)==false) throw;\n             }\n             else\n             {\n                lossToSplit=lossSinceChange-profitSinceChange;\n             }\n         \n         //share the loss and profits between all invest \n         //(proportionnaly. to each investor balance)\n         uint totalShared;\n             for (uint8 k=0; k<setting_maxInvestors; k++)\n             {\n                 address inv=investors[k].investor;\n                 if (inv==0) continue;\n                 else\n                 {\n                       if (profitToSplit!=0) \n                       {\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\n                           balance[inv]+=profitShare;\n                           totalShared+=profitShare;\n                       }\n                       if (lossToSplit!=0) \n                       {\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\n                           balance[inv]-=lossShare;\n                           totalShared+=lossShare;\n                           \n                       }\n                 }\n             }\n          // update payroll\n          if (profitToSplit !=0) \n          {\n              payroll+=profitToSplit;\n              balance[developer]+=profitToSplit-totalShared;\n          }\n          if (lossToSplit !=0) \n          {\n              payroll-=lossToSplit;\n              balance[developer]-=lossToSplit-totalShared;\n          }\n          profitSinceChange=0; //reset Profit;\n          lossSinceChange=0; //reset Loss ;\n          \n          }\n     }\n     \n     \n     //INFORMATION FUNCTIONS\n     \n     function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances)\n     {\n        profit_since_update_balances=profitSinceChange;\n        loss_since_update_balances=lossSinceChange;\n        return;\n     }\n\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\n    {\n          balanceInWei=balance[investor];\n          return;\n     }\n\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\n    {\n          investor=investors[index].investor;\n          endLockPeriod=investors[index].time+setting_lockPeriod;\n          return;\n    }\n	\n\n	function investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\n	{\n		if (openPosition!=255) open_position=true;\n		if (cheapestUnlockedPosition!=255) \n		{\n			unlocked_position=true;\n			buyout_amount=minCurrentInvest;\n		}\n		investLockPeriod=setting_lockPeriod;\n		return;\n	}\n	\n	function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\n	{\n	    maxBet=currentMaxGamble;\n	    blockDelayBeforeSpin=blockDelay;\n	    return ;\n	}\n\n	function getFirstActiveGamble() constant returns(uint _firstActiveGamble)\n	{\n            _firstActiveGamble=firstActiveGamble;\n	    return ;\n	}\n	\n	function getPayroll() constant returns(uint payroll_at_last_update_balances)\n	{\n            payroll_at_last_update_balances=payroll;\n	    return ;\n	}\n\n	\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\n    {\n          player_status=playerStatus[player];\n          bettype=gambles[gambleIndex[player]].betType;\n          input=gambles[gambleIndex[player]].input;\n          value=gambles[gambleIndex[player]].wager;\n          result=gambles[gambleIndex[player]].wheelResult;\n          wheelspinned=gambles[gambleIndex[player]].spinned;\n          win=gambles[gambleIndex[player]].win;\n          blockNb=gambles[gambleIndex[player]].blockNumber;\n	  return;\n     }\n     \n         function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\n    {\n          player=gambles[index].player;\n          bettype=gambles[index].betType;\n          input=gambles[index].input;\n          value=gambles[index].wager;\n          result=gambles[index].wheelResult;\n          wheelspinned=gambles[index].spinned;\n          win=gambles[index].win;\n	  blockNb=gambles[index].blockNumber;\n	  return;\n     }\n\n} //end of contract",2,アスキーアートとコメントが詩的要素を加えているが、機能は実用的。,
1792872,0x51d9f8d3048db5a400317b51c3a48ec4cb6c2980,false,false,,,,TOO_SHORT
1792879,0x05240da139d30034eaae15737610bfbe68b97910,false,false,,,,0xa782e28a912ef9c44cbf827f8a3fefc3a8cb85e0
1793206,0x39aa4006ee5941c0c0e41b924fdafcb2c4c918e8,false,false,,,,0x7d11a8518cbc6560e36cbc23b788d415b9982404
1793578,0xd4c344d8294cfe0dba0f0604c78acac077f0cd4a,false,false,,,,TOO_SHORT
1793716,0x6653de5b7d047a6ae5095e52b449f07c8fd32098,false,false,,,,TOO_SHORT
1794138,0x5c251931762b305810990e4942155971b34cb6ea,false,false,,,,TOO_SHORT
1794301,0x1b0ea873055c36f1fc7bef087b8b0d1befe744ca,false,false,,,,TOO_SHORT
1794375,0x5913969924099bc9c22f0c81af6355e01a420b03,false,false,,,,TOO_SHORT
1794428,0x2d8ba8136a38cff02db0f00aecde8844a8865db3,false,false,,,,TOO_SHORT
1794444,0x131930b8b415a637f49c663cf6b1dec5e4b1e6aa,false,false,,,,TOO_SHORT
1794682,0xa93c4ef11f87d8230a9241e351e057448f064166,false,false,,,,TOO_SHORT
1794753,0x0bab8b87c0c325972654515cdd9325f2936c741b,false,false,,,,TOO_SHORT
1794776,0x9040fe487dba383177438447e4c7c664c5934d4d,false,false,,,,TOO_SHORT
1794839,0x00a25423ea69cf41caa9fd22f197623b9607b99c,false,false,,,,TOO_SHORT
1794855,0x6179658b5ea4b5c17ccd3b76efb1f4997124f9ac,false,false,,,,TOO_SHORT
1794967,0xb9dd61ecd201e989118177eb3410ed4a7d5458c6,false,false,,,,TOO_SHORT
1795076,0x32b617e4b66af48224ef78081eb19df2a7bcbee7,false,false,,,,TOO_SHORT
1795105,0xac37464ae175c6efe64274783e2a459fd7bf8067,false,false,,,,TOO_SHORT
1795375,0x8a8861bb1cf096293a40f27c7cb71027b00492bd,false,false,,,,TOO_SHORT
1795492,0x87e3f7d1aaf8bbe528d18c6e5a6a7fd74a864e2e,false,false,,,,TOO_SHORT
1795649,0xc2f3ede0751770f4c84a366552ae7fb160533adb,false,false,,,,TOO_SHORT
1796180,0xaa9fb10e14c6f2727c77eabd3bb8e39a9ca3bd8d,false,false,,,,TOO_SHORT
1797265,0x6f1329d6c89ce013a1cfdc76b155c569b5a8b17e,false,false,,,,TOO_SHORT
1797382,0xd679a487374e5ee1da801eb69fe542718a8cf695,false,false,,,,TOO_SHORT
1797475,0xea73bb441f60b2d4cdfaa0525637b4e17a9aed64,false,false,,,,TOO_SHORT
1797889,0xff3e0c06ffe0e54da6b0cdb9897dd83934a8c60e,false,false,,,,TOO_SHORT
1798057,0x0285ac2373a2c8a5fb8b20f27d259a428268f4bc,false,false,,,,TOO_SHORT
1798058,0x1aa07ce46e08b73beea921f6408df059cbb2d49c,false,false,,,,TOO_SHORT
1798581,0x9edade13ed9f43e7fba32b9d1679955a968caeb4,false,false,,,,TOO_SHORT
1798695,0xe50b05565422cf0d999deb3d928963539954d004,false,false,,,,TOO_SHORT
1798745,0x7c7da5d15aab8adb87b22b2544b6b897beb05e74,false,false,,,,TOO_SHORT
1798797,0x6a85089529f4799484e287a271ff69a8295dcdf8,false,false,,,,TOO_SHORT
1799240,0x00c5f1f61b59740bd034f6e72012471bdde54df5,false,false,,,,TOO_SHORT
1799345,0x4881df8d7301331e362d30ad3af9803708530ed8,false,false,,,,TOO_SHORT
1799727,0x80117ef730b1fea145486ca3daa6af8850b01ade,false,false,,,,TOO_SHORT
1799878,0x606ddac6f2928369e8515340f8de97fe2d166777,false,false,"// https://github.com/pipermerriam/ethereum-stack-depth-lib\n\nlibrary StackDepthLib {\n    // This will probably work with a value of 390 but no need to cut it\n    // that close in the case that the optimizer changes slightly or\n    // something causing that number to rise slightly.\n    uint constant GAS_PER_DEPTH = 400;\n\n    function checkDepth(address self, uint n) constant returns(bool) {\n        if (n == 0) return true;\n        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n    }\n\n    function __dig(uint n) constant {\n        if (n == 0) return;\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n    }\n}",1,実用的なコードで、スタック深度を管理するライブラリとして機能しています。,
1800105,0x42b3393fe6549738fe2a1e0c20c3e8139a056955,false,false,,,,TOO_SHORT
1800164,0x50016582df593b66aec0bce7de43290b02e7dc37,false,false,,,,TOO_SHORT
1800610,0x76bf0b108e2e16849214ff2bc937ac915e24987c,false,false,,,,TOO_SHORT
1800632,0x013a92248644175fe526d8b010ea0396c796192c,false,false,,,,TOO_SHORT
1800685,0xbf8674becd4dc94670a65442e075549244e9f1fb,false,false,,,,TOO_SHORT
1801013,0x836172015a69214e8ea82a9ac684c60e95eea15c,false,false,,,,TOO_SHORT
1801091,0xeb7d817b65f692e1ad41da1a72124acbf577a51e,false,false,,,,TOO_SHORT
1801110,0x3bb34a5a1cc7ca4c409dc7b33684fb0de3a90356,false,false,,,,TOO_SHORT
1801262,0x2cd07eb5b638e40f76577bbd8da51e926d121fd7,false,false,,,,TOO_SHORT
1801426,0x5eda40c9270e76db2eeace3731170ac3c34ef4c0,false,false,,,,TOO_SHORT
1801441,0x55190829f2b43323b61421b36d6bd1c5b85d1297,false,false,"contract BTCRelay {\n    function getLastBlockHeight() returns (int);\n    function getBlockchainHead() returns (int);\n    function getFeeAmount(int blockHash) returns (int);\n    function getBlockHeader(int blockHash) returns (bytes32[3]);\n}\n\ncontract Lottery {\n    int constant LOTTERY_BLOCKS = 7 * 24 * 6;\n    uint constant LOTTERY_INTERVAL = 7 days;\n    int constant CUTOFF_BLOCKS = 6 * 6;\n    uint constant CUTOFF_INTERVAL = 6 hours;\n    uint constant TICKET_PRICE = 10 finney;\n    uint constant FEE_FACTOR = 200; // 0.5 %\n\n    BTCRelay btcRelay = BTCRelay(0x41f274c0023f83391de4e0733c609df5a124c3d4);\n\n    struct Bucket {\n        uint numHolders;\n        address[] ticketHolders;\n    }\n\n    struct Payout {\n        address winner;\n        uint amount;\n        uint blockNumber;\n        uint timestamp;\n        address processor;\n    }\n\n    int public decidingBlock;\n    int public cutoffBlock;\n    uint public cutoffTimestamp;\n    int public nearestKnownBlock;\n    int public nearestKnownBlockHash;\n\n    uint public numTickets;\n    uint public numBuckets;\n    mapping (uint => Bucket) buckets;\n    uint public lastSaleTimestamp;\n\n    Payout[] public payouts;\n    uint public payoutIdx;\n\n    address public owner;\n\n    modifier onlyOwner { if (msg.sender == owner) _ }\n\n    event Activity();\n\n    function Lottery() {\n        owner = msg.sender;\n        payouts.length = 3;\n        prepareLottery();\n    }\n\n    function prepareLottery() internal {\n        decidingBlock = btcRelay.getLastBlockHeight() + LOTTERY_BLOCKS;\n        cutoffBlock = decidingBlock - CUTOFF_BLOCKS;\n        cutoffTimestamp = now + LOTTERY_INTERVAL - CUTOFF_INTERVAL;\n        nearestKnownBlock = 0;\n        nearestKnownBlockHash = 0;\n\n        numTickets = 0;\n        for (uint i = 0; i < numBuckets; i++) {\n            buckets[i].numHolders = 0;\n        }\n        numBuckets = 0;\n        lastSaleTimestamp = 0;\n    }\n\n    function resetLottery() {\n        if (numTickets > 0) throw;\n        if (!payoutReady()) throw;\n\n        prepareLottery();\n        Activity();\n    }\n\n    function () {\n        buyTickets(msg.sender);\n    }\n\n    function buyTickets(address ticketHolder) {\n        if (msg.value < TICKET_PRICE) throw;\n        if (!ticketsAvailable()) throw;\n\n        uint n = msg.value / TICKET_PRICE;\n        numTickets += n;\n\n        // We maintain the list of ticket holders in a number of buckets.\n        // Entries in the first bucket represent one ticket each, in the\n        // second bucket they represent two tickets each, then four tickets\n        // each and so on. This allows us to process the sale of n tickets\n        // with a gas cost of O(log(n)).\n        uint bucket = 0;\n        while (n > 0) {\n            uint inThisBucket = n & (2 ** bucket);\n            if (inThisBucket > 0) {\n                uint pos = buckets[bucket].numHolders++;\n                if (buckets[bucket].ticketHolders.length <\n                    buckets[bucket].numHolders) {\n                    buckets[bucket].ticketHolders.length =\n                        buckets[bucket].numHolders;\n                }\n                buckets[bucket].ticketHolders[pos] = ticketHolder;\n                n -= inThisBucket;\n            }\n            bucket += 1;\n        }\n\n        if (bucket > numBuckets) numBuckets = bucket;\n\n        int missingBlocks = decidingBlock - btcRelay.getLastBlockHeight();\n        uint betterCutoffTimestamp =\n            now + uint(missingBlocks) * 10 minutes - CUTOFF_INTERVAL;\n        if (betterCutoffTimestamp < cutoffTimestamp) {\n            cutoffTimestamp = betterCutoffTimestamp;\n        }\n\n        lastSaleTimestamp = now;\n        Activity();\n    }\n\n    function ticketsAvailable() constant returns (bool) {\n        return now < cutoffTimestamp &&\n            btcRelay.getLastBlockHeight() < cutoffBlock;\n    }\n\n    function lookupTicketHolder(uint idx) constant returns (address) {\n        uint bucket = 0;\n        while (idx >= buckets[bucket].numHolders * (2 ** bucket)) {\n            idx -= buckets[bucket].numHolders * (2 ** bucket);\n            bucket += 1;\n        }\n\n        return buckets[bucket].ticketHolders[idx / (2 ** bucket)];\n    }\n\n    function getNumHolders(uint bucket) constant returns (uint) {\n        return buckets[bucket].numHolders;\n    }\n\n    function getTicketHolders(uint bucket) constant returns (address[]) {\n        return buckets[bucket].ticketHolders;\n    }\n\n    function getLastBlockHeight() constant returns (int) {\n        return btcRelay.getLastBlockHeight();\n    }\n\n    function getOperatingBudget() constant returns (uint) {\n        return this.balance - numTickets * TICKET_PRICE;\n    }\n\n    function payoutReady() constant returns (bool) {\n        return decidingBlock <= btcRelay.getLastBlockHeight();\n    }\n\n    function processPayout() returns (bool done) {\n        if (!payoutReady()) throw;\n        if (getOperatingBudget() < 1 ether) throw;\n        if (numTickets == 0) throw;\n\n        var (walkingDone, blockHash) = walkTowardsBlock();\n        if (!walkingDone) return false;\n\n        int winnerIdx = blockHash % int(numTickets);\n        address winner = lookupTicketHolder(uint(winnerIdx));\n        uint fee = (numTickets * TICKET_PRICE) / FEE_FACTOR;\n        uint amount = (numTickets * TICKET_PRICE) - fee;\n\n        // keep some records\n        payouts[payoutIdx].winner = winner;\n        payouts[payoutIdx].amount = amount;\n        payouts[payoutIdx].blockNumber = block.number;\n        payouts[payoutIdx].timestamp = now;\n        payouts[payoutIdx].processor = msg.sender;\n        payoutIdx = (payoutIdx + 1) % 3;\n\n        prepareLottery();   // prepare next round\n        var _ = winner.send(amount);\n        Activity();\n\n        return true;\n    }\n\n    function walkTowardsBlock() internal returns (bool, int) {\n        int blockHeight;\n        int blockHash;\n        if (nearestKnownBlock == 0) {\n            blockHeight = btcRelay.getLastBlockHeight();\n            blockHash = btcRelay.getBlockchainHead();\n        } else {\n            blockHeight = nearestKnownBlock;\n            blockHash = nearestKnownBlockHash;\n        }\n\n        // Walk at most 5 steps to keep an upper limit on gas costs.\n        for (uint steps = 0; steps < 5; steps++) {\n            if (blockHeight == decidingBlock) {\n                return (true, blockHash);\n            }\n\n            uint fee = uint(btcRelay.getFeeAmount(blockHash));\n            bytes32 blockHeader =\n                btcRelay.getBlockHeader.value(fee)(blockHash)[2];\n            bytes32 temp;\n\n            assembly {\n                let x := mload(0x40)\n                mstore(x, blockHeader)\n                temp := mload(add(x, 0x04))\n            }\n\n            blockHeight -= 1;\n            blockHash = 0;\n            for (int i = 0; i < 32; i++) {\n                blockHash = blockHash | int(temp[uint(i)]) * (256 ** i);\n            }\n        }\n\n        // Store the progress to pick up from there next time.\n        nearestKnownBlock = blockHeight;\n        nearestKnownBlockHash = blockHash;\n\n        return (false, 0);\n    }\n\n    function accessOperatingBudget(uint amount) onlyOwner {\n        if (getOperatingBudget() < 1 ether) throw;\n\n        uint safeToAccess = getOperatingBudget() - 1 ether;\n        if (amount > safeToAccess) throw;\n\n        var _ = owner.send(amount);\n    }\n\n    function setOwner(address _owner) onlyOwner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ロジックが明確で、芸術的要素は少ない。,
1801657,0xca160042160211cfb63fee6b34cf102a4bdcb433,false,false,,,,TOO_SHORT
1801714,0x9b35f7bf4d3fb2910ba5faf4edc8c02169f50919,false,false,,,,TOO_SHORT
1801737,0x302fe87b56330be266599fab2a54747299b5ac5b,false,false,"contract BTCRelay {\n    function getLastBlockHeight() returns (int);\n    function getBlockchainHead() returns (int);\n    function getFeeAmount(int blockHash) returns (int);\n    function getBlockHeader(int blockHash) returns (bytes32[3]);\n}\n\ncontract Lottery {\n    int constant LOTTERY_BLOCKS = 7 * 24 * 6;\n    uint constant LOTTERY_INTERVAL = 7 days;\n    int constant CUTOFF_BLOCKS = 6 * 6;\n    uint constant CUTOFF_INTERVAL = 6 hours;\n    uint constant TICKET_PRICE = 10 finney;\n    uint constant FEE_FACTOR = 200; // 0.5 %\n\n    BTCRelay btcRelay = BTCRelay(0x41f274c0023f83391de4e0733c609df5a124c3d4);\n\n    struct Bucket {\n        uint numHolders;\n        address[] ticketHolders;\n    }\n\n    struct Payout {\n        address winner;\n        uint amount;\n        uint blockNumber;\n        uint timestamp;\n        address processor;\n    }\n\n    int public decidingBlock;\n    int public cutoffBlock;\n    uint public cutoffTimestamp;\n    int public nearestKnownBlock;\n    int public nearestKnownBlockHash;\n\n    uint public numTickets;\n    uint public numBuckets;\n    mapping (uint => Bucket) buckets;\n    uint public lastSaleTimestamp;\n\n    Payout[] public payouts;\n    uint public payoutIdx;\n\n    address public owner;\n\n    modifier onlyOwner { if (msg.sender == owner) _ }\n\n    event Activity();\n\n    function Lottery() {\n        owner = msg.sender;\n        payouts.length = 3;\n        prepareLottery();\n    }\n\n    function prepareLottery() internal {\n        decidingBlock = btcRelay.getLastBlockHeight() + LOTTERY_BLOCKS;\n        cutoffBlock = decidingBlock - CUTOFF_BLOCKS;\n        cutoffTimestamp = now + LOTTERY_INTERVAL - CUTOFF_INTERVAL;\n        nearestKnownBlock = 0;\n        nearestKnownBlockHash = 0;\n\n        numTickets = 0;\n        for (uint i = 0; i < numBuckets; i++) {\n            buckets[i].numHolders = 0;\n        }\n        numBuckets = 0;\n        lastSaleTimestamp = 0;\n    }\n\n    function resetLottery() {\n        if (numTickets > 0) throw;\n        if (!payoutReady()) throw;\n\n        prepareLottery();\n        Activity();\n    }\n\n    function () {\n        buyTickets(msg.sender);\n    }\n\n    function buyTickets(address ticketHolder) {\n        if (msg.value < TICKET_PRICE) throw;\n        if (!ticketsAvailable()) throw;\n\n        uint n = msg.value / TICKET_PRICE;\n        numTickets += n;\n\n        // We maintain the list of ticket holders in a number of buckets.\n        // Entries in the first bucket represent one ticket each, in the\n        // second bucket they represent two tickets each, then four tickets\n        // each and so on. This allows us to process the sale of n tickets\n        // with a gas cost of O(log(n)).\n        uint bucket = 0;\n        while (n > 0) {\n            uint inThisBucket = n & (2 ** bucket);\n            if (inThisBucket > 0) {\n                uint pos = buckets[bucket].numHolders++;\n                if (buckets[bucket].ticketHolders.length <\n                    buckets[bucket].numHolders) {\n                    buckets[bucket].ticketHolders.length =\n                        buckets[bucket].numHolders;\n                }\n                buckets[bucket].ticketHolders[pos] = ticketHolder;\n                n -= inThisBucket;\n            }\n            bucket += 1;\n        }\n\n        if (bucket > numBuckets) numBuckets = bucket;\n\n        int missingBlocks = decidingBlock - btcRelay.getLastBlockHeight();\n        uint betterCutoffTimestamp =\n            now + uint(missingBlocks) * 10 minutes - CUTOFF_INTERVAL;\n        if (betterCutoffTimestamp < cutoffTimestamp) {\n            cutoffTimestamp = betterCutoffTimestamp;\n        }\n\n        lastSaleTimestamp = now;\n        Activity();\n    }\n\n    function ticketsAvailable() constant returns (bool) {\n        return now < cutoffTimestamp &&\n            btcRelay.getLastBlockHeight() < cutoffBlock;\n    }\n\n    function lookupTicketHolder(uint idx) constant returns (address) {\n        uint bucket = 0;\n        while (idx >= buckets[bucket].numHolders * (2 ** bucket)) {\n            idx -= buckets[bucket].numHolders * (2 ** bucket);\n            bucket += 1;\n        }\n\n        return buckets[bucket].ticketHolders[idx / (2 ** bucket)];\n    }\n\n    function getNumHolders(uint bucket) constant returns (uint) {\n        return buckets[bucket].numHolders;\n    }\n\n    function getTicketHolders(uint bucket) constant returns (address[]) {\n        return buckets[bucket].ticketHolders;\n    }\n\n    function getLastBlockHeight() constant returns (int) {\n        return btcRelay.getLastBlockHeight();\n    }\n\n    function getOperatingBudget() constant returns (uint) {\n        return this.balance - numTickets * TICKET_PRICE;\n    }\n\n    function checkDepth(uint n) constant returns (bool) {\n        if (n == 0) return true;\n        return checkDepth(n - 1);\n    }\n\n    function payoutReady() constant returns (bool) {\n        return decidingBlock <= btcRelay.getLastBlockHeight();\n    }\n\n    function processPayout() returns (bool done) {\n        if (!payoutReady()) throw;\n        if (getOperatingBudget() < 1 ether) throw;\n        if (numTickets == 0) throw;\n        if (!checkDepth(8)) throw;\n\n        var (walkingDone, blockHash) = walkTowardsBlock();\n        if (!walkingDone) return false;\n\n        int winnerIdx = blockHash % int(numTickets);\n        address winner = lookupTicketHolder(uint(winnerIdx));\n        uint fee = (numTickets * TICKET_PRICE) / FEE_FACTOR;\n        uint amount = (numTickets * TICKET_PRICE) - fee;\n\n        // keep some records\n        payouts[payoutIdx].winner = winner;\n        payouts[payoutIdx].amount = amount;\n        payouts[payoutIdx].blockNumber = block.number;\n        payouts[payoutIdx].timestamp = now;\n        payouts[payoutIdx].processor = msg.sender;\n        payoutIdx = (payoutIdx + 1) % 3;\n\n        prepareLottery();   // prepare next round\n        var _ = winner.send(amount);\n        Activity();\n\n        return true;\n    }\n\n    function walkTowardsBlock() internal returns (bool, int) {\n        int blockHeight;\n        int blockHash;\n        if (nearestKnownBlock == 0) {\n            blockHeight = btcRelay.getLastBlockHeight();\n            blockHash = btcRelay.getBlockchainHead();\n        } else {\n            blockHeight = nearestKnownBlock;\n            blockHash = nearestKnownBlockHash;\n        }\n\n        // Walk at most 5 steps to keep an upper limit on gas costs.\n        for (uint steps = 0; steps < 5; steps++) {\n            if (blockHeight == decidingBlock) {\n                return (true, blockHash);\n            }\n\n            uint fee = uint(btcRelay.getFeeAmount(blockHash));\n            bytes32 blockHeader =\n                btcRelay.getBlockHeader.value(fee)(blockHash)[2];\n            bytes32 temp;\n\n            assembly {\n                let x := mload(0x40)\n                mstore(x, blockHeader)\n                temp := mload(add(x, 0x04))\n            }\n\n            blockHeight -= 1;\n            blockHash = 0;\n            for (int i = 0; i < 32; i++) {\n                blockHash = blockHash | int(temp[uint(i)]) * (256 ** i);\n            }\n        }\n\n        // Store the progress to pick up from there next time.\n        nearestKnownBlock = blockHeight;\n        nearestKnownBlockHash = blockHash;\n\n        return (false, 0);\n    }\n\n    function accessOperatingBudget(uint amount) onlyOwner {\n        if (getOperatingBudget() < 1 ether) throw;\n\n        uint safeToAccess = getOperatingBudget() - 1 ether;\n        if (amount > safeToAccess) throw;\n\n        var _ = owner.send(amount);\n    }\n\n    function setOwner(address _owner) onlyOwner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ロジックが明確で、芸術的要素は少ない。,
1802483,0x698e6e617c95d171410d5c136fb94b1882f4f96f,false,false,,,,TOO_SHORT
1802496,0xbbe48e3145fe440d442f67b08a57bd56c3a69c35,false,false,,,,TOO_SHORT
1803792,0x006b7ed5a85fde8f3b9b3bedf1a69153e0465c11,false,false,,,,TOO_SHORT
1804420,0xf2133a06caece9564ec39a627b9f6031b5c0a9f7,false,false,,,,TOO_SHORT
1804493,0x919a2448119aee2d214b7ea5a0442e6a43c49046,false,false,,,,TOO_SHORT
1804944,0x4950f46149d9718c338fd552009cee0f2c6c6376,false,false,,,,TOO_SHORT
1804947,0x6940f1a194788f1bf5409be0b11f2b3b716d9598,false,false,,,,TOO_SHORT
1805671,0x705f04a4f1e7a1e23caea390b8903bd43d96e18e,false,false,contract mortal {\n    address private owner;\n    /* this function is executed at initialization and sets the owner of the contract */\n    function mortal() { owner = msg.sender; }\n    /* Function to recover the funds on the contract */\n    function kill() { if (msg.sender == owner) selfdestruct(owner); }\n}\n\ncontract EtherPennySlots is mortal {\n    address private hotAccount = 0xD837ACd68e7dd0A0a9F03d72623d5CE5180e3bB8;\n    address public lastWinner;\n    address[]  private currentTicketHolders;\n    \n    function placeWager() {\n       if (msg.value > 0 finney && msg.value < 51 finney) {\n            uint i = 0;\n            for (i = 0; i < msg.value; i++){\n                currentTicketHolders.length++;\n                currentTicketHolders[currentTicketHolders.length-1] = msg.sender; \n            }\n                       \n            if (this.balance >= 601 finney) {\n                uint nr_tickets = currentTicketHolders.length;\n                uint randomTicket = block.number % nr_tickets;\n                address randomEntry = currentTicketHolders[randomTicket];\n                if (hotAccount.send(100 finney) && randomEntry.send(500 finney)) {\n                    lastWinner = randomEntry;\n                    currentTicketHolders.length = 0;\n                }\n            } \n        }\n    }\n},1,実用的なギャンブル機能を持つ標準的なスマートコントラクト。,
1805832,0x127a8afa481f541ac1ab6be32714550d7bc29e03,false,false,,,,TOO_SHORT
1805912,0xeded08346feb2ccec6d96439dc4135302bd7136c,false,false,,,,TOO_SHORT
1805944,0xf06e1b46931201f86822de3998f4afcad3fc7983,false,false,,,,TOO_SHORT
1805945,0xd06e310f2449c46327c01ef2845cb3259825c968,false,false,,,,TOO_SHORT
1806061,0x19c3387a89b7251d30b747cde6eeae3857191647,false,false,,,,TOO_SHORT
1806267,0x8f18a83a3f6122c607444ac709dca7688e99408d,false,false,,,,TOO_SHORT
1806513,0x6d3dfb087893d0eba77cc05620fb44712c1dca0e,false,false,,,,TOO_SHORT
1806549,0x0a233993b0fb5de572ba05634d876d4b83149c09,false,false,,,,TOO_SHORT
1806621,0xdef84e3a7d7e9734c58a0401fb86ece9cfde5617,false,false,,,,TOO_SHORT
1806744,0xc9edffc684432451d5971e682e0beadad149042d,false,false,,,,TOO_SHORT
1806948,0xa037575313881f7c861be6c6542a461a31c95667,false,false,,,,TOO_SHORT
1807226,0x989dfd77324ca3b2d357482a32f43f34225116dd,false,false,,,,TOO_SHORT
1807640,0xe0e65c39deedc679865248002d4719c3d235c69e,false,false,,,,TOO_SHORT
1807799,0x0698a6229fff6b82bee731056ca01c298d8eff4d,true,false,"/**\n * Spork Token Contracts\n * See Spork contract below for more detail.\n *\n * The DAO and Spork is free software: you can redistribute it and/or modify\n * it under the terms of the GNU lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The DAO and Spork is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU lesser General Public License for more details.\n *\n * http://www.gnu.org/licenses/\n *\n * credit\n *   The DAO, Slock.it, Ethereum Foundation, EthCore, Consensys, pseudonymous\n *   rebels everywhere, and every lunch spot with proper eating utensils. ?\n */\n\n/**\n * @title TokenInterface\n * @notice ERC 20 token standard and DAO token interface.\n */\ncontract TokenInterface {\n\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount);\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount);\n\n    mapping (address => // owner\n        uint256) balances;\n\n    mapping (address => // owner\n    mapping (address => // spender\n        uint256)) allowed;\n\n    uint256 public totalSupply;\n\n    function balanceOf(address _owner)\n    constant\n    returns (uint256 balance);\n\n    function transfer(address _to, uint256 _amount)\n    returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _amount)\n    returns (bool success);\n\n    function approve(address _spender, uint256 _amount)\n    returns (bool success);\n\n    function allowance(address _owner, address _spender)\n    constant\n    returns (uint256 remaining);\n\n}\n\n/**\n * @title Spork\n *\n * @notice A rogue upgrade token for The DAO. There is nothing safe about this\n *   contract or this life so strap in, bitches. You are responsible for you.\n *   A Spork is minted through burning DAO tokens. This is irreversible and for\n *   entertainment purposes. So why would you do this? Do it for love, do it\n *   for So Tokey Nada Mojito, do it for the lulz; just do it with conviction!\n *\n * usage\n *   1. Use The DAO to grant an allowance of DAO for the Spork contract.\n *      + `DAO.approve(spork_contract_address, amount_of_DAO_to_burn)`\n *      + Only grant the amount of DAO you are ready to destroy forever.\n *   2. Use the Spork mint function to ...\n *      1. Burn an amount of DAO up to the amount approved in the previous step.\n *      2. Mint an equivalent amount of Spork.\n *      3. Assign Spork tokens to the sender account.\n *   3. You now have Sporks. Dig in!\n */\ncontract Spork is TokenInterface {\n\n    // crash and burn\n    address constant TheDAO = 0xbb9bc244d798123fde783fcc1c72d3bb8c189413;\n\n    event Mint(\n        address indexed _sender,\n        uint256 indexed _amount,\n        string _lulz);\n\n    // vanity attributes\n    string public name = ""Spork"";\n    string public symbol = ""SPRK"";\n    string public version = ""Spork:0.1"";\n    uint8 public decimals = 0;\n\n    // @see {Spork.mint}\n    function () {\n        throw; // this is a coin, not a wallet.\n    }\n\n    /**\n     * @notice Burn DAO tokens in exchange for Spork tokens\n     * @param _amount Amount of DAO to burn and equivalent Spork to mint\n     * @param _lulz If you gotta go, go with a smile! ?\n     * @return Determine if request was successful\n     */\n    function mint(uint256 _amount, string _lulz)\n    returns (bool success) {\n        if (totalSupply + _amount <= totalSupply)\n            return false; // zero or rollover value\n\n        if (!TokenInterface(TheDAO).transferFrom(msg.sender, this, _amount))\n            return false; // unable to retrieve DAO tokens for sender\n\n        balances[msg.sender] += _amount;\n        totalSupply += _amount;\n\n        Mint(msg.sender, _amount, _lulz);\n        return true;\n    }\n\n    /**\n     * @notice Transfer Spork tokens from `msg.sender` to another account.\n     * @param _to Account receiving tokens\n     * @param _amount Amount of tokens to transfer\n     * @return Determine if request was successful\n     */\n    function transfer(address _to, uint256 _amount)\n    returns (bool success) {\n        if (balances[_to] + _amount <= balances[_to])\n            return false; // zero or rollover value\n\n        if (balances[msg.sender] < _amount)\n            return false; // party foul, sender does not have enough sporks\n\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer Spork tokens from one account to another\n     * @param _from Account holding tokens for which `msg.sender` is an approved\n     *              spender with an allowance of at least `_amount` tokens\n     * @param _to Account receiving tokens\n     * @param _amount Amount of tokens to transfer\n     * @return Determine if request was successful\n     */\n    function transferFrom(address _from, address _to, uint256 _amount)\n    returns (bool success) {\n        if (balances[_to] + _amount <= balances[_to])\n            return false; // zero or rollover value\n\n        if (allowed[_from][msg.sender] < _amount)\n            return false; // sender does not have enough allowance\n\n        if (balances[msg.sender] < _amount)\n            return false; // party foul, sender does not have enough sporks\n\n        balances[_to] += _amount;\n        balances[_from] -= _amount;\n        allowed[_from][msg.sender] -= _amount;\n\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Determine the Spork token balance for an account\n     * @param _owner Account holding tokens\n     * @return Token balance\n     */\n    function balanceOf(address _owner)\n    constant\n    returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /**\n     * @notice Approve an address to spend tokens on your behalf\n     * @param _spender Account to spend tokens on behalf of `msg.sender`\n     * @param _amount Maximum amount `_spender` can transfer from `msg.sender`\n     * @return Determine if request was successful\n     */\n    function approve(address _spender, uint256 _amount)\n    returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Maximum amount a spender can withdraw from an account\n     * @param _owner The account holding tokens\n     * @param _spender The account spending tokens\n     * @return Remaining allowance `_spender` can withdraw from `_owner`\n     */\n    function allowance(address _owner, address _spender)\n    constant\n    returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n}",2,ユーモラスなコメントと独特なテーマが詩的要素を加えている。,
1807799,0xcc3cf90a6ce68c99b907b48c608f25844f1a34c0,true,false,,,,0x0698a6229fff6b82bee731056ca01c298d8eff4d
1807880,0x7ae2838a5810b870840e86e620038350bc1f0995,false,false,,,,TOO_SHORT
1807894,0xd2f0aad576c8a497c89ae8c0c701a7fb1e962da9,false,false,,,,TOO_SHORT
1808193,0xf67a01444dc4024138f548e70f7ca559ff9a19b4,false,false,,,,TOO_SHORT
1808383,0x49c9e0a1aa87075d683eacd2d3d872184146f54f,false,false,,,,TOO_SHORT
1808809,0x0c06d64e761b7e1dc6fce4b15a15b9baabe376e3,false,false,,,,TOO_SHORT
1809137,0xd6c4cc31c2d01cf9aea74282635da801aa092669,false,false,,,,TOO_SHORT
1809505,0x6b0de8dae9c72a20cd6bea60d2a0b590b3781b8f,false,false,,,,TOO_SHORT
1809555,0x807627feea3c85919fffd7510a6f994978987739,false,false,,,,TOO_SHORT
1809580,0xc69e38d046f4d27651ca0a6e9fb56ac3f6ed69e0,false,false,,,,TOO_SHORT
1810785,0x6adda343900c842e1a8fdda706fb33288d48b25b,false,false,,,,TOO_SHORT
1811222,0x3e0afb17355cf39a1849a3e3a2df7321d12b41d7,false,false,,,,TOO_SHORT
1811258,0x51a152785c8e67273d482cacdb5424ad3db250f8,false,false,,,,TOO_SHORT
1811364,0x4b81355d476c1f0f0af2ed528fba8b6039afc563,false,false,,,,TOO_SHORT
1811455,0xe78c1722f036f1ef9692d1959598c1036ba21a73,false,false,,,,TOO_SHORT
1811920,0x2ab280a36796ff046cbffded4e40f9a08850c87a,false,false,,,,TOO_SHORT
1811982,0x88ee812f94ab0501503466f75a62fee8f2931ab5,false,false,,,,TOO_SHORT
1811983,0xee4e118bc10acc88252e6a8f2a7e9bde32e1f526,false,false,,,,TOO_SHORT
1811984,0xc4a0e50ff985e6d14f8ae8e04b39921c7b8116dc,false,false,,,,TOO_SHORT
1811985,0xeb866dbd5a8cf4b8e16750d33bf1f0ab5ae1d1d5,false,false,,,,TOO_SHORT
1811996,0x75756266e0c8788f760fe04f676996ccff15b627,false,false,,,,TOO_SHORT
1812159,0x0084a2c193e693f37f53e471da934deed51c49c5,false,false,,,,TOO_SHORT
1812167,0x889c3f92e71ab8939ebfb22094c11e0bd0035900,false,false,,,,TOO_SHORT
1812178,0x4a9c3cd1e3a49dc05e1dd5bdb435c125e0b7de50,false,false,,,,TOO_SHORT
1812186,0x26c2068365aad1b1058bfed71128597c87e79026,false,false,,,,TOO_SHORT
1812229,0xa1ce20550ee3c907dadd9799863c9885f8d3474d,false,false,,,,TOO_SHORT
1812382,0x6502a9d52e06af1815102fb066fdf93ffd31b68f,false,false,,,,TOO_SHORT
1812715,0xe10d193253da846a231ac933ac38df19f5426a4d,false,false,,,,TOO_SHORT
1812780,0x36e67b25a7de04b24de50717e40ac97437a65bea,false,false,,,,TOO_SHORT
1812791,0x2d1f5d228e6d07d937b91822deed6c26a5d48795,false,false,,,,TOO_SHORT
1812843,0x17ba494451204d6e7fdfee655b655013ab708401,false,false,,,,TOO_SHORT
1813099,0x62c1279c9c518df97ed79be3c3458083a622e7b1,false,false,,,,TOO_SHORT
1814183,0x749a2f66ed92b942e99f1af3d84a043bd9e807c4,false,false,,,,TOO_SHORT
1814491,0xfd813f7eac21bdc5b98fce27e552ab117eede248,false,false,,,,TOO_SHORT
1814832,0x612c4873ea9f65c1d14f6b90c36236fd69ebee22,false,false,,,,TOO_SHORT
1814854,0x7da63c825446fbe229d95e5187b546c8f10f2da6,false,false,,,,TOO_SHORT
1814874,0x5d31fb54ff7eb584a1c5976defdf7a452daed087,false,false,,,,TOO_SHORT
1815316,0xc5645bec9fd5713c0ff3a4a3d62b595899dd49ae,false,false,,,,TOO_SHORT
1815484,0xb758bc680cf535d5ccfa5a36c19c620833e0dd41,false,false,,,,TOO_SHORT
1815534,0x3c9155d7e6f8d6bb5a1997d19e368f302de60d63,false,false,,,,0x25db0f59bf166c49d1f859c9cb5928cbbf685981
1815860,0x8ee1654d884f47e038ae34538fe644f383489f01,false,false,,,,TOO_SHORT
1815887,0xbbb9461549a974a2fcd24d60d0fa40a0601bde43,false,false,,,,TOO_SHORT
1815895,0x65153a04fe241a8a27aa63df13ca26158842474a,false,false,,,,TOO_SHORT
1816421,0xb24e32d30797bf57ec9336ff35752c2a3f145605,false,false,,,,TOO_SHORT
1816502,0x35c83780bfaf8d33068bceea6e043e28c6c6d7ee,false,false,,,,TOO_SHORT
1816503,0x6774fea07059af9f4f99ceee981a042e7fcd2fc6,false,false,,,,TOO_SHORT
1816504,0x2015e5b2222020e1508fed3f6d19c38dbc345f7b,false,false,,,,TOO_SHORT
1816505,0xfc1f2ca04536c6b1ca611b386045f5e14e4ce36e,false,false,,,,TOO_SHORT
1816517,0xea9fe27c4f8681f9492941161cc5dc4dc5f22d55,false,false,,,,TOO_SHORT
1817028,0x943582ff17752835fe1c4828a3e6237a87a0d8cb,false,false,,,,TOO_SHORT
1817232,0x1f828bf0640d33ed588b86aa93c9e0a5e7b43664,false,false,,,,TOO_SHORT
1817358,0xf0bff27e9e404c425ff0a6ade03119c633f8c68c,false,false,,,,TOO_SHORT
1817641,0x22c37104a60f833a79ae5f4867439efff83e6ab7,false,false,,,,TOO_SHORT
1817733,0xe631f8eeb371ed9e3db2354f7c6909425a3efaf3,false,false,,,,TOO_SHORT
1817829,0xbf1ac36388f056935ee8ef8ecacc1ed3d8303479,false,false,,,,TOO_SHORT
1817884,0x7844d39d43797e5f2e1a126d119eefcad5229f41,false,false,,,,TOO_SHORT
1817899,0xc70fb2378edb01bdc36c6be389207a9fd63d1658,false,false,,,,TOO_SHORT
1818011,0x16dded55bb3c6f6961d967e11f166bb6b3b3ba88,false,false,,,,TOO_SHORT
1818012,0x5b1e6856145ce6ff31c9e4af15d1c835c947612a,false,false,,,,TOO_SHORT
1818059,0x237c99cd1487773d3bcee627c76cb6ca9b50e1ab,false,false,,,,TOO_SHORT
1818191,0x2decba52670b251d2e31b5feb5930b71af3d92c8,false,false,,,,TOO_SHORT
1818318,0x17d230f6cb13db3af94be8ac70269890de6b0238,false,false,,,,TOO_SHORT
1818584,0x57acfc1c5677969acbddd352c3a6668914b900a1,false,false,,,,TOO_SHORT
1819030,0xae2ce44c4b1e942b1b171701d8bea741669a68e8,false,false,,,,TOO_SHORT
1819485,0x42ad5d63abc65b2e179a80730b280c07b2f70af7,false,false,,,,TOO_SHORT
1819551,0x8223d56b995effea1ca4595e580a1b8de6deaebe,false,false,,,,TOO_SHORT
1819552,0xc953765181a56ca06d073cf798863ae2a7a8d361,false,false,,,,TOO_SHORT
1819666,0xe1fc576f5fdee5cefd27e6f53c1dbf9616165c96,false,false,,,,TOO_SHORT
1819749,0x49658b402e0ac4b5e2636344b8b1f76e2c19b362,false,false,,,,TOO_SHORT
1820019,0xb81cd373f9e422e2e101f71257bfb4aadaff0f15,false,false,,,,TOO_SHORT
1820383,0x223a7e42815e7236d94f2c18c2d29d4e867ca681,false,false,,,,TOO_SHORT
1820492,0x37e64c3d36cc9bd96962f3839face9527f9b00fa,false,false,,,,TOO_SHORT
1820631,0x31d14d8dd068ca7ae46b50760422b41c0fd9d6f5,false,false,,,,TOO_SHORT
1820658,0x4a29cdbe3a96952d2a3b55bc9bf2137180de8135,false,false,,,,TOO_SHORT
1820861,0xe4830fd08c1164c82df108eb636f661aa9e0b283,false,false,,,,TOO_SHORT
1820994,0xbc282076896ed2ae340e15d3fc5b70df9aedee5f,false,false,,,,TOO_SHORT
1821049,0x4349b41ecbae065a37b77517fd6de2d2d95df85a,false,false,,,,TOO_SHORT
1821236,0xa8bc2d79849ddc18f08c10025380e19291f75510,false,false,,,,TOO_SHORT
1821304,0xaf77fbb8c4333d7ac65890aa88b865c2783a3c91,false,false,,,,TOO_SHORT
1821516,0x25ee6152b8d8fcc3798b3a9f3fc844cbac5ee701,false,false,,,,TOO_SHORT
1822042,0x8255ce08b7d81fd81cb470b9df59717372cf1abc,false,false,,,,TOO_SHORT
1822087,0x3ddd833c33f28722e2a1cd070cd74946c5c92476,false,false,,,,TOO_SHORT
1823116,0x4f8abb7334f10d3559ea471d0291f6e632af86aa,false,false,,,,TOO_SHORT
1823304,0xdf236e5656500f1f087abd7c3f16020ca477f819,false,false,,,,TOO_SHORT
1823550,0x587d6669a2743a1d6094f150006f56f85b5aade3,false,false,contract Vote {\n    address creator;\n\n    function Vote() {\n        creator = msg.sender;\n    }\n\n    function() {\n        if (msg.value > 0) {\n            tx.origin.send(msg.value);\n        }\n    }\n\n    function kill() {\n        if (msg.sender == creator) {\n            suicide(creator);\n        }\n    }\n},1,基本的な投票コントラクトで、特に芸術的な要素はありません。,
1823562,0x36ba156f8fba7bd116f78461d9fdf265b4e75747,false,false,,,,0x587d6669a2743a1d6094f150006f56f85b5aade3
1823584,0xbe32efed1dd42bbf4d5dd6cd50bda73689756ece,false,false,,,,TOO_SHORT
1823704,0xce7fc1d0fb0063f81be91932e43e86e429583ec9,false,false,,,,TOO_SHORT
1823751,0x536fab989793db898b0eefbc6d00f30399a67ce6,false,false,,,,TOO_SHORT
1823975,0x585e4cd2edd2c912ebdc93ca999f43282e7cffac,false,false,,,,TOO_SHORT
1824376,0xb32474e978bae505b928f10f674846dc5c0cb97e,false,false,,,,TOO_SHORT
1824433,0xc47ba09ab6e3262494968baa71b96fe4b79af5a5,false,false,,,,TOO_SHORT
1824647,0xa63084223d2877d2232d7449833e88fec5b072fe,false,false,,,,TOO_SHORT
1825075,0x5c06686e57787345ed8d4986166c15d55a1849c7,false,false,,,,TOO_SHORT
1825384,0x5d91b060dc4f622a570fd2073aa078190d7f226e,false,false,,,,TOO_SHORT
1825466,0x1e5f704ed1d62b6b42fc841f0d7d4e340cbbaf7d,false,false,"contract DaoChallenge\n{\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	event notifySellToken(uint256 n, address buyer);\n	event notifyRefundToken(uint256 n, address tokenHolder);\n	event notifyTerminate(uint256 finalBalance);\n\n	/* This creates an array with all balances */\n  mapping (address => uint256) public tokenBalanceOf;\n\n	uint256 constant tokenPrice = 1000000000000000; // 1 finney\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address owner;\n\n	function DaoChallenge () {\n		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () {\n		address sender = msg.sender;\n		if(tokenBalanceOf[sender] != 0) {\n			throw;\n		}\n		tokenBalanceOf[sender] = msg.value / tokenPrice; // rounded down\n		notifySellToken(tokenBalanceOf[sender], sender);\n	}\n\n	function refund() noEther {\n		address sender = msg.sender;\n		uint256 tokenBalance = tokenBalanceOf[sender];\n		if (tokenBalance <= 0) { throw; }\n		tokenBalanceOf[sender] = 0;\n		sender.send(tokenBalance * tokenPrice);\n		notifyRefundToken(tokenBalance, sender);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyOwner {\n		notifyTerminate(this.balance);\n		suicide(owner);\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1825506,0xbe56093286038885733a66e554dd43a22a45889f,false,false,,,,0x1e5f704ed1d62b6b42fc841f0d7d4e340cbbaf7d
1825669,0xb9790c6dd4e0c47d0a175a4880225e91b6861279,false,false,,,,TOO_SHORT
1825717,0x425d9b0976d26535b92c87541f2a5c05842b00dd,false,false,,,,TOO_SHORT
1825900,0xfc42c8a45b005def7ff45826c7f02e58c9f58ae1,false,false,,,,TOO_SHORT
1825901,0x29e2c684f39890b8fc90f94cd46bd57dd59fa912,false,false,,,,TOO_SHORT
1825984,0x7c3c7a4d859bc6c8a0d8c77be1c9914f557c9132,false,false,,,,TOO_SHORT
1826860,0xddd9de98c50299f78f3e5e7f1056429624538760,false,false,,,,TOO_SHORT
1826911,0x3aeb3d9661db973e201d80622332c47bab2393e9,false,false,,,,TOO_SHORT
1826942,0x4702654db2d0eb545653aa78a1b115276e6a3ef2,false,false,,,,TOO_SHORT
1827236,0x3f31f9dfa67823f936a369543de8aa238caf9d6f,false,false,,,,TOO_SHORT
1827330,0x784dca1ac0fd088e8c4ddb5a59aaf16501a94dd3,false,false,,,,TOO_SHORT
1827411,0xc2e458013e55e6e413dc65cf5bfe976fcfac19f8,false,false,,,,TOO_SHORT
1828435,0xae1e17795fb2b6e49b1b31fdc9b70550962c24ae,false,false,,,,TOO_SHORT
1828444,0x31de28001c6ec9abc3379f1f13cc35be5ed77635,false,false,,,,TOO_SHORT
1828705,0x096133503887a77e524f2690ba6aae2fa66b032c,false,false,"contract MyEtherBank\n{\n    /* LICENSE :\n\n    MIT License\n\n    Copyright (c) 2016 Consent Development\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the ""Software""), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n\n    */\n	\n    // Author : Alex Darby \n    // Contact email : consentdev@gmail.com \n    // Version : 1.0 - initial release\n	// GitHub : https://github.com/ConsentDevelopment/EtherBank\n    //\n    // \n	// This smart contract is free to use but donations are always welcome :\n	//   Donate Ether - 0x65850dfd9c511a5da3132461d57817f56acc1906\n    //   Donate Bitcoin - 36XRasACPNEvd3YxbLoWWeUfSgCUyZ69z8\n\n    /* -------- State data -------- */\n\n    // Owner\n    address private _owner;\n    uint256 private _bankDonationsBalance = 0;\n    bool private _connectBankAccountToNewOwnerAddressEnabled = true;\n\n    // Bank accounts    \n    struct BankAccount\n    {\n        // Members placed in order for optimization, not readability\n        bool passwordSha3HashSet;\n        uint32 number; \n        uint32 passwordAttempts;\n        uint256 balance;\n        address owner;       \n        bytes32 passwordSha3Hash;   \n        mapping(bytes32 => bool) passwordSha3HashesUsed;\n    }   \n\n    struct BankAccountAddress\n    {\n        bool accountSet;\n        uint32 accountNumber; // accountNumber member is used to index the bank accounts array\n    }\n \n    uint32 private _totalBankAccounts = 0;\n    BankAccount[] private _bankAccountsArray; \n    mapping(address => BankAccountAddress) private _bankAccountAddresses;  \n\n\n    /* -------- Constructor -------- */\n\n    function MyEtherBank() public\n    {\n        // Set the contract owner\n        _owner = msg.sender; \n    }\n\n\n    /* -------- Events -------- */\n\n    // Donation\n    event event_donationMadeToBank_ThankYou(uint256 donationAmount);\n    event event_getBankDonationsBalance(uint256 donationBalance);\n    event event_bankDonationsWithdrawn(uint256 donationsAmount);\n\n    // General banking\n    event event_bankAccountOpened_Successful(address indexed bankAccountOwner, uint32 indexed bankAccountNumber, uint256 indexed depositAmount);\n    event event_getBankAccountNumber_Successful(uint32 indexed bankAccountNumber);\n    event event_getBankAccountBalance_Successful(uint32 indexed bankAccountNumber, uint256 indexed balance);\n    event event_depositMadeToBankAccount_Successful(uint32 indexed bankAccountNumber, uint256 indexed depositAmount); \n    event event_depositMadeToBankAccount_Failed(uint32 indexed bankAccountNumber, uint256 indexed depositAmount); \n    event event_depositMadeToBankAccountFromDifferentAddress_Successful(uint32 indexed bankAccountNumber, address indexed addressFrom, uint256 indexed depositAmount);\n    event event_depositMadeToBankAccountFromDifferentAddress_Failed(uint32 indexed bankAccountNumber, address indexed addressFrom, uint256 indexed depositAmount);\n    event event_withdrawalMadeFromBankAccount_Successful(uint32 indexed bankAccountNumber, uint256 indexed withdrawalAmount); \n    event event_withdrawalMadeFromBankAccount_Failed(uint32 indexed bankAccountNumber, uint256 indexed withdrawalAmount); \n    event event_transferMadeFromBankAccountToAddress_Successful(uint32 indexed bankAccountNumber, uint256 indexed transferalAmount, address indexed destinationAddress); \n    event event_transferMadeFromBankAccountToAddress_Failed(uint32 indexed bankAccountNumber, uint256 indexed transferalAmount, address indexed destinationAddress); \n\n    // Security\n    event event_securityConnectingABankAccountToANewOwnerAddressIsDisabled();\n    event event_securityHasPasswordSha3HashBeenAddedToBankAccount_Yes(uint32 indexed bankAccountNumber);\n    event event_securityHasPasswordSha3HashBeenAddedToBankAccount_No(uint32 indexed bankAccountNumber);\n	event event_securityPasswordSha3HashAddedToBankAccount_Successful(uint32 indexed bankAccountNumber);\n    event event_securityPasswordSha3HashAddedToBankAccount_Failed_PasswordHashPreviouslyUsed(uint32 indexed bankAccountNumber);\n    event event_securityBankAccountConnectedToNewAddressOwner_Successful(uint32 indexed bankAccountNumber, address indexed newAddressOwner);\n    event event_securityBankAccountConnectedToNewAddressOwner_Failed_PasswordHashHasNotBeenAddedToBankAccount(uint32 indexed bankAccountNumber);\n    event event_securityBankAccountConnectedToNewAddressOwner_Failed_SentPasswordDoesNotMatchAccountPasswordHash(uint32 indexed bankAccountNumber, uint32 indexed passwordAttempts);\n    event event_securityGetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress(uint32 indexed bankAccountNumber, uint32 indexed attempts);\n\n\n    /* -------- Modifiers -------- */\n\n    modifier modifier_isContractOwner()\n    { \n        // Contact owner?\n        if (msg.sender != _owner)\n        {\n            throw;       \n        }\n        _ \n    }\n\n    modifier modifier_doesSenderHaveABankAccount() \n    { \n        // Does this sender have a bank account?\n        if (_bankAccountAddresses[msg.sender].accountSet == false)\n        {\n            throw;\n        }\n        else\n        {\n            // Does the bank account owner address match the sender address?\n            uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;\n            if (msg.sender != _bankAccountsArray[accountNumber_].owner)\n            {\n                // Sender address previously had a bank account that was transfered to a new owner address\n                throw;        \n            }\n        }\n        _ \n    }\n\n    modifier modifier_wasValueSent()\n    { \n        // Value sent?\n        if (msg.value > 0)\n        {\n            // Prevent users from sending value accidentally\n            throw;        \n        }\n        _ \n    }\n\n\n    /* -------- Contract owner functions -------- */\n\n    function Donate() public\n    {\n        if (msg.value > 0)\n        {\n            _bankDonationsBalance += msg.value;\n            event_donationMadeToBank_ThankYou(msg.value);\n        }\n    }\n\n    function BankOwner_GetDonationsBalance() public      \n        modifier_isContractOwner()\n        modifier_wasValueSent()\n        returns (uint256)\n    {\n        event_getBankDonationsBalance(_bankDonationsBalance);\n  	    return _bankDonationsBalance;\n    }\n\n    function BankOwner_WithdrawDonations() public\n        modifier_isContractOwner()\n        modifier_wasValueSent()\n    { \n        if (_bankDonationsBalance > 0)\n        {\n            uint256 amount_ = _bankDonationsBalance;\n            _bankDonationsBalance = 0;\n\n            // Check if using send() is successful\n            if (msg.sender.send(amount_))\n            {\n                event_bankDonationsWithdrawn(amount_);\n            }\n            // Check if using call.value() is successful\n            else if (msg.sender.call.value(amount_)())\n            {  \n                event_bankDonationsWithdrawn(amount_);\n            }\n            else\n            {\n                // Set the previous balance\n                _bankDonationsBalance = amount_;\n            }\n        }\n    }\n\n    function BankOwner_EnableConnectBankAccountToNewOwnerAddress() public\n        modifier_isContractOwner()\n    { \n        if (_connectBankAccountToNewOwnerAddressEnabled == false)\n        {\n            _connectBankAccountToNewOwnerAddressEnabled = true;\n        }\n    }\n\n    function  BankOwner_DisableConnectBankAccountToNewOwnerAddress() public\n        modifier_isContractOwner()\n    { \n        if (_connectBankAccountToNewOwnerAddressEnabled)\n        {\n            _connectBankAccountToNewOwnerAddressEnabled = false;\n        }\n    }\n\n\n    /* -------- General bank account functions -------- */\n\n    // Open bank account\n    function OpenBankAccount() public\n        returns (uint32 newBankAccountNumber) \n    {\n        // Does this sender already have a bank account or a previously used address for a bank account?\n        if (_bankAccountAddresses[msg.sender].accountSet)\n        {\n            throw;\n        }\n\n        // Assign the new bank account number\n        newBankAccountNumber = _totalBankAccounts;\n\n        // Add new bank account to the array\n        _bankAccountsArray.push( \n            BankAccount(\n            {\n                passwordSha3HashSet: false,\n                passwordAttempts: 0,\n                number: newBankAccountNumber,\n                balance: 0,\n                owner: msg.sender,\n                passwordSha3Hash: ""0"",\n            }\n            ));\n\n        // Prevent people using ""password"" or ""Password"" sha3 hash for the Security_AddPasswordSha3HashToBankAccount() function\n        bytes32 passwordHash_ = sha3(""password"");\n        _bankAccountsArray[newBankAccountNumber].passwordSha3HashesUsed[passwordHash_] = true;\n        passwordHash_ = sha3(""Password"");\n        _bankAccountsArray[newBankAccountNumber].passwordSha3HashesUsed[passwordHash_] = true;\n\n        // Add the new account\n        _bankAccountAddresses[msg.sender].accountSet = true;\n        _bankAccountAddresses[msg.sender].accountNumber = newBankAccountNumber;\n\n        // Value sent?\n        if (msg.value > 0)\n        {         \n            _bankAccountsArray[newBankAccountNumber].balance += msg.value;\n        }\n\n        // Move to the next bank account\n        _totalBankAccounts++;\n\n        // Event\n        event_bankAccountOpened_Successful(msg.sender, newBankAccountNumber, msg.value);\n        return newBankAccountNumber;\n    }\n\n    // Get account number from a owner address\n    function GetBankAccountNumber() public      \n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (uint32)\n    {\n        event_getBankAccountNumber_Successful(_bankAccountAddresses[msg.sender].accountNumber);\n	    return _bankAccountAddresses[msg.sender].accountNumber;\n    }\n\n    function GetBankAccountBalance() public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (uint256)\n    {   \n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;\n        event_getBankAccountBalance_Successful(accountNumber_, _bankAccountsArray[accountNumber_].balance);\n        return _bankAccountsArray[accountNumber_].balance;\n    }\n\n\n    /* -------- Deposit functions -------- */\n\n    function DepositToBankAccount() public\n        modifier_doesSenderHaveABankAccount()\n        returns (bool)\n    {\n        // Value sent?\n        if (msg.value > 0)\n        {\n            uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n            // Check for overflow  \n            if ((_bankAccountsArray[accountNumber_].balance + msg.value) < _bankAccountsArray[accountNumber_].balance)\n            {\n                throw;\n            }\n\n            _bankAccountsArray[accountNumber_].balance += msg.value; \n            event_depositMadeToBankAccount_Successful(accountNumber_, msg.value);\n            return true;\n        }\n        else\n        {\n            event_depositMadeToBankAccount_Failed(accountNumber_, msg.value);\n            return false;\n        }\n    }\n\n    function DepositToBankAccountFromDifferentAddress(uint32 bankAccountNumber) public\n        returns (bool)\n    {\n        // Check if bank account number is valid\n        if (bankAccountNumber >= _totalBankAccounts)\n        {\n           event_depositMadeToBankAccountFromDifferentAddress_Failed(bankAccountNumber, msg.sender, msg.value);\n           return false;     \n        }    \n            \n        // Value sent?\n        if (msg.value > 0)\n        {   \n            // Check for overflow  \n            if ((_bankAccountsArray[bankAccountNumber].balance + msg.value) < _bankAccountsArray[bankAccountNumber].balance)\n            {\n                throw;\n            }\n\n            _bankAccountsArray[bankAccountNumber].balance += msg.value; \n            event_depositMadeToBankAccountFromDifferentAddress_Successful(bankAccountNumber, msg.sender, msg.value);\n            return true;\n        }\n        else\n        {\n            event_depositMadeToBankAccountFromDifferentAddress_Failed(bankAccountNumber, msg.sender, msg.value);\n            return false;\n        }\n    }\n    \n\n    /* -------- Withdrawal / transfer functions -------- */\n\n    function WithdrawAmountFromBankAccount(uint256 amount) public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        bool withdrawalSuccessful_ = false;\n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n        // Bank account has value that can be withdrawn?\n        if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)\n        {\n            // Reduce the account balance \n            _bankAccountsArray[accountNumber_].balance -= amount;\n\n            // Check if using send() is successful\n            if (msg.sender.send(amount))\n            {\n 	            withdrawalSuccessful_ = true;\n            }\n            // Check if using call.value() is successful\n            else if (msg.sender.call.value(amount)())\n            {  \n                withdrawalSuccessful_ = true;\n            }  \n            else\n            {\n                // Set the previous balance\n                _bankAccountsArray[accountNumber_].balance += amount;\n            }\n        }\n\n        if (withdrawalSuccessful_)\n        {\n            event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); \n            return true;\n        }\n        else\n        {\n            event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); \n            return false;\n        }\n    }\n\n    function WithdrawFullBalanceFromBankAccount() public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        bool withdrawalSuccessful_ = false;\n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n        uint256 fullBalance_ = 0;\n\n        // Bank account has value that can be withdrawn?\n        if (_bankAccountsArray[accountNumber_].balance > 0)\n        {\n            fullBalance_ = _bankAccountsArray[accountNumber_].balance;\n\n            // Reduce the account balance \n            _bankAccountsArray[accountNumber_].balance = 0;\n\n            // Check if using send() is successful\n            if (msg.sender.send(fullBalance_))\n            {\n 	            withdrawalSuccessful_ = true;\n            }\n            // Check if using call.value() is successful\n            else if (msg.sender.call.value(fullBalance_)())\n            {  \n                withdrawalSuccessful_ = true;\n            }  \n            else\n            {\n                // Set the previous balance\n                _bankAccountsArray[accountNumber_].balance = fullBalance_;\n            }\n        }  \n\n        if (withdrawalSuccessful_)\n        {\n            event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); \n            return true;\n        }\n        else\n        {\n            event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); \n            return false;\n        }\n    }\n\n    function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        bool transferSuccessful_ = false; \n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n        // Bank account has value that can be transfered?\n        if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)\n        {\n            // Reduce the account balance \n            _bankAccountsArray[accountNumber_].balance -= amount; \n\n            // Check if using send() is successful\n            if (destinationAddress.send(amount))\n            {\n 	            transferSuccessful_ = true;\n            }\n            // Check if using call.value() is successful\n            else if (destinationAddress.call.value(amount)())\n            {  \n                transferSuccessful_ = true;\n            }  \n            else\n            {\n                // Set the previous balance\n                _bankAccountsArray[accountNumber_].balance += amount;\n            }\n        }  \n\n        if (transferSuccessful_)\n        {\n            event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); \n            return true;\n        }\n        else\n        {\n            event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); \n            return false;\n        }\n    }\n\n\n    /* -------- Security functions -------- */\n\n    function Security_HasPasswordSha3HashBeenAddedToBankAccount() public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n        // Password sha3 hash added to the account?\n        if (_bankAccountsArray[accountNumber_].passwordSha3HashSet)\n        {\n            event_securityHasPasswordSha3HashBeenAddedToBankAccount_Yes(accountNumber_);\n            return true;\n        }\n        else\n        {\n            event_securityHasPasswordSha3HashBeenAddedToBankAccount_No(accountNumber_);\n            return false;\n        }\n    }\n\n    function Security_AddPasswordSha3HashToBankAccount(bytes32 sha3Hash) public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        // VERY IMPORTANT -\n        // \n        // Ethereum uses KECCAK-256. It should be noted that it does not follow the FIPS-202 based standard (a.k.a SHA-3), \n        // which was finalized in August 2015.\n        // \n        // Keccak-256 generator link (produces same output as solidity sha3()) - http://emn178.github.io/online-tools/keccak_256.html\n            \n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n        // Has this password hash been used before for this account?\n        if (_bankAccountsArray[accountNumber_].passwordSha3HashesUsed[sha3Hash] == true)\n        {\n            event_securityPasswordSha3HashAddedToBankAccount_Failed_PasswordHashPreviouslyUsed(accountNumber_);\n            return false;        \n        }\n\n        // Set the account password sha3 hash\n        _bankAccountsArray[accountNumber_].passwordSha3HashSet = true;\n        _bankAccountsArray[accountNumber_].passwordSha3Hash = sha3Hash;\n        _bankAccountsArray[accountNumber_].passwordSha3HashesUsed[sha3Hash] = true;\n\n        // Reset password attempts\n        _bankAccountsArray[accountNumber_].passwordAttempts = 0;\n\n        event_securityPasswordSha3HashAddedToBankAccount_Successful(accountNumber_);\n        return true;\n    }\n\n    function Security_ConnectBankAccountToNewOwnerAddress(uint32 bankAccountNumber, string password) public\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        // VERY IMPORTANT -\n        // \n        // Ethereum uses KECCAK-256. It should be noted that it does not follow the FIPS-202 based standard (a.k.a SHA-3), \n        // which was finalized in August 2015.\n        // \n        // Keccak-256 generator link (produces same output as solidity sha3()) - http://emn178.github.io/online-tools/keccak_256.html\n\n        // Can bank accounts be connected to a new owner address?\n        if (_connectBankAccountToNewOwnerAddressEnabled == false)\n        {\n            event_securityConnectingABankAccountToANewOwnerAddressIsDisabled();\n            return false;        \n        }\n\n        // Check if bank account number is valid\n        if (bankAccountNumber >= _totalBankAccounts)\n        {\n            return false;     \n        }    \n\n        // Does the sender already have a bank account?\n        if (_bankAccountAddresses[msg.sender].accountSet)\n        {\n            // A owner address can only have one bank account\n            return false;\n        }\n\n        // Has password sha3 hash been set?\n        if (_bankAccountsArray[bankAccountNumber].passwordSha3HashSet == false)\n        {\n            event_securityBankAccountConnectedToNewAddressOwner_Failed_PasswordHashHasNotBeenAddedToBankAccount(bankAccountNumber);\n            return false;           \n        }\n\n        // Check if the password sha3 hash matches.\n        bytes memory passwordString = bytes(password);\n        if (sha3(passwordString) != _bankAccountsArray[bankAccountNumber].passwordSha3Hash)\n        {\n            // Keep track of the number of attempts to connect a bank account to a new owner address\n            _bankAccountsArray[bankAccountNumber].passwordAttempts++;  \n            event_securityBankAccountConnectedToNewAddressOwner_Failed_SentPasswordDoesNotMatchAccountPasswordHash(bankAccountNumber, _bankAccountsArray[bankAccountNumber].passwordAttempts); \n            return false;        \n        }\n\n        // Set new bank account address owner and the update the owner address details \n        _bankAccountsArray[bankAccountNumber].owner = msg.sender;\n        _bankAccountAddresses[msg.sender].accountSet = true;\n        _bankAccountAddresses[msg.sender].accountNumber = bankAccountNumber;\n\n        // Reset password sha3 hash\n        _bankAccountsArray[bankAccountNumber].passwordSha3HashSet = false;\n        _bankAccountsArray[bankAccountNumber].passwordSha3Hash = ""0"";\n       \n        // Reset password attempts\n        _bankAccountsArray[bankAccountNumber].passwordAttempts = 0;\n\n        event_securityBankAccountConnectedToNewAddressOwner_Successful(bankAccountNumber, msg.sender);\n        return true;\n    }\n\n    function Security_GetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress() public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (uint64)\n    {\n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n        event_securityGetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress(accountNumber_, _bankAccountsArray[accountNumber_].passwordAttempts);\n        return _bankAccountsArray[accountNumber_].passwordAttempts;\n    }\n\n\n    /* -------- Default function -------- */\n\n    function() \n    {    \n        // Does this sender have a bank account?\n        if (_bankAccountAddresses[msg.sender].accountSet)\n        {\n            // Does the bank account owner address match the sender address?\n            uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;\n            address accountOwner_ = _bankAccountsArray[accountNumber_].owner;\n            if (msg.sender == accountOwner_) \n            {\n                // Value sent?\n                if (msg.value > 0)\n                {                \n                    // Check for overflow\n                    if ((_bankAccountsArray[accountNumber_].balance + msg.value) < _bankAccountsArray[accountNumber_].balance)\n                    {\n                        throw;\n                    }\n \n                    // Update the bank account balance\n                    _bankAccountsArray[accountNumber_].balance += msg.value;\n                    event_depositMadeToBankAccount_Successful(accountNumber_, msg.value);\n                }\n                else\n                {\n                    throw;\n                }\n            }\n            else\n            {\n                // Sender address previously had a bank account that was transfered to a new owner address\n                throw;\n            }\n        }\n        else\n        {\n            // Open a new bank account for the sender address - this function will also add any value sent to the bank account balance\n            OpenBankAccount();\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。銀行機能を実装しており、芸術的要素は少ない。,
1829269,0x33c8977377ff0e7ca7f08a807cc220843eb0c2a2,false,false,,,,TOO_SHORT
1829313,0x3bcca7f578def371715d4253e322afeb216c4101,false,false,,,,TOO_SHORT
1829409,0x226c349f18029bfcd5ff083d95427ba60e0eabbc,false,false,,,,TOO_SHORT
1829416,0x88fe9971279cc020fb69d66f38dc549a7260a399,false,false,,,,TOO_SHORT
1829732,0xa71ed42c540454dd88de11c36a27c70444c9911d,false,false,,,,TOO_SHORT
1829762,0xcb6edb466941504431fe4cf54bb094df8ef8c2f7,false,false,,,,TOO_SHORT
1829887,0xc1ffa562b49edef8025a0b6667cd1d2d52ad57ce,false,false,,,,TOO_SHORT
1830140,0xd880ee4aaf82bd60c7107a718297f6939a9e5bae,false,false,,,,TOO_SHORT
1830211,0x6949270673db0ca81209dce46aeee7ad5a545b8d,false,false,,,,TOO_SHORT
1830246,0x0d07546cfb028e1ba64f36be14b1a18afd49aeea,false,false,,,,TOO_SHORT
1830266,0x916e1c04044ab2e7c255acb14834731b33207377,false,false,,,,TOO_SHORT
1830386,0x94423e63d45eccbbf074eb9fd8848a937b568a43,false,false,,,,TOO_SHORT
1830399,0x289bb268350dca2c61c407611db755067f476e55,false,false,,,,TOO_SHORT
1830408,0xb19ff6657a80a68c94ca3fe6aac3b6cfd16bdcd4,false,false,"/*\nthis smartcontract used to store documents text on the Ethereum blockchain\n*/\n\ncontract ProofOfExistence{\n\n    /* ---- Public variables: */\n    string public created;\n    address public manager; // account that adds info to this smartcontract\n    uint256 public index;   // record's numbers and number of records\n    mapping (uint256 => Doc) public docs; // index => Doc\n    // to get Doc obj call ProofOfExistence.docs(index);\n\n    /* ---- Stored document structure: */\n\n    struct Doc {\n        string publisher; // publisher's email\n        uint256 publishedOnUnixTime; // block timestamp (block.timestamp)\n        uint256 publishedInBlockNumber; // block.number\n        string text; // text of the document\n    }\n\n    /* ---- Constructor: */\n\n    function ProofOfExistence(){\n        manager = msg.sender;\n        created = ""cryptonomica.net"";\n        index = 0; //\n    }\n\n    /* ---- Event:  */\n    // This generates a public event on the blockchain that will notify clients. In 'Mist' SmartContract page enable 'Watch contract events'\n    event DocumentAdded(uint256 indexed index,\n                        string indexed publisher,\n                        uint256 publishedOnUnixTime,\n                        string indexed text);\n\n    /* ----- Main method: */\n\n    function addDoc(string _publisher, string _text) returns (uint256) {\n        // authorization\n        if (msg.sender != manager) throw;\n        // document number\n        index += 1;\n        // add document data:\n        docs[index] = Doc(_publisher, now, block.number, _text);\n        // add event\n        DocumentAdded(index,\n                      docs[index].publisher,\n                      docs[index].publishedOnUnixTime,\n                      docs[index].text);\n        // return number of the stored document\n        return index;\n    }\n\n    /* ---- Utilities: */\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1830427,0xd7fc113b2cff57c4ea9a32e2581a44435abc6e26,false,false,,,,TOO_SHORT
1830713,0x4078cd4d0e8bd7728ea98f2d901a38090f65402e,false,false,,,,TOO_SHORT
1831004,0x042788d3488b9066e6a3e016f97d3c1ac730c169,false,false,,,,TOO_SHORT
1831135,0x2037cafb7c0bcdcac5ecfc69fb4da39100a2f0b6,false,false,,,,TOO_SHORT
1831270,0x50a6020f0bd271ea1dcb54c284dfd73ea07958ab,false,false,,,,TOO_SHORT
1831563,0x36239098c888410c766a3955078232dd19ed35db,false,false,,,,TOO_SHORT
1831692,0x8de8836786cecb7caeb326566568f26d6deb4d44,false,false,,,,TOO_SHORT
1832328,0xc2c21d58164385842563a24019267eb7b35893f8,false,false,,,,TOO_SHORT
1832360,0xd6389c9bf61aca6af20bffd54a8535466d3406da,false,false,,,,TOO_SHORT
1832518,0xfcf119efa3d9ba98786177376fe7356ed407fe20,false,false,,,,TOO_SHORT
1832520,0xf7516a7e466f419eaca93cec3caab75111536ec5,false,false,,,,0xb19ff6657a80a68c94ca3fe6aac3b6cfd16bdcd4
1832989,0x3a8ff49b38bb3e08f04ed1a6a6066a3435030d9c,false,false,,,,TOO_SHORT
1833361,0xd620909bd32fcdd2de0d71314bf32addf122e869,false,false,,,,TOO_SHORT
1833478,0x80ff8dcf15a0ff75905d494e13331c2eb7272988,false,false,,,,TOO_SHORT
1833833,0x4739dab66335f270cc88b8b2c75d6e00620d0745,false,false,,,,TOO_SHORT
1833834,0x792e4b35daacf3dfd4e8cdb597dc90da15960898,false,false,,,,TOO_SHORT
1833909,0x6467687d8aaacd7239ee639c8808624013997b92,false,false,,,,0x48b4cb193b587c6f2dab1a9123a7bd5e7d490ced
1833930,0x918d31d3d458a279c2831493bbaba0e0bc23bea7,false,false,,,,TOO_SHORT
1833984,0xbf7316fab5c8cfbda5e763a5a1f94c4e0ce7ec37,false,false,"// A name registry in Ethereum\n\n// ""Real"" attempts to a name registry with Ethereum:\n// <http://etherid.org/> <https://github.com/sinking-point/dns2/>\n\n// TODO: use the registry interface described in\n// <https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs>?\n\n// Standard strings are poor, we need an extension library,\n// github.com/Arachnid/solidity-stringutils/strings.sol TODO: use it as soon as https://github.com/Arachnid/solidity-stringutils/issues/1 is solved.\n// import ""strings.sol"";\n\ncontract Registry {\n\n  // using strings for *; // TODO see above\n\n  address public nic; // The Network Information Center\n  \n  struct Record {\n    string value; // IP addresses, emails, etc TODO accept an array\n		     // as soon as we have a strings library to\n		     // serialize/deserialize. TODO type the values with an Enum\n    address holder;\n    bool exists; // Or a more detailed state, with an enum?\n    uint idx;\n  }\n  mapping (string => Record) records;\n  mapping (uint => string) index;\n  \n  // TODO define accessors instead\n  uint public maxRecords;\n  uint public currentRecords;\n\n  event debug(string indexed label, string msg);\n  event created(string indexed label, string indexed name, address holder, uint block);\n  event deleted(string indexed label, string indexed name, address holder, uint block);\n  \n  // ""value"" should be a comma-separated list of values. Solidity\n  // public functions cannot use arrays of strings :-( TODO: solve it\n  // when we'll have strings.\n  function register(string name, string value) {\n    /* TODO: pay the price */\n    uint i;\n    if (records[name].exists) {\n      if (msg.sender != records[name].holder) { // TODO: use modifiers instead\n	throw;\n      }\n      else {\n	i = records[name].idx;\n      }\n    }\n    else {\n      records[name].idx = maxRecords;\n      i = maxRecords;\n      maxRecords++;\n    }\n    records[name].value = value;\n    records[name].holder = msg.sender;\n    records[name].exists = true;\n    currentRecords++;\n    index[i] = name;\n    created(""CREATION"", name, msg.sender, block.number);	  \n  }\n\n  function transfer(string name, address to) {\n    if (records[name].exists) {\n      if (msg.sender != records[name].holder) {\n	throw;\n      }\n      records[name].holder = to;\n    }\n    else {\n      throw;\n    }\n  }\n  \n  function get(string name) constant returns(bool exists, string value) {\n    if (records[name].exists) {\n      exists = true;\n      value = records[name].value;\n    } else {\n      exists = false;\n    }\n  }\n\n  // Constructor\n  function Registry() {\n    nic = msg.sender;\n    currentRecords = 0;\n    maxRecords = 0;\n    register(""NIC"", ""Automatically created by for the registry""); // TODO may fail if not\n    // enough gas in the creating transaction?\n  }\n  \n\n  function whois(string name) constant returns(bool exists, string value, address holder) {\n    if (records[name].exists) {\n      exists = true;\n      value = records[name].value;\n      holder = records[name].holder;\n    } else {\n      exists = false;\n    }\n  }\n\n  function remove(string name) {\n    uint i;\n    if (records[name].exists) {\n      if (msg.sender != records[name].holder) {\n	throw;\n      }\n      else {\n	i = records[name].idx;\n      }\n    }\n    else {\n      throw; // 404. Too bad we cannot add content to throw.\n    }\n    records[name].exists = false;\n    currentRecords--;\n    deleted(""DELETION"", name, msg.sender, block.number);	  \n  }\n\n  function download() returns(string all) {\n    if (msg.sender != nic) {\n	throw;\n      }\n    all = ""NOT YET IMPLEMENTED"";\n    // Looping over all the records is easy:\n    //for uint (i = 0; i < maxRecords; i++) {\n    //	if (records[index[i]].exists) {\n    \n    // Or we could use an iterable mapping may\n    // be this library\n    // <https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol>\n\n    // The difficult part is to construct an answer, since Solidity\n    // does not provide string concatenation, or the ability to return\n    // arrays.\n\n	// TODO: provide a function to access one item, using its index,\n	// and to let the caller loops from 0 to maxRecords\n	// http://stackoverflow.com/questions/37606839/how-to-return-mapping-list-in-solidity-ethereum-contract/37643972#37643972\n  }\n  \n}",1,実用的なコードで、標準的な名前レジストリの実装を目指している。芸術的要素は少ない。,
1834156,0x6d7772771c6ef41b0841d12380e88212e047a617,false,false,,,,TOO_SHORT
1834157,0xc799af3a082f245514035156bb1f6122d52bb645,false,false,,,,TOO_SHORT
1834631,0xcb33e1aa5f101b96b4aad9fa80fca253d7c70ab0,false,false,,,,TOO_SHORT
1834732,0xef588c8eaadca9b3981d6ddcc87ea13dc574f46a,false,false,,,,0xb8869c5f264739dde064941c372c551ec47aab44
1834757,0x525edde15f38f7bf7efca67ee16b41220a4d0e7b,false,false,,,,0xb8869c5f264739dde064941c372c551ec47aab44
1834762,0xee3bf3f68f15192f6be80268372108aa749afa3c,false,false,,,,0xb8869c5f264739dde064941c372c551ec47aab44
1834780,0x372e04946a608bfa4bbb10495b195587b8522873,false,false,,,,0xb8869c5f264739dde064941c372c551ec47aab44
1835199,0xf93513e8d79c1316502e4651524c221897eaa2cf,false,false,,,,TOO_SHORT
1835472,0x1513819c7b8f7fde3e7e1af09235cca1055a5eb4,false,false,,,,TOO_SHORT
1835613,0x92a99d1d44ccdd2b5a8a556f95f37556c9948137,false,false,,,,TOO_SHORT
1835614,0xaa287d0596729d68d0c31643591f0e137940f3ea,false,false,,,,TOO_SHORT
1835618,0xa733e64aac39e27ffa30ae939fb4ddb76c695558,false,false,,,,TOO_SHORT
1835789,0x1e350e0f3fe81ada5142b0a5277093c27bfb075e,false,false,,,,TOO_SHORT
1836214,0x3039d0a94d51c67a4f35e742b571874e53467804,false,false,contract Vote {\n    event LogVote(address indexed addr);\n\n    function() {\n        LogVote(msg.sender);\n\n        if (msg.value > 0) {\n            msg.sender.send(msg.value);\n        }\n    }\n},1,基本的な投票機能を持つが、特に芸術的な要素はない。,
1836217,0x58dd96aa829353032a21c95733ce484b949b2849,false,false,,,,0x3039d0a94d51c67a4f35e742b571874e53467804
1836329,0xf8512ef4483870c096ef03ccc0864fbcc32c2d39,false,false,,,,TOO_SHORT
1837364,0xbe7193779e3239781e49faafbdd0a9efa938f389,false,false,"contract EscrowContract {\n\n    // TYPES\n    enum state {Funding, Paid, Accepted, Dispute, Closed}\n    \n    // PRIVATE VARIABLES\n    address private developer;\n    bool private mutex;\n    uint256 private dispute_limit;\n    \n    // PUBLIC VARIABLES\n    address public buyer;\n    address public seller;\n    address public escrow;\n    uint256 public amount;\n    uint256 public fee;\n    uint256 public tip;\n    uint256 public dispute_end;\n    state public status;\n    \n    // EVENTS\n    event CurrentStatus(uint8 s);\n    \n    // CONSTRUCTOR\n    function EscrowContract(address _developer, address _buyer, address _seller, address _escrow, uint256 _amount, uint256 _fee, uint256 _tip ,uint256 _dispute_limit)\n        private\n    {\n        developer = _developer;\n        mutex = false;\n        dispute_limit = _dispute_limit;     \n        buyer = _buyer;\n        seller = _seller;\n        escrow = _escrow;\n        amount = _amount;\n        fee = _fee;\n        tip = _tip;\n        dispute_end = 0;\n        status = state.Funding;\n        CurrentStatus(uint8(status));\n    }\n\n    // MODIFIERS\n    modifier only_when(state s) {\n        if (status != s)  throw;\n        _\n    }\n    modifier only_before(state s) {\n        if (status >= s)  throw;\n        _\n    }\n    modifier only_buyer() {\n        if (msg.sender != buyer) throw;\n        _\n    }\n    modifier only_seller() {\n        if (msg.sender != seller) throw;\n        _\n    }\n    modifier only_buyer_seller() {\n        if (msg.sender != buyer && msg.sender != seller) throw;\n        _\n    }\n    modifier only_escrow() {\n        if (msg.sender != escrow) throw;\n        _\n    }\n    modifier only_no_value() {\n        if (msg.value != 0)  throw;\n        _\n    }\n    modifier check_mutex() {\n        if (mutex) throw;\n        mutex = true;\n        _\n        mutex = false;\n    }\n    \n    // VALIDATE PERCENT\n    function validate_percent(uint8 val)\n        private\n        constant\n    {\n        if (val > 100) throw;\n    }   \n\n    // BUYER CANCEL\n    function buyer_cancel()\n        public\n        only_before(state.Accepted)\n        only_buyer()\n        only_no_value()\n        check_mutex()\n    {\n        if (this.balance > 0)\n            if (!buyer.send(this.balance)) throw;\n        status = state.Closed;\n        CurrentStatus(uint8(status));\n    }\n    \n    // SELLER ACCEPT\n    function seller_accept()\n        public\n        only_when(state.Paid)\n        only_seller()\n        only_no_value()\n        check_mutex()\n    {\n        status = state.Accepted;\n        CurrentStatus(uint8(status));\n    }\n\n    // BUYER PAY\n    function buyer_pay()\n        public\n        only_when(state.Accepted)\n        only_buyer()\n        only_no_value()\n        check_mutex()\n    {\n        if (amount > 0)\n            if (!seller.send(amount)) throw;\n        if (fee > 0)\n            if (!buyer.send(fee)) throw;\n        if (tip > 0)\n            if (!developer.send(tip)) throw;\n        status = state.Closed;\n        CurrentStatus(uint8(status));\n    }\n\n    // DISPUTE\n    function dispute()\n        public\n        only_when(state.Accepted)\n        only_buyer_seller()\n        only_no_value()\n        check_mutex()\n    {\n        status = state.Dispute;\n        dispute_end = block.timestamp + dispute_limit;\n        CurrentStatus(uint8(status));\n    }\n\n    // RESOLVE\n    function resolve(uint8 percent_buyer, uint8 percent_tip)\n        public\n        only_when(state.Dispute)\n        only_escrow()\n        only_no_value()\n        check_mutex()\n    {\n        validate_percent(percent_buyer);\n        validate_percent(percent_tip);\n        uint256 buyer_amount = uint256(amount * percent_buyer)/100;\n        uint256 seller_amount = amount - buyer_amount;\n        uint256 tip_amount = uint256(fee * percent_tip)/100;\n        uint256 escrow_amount = fee - tip_amount;\n        tip_amount = tip_amount + tip;\n        if (buyer_amount > 0)\n            if (!buyer.send(buyer_amount)) throw;\n        if (seller_amount > 0)\n            if (!seller.send(seller_amount)) throw;\n        if (escrow_amount > 0)\n            if (!escrow.send(escrow_amount)) throw;\n        if (tip_amount > 0)\n            if (!developer.send(tip_amount)) throw;\n        status = state.Closed;\n        CurrentStatus(uint8(status));\n    }\n\n    // FIFTY FIFTY\n    function fifty_fifty()\n        public\n        only_when(state.Dispute)\n        only_buyer_seller()\n        only_no_value()\n        check_mutex()\n    {\n        if (block.timestamp < dispute_end) throw;\n        uint256 buyer_amount = uint256(amount * 50)/100;\n        uint256 seller_amount = amount - buyer_amount;\n        buyer_amount = buyer_amount + fee;\n        if (buyer_amount > 0)\n            if (!buyer.send(buyer_amount)) throw;\n        if (seller_amount > 0)\n            if (!seller.send(seller_amount)) throw;\n        if (tip > 0)\n            if (!developer.send(tip)) throw;\n        status = state.Closed;\n        CurrentStatus(uint8(status));\n    }\n    \n    // DEFAULT FUNCTION\n    function()\n        public\n        only_before(state.Closed)\n        check_mutex()\n    {\n        if (status == state.Funding) {\n            if (this.balance >= (amount + fee + tip)) {\n                status = state.Paid;\n                CurrentStatus(uint8(status));\n            }\n        }\n        if (status >= state.Paid) tip = this.balance - (amount + fee);\n    }\n    \n}\n\n\ncontract EscrowFoundry {\n    \n    // PRIVATE VARIABLES\n    address private developer;\n    \n    // EVENTS\n    event NewContract(address a);\n    \n    // CONSTRUCTOR\n    function EscrowFoundry() \n        private\n    {\n        developer = msg.sender;\n    }\n    \n    // MODIFIERS\n    modifier only_no_value() {\n        if (msg.value != 0)  throw;\n        _\n    }\n\n    // VALIDATE PERCENT\n    function validate_percent(uint8 val)\n        private\n        constant\n    {\n        if (val > 100) throw;\n    }\n    \n    // CREATE\n    function create(address _buyer, address _seller, address _escrow, uint256 _amount, uint8 _percent_fee, uint8 _percent_tip, uint256 _dispute_limit)\n        public\n        constant\n        only_no_value()\n        returns (address)\n    {\n        validate_percent(_percent_fee);\n        validate_percent(_percent_tip);\n        uint256 fee = uint256(_amount * _percent_fee)/100;\n        uint256 tip = uint256(_amount * _percent_tip)/100;\n        EscrowContract c = new EscrowContract(developer, _buyer, _seller, _escrow, _amount, fee, tip, _dispute_limit);\n        NewContract(c);\n        return c;\n    }\n    \n    // DEFAULT FUNCTION\n    function()\n        public\n    {\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1837510,0xc8c1e73ff40b58b85efdccc51fb245d7ae91e342,false,false,,,,TOO_SHORT
1837518,0x4d359fc61838255c0b1b50e68250f7c160be1ccc,false,false,,,,TOO_SHORT
1837687,0x257ee99f9c4db0ffae88d23d4d9532153807360f,false,false,,,,TOO_SHORT
1838061,0xe9da10f1aba727bfb3641846ed4d5bbf2add39c4,false,false,"/* \nBased on a contract built by Vlad and Vitalik for Ether signal\nIf you need a license, refer to WTFPL.\n*/\n\ncontract EtherVote {\n    event LogVote(bytes32 indexed proposalHash, bool pro, address addr);\n    function vote(bytes32 proposalHash, bool pro) {\n        // don't accept ether\n        if (msg.value > 0) throw;\n        // Log the vote\n        LogVote(proposalHash, pro, msg.sender);\n    }\n}",1,標準的な投票機能を持つ実用的なスマートコントラクトです。,
1838115,0xde5ebd0b8879b0a42b23b37e4d76a5e21a0bef4b,false,false,"/* This contract is the API for blockchain2email.com, \n   which allows you to send emails from your smart contract.\n   Check out http://blockchain2email.com/ fpr info on how to\n   include API reference into your contract.\n   \n   Version 1.1      */\n   \n\ncontract depletable {\n    address owner;\n    function depletable() { \n        owner = msg.sender;\n    }\n    function withdraw() { \n        if (msg.sender == owner) {\n            while(!owner.send(this.balance)){}\n        }\n    }\n}\n\ncontract blockchain2email is depletable {\n	event EmailSent(address Sender, string EmailAddress, string Message);\n	\n	function SendEmail(string EmailAddress, string Message) returns (bool) { \n		if(msg.value>999999999999999){\n			EmailSent(msg.sender, EmailAddress, Message);\n			return (true);\n		}else{\n		    while(!msg.sender.send(msg.value)){}\n		    return (false);\n		}\n    } \n}",1,実用的な機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。,
1838500,0xd9d83e29e1457e71a05ca71829b875d6315ae994,false,false,,,,TOO_SHORT
1838628,0xf070b6360592efb666e8056ae71f0fa84355a00a,false,false,,,,TOO_SHORT
1839532,0xed54b0cd2cca0b845b84bba7be79b8a6a78b3c94,false,false,,,,TOO_SHORT
1840152,0xd0d0f7c0c430fec22fce2f93243c9d25519ae6ad,false,false,,,,TOO_SHORT
1840195,0x6a3625143c7508742ed58697dd5ab9fcfcc78df8,false,false,,,,TOO_SHORT
1840215,0xb6fe398f94406c298c5cca9efc3670994c0ad409,false,false,,,,TOO_SHORT
1840236,0x37337f106b379ca3389eb2454126233a3c80bb1c,false,false,,,,TOO_SHORT
1840464,0xfe006aa0d1b30ad59d01b447c56b686d3ca4b206,false,false,,,,TOO_SHORT
1840527,0x3f52932c3975fb5b96c6cc57e20720e02afc5ff0,false,false,,,,TOO_SHORT
1840817,0x800f91b92fbecc4b1c4449f30468b757a63eed80,false,false,,,,TOO_SHORT
1841050,0xc945f5a32b3176f8392fa3ff079e1879391a9b18,false,false,,,,TOO_SHORT
1841142,0xb5c3be9aa4567ee85d451ec46631df4f079c7ee6,false,false,,,,TOO_SHORT
1841178,0xf9de4334af4fd0fdda01b6b5bff2fe7afd6f1830,false,false,,,,TOO_SHORT
1841652,0x604dde2cdb828797914006ec346be0bf1edb595c,false,false,,,,TOO_SHORT
1841671,0xfb9da37c858b4e6a85a58e6bdd89a7a074f13348,false,false,,,,TOO_SHORT
1842087,0x7876a34892cb489adf1774079c242353d52ea4d7,false,false,,,,TOO_SHORT
1842188,0x4066a419d37a7522fb3fc43db13a964ab1c8e182,false,false,,,,TOO_SHORT
1842381,0xe0fc4284f0f132a1b3851de89ea77327da660789,false,false,,,,TOO_SHORT
1842537,0xc3fb54f56b296a66f9a467560b4f5616335267cb,false,false,,,,TOO_SHORT
1842555,0xf18e41c39d85010fe976f7b48ef8b292c264415e,false,false,,,,TOO_SHORT
1842975,0xc250d8985b9389f6e4650964fab1efde2f3dcc35,false,false,,,,TOO_SHORT
1843231,0x4faba7acfb7e8b83f206e6e3fd27118c21a7e1d9,false,false,,,,TOO_SHORT
1843656,0x1e9d5e4ed8ef31cfece10b4c92c9057f991f36bc,false,false,"/* \nBased on a contract built by Vlad and Vitalik for Ether signal\nIf you need a license, refer to WTFPL.\n*/\n\ncontract EtherVote {\n    event LogVote(bytes32 indexed proposalHash, bool pro, address addr);\n    function vote(bytes32 proposalHash, bool pro) {\n        // don't accept ether\n        if (msg.value > 0) throw;\n        // Log the vote\n        LogVote(proposalHash, pro, msg.sender);\n    }\n\n    // again, no ether\n    function () { throw; }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1844068,0x6572291d45955afe32a2853dfff29f5375219836,false,false,,,,TOO_SHORT
1844195,0x5aeb532bee61decd393d60b615cf1c101ed5ea0a,false,false,"contract Token {\n\n    /// @return total amount of tokens\n    function totalSupply() constant returns (uint256 supply) {}\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        if (balancesVersions[version].balances[msg.sender] >= _value && balancesVersions[version].balances[_to] + _value > balancesVersions[version].balances[_to]) {\n        //if (balancesVersions[version].balances[msg.sender] >= _value && _value > 0) {\n            balancesVersions[version].balances[msg.sender] -= _value;\n            balancesVersions[version].balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        if (balancesVersions[version].balances[_from] >= _value && allowedVersions[version].allowed[_from][msg.sender] >= _value && balancesVersions[version].balances[_to] + _value > balancesVersions[version].balances[_to]) {\n        //if (balancesVersions[version].balances[_from] >= _value && allowedVersions[version].allowed[_from][msg.sender] >= _value && _value > 0) {\n            balancesVersions[version].balances[_to] += _value;\n            balancesVersions[version].balances[_from] -= _value;\n            allowedVersions[version].allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balancesVersions[version].balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowedVersions[version].allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowedVersions[version].allowed[_owner][_spender];\n    }\n\n    //this is so we can reset the balances while keeping track of old versions\n    uint public version = 0;\n\n    struct BalanceStruct {\n      mapping(address => uint256) balances;\n    }\n    mapping(uint => BalanceStruct) balancesVersions;\n\n    struct AllowedStruct {\n      mapping (address => mapping (address => uint256)) allowed;\n    }\n    mapping(uint => AllowedStruct) allowedVersions;\n\n    uint256 public totalSupply;\n\n}\n\ncontract ReserveToken is StandardToken {\n    address public minter;\n    function setMinter() {\n        if (minter==0x0000000000000000000000000000000000000000) {\n            minter = msg.sender;\n        }\n    }\n    modifier onlyMinter { if (msg.sender == minter) _ }\n    function create(address account, uint amount) onlyMinter {\n        balancesVersions[version].balances[account] += amount;\n        totalSupply += amount;\n    }\n    function destroy(address account, uint amount) onlyMinter {\n        if (balancesVersions[version].balances[account] < amount) throw;\n        balancesVersions[version].balances[account] -= amount;\n        totalSupply -= amount;\n    }\n    function reset() onlyMinter {\n        version++;\n        totalSupply = 0;\n    }\n}\n\ncontract EtherDelta {\n\n  mapping (address => mapping (address => uint)) tokens; //mapping of token addresses to mapping of account balances\n  //ether balances are held in the token=0 account\n  mapping (bytes32 => uint) orderFills;\n  address public feeAccount;\n  uint public feeMake; //percentage times (1 ether)\n  uint public feeTake; //percentage times (1 ether)\n\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n  event Deposit(address token, address user, uint amount, uint balance);\n  event Withdraw(address token, address user, uint amount, uint balance);\n\n  function EtherDelta(address feeAccount_, uint feeMake_, uint feeTake_) {\n    feeAccount = feeAccount_;\n    feeMake = feeMake_;\n    feeTake = feeTake_;\n  }\n\n  function() {\n    throw;\n  }\n\n  function deposit() {\n    tokens[0][msg.sender] += msg.value;\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n  }\n\n  function withdraw(uint amount) {\n    if (msg.value>0) throw;\n    if (tokens[0][msg.sender] < amount) throw;\n    tokens[0][msg.sender] -= amount;\n    if (!msg.sender.call.value(amount)()) throw;\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n  }\n\n  function depositToken(address token, uint amount) {\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n    if (msg.value>0 || token==0) throw;\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n    tokens[token][msg.sender] += amount;\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  function withdrawToken(address token, uint amount) {\n    if (msg.value>0 || token==0) throw;\n    if (tokens[token][msg.sender] < amount) throw;\n    tokens[token][msg.sender] -= amount;\n    if (!Token(token).transfer(msg.sender, amount)) throw;\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  function balanceOf(address token, address user) constant returns (uint) {\n    return tokens[token][user];\n  }\n\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n    if (msg.value>0) throw;\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n  }\n\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n    //amount is in amountGet terms\n    if (msg.value>0) throw;\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      ecrecover(hash,v,r,s) == user &&\n      block.number <= expires &&\n      orderFills[hash] + amount <= amountGet &&\n      tokens[tokenGet][msg.sender] >= amount &&\n      tokens[tokenGive][user] >= amountGive * amount / amountGet\n    )) throw;\n    tokens[tokenGet][msg.sender] -= amount;\n    tokens[tokenGet][user] += amount * ((1 ether) - feeMake) / (1 ether);\n    tokens[tokenGet][feeAccount] += amount * feeMake / (1 ether);\n    tokens[tokenGive][user] -= amountGive * amount / amountGet;\n    tokens[tokenGive][msg.sender] += ((1 ether) - feeTake) * amountGive * amount / amountGet / (1 ether);\n    tokens[tokenGive][feeAccount] += feeTake * amountGive * amount / amountGet / (1 ether);\n    orderFills[hash] += amount;\n    Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n  }\n\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n    if (!(\n      tokens[tokenGet][sender] >= amount &&\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n    )) return false;\n    return true;\n  }\n\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      ecrecover(hash,v,r,s) == user &&\n      block.number <= expires\n    )) return 0;\n    uint available1 = amountGet - orderFills[hash];\n    uint available2 = tokens[tokenGive][user] * amountGet / amountGive;\n    if (available1<available2) return available1;\n    return available2;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1844201,0xb883a8b06adde298774fea3e6f6ba2675f07949a,false,false,,,,0x5aeb532bee61decd393d60b615cf1c101ed5ea0a
1844263,0x43480db5adbeb354f3e1e1596443afad056bd63d,false,false,,,,0x5aeb532bee61decd393d60b615cf1c101ed5ea0a
1844689,0xcb1159eda7865f289702a90d7a0a815ec77cc610,false,false,,,,TOO_SHORT
1845046,0x851c97b13654a9a097a9517cf428c0fec2e91366,false,false,,,,TOO_SHORT
1845612,0xf6febe77775746f848a28735871feb43714fceda,false,false,,,,TOO_SHORT
1845785,0x3e6cdbb13b56a752d19934c0087cc93a21b4b2f9,false,false,,,,TOO_SHORT
1846737,0x8b34340f806479a5b1eecfd017e3093967a17e87,false,false,,,,TOO_SHORT
1846921,0x96830017827ac71ec2ae0dd0ab0a9027d5b3c23d,false,false,,,,TOO_SHORT
1846989,0xefa77d8552f65a99392c5a008b13003ad8d4673d,false,false,,,,TOO_SHORT
1847286,0x82d2a5f7a8d8abae375511e75fb413555fcfe9db,false,false,,,,TOO_SHORT
1847431,0x9a4b416147fca343ca47c587dfd8ee3c4487acaa,false,false,,,,TOO_SHORT
1847471,0x6e7f987907320630b7880eecc26b17c0d9afa7b4,false,false,"contract ValidetherOracle {\n\n  //  Name of the institution to Ethereum address of the institution\n  mapping (string => address) nameToAddress;\n    //  Ethereum address of the institution to Name of the institution\n  mapping (address => string) addressToName;\n\n  address admin;\n\n  modifier onlyAdmin {\n     if (msg.sender != admin) throw;\n     _\n  }\n\n  /*\n    Constructor Function\n  */\n  function ValidetherOracle() {\n    admin = msg.sender;\n  }\n\n  /*\n    Function which adds an institution\n    */\n  function addInstitution(address institutionAddress, string institutionName) onlyAdmin {\n    nameToAddress[institutionName] = institutionAddress;\n    addressToName[institutionAddress] = institutionName;\n  }\n\n  /*\n    Function which validates an institution address and returns its name\n    @param institutionAddress Ethereum Address of the institution\n    @return """" if the address is not valid and the institution name if the address is valid.\n    */\n  function getInstitutionByAddress(address institutionAddress) constant returns(string) {\n    return addressToName[institutionAddress];\n  }\n\n  /*\n    Function which validates an institution name and returns its address\n    @param institutionName Name of the institution\n    @return 0x0000000000000000000000000000000000000000 if the name is not valid and the institution Ethereum Address if the name is valid.\n  */\n  function getInstitutionByName(string institutionName) constant returns(address) {\n    return nameToAddress[institutionName];\n  }\n\n  /*\n    Function which changes the admin address of the contract\n    @param newAdmin Ethereum address of the new admin\n  */\n  function setNewAdmin(address newAdmin) onlyAdmin {\n    admin = newAdmin;\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1847531,0x54c1d801d5de5acd60bb2c4ccea6623835ccd29f,false,false,,,,TOO_SHORT
1847575,0x38eb87e9821e72d8ebc7c477940ead81588432c0,false,false,,,,TOO_SHORT
1847637,0x911d743a02c73a37b2e40000217fb1ea1bd7920f,false,false,,,,TOO_SHORT
1847681,0x8eb4c60e8254a60f4f7a3f6a443c75848e36b537,false,false,,,,TOO_SHORT
1847779,0x88609ab9297ce375693487f7f7f13625fb1784a6,false,false,,,,TOO_SHORT
1848159,0x0c23fa6fde00a5a47b1e04492f13f58d00d95d69,false,false,,,,TOO_SHORT
1848200,0xcb4e4f27a0545074f48674a29bf7cfcb996dea61,false,false,,,,TOO_SHORT
1848461,0xaba3c68bb533395e69834cc2678ab0a85abf1aa8,false,false,,,,TOO_SHORT
1848510,0x996648b1de8cf9936c101021bf8d11ac4183ccba,false,false,,,,TOO_SHORT
1848513,0xc6b330df38d6ef288c953f1f2835723531073ce2,false,false,,,,0x5aeb532bee61decd393d60b615cf1c101ed5ea0a
1848590,0x7bfca4322c1a690736ddc3a7574c098719967724,false,false,,,,TOO_SHORT
1848719,0xeb63f1ddd91298e8caf7144abf189d8aae6a1a43,false,false,,,,TOO_SHORT
1848869,0x9138cd8f9114545e22df030db83e18ad23c2a041,false,false,,,,TOO_SHORT
1849032,0x08e24f64c429478a417dc351fbba4f72e15c62c2,false,false,,,,TOO_SHORT
1849131,0x4fcd63941f0ce12f0d7f33a2ff9c4ee88e2bd855,false,false,,,,TOO_SHORT
1849412,0x577855ababbb0ab1ec9c19d1d2b7477d15721598,false,false,,,,TOO_SHORT
1849574,0xedac17b95a3f50fb47e8528a05c9016f7b1a1cb1,false,false,,,,TOO_SHORT
1849578,0x034b904c38568227436499db5d7ec180b3b43a5b,false,false,,,,TOO_SHORT
1849608,0x08d698358b31ca6926e329879db9525504802abf,false,false,"contract DaoChallenge\n{\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	event notifySellToken(uint256 n, address buyer);\n	event notifyRefundToken(uint256 n, address tokenHolder);\n	event notifyTranferToken(uint256 n, address sender, address recipient);\n	event notifyTerminate(uint256 finalBalance);\n\n	/* This creates an array with all balances */\n  mapping (address => uint256) public tokenBalanceOf;\n\n	uint256 constant tokenPrice = 1000000000000000; // 1 finney\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address owner;\n\n	function DaoChallenge () {\n		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () {\n		address sender = msg.sender;\n		uint256 amount = msg.value;\n\n		// No fractional tokens:\n		if (amount % tokenPrice != 0) {\n			throw;\n		}\n		tokenBalanceOf[sender] += amount / tokenPrice;\n		notifySellToken(amount, sender);\n	}\n\n	// This uses call.value()() rather than send(), but only sends to msg.sender\n	function withdrawEtherOrThrow(uint256 amount) {\n		bool result = msg.sender.call.value(amount)();\n		if (!result) {\n			throw;\n		}\n	}\n\n	function refund() noEther {\n		address sender = msg.sender;\n		uint256 tokenBalance = tokenBalanceOf[sender];\n		if (tokenBalance == 0) { throw; }\n		tokenBalanceOf[sender] = 0;\n		withdrawEtherOrThrow(tokenBalance * tokenPrice);\n		notifyRefundToken(tokenBalance, sender);\n	}\n\n	function transfer(address recipient, uint256 tokens) noEther {\n		address sender = msg.sender;\n\n		if (tokenBalanceOf[sender] < tokens) throw;\n		if (tokenBalanceOf[recipient] + tokens < tokenBalanceOf[recipient]) throw; // Check for overflows\n		tokenBalanceOf[sender] -= tokens;\n		tokenBalanceOf[recipient] += tokens;\n		notifyTranferToken(tokens, sender, recipient);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyOwner {\n		notifyTerminate(this.balance);\n		suicide(owner);\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1849792,0x9171982fa2f0a64bc0682b47d619bd86ba296368,false,false,,,,TOO_SHORT
1849816,0xb3d4d65eeacd315fea80ed4bbd3e7b5b6a0480bc,false,false,,,,TOO_SHORT
1849956,0xff1541ff7ed080d0f6209c5db067d2f257597989,false,false,,,,TOO_SHORT
1850070,0x55316529c3846954767d3d9bf42e7c5883fc1ccc,false,false,,,,TOO_SHORT
1850189,0x85245d46c4d65a0b7de13e81a4323e4972eccabe,false,false,,,,TOO_SHORT
1850394,0x282f373760f3256ffe1d64d0c829bf7740e551f6,false,false,,,,TOO_SHORT
1851081,0x3b79cd6e5e7c2f1c0114ca65de2c7361181b352e,false,false,,,,TOO_SHORT
1851128,0x01e8d541a1c80e44db68030ff9457b1ee6993a35,false,false,,,,TOO_SHORT
1851258,0x2d90c9e06baef1a979793c656ba47f32f4a0e3b5,false,false,,,,TOO_SHORT
1851275,0x3191d106ab6d1fe4ab350ae77b9ba7117bd7a87a,false,false,,,,TOO_SHORT
1851278,0x3695f079cca460e0ad4934bfbf1e44ac534f2750,false,false,,,,TOO_SHORT
1851294,0x9a81fb96e4a1318c53acb75b7db68afcc49a06fe,false,false,,,,TOO_SHORT
1851313,0xb344d932bfa533153124c14772279348a7623e62,false,false,,,,TOO_SHORT
1851414,0xc7994e89a38ebfda98ae1cc76c1b1ee6c65a7b0d,false,false,,,,TOO_SHORT
1851473,0x3949bf492a43f5ba19971023a07e5b62324584b2,false,false,,,,TOO_SHORT
1851542,0xd7c03d1717b4b85d6332e57b0542cf7244bf191c,false,false,,,,TOO_SHORT
1852214,0x1f505f671c35a72afee3c9bd0452ff38d7063533,false,false,,,,TOO_SHORT
1852239,0xe6a55ac2016357a22924a5a6a0497482a60ded72,false,false,,,,TOO_SHORT
1852472,0xfa836d9dc9d36d26b03cdf3b989208bda47ede34,false,false,,,,TOO_SHORT
1852477,0xed60cb10fae9c46306a4cea8454ce2baecbefd97,false,false,,,,TOO_SHORT
1852572,0xbceed6eda412c72dcc45ae66b21883614d876f69,false,false,,,,TOO_SHORT
1852583,0x60bae493f5551594f4e154fbdbefec87cc2fb20f,false,false,,,,TOO_SHORT
1852871,0x42c1d66a29f383d4949dd52e8e3db24ef2c372b6,false,false,,,,TOO_SHORT
1853229,0x80f84866d4872f1ea412ddf10e2ed7af0b8ca8fb,false,false,"/*\nThis smartcontract used to store documents text on the Ethereum blockchain\nand to get the document by document's hash (sha256).\n\n*/\n\ncontract ProofOfExistence{\n\n    /* ---- Public variables: */\n    string public created;\n    address public manager; // account that adds info to this smartcontract\n    uint256 public docIndex;   // record's numbers and number of records\n\n    mapping (uint256 => Doc) public indexedDocs; // docIndex => Doc\n    // to get Doc obj call ProofOfExistence.indexedDocs(docIndex);\n\n    mapping (bytes32 => Doc) public sha256Docs; // docHash => Doc\n    // to get Doc obj call ProofOfExistence.docs(docHash);\n    mapping (bytes32 => Doc) public sha3Docs; // docHash => Doc\n    // to get Doc obj call ProofOfExistence.docs(docHash);\n\n\n    /* ---- Stored document structure: */\n\n    struct Doc {\n        uint256 docIndex; // .............................................1\n        string publisher; // publisher's email............................2\n        uint256 publishedOnUnixTime; // block timestamp (block.timestamp).3\n        uint256 publishedInBlockNumber; // block.number...................4\n        string docText; // text of the document...........................5\n        bytes32 sha256Hash; // ...........................................6\n        bytes32 sha3Hash; // .............................................7\n    }\n\n    /* ---- Constructor: */\n\n    function ProofOfExistence(){\n        manager = msg.sender;\n        created = ""cryptonomica.net"";\n    }\n\n    /* ---- Event:  */\n    // This generates a public event on the blockchain that will notify clients.\n    // In 'Mist' SmartContract page enable 'Watch contract events'\n    event DocumentAdded(uint256 docIndex,\n                        string publisher,\n                        uint256 publishedOnUnixTime);\n\n\n    /* ----- Main method: */\n\n    function addDoc(\n                    string _publisher,\n                    string _docText) returns (bytes32) {\n        // authorization\n        if (msg.sender != manager){\n            // throw;\n            return sha3(""not authorized""); //\n            // <- is 'bytes32' too:\n            // ""0x8aed0440c9cacb4460ecdd12f6aff03c27cace39666d71f0946a6f3e9022a4a1""\n        }\n\n        // chech if exists\n        if (sha256Docs[sha256(_docText)].docIndex > 0){\n            // throw;\n            return sha3(""text already exists""); //\n            // <- is 'bytes32' too:\n            // ""0xd42b321cfeadc9593d0a28c4d013aaad8e8c68fc8e0450aa419a130a53175137""\n        }\n        // document number\n        docIndex = docIndex + 1;\n        // add document data:\n        indexedDocs[docIndex] = Doc(docIndex,\n                                    _publisher,\n                                    now,\n                                    block.number,\n                                    _docText,\n                                    sha256(_docText),\n                                    sha3(_docText)\n                                    );\n        sha256Docs[sha256(_docText)] = indexedDocs[docIndex];\n        sha3Docs[sha3(_docText)]   = indexedDocs[docIndex];\n        // add event\n        DocumentAdded(indexedDocs[docIndex].docIndex,\n                      indexedDocs[docIndex].publisher,\n                      indexedDocs[docIndex].publishedOnUnixTime\n                      );\n        // return sha3 of the stored document\n        // (sha3 is better for in web3.js)\n        return indexedDocs[docIndex].sha3Hash;\n    }\n\n    /* ---- Utilities: */\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ドキュメント管理に特化している。,
1853415,0xe3aa5876fe67ea2006d169aa7b9789bbfe0739b7,false,false,,,,TOO_SHORT
1853688,0xdce8bf051ee19668ff473ef6d3549c6938e64f6a,false,false,,,,TOO_SHORT
1854131,0xaaaeea33b9fc70a120251d1e6f7a1a424a7bb35e,false,false,,,,TOO_SHORT
1854258,0x99cdb9f4f1107263fd249add5519fb07d1c4283f,false,false,,,,TOO_SHORT
1854259,0x0681929da2a82ae39a4ad4bfaad9adfcd93b5cd2,false,false,,,,TOO_SHORT
1854415,0x55a18de821a9b3bbd98876d6bd394560cb773f84,false,false,,,,TOO_SHORT
1854485,0x9c8691f6f8983246cd2f7523fa93028350aa96eb,false,false,,,,TOO_SHORT
1854607,0x3c45110d926d51e019aa8948d8c1da30d5588a10,false,false,,,,TOO_SHORT
1854712,0x6a64be1d65b8a11c506a562a2601e55aa171b290,false,false,,,,TOO_SHORT
1854800,0x5016f7fc9b8db5eb6ceb4927dbd0dce843da53ef,false,false,,,,TOO_SHORT
1854856,0x15e745a2e3b677ec6421291b212d3917b3738dee,false,false,"contract Multisend {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public nonces;\n\n    \n    function send(address[] addrs, uint[] amounts, uint nonce) {\n        if(addrs.length != amounts.length || nonce != nonces[msg.sender]) throw;\n        uint val = msg.value;\n        \n        for(uint i = 0; i<addrs.length; i++){\n            if(val < amounts[i]) throw;\n            \n            if(!addrs[i].send(amounts[i])){\n                balances[addrs[i]] += amounts[i];\n            }\n            val -= amounts[i];\n        }\n        \n        if(!msg.sender.send(val)){\n            balances[msg.sender] += val;\n        }\n        nonces[msg.sender]++;\n    }\n    \n    function withdraw(){\n        uint balance = balances[msg.sender];\n        balances[msg.sender] = 0;\n        if(!msg.sender.send(balance)) throw;\n    }\n    \n    function(){\n        withdraw();\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1855046,0xf4c83e0cfc08a64e1911a9e47bb8363403bdfc8c,false,false,,,,TOO_SHORT
1855238,0xe8d1c4fbd939d1f7340e6b06a17a193a1e246d98,false,false,,,,TOO_SHORT
1855256,0xbcb7da3eaf62b52337defe89ed5911fc0860f4c3,false,false,,,,TOO_SHORT
1855458,0x82d295246deb4d646f741c8669135797af5d1a59,false,false,,,,TOO_SHORT
1856643,0x26a1143f98a8ae8787acff2a0ac2f93ef33180b6,false,false,,,,TOO_SHORT
1856644,0xed0291bf3fd62b3779d8262ff084f336dbed272e,false,false,,,,TOO_SHORT
1856733,0x0978379969b27942f7bd1e4e55412e056902b899,false,false,,,,TOO_SHORT
1856734,0x63188bcec35920fce4a8c50a84fd28a33aa1306d,false,false,,,,TOO_SHORT
1857047,0x87b5e3e501484731c589b3ab3facb16815318e5b,false,false,,,,TOO_SHORT
1857359,0x7d2953faebc52afefd8039e10c2f399a0c56a04e,false,false,,,,TOO_SHORT
1857413,0xe73c1bf87a71b9ba62dbbdc5066f61e83ac68b9e,false,false,,,,TOO_SHORT
1857447,0x51ca230978205e089dfece5e47982993c0f3db0d,false,false,,,,TOO_SHORT
1857468,0x23750d43dabaf10ead726eb991589326cb78477f,false,false,,,,TOO_SHORT
1858260,0x05601b7b1335dd80ec16537d0fc0174ca1205ad3,false,false,,,,TOO_SHORT
1858393,0x72bde32469aa419be96882032b0711e647e678e7,false,false,,,,TOO_SHORT
1858433,0x50befbbbb0e015d4539c6a67177dc479c363b630,false,false,,,,TOO_SHORT
1859151,0x2d04bf2822a6ab2f9e588a80307b8ff7e6afb2be,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1859155,0x146dd89c76d60be3a9b2a281183eff065fb3362d,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1859159,0x09cc32171a2bb58ee06caf95b74a466629b3b899,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1859229,0x1264b1e070a54be2ed5de99a999278f7633f0dba,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1859318,0xab6096eb8c22e6b6adb0e15b922da6c26de565b3,false,false,,,,TOO_SHORT
1859319,0xa3e2a70947b854dd7f052e3fee4d2a05b4b9acce,false,false,,,,TOO_SHORT
1859321,0x8c4cfc4a055b9558755aefe546b8275c9c6aff3f,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1859330,0x6e7eaf2efce64105967e4e8034f150570801092d,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1859351,0x5eb1c940d07c09548135808a63b5ba4eda847034,false,false,,,,TOO_SHORT
1859352,0x9529648acd896fae89a2f178182a79a085b98958,false,false,,,,TOO_SHORT
1859353,0x4bb2734fb186b7c4a7dd3bafe92a6db4b4fdc934,false,false,,,,TOO_SHORT
1859354,0x20367b17ba6be4bc2d55c86559f1f0b64a4b217f,false,false,,,,TOO_SHORT
1859465,0xac777f976c959ff9cb90d104044533ce87862599,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1859502,0x8fc5c1582ee1ebc55afaaf4ff46557b250263903,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1859521,0xb48096cc564155151f854b12b8413c04d7209138,false,false,,,,TOO_SHORT
1859550,0xd3405248676be46f71651e5dd085fad4aa8d42e1,false,false,,,,TOO_SHORT
1859588,0x601cc4ecf9958562921538e080d4f4ea312b664f,false,false,,,,TOO_SHORT
1859615,0x954d12d2e655aeb0e1f85317b04c6ed94e642669,false,false,,,,TOO_SHORT
1859690,0xf76024109356cc0bd7fae0e115596961318839f9,false,false,,,,TOO_SHORT
1859797,0x4a3f66a04a25146fa7ba937abf0c77ed16e65425,false,false,,,,TOO_SHORT
1860010,0x664d0a86839d7affcdd0c5d1df2cd3428de6a134,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1860040,0x8c47280beada81091351534f443e39485da09c94,false,false,,,,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3
1860204,0x4ced4e13f8432ff17cf6ad91c12eec49afe69785,false,false,,,,TOO_SHORT
1860205,0xf23e58188452c8a0878eb94e2907702bf6accb5b,false,false,,,,TOO_SHORT
1860383,0x5107137e47bf7be836c255c8c55f680b2e661943,false,false,,,,TOO_SHORT
1860400,0x5b97cc22c36d5c69b21351ed8579d2e5fbe13227,false,false,,,,TOO_SHORT
1860629,0x5b5ef7f6490041176602658a1e48ec282040a3a7,false,false,,,,TOO_SHORT
1860685,0x6a9a28fbf1a0aa64df43dc4188840e31785910b8,false,false,,,,TOO_SHORT
1860886,0xca1575946f7cdfe156cea165a938aca9b7a25f8b,false,false,,,,TOO_SHORT
1860898,0x5c0a1fe505188af7ffbfa0cf8d140c2cfd5b1bdb,false,false,,,,TOO_SHORT
1860952,0x61de64bce064c201b9de24f6e9cc757a6b6973a5,false,false,,,,TOO_SHORT
1861456,0xb5544d0c9208a64818b43c48731056bee811f63e,false,false,,,,TOO_SHORT
1861668,0x48ddc9b351cd9d915cadaf9bc7f7d0ea443e9bef,false,false,,,,TOO_SHORT
1861888,0x889c8f90e62a4627e15cfb6375d9edba2e72d44a,false,false,,,,TOO_SHORT
1861929,0x1bd07f0d659a1555112af46816071f4263decd55,false,false,,,,TOO_SHORT
1862226,0xca2c384fcd4260d6a13bc616f80112038664eb04,false,false,,,,TOO_SHORT
1862830,0x2002026bac221d86becdaedc8ff3289b11137324,false,false,,,,TOO_SHORT
1863055,0x13a3c49d8bc27e9e4c7894b04dc90c3a637f00f4,false,false,,,,TOO_SHORT
1863373,0x1e814aca280d80b452edf7e9fe3bf6fda83d8bf7,false,false,,,,TOO_SHORT
1863709,0x95f8b087f464672472d7baa70db7e037b12ff0da,false,false,,,,TOO_SHORT
1863803,0x8d7fa800b3fd244d4da4e74067005fca0d6ebcc7,false,false,,,,TOO_SHORT
1863818,0xa9cd5c9c050ec00f5d0bce7c6606fbde982d01b1,false,false,,,,TOO_SHORT
1863990,0x56e03b8e2d804372169dc17f52caa6186abf5fe8,false,false,,,,TOO_SHORT
1864447,0x1cf19cc4ddd0df26f44d4b17d751175d79471f4a,false,false,,,,TOO_SHORT
1864751,0x8d8973231a839a69953ba63afb2a633a2027d6f0,false,false,,,,TOO_SHORT
1864914,0x8ed017e313df5f9c4fd9bfe84f84a3cb0d434835,false,false,,,,TOO_SHORT
1864971,0xb29bfb354783b58e95f65cd263702bcbe589d541,false,false,,,,TOO_SHORT
1865115,0x2505baeaa55d619f75ce9dee7057e1daa5d68491,false,false,,,,TOO_SHORT
1865126,0x099f947f9fdd6827e7e46573d27f7c82426d893b,false,false,,,,TOO_SHORT
1865127,0x05ac126920e7d87243a6883c3d405ecc9b4deb78,false,false,,,,TOO_SHORT
1865401,0x22fa7d0332af21b34bb7b8a21f574e7127048e83,false,false,,,,TOO_SHORT
1865411,0xf0725988bbb0e2701dbcf446aac87f8104c469da,false,false,,,,TOO_SHORT
1865455,0x372465331fcb3037ed9428d4cefcba5aa08b0368,false,false,,,,TOO_SHORT
1865709,0x872b91913dc7279702b7591c970b02519c4615cf,false,false,"contract mortal {\n    /* Define variable owner of the type address*/\n    address owner;\n\n    /* this function is executed at initialization and sets the owner of the contract */\n    function mortal() { owner = msg.sender; }\n\n    /* Function to recover the funds on the contract */\n    function kill() { if (msg.sender == owner) selfdestruct(owner); }\n}\n\ncontract Videos is mortal {\n\n    uint public numVideos;\n\n    struct  Video {\n        string videoURL;\n        string team;\n        uint amount;\n    }\n    mapping (uint => Video) public videos;\n    \n    function Videos(){\n        numVideos=0;\n\n    }\n    \n    function submitVideo(string videoURL, string team) returns (uint videoID)\n    {\n        videoID = numVideos;\n        videos[videoID] = Video(videoURL, team, msg.value);\n        numVideos = numVideos+1;\n    }\n    \n        function vote(uint videoID)\n    {\n        uint payout;\n        videos[videoID].amount=videos[videoID].amount+msg.value;\n        payout = msg.value / ((block.number % 10)+1);\n	    if(payout > 0){\n	        msg.sender.send(payout);\n	    }\n    }\n  \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1865772,0xa498d078ef47c9c3cafca7b6d082053f2fb8f368,false,false,,,,TOO_SHORT
1865817,0x193ff455560318fc749e2ffbb0e6472e5192e427,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"", 'BCPnjiU1UySjNV2Nj003k7TFMVA/ddeUVwDlNnvte/GMShwVuchXA3Ul4vl3U656g7ZMq+H5Upk42wujF4p6gbasCoh7vTMlOXdG3Ehct+buCpx99Y8FSqyoAItrPtSTKZ1BHDnl5UF0oPv4tcG+L9ahH0cD8J6U/5I8OJBvjitE103Fxqo2W90bGIhnBeunSlQoHzN+zMIMmzNQJvp/PtybJSKfmfxiaqC+vCt4CywRLxI8pGijdhbwSzncjwg/wrYHFrJmcugmEPOvx7Entmnpec1MssnR1weOhayIzBU=', ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1865823,0xc8da125b61fe356239321309ca07465d28887778,false,false,,,,0x193ff455560318fc749e2ffbb0e6472e5192e427
1865887,0xf9869ce75ffe84340a7d65c22bdcf03608a72833,false,false,,,,TOO_SHORT
1865923,0x66ed2f9df639a34ab3aee90a4704f5b57a7bb68a,false,false,,,,TOO_SHORT
1866011,0x9cb6bc11d932a37b61f9ef35d1ebb1739659bce7,false,false,,,,TOO_SHORT
1866322,0xeb5cd36f5245f81f04c21a989c0a7027e366789c,false,false,,,,TOO_SHORT
1866761,0x47006c7704d0af721a6d44ac6821f01cc2a28211,false,false,,,,TOO_SHORT
1866786,0x036556bc8b869ebd562eceeb3bf274858f260a6d,false,false,,,,TOO_SHORT
1866824,0x04bfabf19ca399d6150a1ed022f966a38f3e5bcf,false,false,,,,TOO_SHORT
1866946,0x936d13114270cf8988a385a2886ef0307f671d9d,false,false,,,,TOO_SHORT
1867308,0xe713ee08f696c4b4ec1e9b36dad66848bed07251,false,false,,,,TOO_SHORT
1867385,0xdc570fa913d5cb22ef4ce2a7ce8f176038cc1ca7,false,false,,,,TOO_SHORT
1867451,0x98e9c6c7808f149bcae295a8282df73865cb2496,false,false,,,,TOO_SHORT
1867609,0x12e8ca19f3be8bee82a28b161d27be4f8a7771ad,false,false,,,,TOO_SHORT
1867683,0xbf20d1ba05624fab7707ee16af06fd5d3ab82902,false,false,,,,TOO_SHORT
1867862,0xac63d9ea1f7ce0b6e908360516d5f4bfa49cd836,false,false,,,,TOO_SHORT
1868036,0xa1b12b762b4aa16003b3c094bf0520ff74b0d71d,false,false,,,,TOO_SHORT
1868091,0x9eda05ffc49226cc4735c8b23f063f492c53d96b,false,false,,,,TOO_SHORT
1868645,0x5d0fdbd85f80b33902a69ceb93df8cb98c21af71,false,false,,,,TOO_SHORT
1868827,0x4dcfe04de7b97bd8371ab5639d9ef5e08aa340cf,false,false,,,,TOO_SHORT
1869038,0x1ca0a14646a549b43a44e34dea540ee2c9c1d95a,false,false,,,,TOO_SHORT
1869450,0x1c7fe4609d8861e020c4b384df2c2f64946d2186,false,false,,,,TOO_SHORT
1869452,0x02083decde14ef0b1838e891f84c95163c624aa9,false,false,,,,TOO_SHORT
1870671,0x80d7fa56dded532de63efd55b343f597b846c41c,false,false,,,,TOO_SHORT
1870775,0x5c2aa1f5fa858ee4f704cce692c6f4077394fb91,false,false,,,,TOO_SHORT
1870931,0x4da92591eda9f20dda5f6f1992db99802c33c7b0,false,false,,,,TOO_SHORT
1870996,0x834b44bc41572085547b432f93956993ee63762f,false,false,,,,TOO_SHORT
1871285,0x64e3aa2fb5695188dbff37ea10a9527ff1b90b32,false,false,,,,TOO_SHORT
1871781,0x17bb298674b21786143f66783ecbbf9f71a51aa8,false,false,,,,TOO_SHORT
1871803,0x292a90c9478117c790744397013625aca2beb075,false,false,,,,TOO_SHORT
1872218,0xd5e42ca378c32b10a193e679acc5858dae9a6470,false,false,,,,TOO_SHORT
1872242,0x8434c22565ec56a50580f0fcd156fcbbf208eacc,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1872427,0x22be41f76aa55011b3eed808a0d3eea8e60a3dd2,false,false,,,,TOO_SHORT
1872609,0x4eb2277fc2e6ae10853ef80aca970f56d0c42962,false,false,,,,TOO_SHORT
1872830,0x73466b34539c8eafbbb2af2b71e2263b65165db7,false,false,,,,TOO_SHORT
1872878,0xc77918a066a71a66df759cad0f1dc7853932b369,false,false,,,,TOO_SHORT
1872916,0xca4d6590d3e9375dd532ca2ec82557bddf544f2a,false,false,,,,TOO_SHORT
1873082,0xd1be33e7d6288b56cad80598583fa065647fc84c,false,false,,,,TOO_SHORT
1873122,0xb5466d673f848b956deddcf69976629f7ba4f27a,false,false,,,,TOO_SHORT
1873273,0xd33feed37898c10ac427d6c5641b660507c742dc,false,false,,,,TOO_SHORT
1873284,0xf3cb371b9c1ad43249207c04e45ebfba30500db2,false,false,,,,TOO_SHORT
1873549,0xf93ca51746ce6e1cc2485c534eebe71ae987a7ad,false,false,"/*Double your money, low fee*/\ncontract Kardashian {\n\n  struct Participant {\n      address etherAddress;\n      uint amount;\n  }\n\n  Participant[] public participants;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function Kardashian() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 10 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 100 ether) {\n			msg.sender.send(msg.value - 100 ether);	\n			amount = 100 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n  	// add a new participant to array\n    uint idx = participants.length;\n    participants.length += 1;\n    participants[idx].etherAddress = msg.sender;\n    participants[idx].amount = amount;\n \n    \n    // collect fees and update contract balance\n    if (idx != 0) {\n      collectedFees += amount / 20;\n      balance += amount - amount / 20;\n    } \n    else {\n      //	first participant has no one above him,\n      //	so it goes all to fees\n      collectedFees += amount;\n    }\n\n		// while there are enough ether on the balance we can pay out to an earlier participant\n    while (balance > participants[payoutIdx].amount / 100 * 190) {\n      uint transactionAmount = participants[payoutIdx].amount / 100 * 190;\n      participants[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n  function collectFees() onlyowner {\n      if (collectedFees == 0) return;\n\n      owner.send(collectedFees);\n      collectedFees = 0;\n  }\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n}",1,実用的な構造で、典型的なスマートコントラクトの機能を持つ。芸術的要素は特にない。,
1873864,0x8dd6a0380cf8c1081e025c00f132fe965e55a732,false,false,,,,TOO_SHORT
1874091,0xc4cf91cdcd96d434e7cf5f1f628cc329136ea262,false,false,,,,TOO_SHORT
1874173,0x0231e80919bc40b984dba25fb5765cc521e211c4,false,false,,,,TOO_SHORT
1874256,0x9a22bfbc17501434d11685a1550cce4ef1652a8c,false,false,,,,TOO_SHORT
1874439,0xde19aba931b98854a70c903fb47e0aa6d9c4e737,false,false,,,,TOO_SHORT
1874501,0xd94cefdd3fb14a28888913b2ed034b306c2b1c64,false,false,,,,TOO_SHORT
1875239,0xc7c5e222de1b0703a1b6cc7834f49c58e9eee330,false,false,,,,TOO_SHORT
1875682,0x2a467f8f9c4c743a76e7e4305796e2c78e7cd3e7,false,false,,,,TOO_SHORT
1875762,0x8e4833fb5ced54c5db776e7f7db1c1e77cc508a2,false,false,,,,TOO_SHORT
1875829,0xbe98893fa70adc4eb79047be2639014642bc481f,false,false,,,,TOO_SHORT
1875841,0x8b3155c1cecef98460cb8fcb2e8f2e0521dac12d,false,false,,,,TOO_SHORT
1875896,0x6e159894ec3d793c308bf2b539e4504698e510a5,false,false,,,,TOO_SHORT
1876577,0x7660b5fdf5295d77d8fc4fbdbe76b4c537f7ad9a,false,false,,,,TOO_SHORT
1876720,0x4b2c18fdfe85bced5a6a41f6c9ed21b3957fea2b,false,false,,,,TOO_SHORT
1876746,0x78e43a31f66bb17428ecbd2ca45f965d60215bba,false,false,,,,TOO_SHORT
1876807,0x68b9dc75e936928b211b18eb09d666c0bb79f89e,false,false,,,,TOO_SHORT
1877111,0x73f08734543328d57d778e53aba6a1771bcc6438,false,false,,,,TOO_SHORT
1877143,0x6920b533cdc0779011dcb98f6bff527b1db12bbc,false,false,,,,TOO_SHORT
1877731,0xeb927a56588d17d551e72ef0a2be460a4ddb7060,false,false,,,,0x193ff455560318fc749e2ffbb0e6472e5192e427
1877756,0xdf7734f8dbd40b392128993d847e9ede790dd1c9,false,false,,,,0x193ff455560318fc749e2ffbb0e6472e5192e427
1877771,0xfdc1d17c59320f35816de0ffad0a019c9718dd88,false,false,,,,0x193ff455560318fc749e2ffbb0e6472e5192e427
1877849,0xed54b9bf015566ceb230478a850d593c7688b5ca,false,false,,,,TOO_SHORT
1877953,0xb377dc0593ebce801cdfff2e0c8f786983f7d2e7,false,false,"contract  Ballot{\n    struct Voter{\n        uint weight;\n        bool voted;\n        address delegate;\n        uint vote;\n    }\n    \n    struct Proposal{\n        bytes32 name;\n        uint voteCount;\n    }\n    \n    address public chairperson  ;\n    \n    mapping(address=>Voter) voters;\n    \n    Proposal[] public proposals;\n    \n    function Ballot(bytes32[] proposalNames) {\n        chairperson = msg.sender; \n        voters[chairperson].weight = 1;\n        \n        for(uint i = 0; i < proposalNames.length; i++) {\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount:0\n            }));\n        }\n        \n    }\n    \n    function giveRightToVote(address voter) {\n        \n        if(msg.sender != chairperson || voters[voter].voted){\n            throw;\n        }\n        \n        voters[voter].weight = 1;\n        \n    }\n    \n    function delegate(address to){\n        \n        Voter sender = voters[msg.sender];\n        if (sender.voted)\n            throw;\n            \n        while ( \n            voters[to].delegate != address(0)&&\n            voters[to].delegate != msg.sender\n        ){\n            to = voters[to].delegate;\n        }\n        \n        if (to == msg.sender)\n            throw;\n            \n        sender.voted = true;\n        sender.delegate = to;\n        Voter delegate = voters[to];\n        if  (delegate.voted) {\n            proposals[delegate.vote].voteCount += sender.weight;\n        }else {\n            delegate.weight += sender.weight;\n        }\n        \n    }\n    \n    \n    function vote(uint proposal) {\n        Voter sender = voters[msg.sender];\n        if (sender.voted)\n            throw;\n        \n        sender.voted=true;\n        sender.vote=proposal;\n        proposals[proposal].voteCount += sender.weight;\n        \n    }\n    \n    function winningProtocal() returns (uint proposal) \n    {\n        proposal = 0;\n        uint maxCount = 0;\n        for (uint i = 0 ; i < proposals.length ; i++) {\n            if (proposals[i].voteCount > maxCount) {\n                proposal = i;\n                maxCount = proposals[i].voteCount;\n            }\n        }\n        \n        //return proposal;\n    }\n    \n    \n    \n}",1,標準的な投票システムの実装で、実用的なスマートコントラクトです。,
1878197,0x6a3120d8a66fe96eb260cce4b6da02e7835b8426,false,false,"contract chal2sweep {\n    address chal = 0x08d698358b31ca6926e329879db9525504802abf;\n    address noel = 0x1488e30b386903964b2797c97c9a3a678cf28eca;\n\n    // restrict msg.sender\n    modifier only_noel { if (msg.sender == noel) _ }\n    // don't run recursively\n    modifier msg_value_not(uint _amount) {\n        if (msg.value != _amount) _\n    }\n\n    // could use kill() straight-up, but want to test gas on live chain\n    function withdraw(uint _amount) only_noel {\n        if (!noel.send(_amount)) throw;\n    }\n\n    // should allow withdrawal without gas calc\n    function kill() only_noel {\n        suicide(noel);\n    }\n\n    // web3.toWei(10, ""ether"") == ""10000000000000000000""\n    function () msg_value_not(10000000000000000000) {\n        if (!chal.call(""withdrawEtherOrThrow"", 10000000000000000000))\n            throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1878456,0xaf0a3474595815d9eccd52b8307edd81f4828c11,false,false,,,,TOO_SHORT
1878674,0x1a0dc160a432b436516197df69f3bb51fbf1ebae,false,false,,,,TOO_SHORT
1878728,0x7237fb66508a5fe38e152d13d41e2eac07c53627,false,false,,,,TOO_SHORT
1878913,0xd790fc72f301e71446cbc318f0dc5c3817e4f5e5,false,false,,,,TOO_SHORT
1879209,0x7cc5f6285904bfa67b6746c389568ba58848a9a5,false,false,,,,TOO_SHORT
1879473,0xa1c21ab86d339f092a61d42182f9018c12c40041,false,false,,,,TOO_SHORT
1879716,0x80f1f62b8b365c5326100d462d8570771b8d0e57,false,false,"contract DaoChallenge\n{\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	event notifySellToken(uint256 n, address buyer);\n	event notifyRefundToken(uint256 n, address tokenHolder);\n	event notifyTranferToken(uint256 n, address sender, address recipient);\n	event notifyTerminate(uint256 finalBalance);\n\n	/* This creates an array with all balances */\n  mapping (address => uint256) public tokenBalanceOf;\n\n	uint256 constant tokenPrice = 1000000000000000; // 1 finney\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address owner;\n\n	function DaoChallenge () {\n		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () {\n		address sender = msg.sender;\n		uint256 amount = msg.value;\n\n		// No fractional tokens:\n		if (amount % tokenPrice != 0) {\n			throw;\n		}\n		tokenBalanceOf[sender] += amount / tokenPrice;\n		notifySellToken(amount, sender);\n	}\n\n	// This uses call.value()() rather than send(), but only sends to msg.sender\n	function withdrawEtherOrThrow(uint256 amount) private {\n		bool result = msg.sender.call.value(amount)();\n		if (!result) {\n			throw;\n		}\n	}\n\n	function refund() noEther {\n		address sender = msg.sender;\n		uint256 tokenBalance = tokenBalanceOf[sender];\n		if (tokenBalance == 0) { throw; }\n		tokenBalanceOf[sender] = 0;\n		withdrawEtherOrThrow(tokenBalance * tokenPrice);\n		notifyRefundToken(tokenBalance, sender);\n	}\n\n	function transfer(address recipient, uint256 tokens) noEther {\n		address sender = msg.sender;\n\n		if (tokenBalanceOf[sender] < tokens) throw;\n		if (tokenBalanceOf[recipient] + tokens < tokenBalanceOf[recipient]) throw; // Check for overflows\n		tokenBalanceOf[sender] -= tokens;\n		tokenBalanceOf[recipient] += tokens;\n		notifyTranferToken(tokens, sender, recipient);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyOwner {\n		notifyTerminate(this.balance);\n		suicide(owner);\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1879721,0xa1fe640a31c1c4662dd3e3c6de5e66e3345b68f6,false,false,,,,TOO_SHORT
1879812,0x98e445d52310b0842ccba0b0b751e11faf55c854,true,false,"contract MultiAsset {\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function owner(bytes32 _symbol) constant returns(address);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract Ambi {\n    function getNodeAddress(bytes32 _name) constant returns (address);\n    function addNode(bytes32 _name, address _addr) external returns (bool);\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\n}\n\ncontract EtherTreasuryInterface {\n    function withdraw(address _to, uint _value) returns(bool);\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract Asset is Safe, AmbiEnabled {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) noValue() returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return __transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        return __transferWithReference(_to, _value, _reference);\n    }\n\n    function __transferWithReference(address _to, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) :\n            multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference);\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) :\n            multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference);\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference);\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function __transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function approve(address _spender, uint _value) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyApprove(_spender, _value, symbol);\n    }\n\n    function setCosignerAddress(address _cosigner) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxySetCosignerAddress(_cosigner, symbol);\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() noValue() returns(bool) {\n        address owner = multiAsset.owner(symbol);\n        uint balance = this.balance;\n        bool success = true;\n        if (balance > 0) {\n            success = _unsafeSend(owner, balance);\n        }\n        return multiAsset.transfer(owner, balanceOf(owner), symbol) && success;\n    }\n}\n\ncontract OpenDollar is Asset {\n    uint public txGasPriceLimit = 21000000000;\n    uint public refundGas = 40000;\n    uint public transferCallGas = 21000;\n    uint public transferWithReferenceCallGas = 21000;\n    uint public transferFromCallGas = 21000;\n    uint public transferFromWithReferenceCallGas = 21000;\n    uint public transferToICAPCallGas = 21000;\n    uint public transferToICAPWithReferenceCallGas = 21000;\n    uint public transferFromToICAPCallGas = 21000;\n    uint public transferFromToICAPWithReferenceCallGas = 21000;\n    uint public approveCallGas = 21000;\n    uint public forwardCallGas = 21000;\n    uint public setCosignerCallGas = 21000;\n    EtherTreasuryInterface public treasury;\n    mapping(bytes32 => address) public allowedForwards;\n\n    function updateRefundGas() noValue() checkAccess(""setup"") returns(uint) {\n        uint startGas = msg.gas;\n        // just to simulate calculations\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\n        if (tx.gasprice > txGasPriceLimit) {\n            return 0;\n        }\n        // end.\n        if (!_refund(1)) {\n            return 0;\n        }\n        refundGas = startGas - msg.gas;\n        return refundGas;\n    }\n\n    function setOperationsCallGas\n        (\n            uint _transfer,\n            uint _transferFrom,\n            uint _transferToICAP,\n            uint _transferFromToICAP,\n            uint _transferWithReference,\n            uint _transferFromWithReference,\n            uint _transferToICAPWithReference,\n            uint _transferFromToICAPWithReference,\n            uint _approve,\n            uint _forward,\n            uint _setCosigner\n        ) noValue() checkAccess(""setup"") returns(bool)\n    {\n        transferCallGas = _transfer;\n        transferFromCallGas = _transferFrom;\n        transferToICAPCallGas = _transferToICAP;\n        transferFromToICAPCallGas = _transferFromToICAP;\n        transferWithReferenceCallGas = _transferWithReference;\n        transferFromWithReferenceCallGas = _transferFromWithReference;\n        transferToICAPWithReferenceCallGas = _transferToICAPWithReference;\n        transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference;\n        approveCallGas = _approve;\n        forwardCallGas = _forward;\n        setCosignerCallGas = _setCosigner;\n        return true;\n    }\n\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(""admin"") returns(bool) {\n        if (_txGasPriceLimit == 0) {\n            return false;\n        }\n        treasury = EtherTreasuryInterface(_treasury);\n        txGasPriceLimit = _txGasPriceLimit;\n        if (msg.value > 0) {\n            _safeSend(_treasury, msg.value);\n        }\n        return true;\n    }\n\n    function setForward(bytes4 _msgSig, address _forward) noValue() checkAccess(""admin"") returns(bool) {\n        allowedForwards[sha3(_msgSig)] = _forward;\n        return true;\n    }\n\n    function _stringGas(string _string) constant internal returns(uint) {\n        return bytes(_string).length * 75; // ~75 gas per byte, empirical shown 68-72.\n    }\n\n    function _applyRefund(uint _startGas) internal returns(bool) {\n        if (tx.gasprice > txGasPriceLimit) {\n            return false;\n        }\n        uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice;\n        return _refund(refund);\n    }\n\n    function _refund(uint _value) internal returns(bool) {\n        return treasury.withdraw(tx.origin, _value);\n    }\n\n    function _transfer(address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferCallGas;\n        if (!super.transfer(_to, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromCallGas;\n        if (!super.transferFrom(_from, _to, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPCallGas;\n        if (!super.transferToICAP(_icap, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPCallGas;\n        if (!super.transferFromToICAP(_from, _icap, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferWithReference(_to, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferFromWithReference(_from, _to, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferToICAPWithReference(_icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _approve(address _spender, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + approveCallGas;\n        if (!super.approve(_spender, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _setCosignerAddress(address _cosigner) internal returns(bool, bool) {\n        uint startGas = msg.gas + setCosignerCallGas;\n        if (!super.setCosignerAddress(_cosigner)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transfer(_to, _value);\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFrom(_from, _to, _value);\n        return success;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferToICAP(_icap, _value);\n        return success;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAP(_from, _icap, _value);\n        return success;\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferWithReference(_to, _value, _reference);\n        return success;\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromWithReference(_from, _to, _value, _reference);\n        return success;\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferToICAPWithReference(_icap, _value, _reference);\n        return success;\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n        return success;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        bool success;\n        (success,) = _approve(_spender, _value);\n        return success;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        bool success;\n        (success,) = _setCosignerAddress(_cosigner);\n        return success;\n    }\n\n    function checkTransfer(address _to, uint _value) constant returns(bool, bool) {\n        return _transfer(_to, _value);\n    }\n\n    function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) {\n        return _transferFrom(_from, _to, _value);\n    }\n\n    function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferToICAP(_icap, _value);\n    }\n\n    function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferFromToICAP(_from, _icap, _value);\n    }\n\n    function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferWithReference(_to, _value, _reference);\n    }\n\n    function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function checkApprove(address _spender, uint _value) constant returns(bool, bool) {\n        return _approve(_spender, _value);\n    }\n\n    function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) {\n        return _setCosignerAddress(_cosigner);\n    }\n\n    function checkForward(bytes _data) constant returns(bool, bool) {\n        bytes memory sig = new bytes(4);\n        sig[0] = _data[0];\n        sig[1] = _data[1];\n        sig[2] = _data[2];\n        sig[3] = _data[3];\n        return _forward(allowedForwards[sha3(sig)], _data);\n    }\n\n    function _forward(address _to, bytes _data) internal returns(bool, bool) {\n        uint startGas = msg.gas + forwardCallGas + (_data.length * 50); // 50 gas per byte;\n        if (_to == 0x0) {\n            return (false, _safeFalse());\n        }\n        if (!_to.call.value(msg.value)(_data)) {\n            return (false, _safeFalse());\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function () returns(bool) {\n        bool success;\n        (success,) = _forward(allowedForwards[sha3(msg.sig)], msg.data);\n        return success;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1879879,0x4238b17f86446db9a3bbde74f3a23e539e10a1a5,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1879903,0x47a2f68816a6fb8de7dad3614050805651f8a39c,false,false,,,,TOO_SHORT
1879908,0xc86e7c69a53582537cc52c4dfdeaeae27a84d7c5,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1879917,0xd188147d80b6b7cf7e42655fe63fb46def12ce72,false,false,,,,TOO_SHORT
1879919,0xc4b2c66cbaa46fc0ea99caf8e2801b9922ee8327,false,false,,,,TOO_SHORT
1879982,0x3c53754f54d3cc80f5a3530a59eee1482fe5e52d,false,false,,,,TOO_SHORT
1880040,0x3836d6f355cf3eac39515347172fed6b94a59248,false,false,,,,TOO_SHORT
1880468,0xfd6722fbccc92f9a5cc4b1588a9ecd495d4f85be,false,false,,,,TOO_SHORT
1880608,0x579813f55bffd4399bd8eb85ac5d67db5c8927d9,false,false,,,,TOO_SHORT
1880869,0xfcfadd0e071061dc8b153cf9b0c4da06343e1079,false,false,,,,TOO_SHORT
1880985,0xfe4fa55500bf397ef429021455c6a95f65a01b3c,false,false,,,,0xb8869c5f264739dde064941c372c551ec47aab44
1881668,0x1e59bb3bcf50b0e16d51d47b616a2629979fbc96,false,false,,,,TOO_SHORT
1882213,0x2cad5c0ca01137f5012520398a5f1c740f7d9020,false,false,,,,TOO_SHORT
1882490,0x8d11741cc379f6b50a500982e4feb885d3d6f8b3,false,false,,,,TOO_SHORT
1882616,0xb5f94312db1703969059e240ea8ed615cce639d4,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1882652,0x156cf556f589308f6baf956409b72f689cff5446,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1882843,0x624c07a6248013f72cf0fae0833bf5553c2056e6,false,false,,,,TOO_SHORT
1882967,0x408b8fbc19bb5ffff7d5e5c430f765524fae77c5,false,false,"contract DAO {\n    function balanceOf(address addr) returns (uint);\n    function transferFrom(address from, address to, uint balance) returns (bool);\n    uint public totalSupply;\n}\n\ncontract WithdrawDAO {\n    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);\n    address public trustee = 0xcdf7D2D0BdF3511FFf511C62f3C218CF98A136eB; // to be replaced by a multisig\n\n    function withdraw(){\n        uint balance = mainDAO.balanceOf(msg.sender);\n\n        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))\n            throw;\n    }\n\n    function trusteeWithdraw() {\n        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1883093,0x3bba851537e2b387b58835c8a68be96f6401ce95,false,false,,,,0x408b8fbc19bb5ffff7d5e5c430f765524fae77c5
1883143,0x77dac55fc1ce1b87d214fa13d08fb7d5027c67d7,false,false,,,,TOO_SHORT
1883155,0x4d58f47c2d1985f146553994ad327567c5b074b8,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1883227,0x498aaea441af871de5e65848a31ce57385dea597,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"",""BKniCJx8z96RVCJ9FCMlku5t4lEAbCqQS2jF1W41eQLA10mPNC4RYGMkQfWcfvZKlOmpVVhMXiwa6a9ledKfelRiupoMeJxLo2mMapQpo9FY319mSyxFCm9YvW7iNy6Sy+tFDFWWRpTUKqm95GKj93us6eBMACXICmGk8ppy5AA7mmE//xYXnWrniVWtFSuizOy5SO5c4jC8Y9GHNoyBMUHHpbLEHbnzp5NcXEj8VUWvycqA1s24CFDaC4avZsENX8ruVtDKQfuHG2l/vZLY2p6RPaFOYVS6xMQiJ3qS/U0="", ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。Oraclizeを利用した実用的な機能が中心。,
1883264,0xae74565a5c106f3b2fd41195968af834b21a9824,false,false,,,,0x0e403445f183c3b9c8dbad397459d8ce0d0338e4
1883371,0x09d4b4014db27ddfbc73393af4f0a8f444e539ea,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"",""BK+rmSbo3sio5tjcOIXtPF0iYT1uQQcQpwf5JF9DKv/MpFNt35msnfl+AhZEHxYlZ0/p6s87HG10jRoS0coGTzMOBtpbB5iYU6i7mD7St0QvcCXkUvS7apB5O4eQFAkWwGTgEz1RJ9tbSkXilpgurZ+B+ig9s4g+kwPdsKuWx3+1KVDgNlK8a8DG7KfnIp1QZlDGfZ6wge39cY3BXkFXeoO3ZvUSbBAtyG8f36wx6rwhogQBeBQF6a9HHHlj9AFMj7D2nbf24aMfLyhWri7LIQitVHRs976j8F3T7RHp0gc="", ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1883382,0xff01a359c6f762a2b66dfb7d014f4aea3b76e5d8,false,false,,,,TOO_SHORT
1883414,0x60aa80fe41b43c180870a137c7a87334e5c3cb5d,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"",""BDuFfch3GDcmDNoW5Oa6s9VxBG9ZewOoQdP6NLoFPp3hmXhJYXYd/Q/1vipAWIXTkLixowgJrrUvQiFjpFKG5cFdmCXJfM40G9hlAP/O4OfIYKnrHLJ6osW22N1Re1YyJeBYGyBNK5oJ/DLRSMToR490oJODPJkvwMa8wA60EBJHrYwP+Pg6MwnQleekgOe2KyDitAgRJ07W68TTRLFXsrhFDcUiWeMGY+ATYdWCewIQbgdBxGnSF4MG/Lz4vNCYLex37poEqHX6OFdnRXlwgGBKfrka0zkketZsji5IhE8="", ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1883440,0xee9147dd0307e4a663d0f756549d47d6f8bd356b,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"",""BPuA31wfg7jUF88kTj1mY3x5imTGoT05PWA/XE9NeR7mc7KnK6Iu3/PLXkvATCixA7IMCbQ1I5PZzlIjW3iM2rVriza6xG81zD6msS35JSJUZgk+uj6VPgeIfqtSefkG8ncgFgaRDYaL0VNWZURL3pNHQUdkbsajl0yF0RvmyWMytacmms/Sbw7jqwHOcfMq5/xk/S5j65cCiS91maJr5AUJro/Pikgj2YmX8mCp+Yfcsi8+XW9QNYOUJ2mHx3HQ0KuldWeUpRYoaY2LHW3TaKzPWXqAdxtHRVllww8Sw4M="", ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1883496,0xbf4ed7b27f1d666546e30d74d50d173d20bca754,false,false,"contract DAO {\n    function balanceOf(address addr) returns (uint);\n    function transferFrom(address from, address to, uint balance) returns (bool);\n    uint public totalSupply;\n}\n\ncontract WithdrawDAO {\n    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);\n    address public trustee = 0xda4a4626d3e16e094de3225a751aab7128e96526;\n\n    function withdraw(){\n        uint balance = mainDAO.balanceOf(msg.sender);\n\n        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))\n            throw;\n    }\n\n    function trusteeWithdraw() {\n        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1883529,0xef5ee58d50f36f2b34d87c35a9972ea4a73426f3,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"",""BAPEuLxzvUJueO2hndOSpsWkzDbrACq3267djzJW/h2WsmLlxPfdo5LS/tjmHe+Hb3NZUjSh0R3ZAUhWQTG4dYTgAD/wm5gpcFa1jounUoox9uRA5Ctu96VxZbyTbSNDSuHU4IqNe4MzlWRaKUCNuSXCdSH6HvsUF4v8d+jQJ6Mz/SiNBuEI0xQNpm4eiiTvfS1zhdNZGluAIm19Xw62gB6mQsoAonDIH4G6QVrPl+oXK9iHiJrW/sWC1/FsshfQ2pF1jfOTld2Yt1OkxKrurG20HIREwmOQBoEQQjKOpe4="", ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1883585,0x4e8703a59fec01a97d4d2d76271e4f086dbb52fc,false,false,"// This software is a subject to Ambisafe License Agreement.\n// No use or distribution is allowed without written permission from Ambisafe.\n// https://ambisafe.com/terms.pdf\n\ncontract EventsHistory {\n    function versions(address) constant returns(uint);\n}\n\n/**\n * @title MultiAsset Emitter.\n *\n * Contains all the original event emitting function definitions and events.\n * In case of new events needed later, additional emitters can be developed.\n * All the functions is meant to be called using delegatecall.\n */\nlibrary MultiAssetEmitter {\n    event Transfer(address indexed from, address indexed to, bytes32 indexed symbol, uint value, string reference, uint version);\n    event Issue(bytes32 indexed symbol, uint value, address by, uint version);\n    event Revoke(bytes32 indexed symbol, uint value, address by, uint version);\n    event OwnershipChange(address indexed from, address indexed to, bytes32 indexed symbol, uint version);\n    event Approve(address indexed from, address indexed spender, bytes32 indexed symbol, uint value, uint version);\n    event Recovery(address indexed from, address indexed to, address by, uint version);\n    event TransferToICAP(address indexed from, address indexed to, bytes32 indexed icap, uint value, string reference, uint version);\n    event Error(bytes32 message, uint version);\n    \n    function emitTransfer(address _from, address _to, bytes32 _symbol, uint _value, string _reference) {\n        Transfer(_from, _to, _symbol, _value, _reference, _getVersion());\n    }\n\n    function emitIssue(bytes32 _symbol, uint _value, address _by) {\n        Issue(_symbol, _value, _by, _getVersion());\n    }\n\n    function emitRevoke(bytes32 _symbol, uint _value, address _by) {\n        Revoke(_symbol, _value, _by, _getVersion());\n    }\n\n    function emitOwnershipChange(address _from, address _to, bytes32 _symbol) {\n        OwnershipChange(_from, _to, _symbol, _getVersion());\n    }\n\n    function emitApprove(address _from, address _spender, bytes32 _symbol, uint _value) {\n        Approve(_from, _spender, _symbol, _value, _getVersion());\n    }\n\n    function emitRecovery(address _from, address _to, address _by) {\n        Recovery(_from, _to, _by, _getVersion());\n    }\n\n    function emitTransferToICAP(address _from, address _to, bytes32 _icap, uint _value, string _reference) {\n        TransferToICAP(_from, _to, _icap, _value, _reference, _getVersion());\n    }\n\n    function emitError(bytes32 _message) {\n        Error(_message, _getVersion());\n    }\n\n    /**\n     * Get version number of the caller.\n     *\n     * Assuming that the call is made by EventsHistory using delegate call,\n     * context was not changed, so the caller is the address that called\n     * EventsHistory.\n     *\n     * @return current context caller version number.\n     */\n    function _getVersion() constant internal returns(uint) {\n        return EventsHistory(address(this)).versions(msg.sender);\n    }\n}",1,イベント管理のための実用的なライブラリで、特に芸術的な要素はありません。,
1883771,0x78f6a1d4b94d2e6c4ce3c5cc858b9dfb6e98b50f,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"",""BPwAkLB04N2SS7xdbypA3lBJIAGzWtjPHFag/rIv9ki0zldEjuBbjirZlDAJhqoTq9qHASoAmkFcEhSYrQ+oICxfg+q/DzZIWK9mfdxi6nq8OpP9fvcahq0iGirEOHZYqUAcAH2iqzUoklowA6DKBwC9jH58lDUm3WsQSbnj2EHSvbdfqvVGdozBGsrtk6F/H5FIIf4b91ydLdh9rfdthu9iANL5KZmpRhFBD49y2xmFI5tum0KUiZR+HHEZ/5ihOCIyNjp5p4N1wiqhtRH4cygyVARcm+W4flSdz1JDNYU="", ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1883812,0xaae10c1223df062e2df6982a80621977fa8b2d34,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n                delete investorsProfit;\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"",""BDHJtabQ1ZOTn7ru7NwtVZEVKMS3XC58L3kS7WAcW1yfJU7uPfq4hp5N9Uvj9ZAhYl3qfyyUWHiPng8PLAAZhMqp24mUifAbScZZQyJWST4NcHSOtZf9yK6pQKo+cLzRZrC+YlB5VRSgPOGFTJXA16GRfAbmKEAE6BcD+ELIPTOgHZKfT/WQuDxB8N0vrtmDK1RddlxIE5OKlruRL6L2EaV0c77K7Xtr326wr/epJefuJBy0p90/SDCwWHzRwsNaFO1hq9vAHGik655GX6fl0O157w3P9z7BaxqiGOQH5V0="", ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1883895,0xb328b9db206262b62f8291685bfe52b5dadbf1f4,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1883908,0xb27bdddd8722fd1440c11658f87fe9a28c4edcdd,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1883942,0xea69635d9303fea1bad007d771d808a2c11c9deb,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1883944,0x1f43e710565778a09d8f20966fccb4bb16f6df56,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1883949,0x60d7162c7f0cf6580050b34c078d62649873e891,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1883953,0x9b26465c99ffd2ff7653756d4f4d74aba63d1104,false,false,,,,TOO_SHORT
1883981,0x1e84ccd76be062ca7518034c699875d0acb5dff0,false,false,,,,TOO_SHORT
1884023,0x5643cb9b526ead9b113aba1f112716998c975313,false,false,,,,TOO_SHORT
1884232,0xe60bac601f743b5adf16f63672837dccbfbafa0a,false,false,,,,TOO_SHORT
1884322,0x4bd4afa9b213b5184c995aaef4982ce564121d20,false,false,"contract Destination {\n    function recover(address _from, address _to) returns(bool);\n}\n\ncontract RecoveryWithTenant {\n    event Recovery(uint indexed nonce, address indexed from, address indexed to);\n    event Setup(uint indexed nonce, address indexed user);\n    \n    //1: user not existing\n    //2: conflict, user exists already\n    //3: signature not by tenant\n    //4: nonce/signature used before\n    //5: contract call failed\n    //6: oracle access denied\n    //8: requested user not found\n    event Error(uint indexed nonce, uint code);\n    \n    struct User {\n        address addr;\n    }\n    \n    mapping (address => uint) userIndex;\n    User[] public users;\n\n    address public oracle;\n    address public tenant;\n    mapping(uint => bool) nonceUsed;\n    address public callDestination;\n\n\n    modifier onlyOracle() {\n        if (msg.sender == oracle) {\n            _\n        }\n        Error(0, 6);\n    }\n    \n    modifier noEther() {\n        if (msg.value > 0) throw;\n        _\n    }\n\n    function RecoveryWithTenant() {\n        oracle = msg.sender;\n        tenant = msg.sender;\n        users.length++;\n    }\n    \n    //############# INTERNAL FUNCTIONS\n    \n    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {\n        address recovered = ecrecover(_hash, _v, _r, _s);\n\n        if (tenant != recovered) {\n            Error(_nonce, 3);\n            return false;\n        }\n        if (nonceUsed[_nonce]) {\n            Error(_nonce, 4);\n            return false;\n        }\n        nonceUsed[_nonce] = true; \n        return true;\n    }\n    \n    \n    //############# PUBLIC FUNCTIONS\n    \n    function setOracle(address _newOracle) noEther onlyOracle {\n        oracle = _newOracle;\n    }\n    \n    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        if(tenant != oracle && !_checkSigned(sha3(_tenant, _callDestination, _nonce), _nonce, _v, _r, _s))\n            return false;\n        tenant = _tenant;\n        callDestination = _callDestination;\n        return true;\n    }\n    \n    \n    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        if(userIndex[_userAddr] > 0) {\n            Error(_nonce, 2);\n            return false;\n        }\n        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))\n            return false;\n        uint posUser = users.length++;\n        userIndex[_userAddr] = posUser;\n        users[posUser] = User(_userAddr);\n        Setup(_nonce, _userAddr);\n        return true;\n    }\n    \n    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        uint userPos = userIndex[_oldAddr];\n        if (userPos == 0) {\n            Error(_nonce, 1); //user doesn't exsit\n            return false;\n        }\n        \n        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))\n            return false;\n        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);\n        if (result) {\n            users[userPos].addr = _newAddr;\n            Recovery(_nonce, _oldAddr, _newAddr);\n            return true;\n        }\n        Error(_nonce, 5);\n        return false;\n    }\n\n    function () noEther {\n        throw;\n    }\n    \n    //############# STATIC FUNCTIONS\n    \n    function isUser(address _userAddr) constant returns (bool) {\n        return (userIndex[_userAddr] > 0);\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1884387,0x37f5ee4ed2a1f4fd74a7d63a03d2d461523a65cd,false,false,,,,TOO_SHORT
1884580,0x962a2836beb3696ca7b0fae13c375c08e5ae4af9,false,false,,,,TOO_SHORT
1884660,0x42ad57256b8fe0a5482390fcd9063ae889258f04,false,false,,,,TOO_SHORT
1884671,0x5241e7d09ef78580419ef4df2a6b299516311413,false,false,,,,TOO_SHORT
1884788,0xb588630131f3816a94b377fc53bfd6ac8ee14ab4,false,false,,,,TOO_SHORT
1885025,0x2e279d94c88d4b6243727029be8b7b8c5d9de0cf,false,false,,,,TOO_SHORT
1885026,0x7f6d11c426eefaac70bab88e3206d2eb14c79e1f,false,false,,,,TOO_SHORT
1885096,0x37bb7eaea0aef2173590daf7253583a41d6fe0e5,false,false,,,,TOO_SHORT
1885107,0x7211430275020508efe86e8207c478fda6d78b38,false,false,,,,TOO_SHORT
1885342,0x6add7459ba298db15056bb537f73f7174661578d,false,false,,,,TOO_SHORT
1885372,0x68fddf1f2e1b385923c6387980c9d5ca211b7e40,false,false,,,,TOO_SHORT
1885444,0x257f96871302e76287fee5eb373bb19cf75c8757,false,false,,,,TOO_SHORT
1885497,0xdf77c40a422d2f948d0250349ba751bb05d3aa54,false,false,,,,TOO_SHORT
1885498,0x533a879c044cf8b9e5e6e81b0ffd2f3957886e8b,false,false,,,,TOO_SHORT
1885570,0xe807227495822d2f37736941356102695995b45b,false,false,,,,TOO_SHORT
1885642,0x33377a3ef9ebe54b427b4d6c814f27279bf27f22,false,false,,,,TOO_SHORT
1885667,0xb6ce511b13a13f10c3891dafea609a09da500dfb,false,false,,,,TOO_SHORT
1886354,0x6ecdbdfde92bafc52f8076b4761dac530427e4be,false,false,,,,TOO_SHORT
1887045,0x233e912de406a8f137045e12d11b2f33ea6c09cc,false,false,,,,TOO_SHORT
1887129,0x80d3ebb5f0334e5948783af89ec6cb095f005bb8,false,false,,,,TOO_SHORT
1888327,0x2b5b90ed0736d72e5444a19aee75a7416c90e9b3,false,false,,,,TOO_SHORT
1888397,0xedee60eac905c6286b567497187302a7729b5e5f,false,false,,,,TOO_SHORT
1888539,0x7f58f85bd3ed646126a9c5eefbd4c672ffaf2f2b,false,false,,,,TOO_SHORT
1888693,0xebe2cf95907987ddae7a220403d6af700d7931b8,false,false,,,,TOO_SHORT
1888696,0xe40d3ebbd4752cef445f899db04ad39c63e152fc,false,false,,,,TOO_SHORT
1889004,0x803397a3ec30afe0354d882c665eea05b3e1d772,false,false,,,,TOO_SHORT
1889346,0xe2b71c81ea66c959ba4497fe445d8ad61106a7a6,false,false,,,,TOO_SHORT
1889510,0xbfdb714dfd5c572cc8e866b56d906ece1a893c07,false,false,,,,TOO_SHORT
1889813,0x43ac6f90be6c9d1d6cee4bad3dc19b6ffd2198af,false,false,,,,TOO_SHORT
1889866,0xa0b7f1eea74eb22ccfb9cb6befad7ba9d48b17fd,false,false,,,,TOO_SHORT
1889868,0x38ddb419ecbbba83ffdf762ebd0077e27d6c706d,false,false,,,,TOO_SHORT
1889869,0x01141bd76d338a27e4f66f664a9532058de8e430,false,false,,,,TOO_SHORT
1889911,0x402be836017c25bb47880ad53bf6f1cbd949483d,false,false,,,,TOO_SHORT
1889914,0x8626d146cd44db3e2fca58bd2ca08520f55fc19f,false,false,,,,TOO_SHORT
1889951,0xc98c7b13b2577be006b4bf04418a115d43b1489e,false,false,"/*\n	WeeklyLotteryB\n	Coded by: iFA\n	http://wlb.ethereumlottery.net\n	ver: 1.0\n*/\n\ncontract WLBdrawsDBInterface {\n	function newDraw(uint date, uint8[3] numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value);\n	function getDraw(uint id) constant returns (uint date, uint8[3] numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value);\n}\n\ncontract WeeklyLotteryB {\n	/* structures */\n	struct games_s {\n		uint ticketsCount;\n		mapping(bytes32 => uint) hit3Hash;\n		mapping(bytes32 => uint) hit2Hash;\n		uint startTimestamp;\n		uint endTimestamp;\n		bytes3 winningNumbersBytes;\n		uint prepareBlock;\n		bool drawDone;\n		uint prizePot;\n		uint paidPot;\n		uint hit3Count;\n		uint hit3Value;\n		uint hit2Count;\n		uint hit2Value;\n	}\n	struct playerGames_s {\n		bytes3[] numbersBytes;\n		mapping(bytes32 => uint) hit3Hash;\n		mapping(bytes32 => uint) hit2Hash;\n		bool checked;\n	}\n	struct players_s {\n		mapping(uint => playerGames_s) games;\n	}\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint begins;\n	}\n	struct draws_s {\n		uint date;\n		uint gameID;\n		bytes3 numbersBytes;\n		uint hit3Count;\n		uint hit3Value;\n		uint hit2Count;\n		uint hit2Value;\n	}\n	/* config */\n	uint public constant ticketPrice = 100 finney; // 0.1 ether\n	uint private constant drawMaxNumber = 50;\n	uint private constant drawBlockDelay = 5;\n	uint private constant prizeDismissDelay = 5;\n	uint private constant contractDismissDelay = 5 weeks;\n	uint private constant investUnit = 1 ether;\n	uint private constant investMinimum = 10 ether;\n	uint private constant investUserLimit = 200;\n	uint private constant investMinDuration = 5; // 5 draw!\n	uint private constant investIdleTime = 1 days;\n	uint private constant forOwner = 2; //%\n	uint private constant forInvestors = 40; //%\n	uint private constant forHit2 = 30; //%\n	/* variables */\n	address private WLBdrawsDB;\n	address private owner;\n	uint private currentJackpot;\n	uint private investmentsValue;\n	uint private extraJackpot;\n	uint private ticketCounter;\n	uint private currentGame;\n	uint private ownerBalance;\n	bool public contractEnabled = true;\n	uint private contractDisabledTimeStamp;\n	mapping(address => players_s) private players;\n	games_s[] private games;\n	investors_s[] private investors;\n	/* events */\n	event NewTicketEvent(address Player, uint8 Number1, uint8 Number2, uint8 Number3);\n	event ContractDisabledEvent(uint DeadlineTime);\n	event DrawPrepareEvent(uint BlockNumber);\n	event DrawEvent(uint GameID, uint8 Number1, uint8 Number2, uint8 Number3, uint Hit3Count, uint Hit3Value, uint Hit2Count, uint Hit2Value);\n	event InvestAddEvent(address Investor, uint Value);\n	event InvestCancelEvent(address Investor, uint Value);\n	/* constructor */\n	function WeeklyLotteryB(address _WLBdrawsDB) {\n		WLBdrawsDB = _WLBdrawsDB;\n		owner = msg.sender;\n		currentGame = 1;\n		games.length = 2;\n		games[1].startTimestamp = now;\n		games[1].endTimestamp = calcNextDrawTime();\n	}\n	/* constant functions */\n	function Visit() constant returns (string) { return ""http://wlb.ethereumlottery.net""; }\n	function Draws(uint id) constant returns (uint date, uint8[3] Numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value) {\n		return WLBdrawsDBInterface( WLBdrawsDB ).getDraw(id);\n	}\n	function CurrentGame() constant returns (uint GameID, uint Jackpot, uint Start, uint End, uint Tickets) {\n		return (currentGame, currentJackpot, games[currentGame].startTimestamp, games[currentGame].endTimestamp, games[currentGame].ticketsCount);\n	}\n	function PlayerTickets(address Player, uint GameID, uint TicketID) constant returns (uint8[3] numbers, bool Checked) {\n		return ( getNumbersFromBytes( players[Player].games[GameID].numbersBytes[TicketID] ), players[Player].games[GameID].checked);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		var (found, InvestorID) = getInvestorByAddress(Address);\n		if (found == false || ! investors[InvestorID].valid) {\n			return (0, 0, false);\n		}\n		return (investors[InvestorID].value, investors[InvestorID].balance, investors[InvestorID].live);\n	}\n	/* callback function */\n	function () {\n		var Numbers = getNumbersFromHash(sha3(block.coinbase, now, ticketCounter));\n		BuyTicket(Numbers[0],Numbers[1],Numbers[2]);\n	}\n	/* external functions for players */\n	function BuyTicket(uint8 Number1, uint8 Number2, uint8 Number3) noContract OnlyEnabled {\n		var Numbers = [Number1 , Number2 , Number3];\n		if ( ! checkNumbers( Numbers )) { throw; }\n		Numbers = sortNumbers(Numbers);\n		if (msg.value < ticketPrice) { throw; }\n		if (msg.value-ticketPrice > 0) { if ( ! msg.sender.send( msg.value-ticketPrice )) { throw; } }\n		if (currentJackpot == 0) { throw; }\n		if (games[currentGame].endTimestamp < now) { throw; }\n		ticketCounter++;\n		games[currentGame].ticketsCount++;\n		bytes32 hash0 = sha3( Numbers[0], Numbers[1], Numbers[2] );\n		bytes32 hash1 = sha3( Numbers[0], Numbers[1]);\n		bytes32 hash2 = sha3( Numbers[0], Numbers[2]);\n		bytes32 hash3 = sha3( Numbers[1], Numbers[2]);\n		games[currentGame].hit3Hash[hash0]++;\n		games[currentGame].hit2Hash[hash1]++;\n		games[currentGame].hit2Hash[hash2]++;\n		games[currentGame].hit2Hash[hash3]++;\n		players[msg.sender].games[currentGame].numbersBytes.push ( getBytesFromNumbers(Numbers) );\n		players[msg.sender].games[currentGame].hit3Hash[hash0]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash1]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash2]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash3]++;\n		NewTicketEvent( msg.sender, Numbers[0], Numbers[1], Numbers[2] );\n	}\n	function CheckTickets() external noEther noContract {\n		uint _value;\n		uint gameID;\n		uint gameLowID;\n		uint8[3] memory numbers;\n		bool ok;\n		uint hit3Count;\n		uint hit2Count;\n		if (currentGame < prizeDismissDelay) {\n			gameLowID = 1;\n		} else {\n			gameLowID = currentGame-prizeDismissDelay;\n		}\n		for ( gameID=currentGame ; gameID>=gameLowID ; gameID-- ) {\n			if ( ! players[msg.sender].games[gameID].checked) {\n				if (games[gameID].drawDone) {\n					numbers = getNumbersFromBytes(games[gameID].winningNumbersBytes);\n					hit3Count = players[msg.sender].games[gameID].hit3Hash[sha3( numbers[0], numbers[1], numbers[2] )];\n					_value += hit3Count * games[gameID].hit3Value;\n					hit2Count = players[msg.sender].games[gameID].hit2Hash[sha3( numbers[0], numbers[1] )];\n					hit2Count += players[msg.sender].games[gameID].hit2Hash[sha3( numbers[0], numbers[2] )];\n					hit2Count += players[msg.sender].games[gameID].hit2Hash[sha3( numbers[1], numbers[2] )];\n					hit2Count -= hit3Count*3;\n					_value += hit2Count * games[gameID].hit2Value;\n					players[msg.sender].games[gameID].checked = true;\n					ok = true;\n				} else if ( ! contractEnabled && gameID == currentGame) {\n					_value += players[msg.sender].games[gameID].numbersBytes.length * ticketPrice;\n					players[msg.sender].games[gameID].checked = true;\n					ok = true;\n				}\n			}\n		}\n		if ( ! ok) { throw; }\n		if (_value > 0) { if ( ! msg.sender.send(_value)) { throw; } }\n	}\n	/* external functions for investors */\n	function InvestAdd() external OnlyEnabled noContract {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send( value_ % investUnit )) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		if (value_ < investMinimum) { throw; }\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) {\n			if (investors.length == investUserLimit) { throw; }\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].begins = currentGame;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		investmentsValue += value_;\n		setJackpot();\n		InvestAddEvent(msg.sender, value_);\n	}\n	function InvestWithdraw() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		uint _balance = investors[InvestorID].balance;\n		if (_balance == 0) { throw; }\n		investors[InvestorID].balance = 0;\n		if ( ! msg.sender.send( _balance )) { throw; }\n	}\n	function InvestCancel() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (contractEnabled) {\n			if (investors[InvestorID].begins+investMinDuration > now) { throw; }\n			if (games[currentGame].startTimestamp+investIdleTime > now) { throw; }\n		}\n		uint balance_;\n		if (investors[InvestorID].live) {\n			investmentsValue -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n			InvestCancelEvent(msg.sender, investors[InvestorID].value);\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		delete investors[InvestorID];\n		if ( ! msg.sender.send( balance_ )) { throw; }\n	}\n	/* draw functions for everyone*/\n	function DrawPrepare() noContract OnlyEnabled noEther {\n		if (games[currentGame].endTimestamp > now || games[currentGame].prepareBlock != 0) { throw; }\n		games[currentGame].prepareBlock = block.number+drawBlockDelay;\n		DrawPrepareEvent(games[currentGame].prepareBlock);\n	}\n	function Draw() noContract OnlyEnabled noEther {\n		if (games[currentGame].prepareBlock == 0 || games[currentGame].prepareBlock > block.number) { throw; }\n		bytes32 _hash;\n		uint hit3Value;\n		uint hit3Count;\n		uint hit2Value;\n		uint hit2Count;\n		uint a;\n		for ( a = 1 ; a <= drawBlockDelay ; a++ ) {\n			_hash = sha3(_hash, block.blockhash(games[currentGame].prepareBlock - drawBlockDelay+a));\n		}\n		var numbers = getNumbersFromHash(_hash);\n		games[currentGame].winningNumbersBytes = getBytesFromNumbers( numbers );\n		hit3Count += games[currentGame].hit3Hash[ sha3( numbers[0], numbers[1],numbers[2] ) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[0], numbers[1]) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[0], numbers[2]) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[1], numbers[2]) ];\n		hit2Count -= hit3Count*3;\n		uint totalPot = games[currentGame].ticketsCount*ticketPrice;\n		hit2Value = ( totalPot * forHit2 / 100 );\n		games[currentGame].prizePot = hit2Value;\n		hit2Value = hit2Value / hit2Count;\n		totalPot -= hit2Value;\n		uint _ownerBalance = totalPot * forHit2 / 100;\n		totalPot -= _ownerBalance;\n		ownerBalance += _ownerBalance;\n		uint _addInvestorsValue = totalPot * forInvestors / 100;\n		addInvestorsValue(_addInvestorsValue);\n		totalPot -= _addInvestorsValue;\n		if (hit3Count > 0) {\n			games[currentGame].prizePot += currentJackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				delete investors[a].live;\n			}\n			hit3Value = currentJackpot / hit3Count;\n			extraJackpot = 0;\n			investmentsValue = 0;\n		}\n		extraJackpot += totalPot;\n		setJackpot();\n		DrawEvent(currentGame, numbers[0], numbers[1], numbers[2], hit3Count, hit3Value, hit2Count, hit2Value);\n		WLBdrawsDBInterface( WLBdrawsDB ).newDraw( now, numbers, hit3Count, hit3Value, hit2Count, hit2Value);\n		games[currentGame].hit3Count = hit3Count;\n		games[currentGame].hit3Value = hit3Value;\n		games[currentGame].hit2Count = hit2Count;\n		games[currentGame].hit2Value = hit2Value;\n		games[currentGame].drawDone = true;\n		newGame();\n	}\n	/* owner functions */\n	function OwnerGetFee() external OnlyOwner {\n		if (ownerBalance == 0) { throw; }\n		if (owner.send(ownerBalance) == false) { throw; }\n		ownerBalance = 0;\n	}\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! contractEnabled) {\n			if (contractDisabledTimeStamp+contractDismissDelay < now) {\n				suicide(owner);\n			}\n		} else {\n			contractEnabled = false;\n			contractDisabledTimeStamp = now;\n			ContractDisabledEvent(contractDisabledTimeStamp+contractDismissDelay);\n			ownerBalance += extraJackpot;\n			extraJackpot = 0;\n		}\n	}\n	/* private functions */\n	function addInvestorsValue(uint value) private {\n		bool done;\n		uint a;\n		for ( a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / investmentsValue;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			ownerBalance += value;\n		}\n	}\n	function newGame() private {\n		currentGame++;\n		uint gamesID = games.length;\n		games.length++;\n		games[gamesID].startTimestamp = now;\n		games[gamesID].endTimestamp = calcNextDrawTime();\n		if (games.length > prizeDismissDelay) {\n			ownerBalance += games[currentGame-prizeDismissDelay].prizePot;\n			delete games[currentGame-prizeDismissDelay];\n		}\n	}\n	function getNumbersFromHash(bytes32 hash) private returns (uint8[3] numbers) {\n		bool ok = true;\n		uint8 num = 0;\n		uint hashpos = 0;\n		uint8 a;\n		uint8 b;\n		for (a = 0 ; a < numbers.length ; a++) {\n			while (true) {\n				ok = true;\n				if (hashpos == 32) {\n					hashpos = 0;\n					hash = sha3(hash);\n				}\n				num = getPart( hash, hashpos );\n				num = num % uint8(drawMaxNumber) + 1;\n				hashpos += 1;\n				for (b = 0 ; b < numbers.length ; b++) {\n					if (numbers[b] == num) {\n						ok = false;\n						break; \n					}\n				}\n				if (ok == true) {\n					numbers[a] = num;\n					break;\n				}\n			}\n		}\n		numbers = sortNumbers( numbers );\n	}\n	function getPart(bytes32 a, uint i) private returns (uint8) { return uint8(byte(bytes32(uint(a) * 2 ** (8 * i)))); }\n	function setJackpot() private {\n		currentJackpot = investmentsValue + extraJackpot;\n	}\n	function getInvestorByAddress(address Address) private returns (bool found, uint id) {\n		for ( id=0 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return (true, id);\n			}\n		}\n		return (false, 0);\n	}\n	function checkNumbers(uint8[3] Numbers) private returns (bool) {\n		for ( uint a = 0 ; a < Numbers.length ; a++ ) {\n			if (Numbers[a] > drawMaxNumber || Numbers[a] == 0) { return; }\n			for ( uint b = 0 ; a < Numbers.length ; a++ ) {\n				if (a != b && Numbers[a] == Numbers[b]) { return; }\n			}\n		}\n		return true;\n	}\n	function calcNextDrawTime() private returns (uint ret) {\n		ret = 1468152000;\n		while (ret < now) {\n			ret += 1 weeks;\n		}\n	}\n	function sortNumbers(uint8[3] numbers) private returns(uint8[3] sNumbers) {\n		sNumbers = numbers;\n		for (uint8 i=0; i<numbers.length; i++) {\n			for (uint8 j=i+1; j<numbers.length; j++) {\n				if (sNumbers[i] > sNumbers[j]) {\n					uint8 t = sNumbers[i];\n					sNumbers[i] = sNumbers[j];\n					sNumbers[j] = t;\n				}\n			}\n		}\n	}\n	function getNumbersFromBytes(bytes3 Bytes) private returns (uint8[3] Numbers){\n		Numbers[0] = uint8(Bytes);\n		Numbers[1] = uint8(uint24(Bytes) /256);\n		Numbers[2] = uint8(uint24(Bytes) /256/256);\n	}\n	function getBytesFromNumbers(uint8[3] Numbers) private returns (bytes3 Bytes) {\n		return bytes3(uint(Numbers[0])+uint(Numbers[1])*256+uint(Numbers[2])*256*256);\n	}\n	/* modifiers */\n	modifier noContract() {if (tx.origin != msg.sender) { throw; } _ }\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! contractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1890115,0xfdc844966ed62495b0b6d094078880fefd635375,false,false,,,,TOO_SHORT
1890184,0x99d109765583ffaa8cbc0afe40e22c5e6452c03e,false,false,,,,TOO_SHORT
1890284,0x79499d0f0b3a2a29a93583936c5e46a00e836097,false,false,"contract RandomInterface {\n	function getRandom() returns (bytes32 hash) {}\n}\ncontract ILWinnerDBInterface {\n	function Winners(uint id) constant returns(uint date, address addr, uint value, uint rate, uint bet) {}\n	function newWinner(uint date, address addr, uint value, uint rate, uint bet) external returns (bool) {}\n}\ncontract InstantLottery {\n	/*\n		InstantLottery\n		Coded by: iFA\n		http://il.ethereumlottery.net\n		ver: 3.0.0\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	address private winnersDB;\n	address private randomAddr;\n	uint private constant fee = 5;\n	uint private constant investorFee = 70;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 100;\n	\n	bool public ContractEnabled = true;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private ContractDisabledBlock;\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n		uint id;\n		uint sumInvest;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] private investors;\n	\n	string constant public Information = ""http://il.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function InstantLottery(address _winnersDB, address _randomAddr, bool _oldContract, address _oldContractAddress) {\n		owner = msg.sender;\n		winnersDB = _winnersDB;\n		randomAddr = _randomAddr;\n		if (_oldContract && _oldContractAddress != 0x0) {\n			RollCount = InstantLottery( _oldContractAddress ).RollCount();\n			JackpotHits = InstantLottery( _oldContractAddress ).JackpotHits();\n		}\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n		if (jackpot_ == 0) {\n			Rate = 0;\n			Bet = 0;\n			return;\n		}\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		while (Value < Bet) {\n			Rate++;\n			Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n			Rate = BestRollRate;\n			Bet = getRealBet(Rate);\n		}\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		var (found, InvestorID) = getInvestorByAddress(Address);\n		if (found == false || ! investors[InvestorID].valid) {\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n			return;\n		}\n		Investment = investors[InvestorID].value;\n		Balance = investors[InvestorID].balance;\n		Live = investors[InvestorID].live;\n	}\n	function Winners(uint id) constant returns(uint date, address addr, uint value, uint rate, uint bet) {\n		return ILWinnerDBInterface(winnersDB).Winners(id);\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() external OnlyEnabled noContract {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) {\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].timestamp = now + investMinDuration;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		jackpot_ += value_;\n		setJackpot();\n	}\n	function GetMyInvestmentBalance() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		uint _balance = investors[InvestorID].balance;\n		if (_balance == 0) { throw; }\n		investors[InvestorID].balance = 0;\n		if ( ! msg.sender.send( _balance )) { throw; }\n	}\n	function CancelMyInvestment() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].timestamp > now && ContractEnabled) { throw; }\n		uint balance_;\n		if (investors[InvestorID].live) {\n			jackpot_ -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		delete investors[InvestorID];\n		if ( ! msg.sender.send( balance_ )) { throw; }\n	}\n	/* For Players */\n	function DoRoll() external noEther {\n		uint value_;\n		bool found;\n		bool subFound;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n				subFound = false;\n				if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n					uint feeValue_ = players[msg.sender][a].value/2;\n					feeValue += feeValue_;\n					investorAddFee(players[msg.sender][a].value - feeValue_);\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, false, true, false, false, 0, 0, 0);\n					subFound = true;\n				}\n				if ( ! ContractEnabled || players[msg.sender][a].sumInvest != jackpot_ || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, true, false, false, false, 0, 0, 0);\n					subFound = true;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					subFound = true;\n				}\n				if (subFound) {\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if ( ! found) { throw; }\n		if (value_ > 0) { if ( ! msg.sender.send(value_)) { throw; } }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled noContract {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		var (_rate, _realBet) = ChanceOfWinning(msg.value);\n		if (_realBet > msg.value) { throw; }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! ContractEnabled) {\n			if (ContractDisabledBlock < block.number) {\n				if (playersPot == 0) { throw; }\n				uint _value = playersPot;\n				playersPot = 0;\n				if ( ! msg.sender.send( _value )) { throw; }\n			}\n		} else {\n			ContractEnabled = false;\n			ContractDisabledBlock = block.number+rollLossBlockDelay;\n			ContractDisabled(ContractDisabledBlock);\n			feeValue += extraJackpot_;\n			extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner noEther {\n		if (feeValue == 0) { throw; }\n		uint _value = playersPot;\n		feeValue = 0;\n		if ( ! owner.send(_value)) { throw; }\n	}\n	\n	/*\n		Private functions\n	*/\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber == 0 || _rate == 0) { return; }\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n			ILWinnerDBInterface( winnersDB ).newWinner(now, msg.sender, win, _rate, players[msg.sender][id].value);\n			DoRollEvent(msg.sender, win, players[msg.sender][id].id, false, false, false, true, bigNumber, _rate, bigNumber % _rate);\n		} else {\n			DoRollEvent(msg.sender, players[msg.sender][id].value, players[msg.sender][id].id, false, false, true, false, bigNumber, _rate, bigNumber % _rate);\n		}\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		RollCount++;\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed, RandomInterface(randomAddr).getRandom(), address(seed).balance);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		players[msg.sender][rollID].id = RollCount;\n		players[msg.sender][rollID].sumInvest = jackpot_;	\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, players[msg.sender][rollID].value, players[msg.sender][rollID].id);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1 ether / value * 100 / investorFee * extraRate / 100 / 1 ether;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1 ether / ( rate * 1 ether * investorFee / extraRate);\n	}\n	function getInvestorByAddress(address Address) internal returns (bool found, uint id) {\n		for ( id=0 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return (true, id);\n			}\n		}\n		return (false, 0);\n	}\n	\n	/*\n		Events\n	*/	\n	event DoRollEvent(address Player, uint Value, uint RollID, bool Refund, bool LostBet, bool LossRoll, bool WinRoll, uint BigNumber, uint Rate, uint RollResult);\n	event PrepareRollEvent(address Player, uint Block, uint Bet, uint RollID);\n	event ContractDisabled(uint LossAllBetBlockNumber);\n	\n	/*\n		Modifiers\n	*/\n	modifier noContract() {if (tx.origin != msg.sender) { throw; } _ }\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1890286,0xcb948f345e5375e5e9d64e281645f93685d2a056,false,false,,,,TOO_SHORT
1890459,0x332006af5ecd4b56a1bd41c90482fc36179f96b9,false,false,,,,TOO_SHORT
1890460,0x543d01e587583d2fe4e1661cfeda9fa0bd491a5a,false,false,,,,TOO_SHORT
1890610,0xfd54a7f23af94a5d2f9a6325b16dc6da268d00c2,false,false,,,,TOO_SHORT
1890694,0x7594eae89489b43ca45125f3c61aa00a06cd8423,false,false,,,,TOO_SHORT
1890716,0x8dc1ca7ab695c3ec66400c4fd9d6ec163ea451c4,false,false,,,,TOO_SHORT
1890877,0x9aa6257ef35ffa4a9574eba79bec396a25ff31e8,false,false,,,,TOO_SHORT
1890880,0xebdb404ac01f1cc5ece31d4cad78c5eebd11ac3c,false,false,,,,TOO_SHORT
1892779,0xf78f83039f1bd90bf091da94c824d93eae2bc2e6,false,false,,,,TOO_SHORT
1892907,0xaaeaa0bf2ac2ac4439f0a646ec6f432052cb8990,false,false,,,,TOO_SHORT
1893167,0xac1379b69303ba428bf18467c4d16f48fe0fb990,false,false,,,,TOO_SHORT
1893467,0x7dbb3cfedfb79013b905c43a7e7a93f17dabdfd9,false,false,,,,TOO_SHORT
1893654,0xff67cad68710e3fcda151845125c627d7479c17f,false,false,,,,TOO_SHORT
1893849,0x8e958dab3c80a1eb70ede8adc55aef90e883bf25,false,false,,,,TOO_SHORT
1893928,0x678ae832ec6d54be634844a777e5cb170338901d,false,false,,,,TOO_SHORT
1894012,0x0a29e2110483677814a81f5a3403b238436d6043,false,false,,,,TOO_SHORT
1894332,0x62305375d431643cb842e6d9adfa4b6bf3bff76c,false,false,,,,TOO_SHORT
1894366,0xa80035c7e141a2ccc9c6d7c7b318ed1b31faf721,false,false,,,,TOO_SHORT
1894367,0xc602da4b1cb796e2984c82f2658689f647845855,false,false,,,,TOO_SHORT
1894444,0x114fce449963b3bd5c376505584fe237f1e7afb0,false,false,,,,TOO_SHORT
1894893,0x10afe45b694345fae18c7c297264533f72e4afb8,false,false,,,,TOO_SHORT
1895040,0x32032ff8815f4d6c858cba2fdc63a20b898569af,false,false,,,,TOO_SHORT
1895535,0x2a16032e935bd30006838131cb52f14cced08e17,false,false,,,,TOO_SHORT
1896093,0xd993b3fc69074cc0e1c85d452bab37352504df31,false,false,,,,TOO_SHORT
1896294,0xae6a32d6f0541b2737cb4acae260cd3e0ed8ace9,false,false,,,,TOO_SHORT
1896502,0x59a4ef5dba62f7de17420de85fbb3c997972374b,false,false,,,,TOO_SHORT
1896524,0x49df8d5937f57b5c363c179affeb7f859805cba4,false,false,,,,TOO_SHORT
1896697,0x2086a3508a520d5641273b6811da5a1b7eb4f9ea,false,false,,,,TOO_SHORT
1896831,0xd4b201b54a47e8f7a7321b75a7f51f6b018e15c0,false,false,,,,TOO_SHORT
1897135,0x90d020dc7a984ce9183789d4a044f658ccf490f3,false,false,,,,TOO_SHORT
1897692,0xb5daaf3a1665a48687141dabf3887acb451bee7f,false,false,,,,TOO_SHORT
1897703,0xafda26be0408f8a47110540e0025b3dffae7f7af,false,false,,,,TOO_SHORT
1898673,0x29b10948f28fd219ca3c6781b95b44c2cece3d2e,false,false,,,,TOO_SHORT
1898767,0x00990813acf07238b92f3ff9be8b4cd2670325b4,false,false,,,,TOO_SHORT
1899840,0x876c11d07f7295fbf489bcaee87ab8ec2d9e2c80,false,false,,,,TOO_SHORT
1900365,0x6c901d954fd59747c991b0893f0286e63de4e779,false,false,,,,TOO_SHORT
1900464,0x20afc097e6a3c753ca347d1c84facff5f3b9366a,false,false,,,,TOO_SHORT
1900714,0xc8c6b9d8f93941d0b8f1eb78b5bafd0c1534513f,false,false,,,,TOO_SHORT
1900730,0x3e02c73e7b8bb4427e0f5bae47da955b9ed3f2d4,false,false,,,,TOO_SHORT
1901438,0xff325063ef16a395c1214a71ec2d3300531738dc,false,false,,,,TOO_SHORT
1901712,0xb671c3883307cf05bb3dff77a9754e87b4347195,false,false,contract HFConditionalTransfer {\n    function transferIfHF(address to) {\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance > 1000000 ether)\n            to.send(msg.value);\n        else\n            msg.sender.send(msg.value);\n    }\n    function transferIfNoHF(address to) {\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance <= 1000000 ether)\n            to.send(msg.value);\n        else\n            msg.sender.send(msg.value);\n    }\n},1,実用的な条件付き送金ロジックを持つが、特に芸術的要素はない。,
1901907,0x9928a1e2be5f2bc0a95a3d70fc480340a6a590a0,false,false,,,,TOO_SHORT
1902144,0x0003fba75244fa4812c9636461cef9682b989736,false,false,,,,TOO_SHORT
1902606,0x24db2203440dabf82380a77977fed16a8641212e,false,false,,,,TOO_SHORT
1902778,0x292b04be24490c1033921e3390e401a397dfce12,false,false,,,,TOO_SHORT
1903013,0x651678b95ba2cec634af1b985e17d75eb2db47d5,false,false,,,,TOO_SHORT
1903115,0xe0b8fce1183e31c995b40460e6cb6712fa929f59,false,false,contract AmIOnTheFork {\n    bool public forked = false;\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    // Check the fork condition during creation of the contract.\n    // This function should be called between block 1920000 and 1930000.\n    // After that the status will be locked in.\n    function update() {\n        if (block.number >= 1920000 && block.number <= 1930000) {\n            forked = darkDAO.balance < 3600000 ether;\n        }\n    }\n    function() {\n        throw;\n    }\n},1,実用的なフォーク検出機能を持つ標準的なスマートコントラクト。,
1903165,0x27708674b4b290d069946a12ac71e343a70e9fdc,false,false,,,,TOO_SHORT
1903251,0x7eab824bdbb0982ade9b601de5c483de8ebafb9d,false,false,,,,0xb671c3883307cf05bb3dff77a9754e87b4347195
1903369,0x15cd445e5db007bdfb86cc2eca9e42f96df5b93e,false,false,,,,TOO_SHORT
1903370,0xdd5dc09056d31d0232b00f9ff2fa1d6978e78f64,false,false,,,,TOO_SHORT
1903391,0x3e72548c1535beadcdf084ec13fd7850c49050ed,false,false,"contract testExpensiveFallback {\n    address constant WithdrawDAO = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\n    address constant DarkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    address constant veox = 0x1488e30b386903964b2797c97c9a3a678cf28eca;\n\n    // public, so accessors available\n    bool public ran;\n    bool public forked;\n    bool public notforked;\n    \n    modifier before_dao_hf_block {\n        if (block.number >= 1920000) throw;\n        _\n    }\n    \n    modifier run_once {\n        if (ran) throw;\n        _\n    }\n\n    modifier has_millions(address _addr, uint _millions) {\n        if (_addr.balance >= (_millions * 1000000 ether)) _\n    }\n\n    // 10M ether is ~ 2M less than would be available for a short\n    // while in WithdrawDAO after the HF, but probably more than\n    // anyone is willing to drop into WithdrawDAO in Classic\n    function check_withdrawdao() internal\n        has_millions(WithdrawDAO, 10) {\n        forked = true;\n    }\n\n    // failsafe: if the above assumption is incorrect, HF tine\n    // won't have balance in DarkDAO anyway, and Classic has a\n    // sliver of time before DarkDAO split happens\n    function check_darkdao() internal\n        has_millions(DarkDAO, 3) {\n        notforked = true;\n    }\n\n    function kill1() { suicide(veox); }\n    function kill2() { selfdestruct(veox); }\n    \n    // running is possible only once\n    // after that the dapp can only throw\n    function ()\n        before_dao_hf_block run_once {\n        ran = true;\n\n        check_withdrawdao();\n        check_darkdao();\n\n        // if both flags are same, then something went wrong\n        if (forked == notforked) throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1903469,0x96cd38e789a0d4877ca974bdab045e875a239343,false,false,,,,TOO_SHORT
1903520,0xdcf600f2432cd530fdb31c6a60ab22d7c3e9e087,false,false,,,,TOO_SHORT
1903564,0x1318d6fdde3606103b9b78cf4670427135e7bd7d,false,false,,,,TOO_SHORT
1903570,0x5e9986c53e213556fb8e15a9201dce755d194abf,false,false,,,,TOO_SHORT
1903587,0x62eb1fd495114bc05d34c6ea6c0d3fd1c416bdab,false,false,,,,TOO_SHORT
1903616,0x72ce9cb0220698e6e04beb7093e5c30d2b100861,false,false,,,,TOO_SHORT
1903684,0xe8821f9be7a0f7f20c7358339284a53ef788718b,false,false,,,,TOO_SHORT
1903704,0xe8e506306ddb78ee38c9b0d86c257bd97c2536b3,false,false,"contract TheDAOHardForkOracle {\n    address constant WithdrawDAO = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\n    address constant DarkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n\n    // public, so accessors available\n    bool public ran;\n    bool public forked;\n    bool public notforked;\n    \n    modifier after_dao_hf_block {\n        if (block.number < 1920000) throw;\n        _\n    }\n    \n    modifier run_once {\n        if (ran) throw;\n        _\n    }\n\n    modifier has_millions(address _addr, uint _millions) {\n        if (_addr.balance >= (_millions * 1000000 ether)) _\n    }\n\n    // 10M ether is ~ 2M less than would be available for a short\n    // while in WithdrawDAO after the HF, but probably more than\n    // anyone is willing to drop into WithdrawDAO in Classic\n    function check_withdrawdao() internal\n        has_millions(WithdrawDAO, 10) {\n        forked = true;\n    }\n\n    // failsafe: if the above assumption is incorrect, HF tine\n    // won't have balance in DarkDAO anyway, and Classic has a\n    // sliver of time before DarkDAO split happens\n    function check_darkdao() internal\n        has_millions(DarkDAO, 3) {\n        notforked = true;\n    }\n\n    // running is possible only once\n    // after that the dapp can only throw\n    function ()\n        after_dao_hf_block run_once {\n        ran = true;\n\n        check_withdrawdao();\n        check_darkdao();\n\n        // if both flags are same, then something went wrong\n        if (forked == notforked) throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1903875,0x33ada680b83d86b8d20067785222bb752efb56a8,false,false,"contract DataService {\n    event NewDataRequest(uint id, bool initialized, string dataUrl); \n    event GetDataRequestLength(uint length);\n    event GetDataRequest(uint id, bool initialized, string dataurl, uint dataPointsLength);\n\n    event AddDataPoint(uint dataRequestId, bool success, string response);\n    event GetDataPoint(uint dataRequestId, uint id, bool success, string response);\n\n    struct DataPoint {\n        bool initialized;\n        bool success;\n        string response; \n    }\n    struct DataRequest {\n        bool initialized;\n        string dataUrl;\n        DataPoint[] dataPoints;\n    }\n\n    address private organizer;\n    DataRequest[] private dataRequests;\n\n    // Create a new lottery with numOfBets supported bets.\n    function DataService() {\n        organizer = msg.sender;\n    }\n    \n    // Fallback function returns ether\n    function() {\n        throw;\n    }\n    \n    // Lets the organizer add a new data request\n    function addDataRequest(string dataUrl) {\n        // Only let organizer add requests for now\n        if(msg.sender != organizer) { throw; }\n\n        // Figure out where to store the new DataRequest (next available element)\n        uint nextIndex = dataRequests.length++;\n    \n        // Init the data request and save it\n        DataRequest newDataRequest = dataRequests[nextIndex];\n        newDataRequest.initialized = true;\n        newDataRequest.dataUrl = dataUrl;\n\n        NewDataRequest(dataRequests.length - 1, newDataRequest.initialized, newDataRequest.dataUrl);\n    }\n\n    // Returns the amount of dataRequests currently present\n    function getDataRequestLength() {\n        GetDataRequestLength(dataRequests.length);\n    }\n\n    // Logs the data request with the requested ID\n    function getDataRequest(uint id) {\n        DataRequest dataRequest = dataRequests[id];\n        GetDataRequest(id, dataRequest.initialized, dataRequest.dataUrl, dataRequest.dataPoints.length);\n    }\n\n    // Gets the data point associated with the provided dataRequest.\n    function getDataPoint(uint dataRequestId, uint dataPointId) {\n        DataRequest dataRequest = dataRequests[dataRequestId];\n        DataPoint dataPoint = dataRequest.dataPoints[dataPointId];\n\n        GetDataPoint(dataRequestId, dataPointId, dataPoint.success, dataPoint.response);\n    }\n\n    // Lets the organizer add a new data point\n    function addDataPoint(uint dataRequestId, bool success, string response) {\n        if(msg.sender != organizer) { throw; }\n        \n        // Get the DataRequest to edit, only allow adding a data point if initialized\n        DataRequest dataRequest = dataRequests[dataRequestId];\n        if(!dataRequest.initialized) { throw; }\n\n        // Init the new DataPoint and save it\n        DataPoint newDataPoint = dataRequest.dataPoints[dataRequest.dataPoints.length++];\n        newDataPoint.initialized = true;\n        newDataPoint.success = success;\n        newDataPoint.response = response;\n\n        AddDataPoint(dataRequestId, success, response);\n    }\n\n    // Suicide :(\n    function destroy() {\n        if(msg.sender != organizer) { throw; }\n        \n        suicide(organizer);\n    }\n}",1,標準的なデータ管理スマートコントラクトで、特に芸術的要素はありません。,
1904149,0x0b054caa473a093f6782dbb7210f8cf0eae2333a,false,false,,,,TOO_SHORT
1904232,0x2bd2326c993dfaef84f696526064ff22eba5b362,false,false,contract AmIOnTheFork {\n    bool public forked = false;\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    // Check the fork condition during creation of the contract.\n    // This function should be called between block 1920000 and 1921200.\n    // Approximately between 2016-07-20 12:00:00 UTC and 2016-07-20 17:00:00 UTC.\n    // After that the status will be locked in.\n    function update() {\n        if (block.number >= 1920000 && block.number <= 1921200) {\n            forked = darkDAO.balance < 3600000 ether;\n        }\n    }\n    function() {\n        throw;\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1904477,0x14f167eefe141c4c0eb375ec979a510f487472f7,false,false,,,,TOO_SHORT
1904517,0xa0fd10be97cca603450373cdfaeb08316e684360,false,false,,,,0x33ada680b83d86b8d20067785222bb752efb56a8
1904746,0x4d006bf35769da178cdf40dc74e0f0dd14ee3613,false,false,,,,TOO_SHORT
1905527,0x868f397d2c294e42c6dc72c3a04d2d0da5a73905,false,false,,,,TOO_SHORT
1905763,0xdd1cd54adda7345b570740e3426259a119b3a15e,false,false,,,,TOO_SHORT
1905801,0x92b43f1317e888d850110945197f51f63cdb6490,false,false,,,,TOO_SHORT
1905848,0x1b6bc10249437aa99921584b7f40ec4b700eb8f3,false,false,,,,TOO_SHORT
1905970,0x7f32d09e745077d0aa42429a93c8cf601ff0071c,false,false,,,,TOO_SHORT
1906240,0x452f069df18059ff2754c08ea970388cd6d22ca3,false,false,,,,TOO_SHORT
1906534,0x89f65a9c8b5d5e9bc076c20d4c00f68341fc3505,false,false,,,,TOO_SHORT
1906549,0x002715995f7a468a92eaf4a62909a731b341d261,false,false,,,,TOO_SHORT
1906689,0xd53750984b6a961c1dc3ad7d9947c4445002e17d,false,false,,,,TOO_SHORT
1906862,0x4ca1c07dd54509935aa2efa8bfd01fe6c5ff68e3,false,false,,,,TOO_SHORT
1907956,0xd6670590fc0b19a55ae8da62895a863f19913f5a,false,false,,,,TOO_SHORT
1908025,0xb3816025915d9d9428314e2f0cb363de07fd8ef9,false,false,,,,TOO_SHORT
1908288,0xb9d5e5d9641b77e76b079ddba9c9ac08c0a57889,false,false,,,,TOO_SHORT
1908486,0x4a53a5e9dbe25204995cf3dfa480ee133746a195,false,false,,,,TOO_SHORT
1908590,0x62822c9a50cb6b7f54289a1d7f424f52b42ea3fd,false,false,,,,TOO_SHORT
1908592,0xb20547cc8bf030355ef913d7fec1a284a224907a,false,false,,,,TOO_SHORT
1908696,0xe7f4f5abba4a0ae18eaa31796876d137e19b93ad,false,false,contract ChainSensitive {\n    // store the data for long-term usability\n    uint256 public afterForkBlockNumber;\n    uint256 public afterForkRescueContractBalance;\n\n    // pre-fork: return 0\n    // puritanical: return 1\n    // dao-rescue (hard forked): return 2\n    function whichChainIsThis() internal returns (uint8) {\n        if (block.number >= 1920000) {\n            if (afterForkBlockNumber == 0) { // default\n                afterForkBlockNumber = block.number;\n                afterForkRescueContractBalance = address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance;\n            }\n            if (afterForkRescueContractBalance < 1000000 ether) {\n                return 1; // puritanical chain\n            } else {\n                return 2; // hard-forked dao-rescue chain\n            }\n        } else {\n            return 0; // pre-fork\n        }\n    }\n\n    function() {\n        secureSend(msg.sender);\n        whichChainIsThis();  // store data if not stored yet\n    }\n\n    function secureSend(address to) internal {\n        if (!to.send(msg.value))\n            throw;\n    }\n\n    function isThisPreforkVersion() returns (bool) {\n        secureSend(msg.sender);\n        return whichChainIsThis() == 0;\n    }\n    \n    function isThisPuritanicalVersion() returns (bool) {\n        secureSend(msg.sender);\n        return whichChainIsThis() == 1;\n    }\n\n    function isThisHardforkedVersion() returns (bool) {\n        secureSend(msg.sender);\n        return whichChainIsThis() == 2;\n    }\n\n    function transferIfPuritanical(address to) {\n        if (whichChainIsThis() == 1) {\n            secureSend(to);\n        } else {\n            secureSend(msg.sender);\n        }\n    }\n\n    function transferIfHardForked(address to) {\n        if (whichChainIsThis() == 2) {\n            secureSend(to);\n        } else {\n            secureSend(msg.sender);\n        }\n    }\n},1,DAOハードフォークを識別する実用的なコードで、特に芸術的な要素はありません。,
1909237,0xe21c235e936b813483351efe99e9039ad7f70e70,false,false,,,,TOO_SHORT
1909245,0x013c64a010d71beecddd8d0a957b9844c13f957d,false,false,,,,TOO_SHORT
1909250,0x5dfff96f59c0df5c7caf0be702f4203ce3678a85,false,false,,,,TOO_SHORT
1909252,0x60bf91ac87fee5a78c28f7b67701fbcfa79c18ec,false,false,"// This software is a subject to Ambisafe License Agreement.\n// No use or distribution is allowed without written permission from Ambisafe.\n// https://ambisafe.com/terms.pdf\n\ncontract Ambi {\n    function getNodeAddress(bytes32 _nodeName) constant returns(address);\n    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);\n    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);\n}\n\ncontract AmbiEnabled {\n    Ambi public ambiC;\n    bool public isImmortal;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            if (!ambiContract.addNode(_name, address(this))){\n                return false;\n            }\n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function immortality() checkAccess(""owner"") returns(bool) {\n        isImmortal = true;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") returns(bool) {\n        if (isImmortal) {\n            return false;\n        }\n        selfdestruct(msg.sender);\n        return true;\n    }\n}\n\nlibrary StackDepthLib {\n    // This will probably work with a value of 390 but no need to cut it\n    // that close in the case that the optimizer changes slightly or\n    // something causing that number to rise slightly.\n    uint constant GAS_PER_DEPTH = 400;\n\n    function checkDepth(address self, uint n) constant returns(bool) {\n        if (n == 0) return true;\n        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n    }\n\n    function __dig(uint n) constant {\n        if (n == 0) return;\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n    }\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\n/**\n * @title Events History universal contract.\n *\n * Contract serves as an Events storage and version history for a particular contract type.\n * Events appear on this contract address but their definitions provided by other contracts/libraries.\n * Version info is provided for historical and informational purposes.\n *\n * Note: all the non constant functions return false instead of throwing in case if state change\n * didn't happen yet.\n */\ncontract EventsHistory is AmbiEnabled, Safe {\n    // Event emitter signature to address with Event definiton mapping.\n    mapping(bytes4 => address) public emitters;\n\n    // Calling contract address to version mapping.\n    mapping(address => uint) public versions;\n\n    // Version to info mapping.\n    mapping(uint => VersionInfo) public versionInfo;\n\n    // Latest verion number.\n    uint public latestVersion;\n\n    struct VersionInfo {\n        uint block;        // Block number in which version has been introduced.\n        address by;        // Contract owner address who added version.\n        address caller;    // Address of this version calling contract.\n        string name;       // Version name, informative.\n        string changelog;  // Version changelog, informative.\n    }\n\n    /**\n     * Assign emitter address to a specified emit function signature.\n     *\n     * Can be set only once for each signature, and only by contract owner.\n     * Caller contract should be sure that emitter for a particular signature will never change.\n     *\n     * @param _eventSignature signature of the event emitting function.\n     * @param _emitter address with Event definition.\n     *\n     * @return success.\n     */\n    function addEmitter(bytes4 _eventSignature, address _emitter) noValue() checkAccess(""admin"") returns(bool) {\n        if (emitters[_eventSignature] != 0x0) {\n            return false;\n        }\n        emitters[_eventSignature] = _emitter;\n        return true;\n    }\n\n    /**\n     * Introduce new caller contract version specifing version information.\n     *\n     * Can be set only once for each caller, and only by contract owner.\n     * Name and changelog should not be empty.\n     *\n     * @param _caller address of the new caller.\n     * @param _name version name.\n     * @param _changelog version changelog.\n     *\n     * @return success.\n     */\n    function addVersion(address _caller, string _name, string _changelog) noValue() checkAccess(""admin"") returns(bool) {\n        if (versions[_caller] != 0) {\n            return false;\n        }\n        if (bytes(_name).length == 0) {\n            return false;\n        }\n        if (bytes(_changelog).length == 0) {\n            return false;\n        }\n        uint version = ++latestVersion;\n        versions[_caller] = version;\n        versionInfo[version] = VersionInfo(block.number, msg.sender, _caller, _name, _changelog);\n        return true;\n    }\n\n    /**\n     * Event emitting fallback.\n     *\n     * Can be and only called caller with assigned version.\n     * Resolves msg.sig to an emitter address, and calls it to emit an event.\n     *\n     * Throws if emit function signature is not registered, or call failed.\n     */\n    function () noValue() {\n        if (versions[msg.sender] == 0) {\n            return;\n        }\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        if (!emitters[msg.sig].delegatecall(msg.data)) {\n            throw;\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1909268,0x96a51938cfb22565e0d40694fe103675c63ae218,false,false,"// This software is a subject to Ambisafe License Agreement.\n// No use or distribution is allowed without written permission from Ambisafe.\n// https://ambisafe.com/terms.pdf\n\ncontract Ambi {\n    function getNodeAddress(bytes32 _nodeName) constant returns(address);\n    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);\n    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);\n}\n\ncontract AmbiEnabled {\n    Ambi public ambiC;\n    bool public isImmortal;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            if (!ambiContract.addNode(_name, address(this))){\n                return false;\n            }\n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function immortality() checkAccess(""owner"") returns(bool) {\n        isImmortal = true;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") returns(bool) {\n        if (isImmortal) {\n            return false;\n        }\n        selfdestruct(msg.sender);\n        return true;\n    }\n}\n\nlibrary StackDepthLib {\n    // This will probably work with a value of 390 but no need to cut it\n    // that close in the case that the optimizer changes slightly or\n    // something causing that number to rise slightly.\n    uint constant GAS_PER_DEPTH = 400;\n\n    function checkDepth(address self, uint n) constant returns(bool) {\n        if (n == 0) return true;\n        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n    }\n\n    function __dig(uint n) constant {\n        if (n == 0) return;\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n    }\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\ncontract RegistryICAP is AmbiEnabled, Safe {\n    function decodeIndirect(bytes _bban) constant returns(string, string, string) {\n        bytes memory asset = new bytes(3);\n        bytes memory institution = new bytes(4);\n        bytes memory client = new bytes(9);\n\n        uint8 k = 0;\n\n        for (uint8 i = 0; i < asset.length; i++) {\n            asset[i] = _bban[k++];\n        }\n        for (i = 0; i < institution.length; i++) {\n            institution[i] = _bban[k++];\n        }\n        for (i = 0; i < client.length; i++) {\n            client[i] = _bban[k++];\n        }\n        return (string(asset), string(institution), string(client));\n    }\n\n    function parse(bytes32 _icap) constant returns(address, bytes32, bool) {\n        // Should start with XE.\n        if (_icap[0] != 88 || _icap[1] != 69) {\n            return (0, 0, false);\n        }\n        // Should have 12 zero bytes at the end.\n        for (uint8 j = 20; j < 32; j++) {\n            if (_icap[j] != 0) {\n                return (0, 0, false);\n            }\n        }\n        bytes memory bban = new bytes(18);\n        for (uint8 i = 0; i < 16; i++) {\n             bban[i] = _icap[i + 4];\n        }\n        var (asset, institution, _) = decodeIndirect(bban);\n\n        bytes32 assetInstitutionHash = sha3(asset, institution);\n\n        uint8 parseChecksum = (uint8(_icap[2]) - 48) * 10 + (uint8(_icap[3]) - 48);\n        uint8 calcChecksum = 98 - mod9710(prepare(bban));\n        if (parseChecksum != calcChecksum) {\n            return (institutions[assetInstitutionHash], assets[sha3(asset)], false);\n        }\n        return (institutions[assetInstitutionHash], assets[sha3(asset)], registered[assetInstitutionHash]);\n    }\n\n    function prepare(bytes _bban) constant returns(bytes) {\n        for (uint8 i = 0; i < 16; i++) {\n            uint8 charCode = uint8(_bban[i]);\n            if (charCode >= 65 && charCode <= 90) {\n                _bban[i] = byte(charCode - 65 + 10);\n            }\n        }\n        _bban[16] = 33; // X\n        _bban[17] = 14; // E\n        //_bban[18] = 48; // 0\n        //_bban[19] = 48; // 0\n        return _bban;\n    }\n\n    function mod9710(bytes _prepared) constant returns(uint8) {\n        uint m = 0;\n        for (uint8 i = 0; i < 18; i++) {\n            uint8 charCode = uint8(_prepared[i]);\n            if (charCode >= 48) {\n                m *= 10;\n                m += charCode - 48; // number\n                m %= 97;\n            } else {\n                m *= 10;\n                m += charCode / 10; // part1\n                m %= 97;\n                m *= 10;\n                m += charCode % 10; // part2\n                m %= 97;\n            }\n        }\n        m *= 10;\n        //m += uint8(_prepared[18]) - 48;\n        m %= 97;\n        m *= 10;\n        //m += uint8(_prepared[19]) - 48;\n        m %= 97;\n        return uint8(m);\n    }\n\n    mapping(bytes32 => bool) public registered;\n    mapping(bytes32 => address) public institutions;\n    mapping(bytes32 => address) public institutionOwners;\n    mapping(bytes32 => bytes32) public assets;\n\n    modifier onlyInstitutionOwner(string _institution) {\n        if (msg.sender == institutionOwners[sha3(_institution)]) {\n            _\n        }\n    }\n\n    function changeInstitutionOwner(string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n        institutionOwners[sha3(_institution)] = _address;\n        return true;\n    }\n\n    // web3js sendIBANTransaction interface\n    function addr(bytes32 _institution) constant returns(address) {\n        return institutions[sha3(""ETH"", _institution[0], _institution[1], _institution[2], _institution[3])];\n    }\n\n    function registerInstitution(string _institution, address _address) noValue() checkAccess(""admin"") returns(bool) {\n        if (bytes(_institution).length != 4) {\n            return false;\n        }\n        if (institutionOwners[sha3(_institution)] != 0) {\n            return false;\n        }\n        institutionOwners[sha3(_institution)] = _address;\n        return true;\n    }\n\n    function registerInstitutionAsset(string _asset, string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n        if (!registered[sha3(_asset)]) {\n            return false;\n        }\n        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n        if (registered[assetInstitutionHash]) {\n            return false;\n        }\n        registered[assetInstitutionHash] = true;\n        institutions[assetInstitutionHash] = _address;\n        return true;\n    }\n\n    function updateInstitutionAsset(string _asset, string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n        if (!registered[assetInstitutionHash]) {\n            return false;\n        }\n        institutions[assetInstitutionHash] = _address;\n        return true;\n    }\n\n    function removeInstitutionAsset(string _asset, string _institution) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n        if (!registered[assetInstitutionHash]) {\n            return false;\n        }\n        delete registered[assetInstitutionHash];\n        delete institutions[assetInstitutionHash];\n        return true;\n    }\n\n    function registerAsset(string _asset, bytes32 _symbol) noValue() checkAccess(""admin"") returns(bool) {\n        if (bytes(_asset).length != 3) {\n            return false;\n        }\n        bytes32 asset = sha3(_asset);\n        if (registered[asset]) {\n            return false;\n        }\n        registered[asset] = true;\n        assets[asset] = _symbol;\n        return true;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1909407,0x448fae87f7f5b58c6f215abd53d5cd8125e733c5,true,false,,,,0x98e445d52310b0842ccba0b0b751e11faf55c854
1909432,0x2d5b6ad223654018aa31c5660a48fee33d016adf,true,false,"contract MultiAsset {\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function owner(bytes32 _symbol) constant returns(address);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract Ambi {\n    function getNodeAddress(bytes32 _name) constant returns (address);\n    function addNode(bytes32 _name, address _addr) external returns (bool);\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\n}\n\ncontract EtherTreasuryInterface {\n    function withdraw(address _to, uint _value) returns(bool);\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract Asset is Safe, AmbiEnabled {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) noValue() returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return __transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        return __transferWithReference(_to, _value, _reference);\n    }\n\n    function __transferWithReference(address _to, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) :\n            multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference);\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) :\n            multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference);\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference);\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function __transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function approve(address _spender, uint _value) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyApprove(_spender, _value, symbol);\n    }\n\n    function setCosignerAddress(address _cosigner) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxySetCosignerAddress(_cosigner, symbol);\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() noValue() returns(bool) {\n        address owner = multiAsset.owner(symbol);\n        uint balance = this.balance;\n        bool success = true;\n        if (balance > 0) {\n            success = _unsafeSend(owner, balance);\n        }\n        return multiAsset.transfer(owner, balanceOf(owner), symbol) && success;\n    }\n}\n\ncontract HayekGold is Asset {\n    uint public txGasPriceLimit = 21000000000;\n    uint public refundGas = 40000;\n    uint public transferCallGas = 21000;\n    uint public transferWithReferenceCallGas = 21000;\n    uint public transferFromCallGas = 21000;\n    uint public transferFromWithReferenceCallGas = 21000;\n    uint public transferToICAPCallGas = 21000;\n    uint public transferToICAPWithReferenceCallGas = 21000;\n    uint public transferFromToICAPCallGas = 21000;\n    uint public transferFromToICAPWithReferenceCallGas = 21000;\n    uint public approveCallGas = 21000;\n    uint public forwardCallGas = 21000;\n    uint public setCosignerCallGas = 21000;\n    EtherTreasuryInterface public treasury;\n    mapping(bytes32 => address) public allowedForwards;\n\n    function updateRefundGas() noValue() checkAccess(""setup"") returns(uint) {\n        uint startGas = msg.gas;\n        // just to simulate calculations\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\n        if (tx.gasprice > txGasPriceLimit) {\n            return 0;\n        }\n        // end.\n        if (!_refund(1)) {\n            return 0;\n        }\n        refundGas = startGas - msg.gas;\n        return refundGas;\n    }\n\n    function setOperationsCallGas\n        (\n            uint _transfer,\n            uint _transferFrom,\n            uint _transferToICAP,\n            uint _transferFromToICAP,\n            uint _transferWithReference,\n            uint _transferFromWithReference,\n            uint _transferToICAPWithReference,\n            uint _transferFromToICAPWithReference,\n            uint _approve,\n            uint _forward,\n            uint _setCosigner\n        ) noValue() checkAccess(""setup"") returns(bool)\n    {\n        transferCallGas = _transfer;\n        transferFromCallGas = _transferFrom;\n        transferToICAPCallGas = _transferToICAP;\n        transferFromToICAPCallGas = _transferFromToICAP;\n        transferWithReferenceCallGas = _transferWithReference;\n        transferFromWithReferenceCallGas = _transferFromWithReference;\n        transferToICAPWithReferenceCallGas = _transferToICAPWithReference;\n        transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference;\n        approveCallGas = _approve;\n        forwardCallGas = _forward;\n        setCosignerCallGas = _setCosigner;\n        return true;\n    }\n\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(""admin"") returns(bool) {\n        if (_txGasPriceLimit == 0) {\n            return false;\n        }\n        treasury = EtherTreasuryInterface(_treasury);\n        txGasPriceLimit = _txGasPriceLimit;\n        if (msg.value > 0) {\n            _safeSend(_treasury, msg.value);\n        }\n        return true;\n    }\n\n    function setForward(bytes4 _msgSig, address _forward) noValue() checkAccess(""admin"") returns(bool) {\n        allowedForwards[sha3(_msgSig)] = _forward;\n        return true;\n    }\n\n    function _stringGas(string _string) constant internal returns(uint) {\n        return bytes(_string).length * 75; // ~75 gas per byte, empirical shown 68-72.\n    }\n\n    function _applyRefund(uint _startGas) internal returns(bool) {\n        if (tx.gasprice > txGasPriceLimit) {\n            return false;\n        }\n        uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice;\n        return _refund(refund);\n    }\n\n    function _refund(uint _value) internal returns(bool) {\n        return treasury.withdraw(tx.origin, _value);\n    }\n\n    function _transfer(address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferCallGas;\n        if (!super.transfer(_to, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromCallGas;\n        if (!super.transferFrom(_from, _to, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPCallGas;\n        if (!super.transferToICAP(_icap, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPCallGas;\n        if (!super.transferFromToICAP(_from, _icap, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferWithReference(_to, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferFromWithReference(_from, _to, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferToICAPWithReference(_icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _approve(address _spender, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + approveCallGas;\n        if (!super.approve(_spender, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _setCosignerAddress(address _cosigner) internal returns(bool, bool) {\n        uint startGas = msg.gas + setCosignerCallGas;\n        if (!super.setCosignerAddress(_cosigner)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transfer(_to, _value);\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFrom(_from, _to, _value);\n        return success;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferToICAP(_icap, _value);\n        return success;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAP(_from, _icap, _value);\n        return success;\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferWithReference(_to, _value, _reference);\n        return success;\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromWithReference(_from, _to, _value, _reference);\n        return success;\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferToICAPWithReference(_icap, _value, _reference);\n        return success;\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n        return success;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        bool success;\n        (success,) = _approve(_spender, _value);\n        return success;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        bool success;\n        (success,) = _setCosignerAddress(_cosigner);\n        return success;\n    }\n\n    function checkTransfer(address _to, uint _value) constant returns(bool, bool) {\n        return _transfer(_to, _value);\n    }\n\n    function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) {\n        return _transferFrom(_from, _to, _value);\n    }\n\n    function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferToICAP(_icap, _value);\n    }\n\n    function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferFromToICAP(_from, _icap, _value);\n    }\n\n    function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferWithReference(_to, _value, _reference);\n    }\n\n    function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function checkApprove(address _spender, uint _value) constant returns(bool, bool) {\n        return _approve(_spender, _value);\n    }\n\n    function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) {\n        return _setCosignerAddress(_cosigner);\n    }\n\n    function checkForward(bytes _data) constant returns(bool, bool) {\n        bytes memory sig = new bytes(4);\n        sig[0] = _data[0];\n        sig[1] = _data[1];\n        sig[2] = _data[2];\n        sig[3] = _data[3];\n        return _forward(allowedForwards[sha3(sig)], _data);\n    }\n\n    function _forward(address _to, bytes _data) internal returns(bool, bool) {\n        uint startGas = msg.gas + forwardCallGas + (_data.length * 50); // 50 gas per byte;\n        if (_to == 0x0) {\n            return (false, _safeFalse());\n        }\n        if (!_to.call.value(msg.value)(_data)) {\n            return (false, _safeFalse());\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function () returns(bool) {\n        bool success;\n        (success,) = _forward(allowedForwards[sha3(msg.sig)], msg.data);\n        return success;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1909610,0x22a0ab00594a8b38a64b2f01b3d2749b8cc0347d,false,false,,,,TOO_SHORT
1909611,0x79138654af3ed550ef25ffe567218f9cdd584dd8,false,false,,,,TOO_SHORT
1909620,0xccd132a7a838070ea97b9b0d5e30cb6f0ae77843,false,false,,,,TOO_SHORT
1910205,0x9b8bc1f494691a259979f67427739a77deb5c5e8,false,false,,,,TOO_SHORT
1910509,0xd0c4ad1243d8d5644ccfd1c0921c8af68c9a8ace,false,false,,,,TOO_SHORT
1910561,0x63204a91b305701aec2981a203d5dc4cbde692fa,false,false,,,,TOO_SHORT
1910690,0xf24ef60621931a9892371d42cab9da80e9b77331,false,false,,,,TOO_SHORT
1910694,0x81650cb68616e05fca3390a287aa8bf3007ab51b,false,false,,,,TOO_SHORT
1910720,0x776d64529933b234438cd371eb354f7c2d67ddd9,false,false,,,,TOO_SHORT
1910938,0x45ef41c737296dc92ef7757c727191745e65cd6e,false,false,,,,TOO_SHORT
1911270,0xa5c201d317fb9bd84a3c5fa7033896c84c5888d9,false,false,,,,TOO_SHORT
1912313,0x80c7e9326e4f69d2f0ba0887170ab4031664c0dd,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1912483,0x5b2ff75d7eaa47db475707dae12a688102ef4290,false,false,"//Simple Msg XChange Registrar (does not provide validateion!)\ncontract Message {\n	address public registrar;	\n	address public from;\n	address public to;\n	string public hash_msg;\n	string public hash_ack;\n	uint256 public timestamp_msg;\n	uint256 public timestamp_ack;\n	\n	\n	function Message(address _registrar,address _from,address _to,string _hash_msg) {\n		registrar=_registrar;\n		from=_from;\n		to=_to;\n		hash_msg=_hash_msg;\n		timestamp_msg=now;\n	}\n	\n	function ack(string _hash) {\n		if(msg.sender!=to) throw;\n		if(timestamp_ack>0) throw;\n		hash_ack=_hash;\n		timestamp_ack=now;		\n	}\n	\n	function() {\n		if(msg.value>0) {\n			if(msg.sender==from) {			\n				to.send(msg.value);\n			} else {\n				from.send(msg.value);\n			}\n		}\n	}\n	\n}\ncontract Registrar\n{\n	address public registrar;		\n	\n	uint256 public fee_registration;\n	uint256 public fee_msg;\n	uint256 public cnt_registrations;\n	\n	struct Registration {\n		address adr;\n		string hash;\n		string gnid;\n	}	\n	\n	mapping(address=>Registration) public regadr;	\n	mapping(address=>Message[]) public msgs;\n	mapping(address=>Message[]) public sent;\n	mapping(address=>bool) public preregister;	\n	\n	Registration[] public regs;\n	\n	function Registrar() {\n		registrar=msg.sender;\n	}\n	\n	function register(string hash) {\n		updateRegistration(hash,'');		\n	}\n	\n	function unregister() {\n		delete regadr[msg.sender];\n	}\n	\n	function updateRegistration(string hash,string gnid) {		\n		if((msg.value>=fee_registration)||(preregister[msg.sender])) {			\n			regadr[msg.sender]=Registration(msg.sender,hash,gnid);\n			regs.push(regadr[msg.sender]);\n			if(fee_registration>0) registrar.send(this.balance);\n			preregister[msg.sender]=false;\n			cnt_registrations++;\n		} else throw;\n	}\n	\n	function preRegister(address preReg) {\n		if(msg.sender!=registrar) throw;\n		preReg.send(msg.value);		\n		preregister[preReg]=true;\n	}\n	\n	function getMsgs() returns (Message[]) {\n		return msgs[msg.sender];	\n	}\n	\n	function setRegistrationPrice(uint256 price) {\n		if(msg.sender!=registrar) throw;\n		fee_registration=price;\n	}\n	\n	function setMsgPrice(uint256 price) {\n		if(msg.sender!=registrar) throw;\n		fee_msg=price;\n	}\n	\n	function sendMsg(address to,string hash) {\n		if(msg.value>=fee_msg) {	\n			    Message m = new  Message(this,msg.sender,to,hash);\n				msgs[to].push(m);	\n			    sent[msg.sender].push(m);\n			if(fee_msg>0) registrar.send(this.balance);\n		} else throw;		\n	}\n	\n	function ackMsg(uint256 msgid,string hash) {\n		Message message =Message(msgs[msg.sender][msgid]);\n		message.ack(hash);\n	}\n	\n	function() {\n		if(msg.value>0) {\n			registrar.send(msg.value);\n		}\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1912582,0x54cd6f245a4581c8ddb46fe554e3a642c71cddc3,false,false,,,,TOO_SHORT
1912829,0xfdf5ecefd831a3e5f2b1a667d92d8796dd53f0ec,false,false,"contract Destination {\n    function recover(address _from, address _to) returns(bool);\n}\n\ncontract RecoveryWithTenant {\n    event Recovery(uint indexed nonce, address indexed from, address indexed to);\n    event Setup(uint indexed nonce, address indexed user);\n    \n    //1: user not existing\n    //2: conflict, user exists already\n    //3: signature not by tenant\n    //4: nonce/signature used before\n    //5: contract call failed\n    //6: oracle access denied\n    //8: requested user not found\n    event Error(uint indexed nonce, uint code);\n    \n    struct User {\n        address addr;\n    }\n    \n    mapping (address => uint) userIndex;\n    User[] public users;\n\n    address public oracle;\n    address public tenant;\n    mapping(uint => bool) nonceUsed;\n    address public callDestination;\n\n\n    modifier onlyOracle() {\n        if (msg.sender == oracle) {\n            _\n        }\n        Error(0, 6);\n    }\n    \n    modifier noEther() {\n        if (msg.value > 0) throw;\n        _\n    }\n\n    function RecoveryWithTenant() {\n        oracle = msg.sender;\n        tenant = msg.sender;\n        users.length++;\n    }\n    \n    //############# INTERNAL FUNCTIONS\n    \n    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {\n        address recovered = ecrecover(_hash, _v, _r, _s);\n\n        if (tenant != recovered) {\n            Error(_nonce, 3);\n            return false;\n        }\n        if (nonceUsed[_nonce]) {\n            Error(_nonce, 4);\n            return false;\n        }\n        nonceUsed[_nonce] = true; \n        return true;\n    }\n    \n    \n    //############# PUBLIC FUNCTIONS\n    \n    function setOracle(address _newOracle) noEther onlyOracle {\n        oracle = _newOracle;\n    }\n    \n    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        if(tenant != oracle && !_checkSigned(sha3(_tenant, _callDestination, _nonce), _nonce, _v, _r, _s))\n            return false;\n        tenant = _tenant;\n        callDestination = _callDestination;\n        return true;\n    }\n    \n    \n    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        if(userIndex[_userAddr] > 0) {\n            Error(_nonce, 2);\n            return false;\n        }\n        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))\n            return false;\n        uint posUser = users.length++;\n        userIndex[_userAddr] = posUser;\n        users[posUser] = User(_userAddr);\n        Setup(_nonce, _userAddr);\n        return true;\n    }\n    \n    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        uint userPos = userIndex[_oldAddr];\n        if (userPos == 0) {\n            Error(_nonce, 1); //user doesn't exsit\n            return false;\n        }\n        \n        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))\n            return false;\n        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);\n        if (result) {\n            users[userPos].addr = _newAddr;\n            delete userIndex[_oldAddr];\n            userIndex[_newAddr] = userPos;\n            Recovery(_nonce, _oldAddr, _newAddr);\n            return true;\n        }\n        Error(_nonce, 5);\n        return false;\n    }\n\n    function () noEther {\n        throw;\n    }\n    \n    //############# STATIC FUNCTIONS\n    \n    function isUser(address _userAddr) constant returns (bool) {\n        return (userIndex[_userAddr] > 0);\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1913422,0xa150de0e6998e05d6e19fca736ab758e698da21a,false,false,,,,TOO_SHORT
1913864,0x3a1827b2ce334cd9c412eb5cdce2738815fc05cd,false,false,,,,TOO_SHORT
1914018,0x5c6800d0470751c93a613e63e88d52375dc8c96a,false,false,,,,TOO_SHORT
1914245,0x5cbdde93d766529be299eb9d09bc706dc1dc36f0,false,false,,,,TOO_SHORT
1914295,0x5de6ad1b563c8d1e18301fb8535728a34726bf23,false,false,,,,TOO_SHORT
1914321,0xb5a7f4ea27e362c57d41b942392f1a4654868046,false,false,,,,0x2bd2326c993dfaef84f696526064ff22eba5b362
1914420,0xe243186ac865b64ec7f0ef3d257f81426535dbe5,false,false,,,,TOO_SHORT
1914463,0xe2157fd574bd6a621d6c669c0f65d033510fe393,false,false,,,,TOO_SHORT
1914544,0x74c05c56b88422a3982c096e8b976cf6aae2953e,false,false,,,,TOO_SHORT
1914761,0xe4c7b738421cf218c2542d392cbde4623c62702a,false,false,"/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n*/\n\ncontract AmIOnTheFork{\n    function forked() constant returns(bool);\n}\n\n\ncontract Oraclize {\n    mapping (address => uint) reqc;\n    \n    address public cbAddress = 0x26588a9301b0428d95e6fc3a5024fce8bec12d51;\n    \n    address constant AmIOnTheForkAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;\n    \n    event Log1(address sender, bytes32 cid, uint timestamp, string datasource, string arg, uint gaslimit, byte proofType, uint gasPrice);\n    event Log2(address sender, bytes32 cid, uint timestamp, string datasource, string arg1, string arg2, uint gaslimit, byte proofType, uint gasPrice);\n    \n    address owner;\n    \n    modifier onlyadmin {\n        if ((msg.sender != owner)&&(msg.sender != cbAddress)) throw;\n        _\n    }\n    \n    function addDSource(string dsname, uint multiplier) {\n        addDSource(dsname, 0x00, multiplier);\n    }\n    \n    function addDSource(string dsname, byte proofType, uint multiplier) onlyadmin {\n        bytes32 dsname_hash = sha3(dsname, proofType);\n        dsources[dsources.length++] = dsname_hash;\n        price_multiplier[dsname_hash] = multiplier;\n    }\n\n    mapping (bytes32 => bool) coupons;\n    bytes32 coupon;\n    \n    function createCoupon(string _code) onlyadmin {\n        coupons[sha3(_code)] = true;\n    }\n    \n    function deleteCoupon(string _code) onlyadmin {\n        coupons[sha3(_code)] = false;\n    }\n    \n    function multisetProofType(uint[] _proofType, address[] _addr) onlyadmin {\n        for (uint i=0; i<_addr.length; i++) addr_proofType[_addr[i]] = byte(_proofType[i]);\n    }\n    \n    function multisetCustomGasPrice(uint[] _gasPrice, address[] _addr) onlyadmin {\n        for (uint i=0; i<_addr.length; i++) addr_gasPrice[_addr[i]] = _gasPrice[i];\n    }\n\n    uint gasprice = 20000000000;\n    \n    function setGasPrice(uint newgasprice) onlyadmin {\n        gasprice = newgasprice;\n    }\n    \n    function setBasePrice(uint new_baseprice) onlyadmin { //0.001 usd in ether\n        baseprice = new_baseprice;\n        for (uint i=0; i<dsources.length; i++) price[dsources[i]] = new_baseprice*price_multiplier[dsources[i]];\n    }\n\n    function setBasePrice(uint new_baseprice, bytes proofID) onlyadmin { //0.001 usd in ether\n        baseprice = new_baseprice;\n        for (uint i=0; i<dsources.length; i++) price[dsources[i]] = new_baseprice*price_multiplier[dsources[i]];\n    }\n    \n    function withdrawFunds(address _addr) onlyadmin {\n        _addr.send(this.balance);\n    }\n    \n    function() onlyadmin {}\n    \n    function Oraclize() {\n        owner = msg.sender;\n    }\n    \n    modifier costs(string datasource, uint gaslimit) {\n        uint price = getPrice(datasource, gaslimit, msg.sender);\n        if (msg.value >= price){\n            uint diff = msg.value - price;\n            if (diff > 0) msg.sender.send(diff);\n            _\n        } else throw;\n    }\n\n    mapping (address => byte) addr_proofType;\n    mapping (address => uint) addr_gasPrice;\n    uint public baseprice;\n    mapping (bytes32 => uint) price;\n    mapping (bytes32 => uint) price_multiplier;\n    bytes32[] dsources;\n    function useCoupon(string _coupon) {\n        coupon = sha3(_coupon);\n    }\n    \n    function setProofType(byte _proofType) {\n        addr_proofType[msg.sender] = _proofType;\n    }\n    \n    function setCustomGasPrice(uint _gasPrice) {\n        addr_gasPrice[msg.sender] = _gasPrice;\n    }\n    \n    function getPrice(string _datasource) public returns (uint _dsprice) {\n        return getPrice(_datasource, msg.sender);\n    }\n    \n    function getPrice(string _datasource, uint _gaslimit) public returns (uint _dsprice) {\n        return getPrice(_datasource, _gaslimit, msg.sender);\n    }\n    \n    function getPrice(string _datasource, address _addr) private returns (uint _dsprice) {\n        return getPrice(_datasource, 200000, _addr);\n    }\n    \n    function getPrice(string _datasource, uint _gaslimit, address _addr) private returns (uint _dsprice) {\n        if ((_gaslimit <= 200000)&&(reqc[_addr] == 0)&&(tx.origin != cbAddress)) return 0;\n        if ((coupon != 0)&&(coupons[coupon] == true)) return 0;\n        _dsprice = price[sha3(_datasource, addr_proofType[_addr])];\n        uint gasprice_ = addr_gasPrice[_addr];\n        if (gasprice_ == 0) gasprice_ = gasprice; \n        _dsprice += _gaslimit*gasprice_;\n        return _dsprice;\n    }\n    \n    function query(string _datasource, string _arg) returns (bytes32 _id) {\n        return query1(0, _datasource, _arg, 200000);\n    }\n    \n    function query1(string _datasource, string _arg) returns (bytes32 _id) {\n        return query1(0, _datasource, _arg, 200000);\n    }\n    \n    function query2(string _datasource, string _arg1, string _arg2) returns (bytes32 _id) {\n        return query2(0, _datasource, _arg1, _arg2, 200000);\n    }\n    \n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id) {\n        return query1(_timestamp, _datasource, _arg, 200000);\n    }\n    \n    function query1(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id) {\n        return query1(_timestamp, _datasource, _arg, 200000);\n    }\n    \n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id) {\n        return query2(_timestamp, _datasource, _arg1, _arg2, 200000);\n    }\n    \n    function query(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\n    }\n    \n    function query1(uint _timestamp, string _datasource, string _arg, uint _gaslimit) costs(_datasource, _gaslimit) returns (bytes32 _id) {\n	if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;\n	bool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();\n        _id = sha3(forkFlag, this, msg.sender, reqc[msg.sender]);\n        reqc[msg.sender]++;\n        Log1(msg.sender, _id, _timestamp, _datasource, _arg, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\n        return _id;\n    }\n    \n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) costs(_datasource, _gaslimit) returns (bytes32 _id) {\n	if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;\n	bool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();\n        _id = sha3(forkFlag, this, msg.sender, reqc[msg.sender]);\n        reqc[msg.sender]++;\n        Log2(msg.sender, _id, _timestamp, _datasource, _arg1, _arg2, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\n        return _id;\n    }\n    \n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\n        return query(_timestamp, _datasource, _arg, _gaslimit);\n    }\n    \n    function query1_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\n    }\n    \n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id) {\n        return query2(_timestamp, _datasource, _arg1, _arg2, _gaslimit);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1914844,0x001a589dda0d6be37632925eaf1256986b2c6ad0,false,false,,,,0xe4c7b738421cf218c2542d392cbde4623c62702a
1914879,0x759d15d83cc79d4991e368cde4a08fda1a13d6df,false,false,,,,TOO_SHORT
1914926,0x6a6581a884c4729586479307e5694bf836617517,false,false,"// DAO>9000 (http://dao9000.com) under CC0\n\ncontract Dao9000 {\n    string message; //This is variable is first for easier interaction with outside world (offset 0x0), contains latest member message\n    address[] public members;\n\n    function Dao9000 () {\n        members.push (msg.sender); //The contact owner is added as the first member\n        message = ""Message not yet defined"";\n    }\n    \n    //These two functions are for easier external interaction via api.etherscan.io:\n    function getMembers () constant returns (uint256 retVal) {\n        return members.length;\n    }\n    \n    function getMessage () constant returns (string retVal) {\n        return message;\n    }\n    \n    //This is the default function, this is called when normal transaction is made\n    function () {\n        //Since this is a DAO parody, we really do not let people invest more than 1.5 ETH max.\n        if (msg.value < 1500000000000000000 && msg.value > 1) {\n            //RNG happens here: for the ""seed"" hash of the previous block is taken, and current timestamp is added\n            uint256 randomIndex = (uint256(block.blockhash(block.number-1)) + now) % members.length;\n            if (members[randomIndex].send(msg.value)) {\n                if (msg.data.length > 0)\n                    message = string(msg.data); //If additional message is defined, we save it here\n                members.push (msg.sender); //After a successful transaction, new member is added, multiple entries for same member are permitted\n            } else {\n                throw;\n            }\n        } else {\n            throw;\n        }\n    }\n}",1,DAOのパロディとしての実用的なスマートコントラクトで、特に芸術的な要素はない。,
1914936,0x022621485b39e3c7d116fd768239c6234ec6ded4,false,false,,,,TOO_SHORT
1915051,0x09cb1e30cbd66dc7b55f74fb12778f324db28a17,false,false,,,,TOO_SHORT
1915109,0xb9136946626c1300114179900106577c87c807e6,false,false,,,,TOO_SHORT
1915375,0xad24b48f33746e68bdcdc2e7f5857ee0eeec2efb,false,false,,,,TOO_SHORT
1915385,0x0248b5e8572ebb2b0c8c7ba09ae1e191c576414f,false,false,,,,TOO_SHORT
1915398,0x263a451b8e4395ea9918f6caa67e1f0628ff88f3,false,false,,,,TOO_SHORT
1915929,0xa28398b83d4bde602cd5d6a0a1257a3388e35c2b,false,false,,,,TOO_SHORT
1916313,0xa732cc4f25ced3114104ab26a108bad4177943e2,false,false,,,,TOO_SHORT
1916421,0x017bc6ceadee1223026a6bb9b6dcdb43f8173abe,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//  ROULETH \n//\n//  Play the Roulette on ethereum blockchain !\n//  (or become a member of Rouleth's Decentralized Organisation  and contribute to the bankroll.) \n//\n//\n//\n//   check latest contract address version on the current website interface\n//   V 2\n//\n//\n//\n\ncontract Rouleth\n{\n    //Game and Global Variables, Structure of gambles\n    address developer;\n    uint8 blockDelay; //nb of blocks to wait before spin\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\n    uint256 maxGamble; //max gamble value manually set by config\n    uint256 minGamble; //min gamble value manually set by config\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\n    uint casinoStatisticalLimit; //ratio payroll and max win\n    //Current gamble value possibly lower than limit auto\n    uint256 currentMaxGamble; \n    //Gambles\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \n    struct Gamble\n    {\n	address player;\n        bool spinned; //Was the rouleth spinned ?\n	bool win;\n	//Possible bet types\n        BetTypes betType;\n	uint8 input; //stores number, color, dozen or oddeven\n	uint256 wager;\n	uint256 blockNumber; //block of bet\n	uint256 blockSpinned; //block of spin\n        uint8 wheelResult;\n    }\n    Gamble[] private gambles;\n    uint totalGambles; \n    //Tracking progress of players\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\n    //records current status of player\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; \n\n\n    //**********************************************\n    //        Management & Config FUNCTIONS        //\n    //**********************************************\n\n    function  Rouleth() private //creation settings\n    { \n        developer = msg.sender;\n        blockDelay=1; //indicates which block after bet will be used for RNG\n	blockExpiration=200; //delay after which gamble expires\n        minGamble=50 finney; //configurable min bet\n        maxGamble=500 finney; //configurable max bet\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\n        casinoStatisticalLimit=100; //we are targeting at least 400\n    }\n    \n    modifier onlyDeveloper() \n    {\n	if (msg.sender!=developer) throw;\n	_\n    }\n    \n    function changeDeveloper_only_Dev(address new_dev)\n    noEthSent\n    onlyDeveloper\n    {\n	developer=new_dev;\n    }\n\n    //Prevents accidental sending of Eth when you shouldn't\n    modifier noEthSent()\n    {\n        if (msg.value>0) \n	{\n	    throw;\n	}\n        _\n    }\n\n\n    //Activate, Deactivate Betting\n    enum States{active, inactive} States private contract_state;\n    \n    function disableBetting_only_Dev()\n    noEthSent\n    onlyDeveloper\n    {\n        contract_state=States.inactive;\n    }\n\n\n    function enableBetting_only_Dev()\n    noEthSent\n    onlyDeveloper\n    {\n        contract_state=States.active;\n\n    }\n    \n    modifier onlyActive()\n    {\n        if (contract_state==States.inactive) throw;\n        _\n    }\n\n\n\n    //Change some settings within safety bounds\n    function changeSettings_only_Dev(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMinGamble, uint256 newMaxGamble, uint16 newMaxInvestor, uint256 newMinInvestment,uint256 newMaxInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\n    noEthSent\n    onlyDeveloper\n    {\n\n\n        // changes the statistical multiplier that guarantees the long run casino survival\n        if (newCasinoStatLimit<100) throw;\n        casinoStatisticalLimit=newCasinoStatLimit;\n        //Max number of bets per block to prevent miner cheating\n        maxBetsPerBlock=newMaxBetsBlock;\n        //MAX BET : limited by payroll/(casinoStatisticalLimit*35)\n        if (newMaxGamble<newMinGamble) throw;  \n	else { maxGamble=newMaxGamble; }\n        //Min Bet\n        if (newMinGamble<0) throw; \n	else { minGamble=newMinGamble; }\n        //MAX NB of DAO members (can only increase (within bounds) or stay equal)\n        //this number of members can only increase after 25k spins on Rouleth\n        //refuse change of max number of members if less than 25k spins played\n        if (newMaxInvestor!=setting_maxInvestors && gambles.length<25000) throw;\n        if ( newMaxInvestor<setting_maxInvestors \n             || newMaxInvestor>investors.length) throw;\n        else { setting_maxInvestors=newMaxInvestor;}\n        //computes the results of the vote of the VIP members, fees to apply to new members\n        computeResultVoteExtraInvestFeesRate();\n        if (newMaxInvestment<newMinInvestment) throw;\n        //MIN INVEST : \n        setting_minInvestment=newMinInvestment;\n        //MAX INVEST : \n        setting_maxInvestment=newMaxInvestment;\n        //Invest LOCK PERIOD\n	//1 year max\n	//can also serve as a failsafe to shutdown withdraws for a period\n        if (setting_lockPeriod>360 days) throw; \n        setting_lockPeriod=newLockPeriod;\n        //Delay before spin :\n	blockDelay=newBlockDelay;\n	if (newBlockExpiration<blockDelay+20) throw;\n	blockExpiration=newBlockExpiration;\n        updateMaxBet();\n    }\n\n\n    //**********************************************\n    //                 Nicknames FUNCTIONS                    //\n    //**********************************************\n\n    //User set nickname\n    mapping (address => string) nicknames;\n    function setNickname(string name) \n    noEthSent\n    {\n        if (bytes(name).length >= 2 && bytes(name).length <= 30)\n            nicknames[msg.sender] = name;\n    }\n    function getNickname(address _address) constant returns(string _name) {\n        _name = nicknames[_address];\n    }\n\n    \n    //**********************************************\n    //                 BETTING FUNCTIONS                    //\n    //**********************************************\n\n    //***//basic betting without Mist or contract call\n    //activates when the player only sends eth to the contract\n    //without specifying any type of bet.\n    function () \n    {\n	//defaut bet : bet on red\n	betOnColor(true,false);\n    } \n\n    //Admin function that\n    //recalculates max bet\n    //updated after each bet and change of bankroll\n    function updateMaxBet() private\n    {\n	//check that setting is still within safety bounds\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \n	{ \n	    currentMaxGamble=maxGamble;\n        }\n	else\n	{ \n	    currentMaxGamble = payroll/(casinoStatisticalLimit*35);\n	}\n    }\n\n\n    //***//Guarantees that gamble is under max bet and above min.\n    // returns bet value\n    function checkBetValue() private returns(uint256 playerBetValue)\n    {\n        if (msg.value < minGamble) throw;\n	if (msg.value > currentMaxGamble) //if above max, send difference back\n	{\n            playerBetValue=currentMaxGamble;\n	}\n        else\n        { playerBetValue=msg.value; }\n        return;\n    }\n\n\n    //check number of bets in block (to prevent miner cheating)\n    modifier checkNbBetsCurrentBlock()\n    {\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\n        else nbBetsCurrentBlock=0;\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\n        _\n    }\n\n\n    //Function record bet called by all others betting functions\n    function placeBet(BetTypes betType_, uint8 input_) private\n    {\n	// Before we record, we may have to spin the past bet if the croupier bot \n	// is down for some reason or if the player played again too quickly.\n	// This would fail though if the player tries too play to quickly (in consecutive block).\n	// gambles should be spaced by at least a block\n	// the croupier bot should spin within 2 blocks (~30 secs) after your bet.\n	// if the bet expires it is added to casino profit, otherwise it would be a way to cheat\n	if (playerStatus[msg.sender]!=Status.waitingForBet)\n	{\n            SpinTheWheel(msg.sender);\n	}\n        //Once this is done, we can record the new bet\n	playerStatus[msg.sender]=Status.waitingForSpin;\n	gambleIndex[msg.sender]=gambles.length;\n        totalGambles++;\n        //adapts wager to casino limits\n        uint256 betValue = checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, betType_, input_, betValue, block.number, 0, 37)); //37 indicates not spinned yet\n	//refund excess bet (at last step vs re-entry)\n        if (betValue<msg.value) \n        {\n 	    if (msg.sender.send(msg.value-betValue)==false) throw;\n        }\n    }\n\n\n    //***//bet on Number	\n    function betOnNumber(uint8 numberChosen)\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        //check that number chosen is valid and records bet\n        if (numberChosen>36) throw;\n        placeBet(BetTypes.number, numberChosen);\n    }\n\n    //***// function betOnColor\n    //bet type : color\n    //input : 0 for red\n    //input : 1 for black\n    function betOnColor(bool Red, bool Black)\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Red) \n        { \n            count+=1; \n            input=0;\n        }\n        if (Black) \n        {\n            count+=1; \n            input=1;\n        }\n        if (count!=1) throw;\n        placeBet(BetTypes.color, input);\n    }\n\n    //***// function betOnLow_High\n    //bet type : lowhigh\n    //input : 0 for low\n    //input : 1 for low\n    function betOnLowHigh(bool Low, bool High)\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Low) \n        { \n            count+=1; \n            input=0;\n        }\n        if (High) \n        {\n            count+=1; \n            input=1;\n        }\n        if (count!=1) throw;\n        placeBet(BetTypes.lowhigh, input);\n    }\n\n    //***// function betOnOddEven\n    //bet type : parity\n    //input : 0 for even\n    //input : 1 for odd\n    function betOnOddEven(bool Odd, bool Even)\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Even) \n        { \n            count+=1; \n            input=0;\n        }\n        if (Odd) \n        {\n            count+=1; \n            input=1;\n        }\n        if (count!=1) throw;\n        placeBet(BetTypes.parity, input);\n    }\n\n\n    //***// function betOnDozen\n    //     //bet type : dozen\n    //     //input : 0 for first dozen\n    //     //input : 1 for second dozen\n    //     //input : 2 for third dozen\n    function betOnDozen(bool First, bool Second, bool Third)\n    {\n        betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\n    }\n\n\n    // //***// function betOnColumn\n    //     //bet type : column\n    //     //input : 0 for first column\n    //     //input : 1 for second column\n    //     //input : 2 for third column\n    function betOnColumn(bool First, bool Second, bool Third)\n    {\n        betOnColumnOrDozen(First, Second, Third, BetTypes.column);\n    }\n\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\n    onlyActive\n    checkNbBetsCurrentBlock\n    { \n        uint8 count;\n        uint8 input;\n        if (First) \n        { \n            count+=1; \n            input=0;\n        }\n        if (Second) \n        {\n            count+=1; \n            input=1;\n        }\n        if (Third) \n        {\n            count+=1; \n            input=2;\n        }\n        if (count!=1) throw;\n        placeBet(bet, input);\n    }\n\n\n    //**********************************************\n    // Spin The Wheel & Check Result FUNCTIONS//\n    //**********************************************\n\n    event Win(address player, uint8 result, uint value_won, bytes32 bHash, bytes32 sha3Player, uint gambleId);\n    event Loss(address player, uint8 result, uint value_loss, bytes32 bHash, bytes32 sha3Player, uint gambleId);\n\n    //***//function to spin callable\n    // no eth allowed\n    function spinTheWheel(address spin_for_player)\n    noEthSent\n    {\n        SpinTheWheel(spin_for_player);\n    }\n\n\n    function SpinTheWheel(address playerSpinned) private\n    {\n        if (playerSpinned==0)\n	{\n	    playerSpinned=msg.sender;         //if no index spins for the sender\n	}\n\n	//check that player has to spin\n        if (playerStatus[playerSpinned]!=Status.waitingForSpin) throw;\n        //redundent double check : check that gamble has not been spinned already\n        if (gambles[gambleIndex[playerSpinned]].spinned==true) throw;\n        //check that the player waited for the delay before spin\n        //and also that the bet is not expired\n	uint playerblock = gambles[gambleIndex[playerSpinned]].blockNumber;\n        //too early to spin\n	if (block.number<=playerblock+blockDelay) throw;\n        //too late, bet expired, player lost\n        else if (block.number>playerblock+blockExpiration)  solveBet(playerSpinned, 255, false, 1, 0, 0) ;\n	//spin !\n        else\n	{\n	    uint8 wheelResult;\n            //Spin the wheel, \n            bytes32 blockHash= block.blockhash(playerblock+blockDelay);\n            //security check that the Hash is not empty\n            if (blockHash==0) throw;\n	    // generate the hash for RNG from the blockHash and the player's address\n            bytes32 shaPlayer = sha3(playerSpinned, blockHash);\n	    // get the final wheel result\n	    wheelResult = uint8(uint256(shaPlayer)%37);\n            //check result against bet and pay if win\n	    checkBetResult(wheelResult, playerSpinned, blockHash, shaPlayer);\n	}\n    }\n    \n\n    //CHECK BETS FUNCTIONS private\n    function checkBetResult(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        BetTypes betType=gambles[gambleIndex[player]].betType;\n        //bet on Number\n        if (betType==BetTypes.number) checkBetNumber(result, player, blockHash, shaPlayer);\n        else if (betType==BetTypes.parity) checkBetParity(result, player, blockHash, shaPlayer);\n        else if (betType==BetTypes.color) checkBetColor(result, player, blockHash, shaPlayer);\n	else if (betType==BetTypes.lowhigh) checkBetLowhigh(result, player, blockHash, shaPlayer);\n	else if (betType==BetTypes.dozen) checkBetDozen(result, player, blockHash, shaPlayer);\n        else if (betType==BetTypes.column) checkBetColumn(result, player, blockHash, shaPlayer);\n        updateMaxBet();  //at the end, update the Max possible bet\n    }\n\n    // function solve Bet once result is determined : sends to winner, adds loss to profit\n    function solveBet(address player, uint8 result, bool win, uint8 multiplier, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        //Update status and record spinned\n        playerStatus[player]=Status.waitingForBet;\n        gambles[gambleIndex[player]].wheelResult=result;\n        gambles[gambleIndex[player]].spinned=true;\n        gambles[gambleIndex[player]].blockSpinned=block.number;\n	uint bet_v = gambles[gambleIndex[player]].wager;\n	\n        if (win)\n        {\n	    gambles[gambleIndex[player]].win=true;\n	    uint win_v = (multiplier-1)*bet_v;\n            lossSinceChange+=win_v;\n            Win(player, result, win_v, blockHash, shaPlayer, gambleIndex[player]);\n            //send win!\n	    //safe send vs potential callstack overflowed spins\n            if (player.send(win_v+bet_v)==false) throw;\n        }\n        else\n        {\n	    Loss(player, result, bet_v-1, blockHash, shaPlayer, gambleIndex[player]);\n            profitSinceChange+=bet_v-1;\n            //send 1 wei to confirm spin if loss\n            if (player.send(1)==false) throw;\n        }\n\n    }\n\n    // checkbeton number(input)\n    // bet type : number\n    // input : chosen number\n    function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool win;\n        //win\n	if (result==gambles[gambleIndex[player]].input)\n	{\n            win=true;  \n        }\n        solveBet(player, result,win,36, blockHash, shaPlayer);\n    }\n\n\n    // checkbet on oddeven\n    // bet type : parity\n    // input : 0 for even, 1 for odd\n    function checkBetParity(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool win;\n        //win\n	if (result%2==gambles[gambleIndex[player]].input && result!=0)\n	{\n            win=true;                \n        }\n        solveBet(player,result,win,2, blockHash, shaPlayer);\n    }\n    \n    // checkbet on lowhigh\n    // bet type : lowhigh\n    // input : 0 low, 1 high\n    function checkBetLowhigh(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool win;\n        //win\n	if (result!=0 && ( (result<19 && gambles[gambleIndex[player]].input==0)\n			   || (result>18 && gambles[gambleIndex[player]].input==1)\n			 ) )\n	{\n            win=true;\n        }\n        solveBet(player,result,win,2, blockHash, shaPlayer);\n    }\n\n    // checkbet on color\n    // bet type : color\n    // input : 0 red, 1 black\n    uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\n    function checkBetColor(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool red;\n        //check if red\n        for (uint8 k; k<18; k++)\n        { \n            if (red_list[k]==result) \n            { \n                red=true; \n                break;\n            }\n        }\n        bool win;\n        //win\n        if ( result!=0\n             && ( (gambles[gambleIndex[player]].input==0 && red)  \n                  || ( gambles[gambleIndex[player]].input==1 && !red)  ) )\n        {\n            win=true;\n        }\n        solveBet(player,result,win,2, blockHash, shaPlayer);\n    }\n\n    // checkbet on dozen\n    // bet type : dozen\n    // input : 0 first, 1 second, 2 third\n    function checkBetDozen(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    { \n        bool win;\n        //win on first dozen\n     	if ( result!=0 &&\n             ( (result<13 && gambles[gambleIndex[player]].input==0)\n     	       ||\n               (result>12 && result<25 && gambles[gambleIndex[player]].input==1)\n               ||\n               (result>24 && gambles[gambleIndex[player]].input==2) ) )\n     	{\n            win=true;                \n        }\n        solveBet(player,result,win,3, blockHash, shaPlayer);\n    }\n\n    // checkbet on column\n    // bet type : column\n    // input : 0 first, 1 second, 2 third\n    function checkBetColumn(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool win;\n        //win\n        if ( result!=0\n             && ( (gambles[gambleIndex[player]].input==0 && result%3==1)  \n                  || ( gambles[gambleIndex[player]].input==1 && result%3==2)\n                  || ( gambles[gambleIndex[player]].input==2 && result%3==0)  ) )\n        {\n            win=true;\n        }\n        solveBet(player,result,win,3, blockHash, shaPlayer);\n    }\n\n\n    //D.A.O. FUNCTIONS\n\n\n    //total casino payroll\n    uint256 payroll;\n    //Profit Loss since last investor change\n    uint256 profitSinceChange;\n    uint256 lossSinceChange;\n    //DAO members struct array (hard capped to 777 members (77 VIP + 700 extra members) )\n    struct Investor\n    {\n	address investor;\n	uint256 time;\n    }	\n    \n    Investor[777] private investors; //array of 777 elements (max Rouleth's members nb.)\n    uint16 setting_maxInvestors = 77; //Initially restricted to 77 VIP Members\n    //Balances of the DAO members\n    mapping (address=>uint256) balance; \n    //lockPeriod\n    //minimum membership time\n    uint256 setting_lockPeriod=30 days ;\n    uint256 setting_minInvestment=100 ether; //min amount to send when using ""invest()""\n    uint256 setting_maxInvestment=200 ether; //max amount to send when using ""invest()""\n    \n    event newInvest(address player, uint invest_v, uint net_invest_v);\n\n\n    //Become a DAO member.\n    function invest()\n    {\n        // update balances before altering the shares            \n        updateBalances();\n        uint256 netInvest;\n        uint excess;\n        // reset the open position counter to values out of bounds\n        // =999 if full\n        uint16 openPosition=999;\n        bool alreadyInvestor;\n        // loop over array to find if already member, \n        // and record a potential openPosition\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\n        { \n            // captures an index of an open position\n            if (investors[k].investor==0) openPosition=k; \n            // captures if already a member \n            else if (investors[k].investor==msg.sender)\n            {\n                alreadyInvestor=true;\n                break;\n            }\n        }\n        //new Member\n        if (!alreadyInvestor)\n        {\n            // check that more than min is sent (variable setting)\n            if (msg.value<setting_minInvestment) throw;\n            // check that less than max is sent (variable setting)\n            // otherwise refund\n            if (msg.value>setting_maxInvestment)\n            {\n                excess=msg.value-setting_maxInvestment;\n  		netInvest=setting_maxInvestment;\n            }\n	    else\n	    {\n		netInvest=msg.value;\n	    }\n            //members can't become a VIP member after the initial period\n            if (setting_maxInvestors >77 && openPosition<77) throw;\n            //case : array not full, record new member\n            else if (openPosition!=999) investors[openPosition]=Investor(msg.sender, now);\n            //case : array full\n            else\n            {\n                throw;\n            }\n        }\n        //already a member\n        else\n        {\n            netInvest=msg.value;\n            //is already above the max balance allowed or is sending\n	    // too much refuse additional invest\n            if (balance[msg.sender]+msg.value>setting_maxInvestment)\n            {\n                throw;\n            }\n	    // this additionnal amount should be of at least 1/5 of ""setting_minInvestment"" (vs spam)\n	    if (msg.value<setting_minInvestment/5) throw;\n        }\n\n        // add to balance of member and to bankroll\n        // 10% of initial 77 VIP members investment is allocated to\n        // game developement provider chosen by Rouleth DAO\n	// 90% to bankroll\n        //share that will be allocated to game dev\n        uint256 developmentAllocation;\n        developmentAllocation=10*netInvest/100; \n        netInvest-=developmentAllocation;\n        //send game development allocation to Rouleth DAO or tech provider\n        if (developer.send(developmentAllocation)==false) throw;\n\n	// Apply extra entry fee once casino has been opened to extra members\n	// that fee will be shared between the VIP members and represents the increment of\n	// market value of their shares in Rouleth to outsiders\n	// warning if a VIP adds to its initial invest after the casino has been opened to \n	// extra members he will pay have to pay this fee.\n        if (setting_maxInvestors>77)\n        {\n            // % of extra member's investment that rewards VIP funders\n            // Starts at 100%\n            // is set by a vote and computed when settings are changed\n            // to allow more investors\n            uint256 entryExtraCost=voted_extraInvestFeesRate*netInvest/100;\n            // add to VIP profit (to be shared by later call by dev.)\n            profitVIP += entryExtraCost;\n            netInvest-=entryExtraCost;\n        }\n        newInvest(msg.sender, msg.value, netInvest);//event log\n        balance[msg.sender]+=netInvest; //add to balance\n        payroll+=netInvest; //add to bankroll\n        updateMaxBet();\n        //refund potential excess\n        if (excess>0) \n        {\n            if (msg.sender.send(excess)==false) throw;\n        }\n    }\n\n\n    //Allows to transfer your DAO account to another address\n    //target should not be currently a DAO member of rouleth\n    //enter twice the address to make sure you make no mistake.\n    //this can't be reversed if you don't own the target account\n    function transferInvestorAccount(address newInvestorAccountOwner, address newInvestorAccountOwner_confirm)\n    noEthSent\n    {\n        if (newInvestorAccountOwner!=newInvestorAccountOwner_confirm) throw;\n        if (newInvestorAccountOwner==0) throw;\n        //retrieve investor ID\n        uint16 investorID=999;\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\n        {\n	    //new address cant be of a current investor\n            if (investors[k].investor==newInvestorAccountOwner) throw;\n\n	    //retrieve investor id\n            if (investors[k].investor==msg.sender)\n            {\n                investorID=k;\n            }\n        }\n        if (investorID==999) throw; //stop if not a member\n	else\n	    //accept and execute change of address\n	    //votes on entryFeesRate are not transfered\n	    //new address should vote again\n	{\n	    balance[newInvestorAccountOwner]=balance[msg.sender];\n	    balance[msg.sender]=0;\n            investors[investorID].investor=newInvestorAccountOwner;\n	}\n    }\n    \n    //***// Withdraw function (only after lockPeriod)\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\n    // if your withdraw brings your balance under the min required,\n    // your balance is fully withdrawn\n    event withdraw(address player, uint withdraw_v);\n    \n    function withdrawInvestment(uint256 amountToWithdrawInWei)\n    noEthSent\n    {\n	//vs spam withdraw min 1/10 of min\n	if (amountToWithdrawInWei!=0 && amountToWithdrawInWei<setting_minInvestment/10) throw;\n        //before withdraw, update balances with the Profit and Loss sinceChange\n        updateBalances();\n	//check that amount requested is authorized  \n	if (amountToWithdrawInWei>balance[msg.sender]) throw;\n        //retrieve member ID\n        uint16 investorID=999;\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\n        {\n            if (investors[k].investor==msg.sender)\n            {\n                investorID=k;\n                break;\n            }\n        }\n        if (investorID==999) throw; //stop if not a member\n        //check if investment lock period is over\n        if (investors[investorID].time+setting_lockPeriod>now) throw;\n        //if balance left after withdraw is still above min accept partial withdraw\n        if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\n        {\n            balance[msg.sender]-=amountToWithdrawInWei;\n            payroll-=amountToWithdrawInWei;\n            //send amount to investor (with security if transaction fails)\n            if (msg.sender.send(amountToWithdrawInWei)==false) throw;\n	    withdraw(msg.sender, amountToWithdrawInWei);\n        }\n        else\n            //if amountToWithdraw=0 : user wants full withdraw\n            //if balance after withdraw is < min invest, withdraw all and delete member\n        {\n            //send amount to member (with security if transaction fails)\n            uint256 fullAmount=balance[msg.sender];\n            payroll-=fullAmount;\n            balance[msg.sender]=0;\n\n	    //delete member\n            delete investors[investorID];\n            if (msg.sender.send(fullAmount)==false) throw;\n   	    withdraw(msg.sender, fullAmount);\n        }\n        updateMaxBet();\n    }\n\n    //***// updates balances with Profit Losses when there is a withdraw/deposit\n    // can be called by dev for accounting when there are no more changes\n    function manualUpdateBalances_only_Dev()\n    noEthSent\n    onlyDeveloper\n    {\n	updateBalances();\n    }\n    function updateBalances() private\n    {\n        //split Profits\n        uint256 profitToSplit;\n        uint256 lossToSplit;\n        if (profitSinceChange==0 && lossSinceChange==0)\n        { return; }\n        \n        else\n        {\n            // Case : Global profit (more win than losses)\n            // 20% fees for game development on global profit (if profit>loss)\n            if (profitSinceChange>lossSinceChange)\n            {\n                profitToSplit=profitSinceChange-lossSinceChange;\n                uint256 developerFees=profitToSplit*20/100;\n                profitToSplit-=developerFees;\n                if (developer.send(developerFees)==false) throw;\n            }\n            else\n            {\n                lossToSplit=lossSinceChange-profitSinceChange;\n            }\n            \n            //share the loss and profits between all DAO members \n            //(proportionnaly. to each one's balance)\n\n            uint totalShared;\n            for (uint16 k=0; k<setting_maxInvestors; k++)\n            {\n                address inv=investors[k].investor;\n                if (inv==0) continue;\n                else\n                {\n                    if (profitToSplit!=0) \n                    {\n                        uint profitShare=(profitToSplit*balance[inv])/payroll;\n                        balance[inv]+=profitShare;\n                        totalShared+=profitShare;\n                    }\n                    else if (lossToSplit!=0) \n                    {\n                        uint lossShare=(lossToSplit*balance[inv])/payroll;\n                        balance[inv]-=lossShare;\n                        totalShared+=lossShare;\n                        \n                    }\n                }\n            }\n            // update bankroll\n	    // and handle potential very small left overs from integer div.\n            if (profitToSplit !=0) \n            {\n		payroll+=profitToSplit;\n		balance[developer]+=profitToSplit-totalShared;\n            }\n            else if (lossToSplit !=0) \n            {\n		payroll-=lossToSplit;\n		balance[developer]-=lossToSplit-totalShared;\n            }\n            profitSinceChange=0; //reset Profit;\n            lossSinceChange=0; //reset Loss ;\n        }\n    }\n    \n\n    //VIP Voting on Extra Invest Fees Rate\n    //mapping records 100 - vote\n    mapping (address=>uint) hundredminus_extraInvestFeesRate;\n    // max fee is 99%\n    // a fee of 100% indicates that the VIP has never voted.\n    function voteOnNewEntryFees_only_VIP(uint8 extraInvestFeesRate_0_to_99)\n    noEthSent\n    {\n        if (extraInvestFeesRate_0_to_99<1 || extraInvestFeesRate_0_to_99>99) throw;\n        hundredminus_extraInvestFeesRate[msg.sender]=100-extraInvestFeesRate_0_to_99;\n    }\n\n    uint256 payrollVIP;\n    uint256 voted_extraInvestFeesRate;\n    function computeResultVoteExtraInvestFeesRate() private\n    {\n        payrollVIP=0;\n        voted_extraInvestFeesRate=0;\n        //compute total payroll of the VIPs\n        //compute vote results among VIPs\n        for (uint8 k=0; k<77; k++)\n        {\n            if (investors[k].investor==0) continue;\n            else\n            {\n                //don't count vote if the VIP never voted\n                if (hundredminus_extraInvestFeesRate[investors[k].investor]==0) continue;\n                else\n                {\n                    payrollVIP+=balance[investors[k].investor];\n                    voted_extraInvestFeesRate+=hundredminus_extraInvestFeesRate[investors[k].investor]*balance[investors[k].investor];\n                }\n            }\n        }\n	//compute final result\n	    if (payrollVIP!=0)\n	    {\n            voted_extraInvestFeesRate=100-voted_extraInvestFeesRate/payrollVIP;\n     	    }\n    }\n\n\n    //Split the profits of the VIP members on extra members' contribution\n    uint profitVIP;\n    function splitProfitVIP_only_Dev()\n    noEthSent\n    onlyDeveloper\n    {\n        payrollVIP=0;\n        //compute total payroll of the VIPs\n        for (uint8 k=0; k<77; k++)\n        {\n            if (investors[k].investor==0) continue;\n            else\n            {\n                payrollVIP+=balance[investors[k].investor];\n            }\n        }\n        //split the profits of the VIP members on extra member's contribution\n	uint totalSplit;\n        for (uint8 i=0; i<77; i++)\n        {\n            if (investors[i].investor==0) continue;\n            else\n            {\n		uint toSplit=balance[investors[i].investor]*profitVIP/payrollVIP;\n                balance[investors[i].investor]+=toSplit;\n		totalSplit+=toSplit;\n            }\n        }\n	//take care of Integer Div remainders, and add to bankroll\n	balance[developer]+=profitVIP-totalSplit;\n	payroll+=profitVIP;\n	//reset var profitVIP\n        profitVIP=0;\n    }\n\n    \n    //INFORMATION FUNCTIONS\n    function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances, uint profit_VIP_since_update_balances)\n    {\n        profit_since_update_balances=profitSinceChange;\n        loss_since_update_balances=lossSinceChange;\n        profit_VIP_since_update_balances=profitVIP;	\n        return;\n    }\n\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\n    {\n        balanceInWei=balance[investor];\n        return;\n    }\n\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\n    {\n        investor=investors[index].investor;\n        endLockPeriod=investors[index].time+setting_lockPeriod;\n        return;\n    }\n    \n    function investmentEntryInfos() constant returns(uint current_max_nb_of_investors, uint investLockPeriod, uint voted_Fees_Rate_on_extra_investments)\n    {\n    	investLockPeriod=setting_lockPeriod;\n    	voted_Fees_Rate_on_extra_investments=voted_extraInvestFeesRate;\n    	current_max_nb_of_investors=setting_maxInvestors;\n    	return;\n    }\n    \n    function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\n    {\n    	maxBet=currentMaxGamble;\n    	blockDelayBeforeSpin=blockDelay;\n    	return ;\n    }\n\n    function getTotalGambles() constant returns(uint _totalGambles)\n    {\n        _totalGambles=totalGambles;\n    	return ;\n    }\n    \n    function getPayroll() constant returns(uint payroll_at_last_update_balances)\n    {\n        payroll_at_last_update_balances=payroll;\n    	return ;\n    }\n\n    \n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin, uint gambleID)\n    {\n        player_status=playerStatus[player];\n        bettype=gambles[gambleIndex[player]].betType;\n        input=gambles[gambleIndex[player]].input;\n        value=gambles[gambleIndex[player]].wager;\n        result=gambles[gambleIndex[player]].wheelResult;\n        wheelspinned=gambles[gambleIndex[player]].spinned;\n        win=gambles[gambleIndex[player]].win;\n        blockNb=gambles[gambleIndex[player]].blockNumber;\n        blockSpin=gambles[gambleIndex[player]].blockSpinned;\n    	gambleID=gambleIndex[player];\n    	return;\n    }\n    \n    function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin)\n    {\n        player=gambles[index].player;\n        bettype=gambles[index].betType;\n        input=gambles[index].input;\n        value=gambles[index].wager;\n        result=gambles[index].wheelResult;\n        wheelspinned=gambles[index].spinned;\n        win=gambles[index].win;\n    	blockNb=gambles[index].blockNumber;\n        blockSpin=gambles[index].blockSpinned;\n    	return;\n    }\n\n} //end of contract",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ルーレットゲームの実装に焦点を当てている。,
1916438,0x8de835efbc0e7110a72451dcc4d06e70cbe599ee,false,false,,,,0x017bc6ceadee1223026a6bb9b6dcdb43f8173abe
1916448,0x1330add1cf2d9f7f4fe83cc8b18e36745aa22156,false,false,,,,0x017bc6ceadee1223026a6bb9b6dcdb43f8173abe
1916458,0x18a672e11d637fffadccc99b152f4895da069601,false,false,,,,0x017bc6ceadee1223026a6bb9b6dcdb43f8173abe
1916776,0x5d56172102a10173f1bc1fec15268f44d507add1,false,false,,,,TOO_SHORT
1917036,0xacda1375bce61289af8d8bbbc98454e8e2e4b5b1,false,false,,,,TOO_SHORT
1917081,0xa7bb41891c1af98fa446b4f42dc75432e5cf9f44,false,false,,,,TOO_SHORT
1917182,0xa11eb62b841d4695df48c51762cae228752a46f0,false,false,,,,TOO_SHORT
1917262,0x7b540469d2cc3851e149a13957feabbab18363ca,false,false,,,,TOO_SHORT
1917509,0x1793a9360593b514f2f69a714bf11828210bbb4a,false,false,,,,TOO_SHORT
1917510,0xc7efdaeb96f4d41112a0bddcb81eccd9bd7aee72,false,false,,,,TOO_SHORT
1917567,0x35f79f83fe60e59a2fe6a79b73c9599f7faf44fc,false,false,,,,TOO_SHORT
1917943,0x31b3f3301816748d0cd33b091cd9314472ee1fe4,false,false,,,,TOO_SHORT
1918150,0x74be2de614fba5306c9ee89b17def45f0c6dbcc4,false,false,,,,TOO_SHORT
1918164,0x3357adecccf7fa4f1ded3067995fbceab7e0deec,false,false,,,,TOO_SHORT
1918483,0xd9899b6e82a7e30d1ed9df7e10384348b0f6b416,false,false,,,,TOO_SHORT
1918487,0x373711ba374700391a48d790e0509d7a72b84c43,false,false,,,,TOO_SHORT
1918491,0x969585e29320dff2ec3a59bf5f21e3988d97017e,false,false,,,,TOO_SHORT
1918505,0x15324b805088706a19cf0422210031c123e2445c,false,false,,,,TOO_SHORT
1918649,0x34086f5d51ef8b895f22a7e6fa376879a5efaa85,false,false,,,,TOO_SHORT
1918697,0xe805d3419e24ec4ecb6c574a7c3f0cc37df8b3a7,false,false,,,,TOO_SHORT
1918776,0x684282178b1d61164febcf9609ca195bef9a33b5,false,false,"/*\nCorporation SmartContract.\ndeveloped by: cryptonomica.net, 2016\n\nused sources:\nhttps://www.ethereum.org/token // example of the token standart\nhttps://github.com/ethereum/EIPs/issues/20 // token standart description\nhttps://www.ethereum.org/dao // voting example\n*/\n\n/*\nHow to deploy (estimated: 1,641,268 gas):\n1) For development: use https://ethereum.github.io/browser-solidity/\n2) For testing on Testnet: Open the default ('Mist') wallet (if you are only testing, go to the menu develop > network > testnet), go to the Contracts tab and then press deploy contract, and on the solidity code box, paste the code above.\n3) For prodaction, like in 2) but on Main Network.\nTo verify your deployed smartcontract source code for public go to:\nhttps://etherscan.io/verifyContract\n*/\n\n// 'interface':\n//  this is expected from another contract,\n//  if it wants to spend tokens (shares) of behalf of the token owner\n//  in our contract\n//  f.e.: a 'multisig' SmartContract for transfering shares from seller\n//  to buyer\ncontract tokenRecipient {\n    function receiveApproval(address _from,     // sharehoder\n                             uint256 _value,    // number of shares\n                             address _share,    // - will be this contract\n                             bytes _extraData); //\n}\n\ncontract Corporation {\n\n    /* Standard public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    /* ------------------- Corporate Stock Ledger ---------- */\n    // Shares, shareholders, balances ect.\n\n    // list of all sharehoders (represented by Ethereum accounts)\n    // in this Corporation's history, # is ID\n    address[] public shareholder;\n    // this helps to find address by ID without loop\n    mapping (address => uint256) public shareholderID;\n    // list of adresses, that who currently own at least share\n    // not public, use getCurrentShareholders()\n    address[] activeShareholdersArray;\n    // balances:\n    mapping (address => uint256) public balanceOf;\n    // shares that have to be managed by external contract\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    /*  --------------- Constructor --------- */\n    // Initializes contract with initial supply tokens to the creator of the contract\n    function Corporation () { // - truffle compiles only no args Constructor\n        uint256 initialSupply = 12000; // shares quantity, constant\n        balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens\n        totalSupply = initialSupply;  // Update total supply\n        name = ""shares""; //tokenName; // Set the name for display purposes\n        symbol = ""sh""; // tokenSymbol; // Set the symbol for display purposes\n        decimals = 0; // Amount of decimals for display purposes\n\n        // -- start corporate stock ledger\n        shareholderID[this] = shareholder.push(this)-1; // # 0\n        shareholderID[msg.sender] = shareholder.push(msg.sender)-1; // #1\n        activeShareholdersArray.push(msg.sender); // add to active shareholders\n    }\n\n    /* --------------- Shares management ------ */\n\n    // This generates a public event on the blockchain that will notify clients. In 'Mist' SmartContract page enable 'Watch contract events'\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function getCurrentShareholders() returns (address[]){\n        delete activeShareholdersArray;\n        for (uint256 i=0; i < shareholder.length; i++){\n            if (balanceOf[shareholder[i]] > 0){\n                activeShareholdersArray.push(shareholder[i]);\n            }\n            } return activeShareholdersArray;\n        }\n\n    /*  -- can be used to transfer shares to new contract\n    together with getCurrentShareholders() */\n    function getBalanceByAdress(address _address) returns (uint256) {\n        return balanceOf[_address];\n    }\n\n    function getMyShareholderID() returns (uint256) {\n        return shareholderID[msg.sender];\n    }\n\n    function getShareholderAdressByID(uint256 _id) returns (address){\n        return shareholder[_id];\n    }\n\n    function getMyShares() returns (uint256) {\n        return balanceOf[msg.sender];\n    }\n\n\n    /* ---- Transfer shares to another adress ----\n    (shareholder's address calls this)\n    */\n    function transfer(address _to, uint256 _value) {\n        // check arguments:\n        if (_value < 1) throw;\n        if (this == _to) throw; // do not send shares to contract itself;\n        if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough\n\n        // make transaction\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\n        balanceOf[_to] += _value;       // Add the same to the recipient\n\n        // if new address, add it to shareholders history (stock ledger):\n        if (shareholderID[_to] == 0){ // ----------- check if works\n            shareholderID[_to] = shareholder.push(_to)-1;\n        }\n\n        // Notify anyone listening that this transfer took place\n        Transfer(msg.sender, _to, _value);\n    }\n\n    /* Allow another contract to spend some shares in your behalf\n    (shareholder calls this) */\n    function approveAndCall(address _spender, // another contract's adress\n                            uint256 _value, // number of shares\n                            bytes _extraData) // data for another contract\n    returns (bool success) {\n        // msg.sender - account owner who gives allowance\n        // _spender   - address of another contract\n        // it writes in ""allowance"" that this owner allows another\n        // contract (_spender) to spend thi amont (_value) of shares\n        // in his behalf\n        allowance[msg.sender][_spender] = _value;\n        // 'spender' is another contract that implements code\n        //  prescribed in 'shareRecipient' above\n        tokenRecipient spender = tokenRecipient(_spender);\n        // this contract calls 'receiveApproval' function\n        // of another contract to send information about\n        // allowance\n        spender.receiveApproval(msg.sender, // shares owner\n                                _value,     // number of shares\n                                this,       // this contract's adress\n                                _extraData);// data from shares owner\n        return true;\n    }\n\n    /* this function can be called from another contract, after it\n    have allowance to transfer shares in behalf of sharehoder  */\n    function transferFrom(address _from,\n                          address _to,\n                          uint256 _value)\n    returns (bool success) {\n\n        // Check arguments:\n        // should one share or more\n        if (_value < 1) throw;\n        // do not send shares to this contract itself;\n        if (this == _to) throw;\n        // Check if the sender has enough\n        if (balanceOf[_from] < _value) throw;\n\n        // Check allowance\n        if (_value > allowance[_from][msg.sender]) throw;\n\n        // if transfer to new address -- add him to ledger\n        if (shareholderID[_to] == 0){\n            shareholderID[_to] = shareholder.push(_to)-1; // push function returns the new length\n        }\n\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n\n        // Change allowances correspondingly\n        allowance[_from][msg.sender] -= _value;\n        // Notify anyone listening that this transfer took place\n        Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n\n    /*  --------- Voting  --------------  */\n    // we only count 'yes' votes, not voting 'yes'\n    // considered as voting 'no' (as stated in Bylaws)\n\n    // each proposal should contain it's text\n    // index of text in this array is a proposal ID\n    string[] public proposalText;\n    // proposalID => (shareholder => ""if already voted for this proposal"")\n    mapping (uint256 => mapping (address => bool)) voted;\n    // proposalID => addresses voted 'yes'\n    // exact number of votes according to shares will be counted\n    // after deadline\n    mapping (uint256 => address[]) public votes;\n    // proposalID => deadline\n    mapping (uint256 => uint256) public deadline;\n    // proposalID => final 'yes' votes\n    mapping (uint256 => uint256) public results;\n    // proposals of every shareholder\n    mapping (address => uint256[]) public proposalsByShareholder;\n\n\n    event ProposalAdded(uint256 proposalID,\n                        address initiator,\n                        string description,\n                        uint256 deadline);\n\n    event VotingFinished(uint256 proposalID, uint256 votes);\n\n    function makeNewProposal(string _proposalDescription,\n                             uint256 _debatingPeriodInMinutes)\n    returns (uint256){\n        // only shareholder with one or more shares can make a proposal\n        // !!!! can be more then one share required\n        if (balanceOf[msg.sender] < 1) throw;\n\n        uint256 id = proposalText.push(_proposalDescription)-1;\n        deadline[id] = now + _debatingPeriodInMinutes * 1 minutes;\n\n        // add to proposals of this shareholder:\n        proposalsByShareholder[msg.sender].push(id);\n\n        // initiator always votes 'yes'\n        votes[id].push(msg.sender);\n        voted[id][msg.sender] = true;\n\n        ProposalAdded(id, msg.sender, _proposalDescription, deadline[id]);\n\n        return id; // returns proposal id\n    }\n\n    function getMyProposals() returns (uint256[]){\n        return proposalsByShareholder[msg.sender];\n    }\n\n    function voteForProposal(uint256 _proposalID) returns (string) {\n\n        // if no shares currently owned - no right to vote\n        if (balanceOf[msg.sender] < 1) return ""no shares, vote not accepted"";\n\n        // if already voted - throw, else voting can be spammed\n        if (voted[_proposalID][msg.sender]){\n            return ""already voted, vote not accepted"";\n        }\n\n        // no votes after deadline\n        if (now > deadline[_proposalID] ){\n            return ""vote not accepted after deadline"";\n        }\n\n        // add to list of voted 'yes'\n        votes[_proposalID].push(msg.sender);\n        voted[_proposalID][msg.sender] = true;\n        return ""vote accepted"";\n    }\n\n    // to count votes this transaction should be started manually\n    // from _any_ Ethereum address after deadline\n    function countVotes(uint256 _proposalID) returns (uint256){\n\n        // if not after deadline - throw\n        if (now < deadline[_proposalID]) throw;\n\n        // if already counted return result;\n        if (results[_proposalID] > 0) return results[_proposalID];\n\n        // else should count results and store in public variable\n        uint256 result = 0;\n        for (uint256 i = 0; i < votes[_proposalID].length; i++){\n\n            address voter = votes[_proposalID][i];\n            result = result + balanceOf[voter];\n        }\n\n        // Log and notify anyone listening that this voting finished\n        // with 'result' - number of 'yes' votes\n        VotingFinished(_proposalID, result);\n\n        return result;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。コメントが多く、教育的な要素がある。,
1918851,0x61ccad1535a8556bc878193dfe129e30f4cbfe4b,false,false,,,,TOO_SHORT
1919071,0xefd5cbf98d0e919ab1727462e4b95a7a1a24b630,false,false,,,,TOO_SHORT
1919072,0x9e5a7736e6b2cf34696f480b4f5ec00efe17ecfb,false,false,,,,TOO_SHORT
1919268,0x299b381812ca401827f67b6597ebcab09ddf2639,false,false,,,,TOO_SHORT
1919491,0xd69a5cc5023e5108a85dde1a2b55ff4af400ce82,false,false,,,,TOO_SHORT
1919680,0x0c43f14bc631e328077e3be183f11d543256c446,false,false,,,,TOO_SHORT
1919734,0x1946c91f55e3c098ceb8b1d5a395e50f71867861,false,false,,,,TOO_SHORT
1919754,0x223147fe13a95947e79968e895d5708c90ddc4e6,false,false,,,,TOO_SHORT
1919766,0x4b902704026d14117b5e9efa7fdafdff4ba610ef,false,false,"contract DaoAccount\n{\n	/**************************\n			    Constants\n	***************************/\n\n	uint256 constant tokenPrice = 1000000000000000; // 1 finney\n\n	/**************************\n					Events\n	***************************/\n\n	// No events\n	\n	/**************************\n	     Public variables\n	***************************/\n\n  uint256 public tokenBalance; // number of tokens in this account\n\n	/**************************\n	     Private variables\n	***************************/\n\n  address owner;        // owner of the otkens\n	address daoChallenge; // the DaoChallenge this account belongs to\n\n  // Owner of the challenge with backdoor access.\n  // Remove for a real DAO contract:\n  address challengeOwner;\n\n	/**************************\n			     Modifiers\n	***************************/\n\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\n\n	/**************************\n	 Constructor and fallback\n	**************************/\n\n  function DaoAccount (address _owner, address _challengeOwner) {\n    owner = _owner;\n    daoChallenge = msg.sender;\n\n    // Remove for a real DAO contract:\n    challengeOwner = _challengeOwner;\n	}\n\n  // Only owner can fund:\n	function () onlyOwner returns (uint256 newBalance){\n		uint256 amount = msg.value;\n\n		// No fractional tokens:\n		if (amount % tokenPrice != 0) {\n			throw;\n		}\n\n    uint256 tokens = amount / tokenPrice;\n\n		tokenBalance += tokens;\n\n    return tokenBalance;\n	}\n\n	/**************************\n	     Private functions\n	***************************/\n\n	// This uses call.value()() rather than send(), but only sends to msg.sender\n  // who is also the owner.\n	function withdrawEtherOrThrow(uint256 amount) private {\n    if (msg.sender != owner) throw;\n		bool result = owner.call.value(amount)();\n		if (!result) {\n			throw;\n		}\n	}\n\n	/**************************\n			 Public functions\n	***************************/\n\n	function refund() noEther onlyOwner {\n		if (tokenBalance == 0) throw;\n		tokenBalance = 0;\n		withdrawEtherOrThrow(tokenBalance * tokenPrice);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyChallengeOwner {\n		suicide(challengeOwner);\n	}\n}\ncontract DaoChallenge\n{\n	/**************************\n					Constants\n	***************************/\n\n	// No Constants\n\n	/**************************\n					Events\n	***************************/\n\n	event notifyTerminate(uint256 finalBalance);\n\n	/**************************\n	     Public variables\n	***************************/\n\n	/**************************\n			 Private variables\n	***************************/\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address owner;\n\n	mapping (address => DaoAccount) private daoAccounts;\n\n	/**************************\n					 Modifiers\n	***************************/\n\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	/**************************\n	 Constructor and fallback\n	**************************/\n\n	function DaoChallenge () {\n		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () noEther {\n	}\n\n	/**************************\n	     Private functions\n	***************************/\n\n	// No private functions\n\n	/**************************\n	     Public functions\n	***************************/\n\n	function createAccount () noEther returns (DaoAccount account) {\n		address accountOwner = msg.sender;\n		address challengeOwner = owner; // Don't use in a real DAO\n\n		// One account per address:\n		if(daoAccounts[accountOwner] != DaoAccount(0x00)) throw;\n\n		daoAccounts[accountOwner] = new DaoAccount(accountOwner, challengeOwner);\n		return daoAccounts[accountOwner];\n	}\n\n	function myAccount () noEther returns (DaoAccount) {\n		address accountOwner = msg.sender;\n		return daoAccounts[accountOwner];\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyOwner {\n		notifyTerminate(this.balance);\n		suicide(owner);\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。コメントが多いが、芸術的要素は少ない。,
1919996,0x341e790174e3a4d35b65fdc067b6b5634a61caea,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\n/**\n * \n */\ncontract ReplaySafeSplit {\n    // Fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    // Splits the funds into 2 addresses\n    function split(address targetFork, address targetNoFork) returns(bool) {\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\n            return true;\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\n            return true;\n        }\n        return false;\n    }\n\n    // Reject value transfers.\n    function() {\n        throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1920012,0x23141df767233776f7cbbec497800ddedaa4c684,false,false,"// Simple smart contract that allows anyone to send ether from one address to\n// another in certain branch of the blockchain only.  This contract is supposed\n// to be used after hard forks to clearly separate ""classic"" ether from ""new""\n// ether.\ncontract BranchSender {\n  // Is set to true if and only if we are currently in the ""right"" branch of\n  // the blockchain, i.e. the branch this contract allows sending money in.\n  bool public isRightBranch;\n\n  // Instantiate the contract.\n  //\n  // @param blockNumber number of block in the ""right"" blockchain whose hash is\n  //        known\n  // @param blockHash known hash of the given block in the ""right"" blockchain\n  function BranchSender(uint blockNumber, bytes32 blockHash) {\n    if (msg.value > 0) throw; // We do not accept any money here\n\n    isRightBranch = (block.number < 256 || blockNumber > block.number - 256) &&\n                    (blockNumber < block.number) &&\n                    (block.blockhash (blockNumber) == blockHash);\n  }\n\n  // Default function just throw.\n  function () {\n    throw;\n  }\n\n  // If we are currently in the ""right"" branch of the blockchain, send money to\n  // the given recipient.  Otherwise, throw.\n  //\n  // @param recipient address to send money to if we are currently in the\n  //                  ""right"" branch of the blockchain\n  function send (address recipient) {\n    if (!isRightBranch) throw;\n    if (!recipient.send (msg.value)) throw;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1920048,0x24d7d1d0445271982c7a908e6db3f24808fd807d,false,false,,,,TOO_SHORT
1920094,0x080cd1164ff3af3d00e43e3d5e5266c5355cc3fe,false,false,,,,TOO_SHORT
1920161,0xc5841ad0414d1b3d62066fdd75aa01a587207e24,false,false,,,,TOO_SHORT
1920242,0x5de9658284d2fb76a82315105a4d750624ae1a2b,false,false,,,,TOO_SHORT
1920356,0x8dabdd9168bcd9d5f0c7c5b154e59cc3dbccefc1,false,false,,,,TOO_SHORT
1920386,0x975417e8bb16907b477694b9e16e5d52d15fcc56,false,false,,,,TOO_SHORT
1920419,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract ReplaySafeSplit {\n    // Fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    // Splits the funds into 2 addresses\n    function split(address targetFork, address targetNoFork) returns(bool) {\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\n            return true;\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\n            return true;\n        }\n        throw; // don't accept value transfer, otherwise it would be trapped.\n    }\n\n    // Reject value transfers.\n    function() {\n        throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1920434,0xeae09079205b9fad1d0981ffa2a41ab374513dd5,false,false,,,,TOO_SHORT
1920538,0xfb82f4e99865bf2e7f70fd8365dee0bedb1a6056,false,false,,,,TOO_SHORT
1920585,0x72ed54a6d4be7d45a2b7784b7facec8d9d868e4c,false,false,,,,TOO_SHORT
1920607,0xba1daf47fffa5b55e9dc9eda3417b1b3f2f4e4e3,false,false,,,,TOO_SHORT
1920630,0x82fa8ef17964f6b4fb6e1e4146f8d59a2075aa70,false,false,,,,0x341e790174e3a4d35b65fdc067b6b5634a61caea
1920644,0xe7aa527c6cab0c14bbc9b4b9955820212d9c3363,false,false,,,,TOO_SHORT
1920670,0x2e2f3d58b97e29696c90dd6c2702738a493eaadc,false,false,,,,TOO_SHORT
1920902,0xaa9e1390d07bf6fb278872165b17182ab80291d0,false,false,,,,TOO_SHORT
1920916,0x77f7d7e412982d336bff29dfedc9bbddb7885775,false,false,,,,TOO_SHORT
1920940,0x1dcdaf31a3c94fd85696eeb8102341198bcdb44f,false,false,,,,TOO_SHORT
1920963,0x5446f23252e1d9653e57f9ecd1c37919720d8f43,false,false,,,,TOO_SHORT
1921178,0xf644d91e90a663cd0f12b9eb30e6aaa8e2839dd5,false,false,,,,TOO_SHORT
1921190,0x7b0d89b751e91d3dcd1caa3081cfd2d4f841e40f,false,false,,,,TOO_SHORT
1921235,0x4d0b186c2213ad9e03236fb66102f8d6801dd624,false,false,,,,TOO_SHORT
1921412,0xc19c287b8fb68da465487633553b7b8f7f1cfebd,false,false,,,,TOO_SHORT
1921526,0x211b3d15a8e36de1362ce0584d61d2b7aa80ea94,false,false,,,,TOO_SHORT
1921578,0xcdebf698ad9b75a071646cf70e820ac83324a899,false,false,,,,TOO_SHORT
1921696,0x5c028ef294c50a2d4611cc09f08495b2b0f6fd5a,false,false,,,,TOO_SHORT
1921837,0x52965f9bd9d0f2bbea9b5a9c155a455d0e58fe25,false,false,,,,TOO_SHORT
1921898,0x8d30ceec8fd440dac67dddf901f334cdd5f67397,false,false,,,,TOO_SHORT
1921968,0xc3516551c57370bb4f6755cd9b49ec65cffd2e1a,false,false,,,,TOO_SHORT
1921992,0xdd5fd143b6b8359665c1c5b8282328e0495b23a7,false,false,,,,TOO_SHORT
1922008,0x6f02710036649d12df4027205752720b06a63b23,false,false,,,,TOO_SHORT
1922022,0xba358a90bc7389da684304153ff7df03ca0c0be4,false,false,,,,TOO_SHORT
1922046,0xd5c64535f370fe00c5c73b8a42e4943dff4806b7,false,false,,,,TOO_SHORT
1922057,0x3cfc056462a06d3d146a2c6e73e5a48ea3798f24,false,false,,,,TOO_SHORT
1922238,0xf609f22fe8ae19cbb3f18c8101cda3b02e6e6a0d,false,false,,,,TOO_SHORT
1922498,0x019291fdc170d09c2deb3180802e8a1ecb084b60,false,false,,,,TOO_SHORT
1922590,0xf3a8593957640dec1459ae0f43f2caa2e6a022c2,false,false,,,,TOO_SHORT
1922624,0xf302c83e19757c1dbdea16731db570848f706c1d,false,false,,,,TOO_SHORT
1922880,0x69ff4582151878c4f866f8032b397954ab692b09,false,false,,,,TOO_SHORT
1922957,0x946f4a4c05c6e821f0eaedb1280b94bead103c3e,false,false,,,,TOO_SHORT
1923199,0xec96c9bbc59fd480f6a72dddc54aae21bcafec55,false,false,,,,TOO_SHORT
1923379,0x8f058d8a161f5be34b47149d70c47d6c60252eee,false,false,"contract AmIOnTheFork {\n    bool public forked = false;\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    // Check the fork condition during creation of the contract.\n    // This function should be called between block 1920000 and 1921200.\n    // Approximately between 2016-07-20 12:00:00 UTC and 2016-07-20 17:00:00 UTC.\n    // After that the status will be locked in.\n    function update() {\n        if (block.number >= 1920000 && block.number <= 1921200) {\n            forked = darkDAO.balance < 3600000 ether;\n        }\n    }\n    function() {\n        throw;\n    }\n}\ncontract ReplaySafeSplit {\n    // Fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    // Splits the funds into 2 addresses\n    function split(address targetFork, address targetNoFork) returns(bool) {\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\n            return true;\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\n            return true;\n        }\n        throw;\n    }\n\n    // Reject value transfers.\n    function() {\n        throw;\n    }\n}",1,DAOハードフォーク対応の実用的なスマートコントラクトで、芸術的要素は少ないです。,
1923436,0x9554efa1669014c25070bc23c2df262825704228,false,false,,,,0x8f058d8a161f5be34b47149d70c47d6c60252eee
1923633,0x84e37d39a263866691e285f23df9650487d728f5,false,false,,,,0x2bd2326c993dfaef84f696526064ff22eba5b362
1924257,0x815e66ae1f84253e6eaefb684a642c4ad859cd21,false,false,,,,TOO_SHORT
1924648,0x7455a6e2364022349923de802686ea80dd62d9b4,false,false,,,,TOO_SHORT
1924919,0xfa81ef9d0b787326ed071e123d38fa9e81be3ab5,false,false,,,,0x341e790174e3a4d35b65fdc067b6b5634a61caea
1924940,0x1daaf5180a87d4ce35a281b61832b362dd4c9401,false,false,,,,TOO_SHORT
1924983,0x606fdaa55514203c4f60030df839d08d0a2347a1,false,false,,,,TOO_SHORT
1925153,0xf53e7f01371c6fc0e1c821d3c3c8b30be366bb6e,false,false,"contract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\ncontract token {\n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function token(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol\n        ) {\n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n        totalSupply = initialSupply;                        // Update total supply\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        decimals = decimalUnits;                            // Amount of decimals for display purposes\n    }\n\n    /* Send coins */\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n\n    /* Allow another contract to spend some tokens in your behalf */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        tokenRecipient spender = tokenRecipient(_spender);\n        spender.receiveApproval(msg.sender, _value, this, _extraData);\n        return true;\n    }\n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}\n\ncontract MyAdvancedToken is owned, token {\n\n    uint256 public totalSupply;\n\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyAdvancedToken(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        address centralMinter\n    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {\n        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)\n        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens\n    }\n\n    /* Send coins */\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if frozen\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n\n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if frozen            \n        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, owner, mintedAmount);\n        Transfer(owner, target, mintedAmount);\n    }\n\n    function freezeAccount(address target, bool freeze) onlyOwner {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1925470,0xa5d25d38b95a94d30a8a73abe0523f3d293a9280,false,false,,,,TOO_SHORT
1925903,0xc0bb33aef27f9f103b27649b77b8aa8e1bdccb64,false,false,,,,TOO_SHORT
1925938,0x2837dba98c34c2db46cffd0856cdb42259709bc8,false,false,,,,TOO_SHORT
1925997,0xbe4d7ae697e2f0cd6e5f509e4a5dd89899a925af,false,false,,,,TOO_SHORT
1926004,0x1f8e77083b22d9c2a69d740ac071e637ba6ba3a0,false,false,,,,TOO_SHORT
1926069,0xc355aeed8f53e3082347f48c8ff1dace9435ccfb,false,false,,,,TOO_SHORT
1926230,0x63bf4b83d9888bfffade6e1d1a3c03208a6872d4,false,false,contract AmIOnTheFork {\n    bool public forked = false;\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    // Check the fork condition during creation of the contract.\n    // This function should be called between block 1920000 and 1921200.\n    // Approximately between 2016-07-20 12:00:00 UTC and 2016-07-20 17:00:00 UTC.\n    // After that the status will be locked in.\n    function update() {\n        if (block.number >= 1920000 && block.number <= 1921200) {\n            forked = darkDAO.balance < 3600000 ether;\n        }\n    }\n    function() {\n        throw;\n    }\n}\n\ncontract MyReplaySafeProxy {\n    \n    address eth_target = 0x447F7556C8D2E5281438358087DdD368B6bCb824; \n    address ethc_target = 0xCd76f273d307551016452724241EA3C1775270a2;\n\n	address public target;\n	\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    \n    function MyReplaySafeProxy () {\n			if (amIOnTheFork.forked())\n				target =  eth_target;\n			else\n				target =  ethc_target;\n    }\n\n    function() {\n        if(!target.send(msg.value))\n            throw;\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1926243,0xf1101db4c9dd26bdace9bc7e30393f80c7b5e6c6,false,false,,,,0x63bf4b83d9888bfffade6e1d1a3c03208a6872d4
1926331,0x7bd3e1faa406f248cb712f5a59488dfd60166c69,false,false,,,,TOO_SHORT
1926539,0x4ba620453a2e2ef058e2a6d33995aaac99055b7d,false,false,,,,TOO_SHORT
1926867,0x774f7a744743ca926970ee977569ec07c8326d13,false,false,,,,TOO_SHORT
1926874,0x9361062e0c2944d996c447e58c5da51999ef673a,false,false,,,,TOO_SHORT
1926895,0x2b8c511f952fcd994297f703848fd93b13875a38,false,false,,,,TOO_SHORT
1927021,0x3d3f34b270ef27c7bcd490401f899949bd7305cf,false,false,,,,TOO_SHORT
1927032,0xbfb7c2a2936043e780b7069fa2f6bd4637c3a437,false,false,,,,TOO_SHORT
1927326,0xe19873a3f668127f07dabc100f8d4aeb77a6b2ee,false,false,,,,TOO_SHORT
1927368,0xcca63a5e33059a86948d05a9e6c4ce57ae0f5384,false,false,,,,TOO_SHORT
1927615,0x3b19e77570a71ec32470c1144a9d3a86203ea3d5,false,false,,,,TOO_SHORT
1927629,0x86de3e392aa72cb959999579d5aa7dd49c128283,false,false,,,,TOO_SHORT
1927787,0x0e3358ca80a0e6ef98c49747e2533b525d2a7a3b,false,false,,,,TOO_SHORT
1927903,0x5f1624c38055329ff3dce95c454b5d5eb0b41486,false,false,,,,TOO_SHORT
1928277,0xf41596d6d899fc10d9ab2c4a496e2baadec4433f,false,false,,,,TOO_SHORT
1928351,0x1255e15350de7816873f3c8b4769f10f1f847eec,false,false,,,,TOO_SHORT
1928541,0x60206fb0ed63d3cf3882fd6e8526fcca4c5f7eb6,false,false,,,,TOO_SHORT
1928549,0x3b680bac0f23a34c8f88aa37856d6fe67d7a8f00,false,false,,,,TOO_SHORT
1928583,0x52adc16e0cfb7aff152ad8a9c34eda4b6b1c71c7,false,false,,,,TOO_SHORT
1928680,0x855e73839644fe6f333ff465f01dc21fcb0ae1d2,false,false,,,,TOO_SHORT
1928880,0xd9fcb4528e22753bd897a9ba565b4e438d1735e1,false,false,,,,TOO_SHORT
1928969,0x794d8dcff1a88fa895b12260de2e40b3455ab524,false,false,,,,TOO_SHORT
1929070,0x4d7471888658525b1ec4b3419a15ac51a20e0c20,false,false,,,,TOO_SHORT
1929272,0x134e655f9616a315b1c28f989fb501e6180511ad,false,false,,,,TOO_SHORT
1929406,0x38e88b0cf5d2b987e3173c1d1924faf7f8ab9e95,false,false,,,,TOO_SHORT
1929460,0x2764ba5da8a60257e20dfd4e8991782210f00a97,false,false,,,,TOO_SHORT
1929696,0xd349f41aea6a440e81512b4ce98c3f368c5db23d,false,false,,,,TOO_SHORT
1929702,0x135b3689ab7197ba70fbbea1acfc4b4bf60027b8,false,false,,,,TOO_SHORT
1929716,0x9aeedf99792efd64f5227830515a82c61753f801,false,false,,,,TOO_SHORT
1929717,0x3d805264f78e0a0e8be047da756b70446f551712,false,false,,,,TOO_SHORT
1929805,0x8d562070408aa50f2cce01d17b39437583f53d8d,false,false,,,,TOO_SHORT
1930064,0x27dd490b7a29e11bab6c736b1a582d896375c91e,false,false,,,,TOO_SHORT
1930134,0x875174648f4f5ee514248cbfda6fd9705c446223,false,false,,,,TOO_SHORT
1930234,0x66ed73346b839c4b50438268972b94b5ecd66387,false,false,,,,TOO_SHORT
1930272,0xb3ba7669b1232c6020b29dd470fc6a6450fde905,false,false,,,,TOO_SHORT
1930480,0x0f02e959617b3e24d077fcb8b0d9b780cb6fcf55,false,false,,,,TOO_SHORT
1930739,0x7f89e3de2735a75ff5a55e151e24ddc58ee255af,false,false,,,,TOO_SHORT
1930912,0x5c353a8dde7c400a84a673719cc0a0800108ea73,false,false,"contract Assertive {\n    function assert(bool assertion) internal {\n        if (!assertion) throw;\n    }\n}\n\ncontract MutexUser {\n    bool private lock;\n    modifier exclusive {\n        if (lock) throw;\n        lock = true;\n        _\n        lock = false;\n    }\n}\ncontract ERC20 {\n    function totalSupply() constant returns (uint);\n    function balanceOf(address who) constant returns (uint);\n    function allowance(address owner, address spender) constant returns (uint);\n\n    function transfer(address to, uint value) returns (bool ok);\n    function transferFrom(address from, address to, uint value) returns (bool ok);\n    function approve(address spender, uint value) returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract FallbackFailer {\n  function () {\n    throw;\n  }\n}\n\n// A simple direct exchange order manager.\n\ncontract EventfulMarket {\n    event ItemUpdate( uint id );\n    event Trade( uint sell_how_much, address indexed sell_which_token,\n                 uint buy_how_much, address indexed buy_which_token );\n}\ncontract SimpleMarket is EventfulMarket\n                       , Assertive\n                       , FallbackFailer\n                       , MutexUser\n{\n    struct OfferInfo {\n        uint sell_how_much;\n        ERC20 sell_which_token;\n        uint buy_how_much;\n        ERC20 buy_which_token;\n        address owner;\n        bool active;\n    }\n    mapping( uint => OfferInfo ) public offers;\n\n    uint public last_offer_id;\n\n    function next_id() internal returns (uint) {\n        last_offer_id++; return last_offer_id;\n    }\n\n    modifier can_offer {\n        _\n    }\n    modifier can_buy(uint id) {\n        assert(isActive(id));\n        _\n    }\n    modifier can_cancel(uint id) {\n        assert(isActive(id));\n        assert(getOwner(id) == msg.sender);\n        _\n    }\n    function isActive(uint id) constant returns (bool active) {\n        return offers[id].active;\n    }\n    function getOwner(uint id) constant returns (address owner) {\n        return offers[id].owner;\n    }\n    function getOffer( uint id ) constant returns (uint, ERC20, uint, ERC20) {\n      var offer = offers[id];\n      return (offer.sell_how_much, offer.sell_which_token,\n              offer.buy_how_much, offer.buy_which_token);\n    }\n\n    // non underflowing subtraction\n    function safeSub(uint a, uint b) internal returns (uint) {\n        assert(b <= a);\n        return a - b;\n    }\n    // non overflowing multiplication\n    function safeMul(uint a, uint b) internal returns (uint c) {\n        c = a * b;\n        assert(a == 0 || c / a == b);\n    }\n\n    function trade( address seller, uint sell_how_much, ERC20 sell_which_token,\n                    address buyer,  uint buy_how_much,  ERC20 buy_which_token )\n        internal\n    {\n        var seller_paid_out = buy_which_token.transferFrom( buyer, seller, buy_how_much );\n        assert(seller_paid_out);\n        var buyer_paid_out = sell_which_token.transfer( buyer, sell_how_much );\n        assert(buyer_paid_out);\n        Trade( sell_how_much, sell_which_token, buy_how_much, buy_which_token );\n    }\n\n    // ---- Public entrypoints ---- //\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer( uint sell_how_much, ERC20 sell_which_token\n                  , uint buy_how_much,  ERC20 buy_which_token )\n        can_offer\n        exclusive\n        returns (uint id)\n    {\n        assert(sell_how_much > 0);\n        assert(sell_which_token != ERC20(0x0));\n        assert(buy_how_much > 0);\n        assert(buy_which_token != ERC20(0x0));\n        assert(sell_which_token != buy_which_token);\n\n        OfferInfo memory info;\n        info.sell_how_much = sell_how_much;\n        info.sell_which_token = sell_which_token;\n        info.buy_how_much = buy_how_much;\n        info.buy_which_token = buy_which_token;\n        info.owner = msg.sender;\n        info.active = true;\n        id = next_id();\n        offers[id] = info;\n\n        var seller_paid = sell_which_token.transferFrom( msg.sender, this, sell_how_much );\n        assert(seller_paid);\n\n        ItemUpdate(id);\n    }\n    // Accept given `quantity` of an offer. Transfers funds from caller to\n    // offer maker, and from market to caller.\n    function buy( uint id, uint quantity )\n        can_buy(id)\n        exclusive\n        returns ( bool success )\n    {\n        // read-only offer. Modify an offer by directly accessing offers[id]\n        OfferInfo memory offer = offers[id];\n\n        // inferred quantity that the buyer wishes to spend\n        uint spend = safeMul(quantity, offer.buy_how_much) / offer.sell_how_much;\n\n        if ( spend > offer.buy_how_much || quantity > offer.sell_how_much ) {\n            // buyer wants more than is available\n            success = false;\n        } else if ( spend == offer.buy_how_much && quantity == offer.sell_how_much ) {\n            // buyer wants exactly what is available\n            delete offers[id];\n\n            trade( offer.owner, quantity, offer.sell_which_token,\n                   msg.sender, spend, offer.buy_which_token );\n\n            ItemUpdate(id);\n            success = true;\n        } else if ( spend > 0 && quantity > 0 ) {\n            // buyer wants a fraction of what is available\n            offers[id].sell_how_much = safeSub(offer.sell_how_much, quantity);\n            offers[id].buy_how_much = safeSub(offer.buy_how_much, spend);\n\n            trade( offer.owner, quantity, offer.sell_which_token,\n                    msg.sender, spend, offer.buy_which_token );\n\n            ItemUpdate(id);\n            success = true;\n        } else {\n            // buyer wants an unsatisfiable amount (less than 1 integer)\n            success = false;\n        }\n    }\n    // Cancel an offer. Refunds offer maker.\n    function cancel( uint id )\n        can_cancel(id)\n        exclusive\n        returns ( bool success )\n    {\n        // read-only offer. Modify an offer by directly accessing offers[id]\n        OfferInfo memory offer = offers[id];\n        delete offers[id];\n\n        var seller_refunded = offer.sell_which_token.transfer( offer.owner , offer.sell_how_much );\n        assert(seller_refunded);\n\n        ItemUpdate(id);\n        success = true;\n    }\n}\n\n// Simple Market with a market lifetime. When the lifetime has elapsed,\n// offers can only be cancelled (offer and buy will throw).\n\ncontract ExpiringMarket is SimpleMarket {\n    uint public close_time;\n    function ExpiringMarket(uint lifetime) {\n        close_time = getTime() + lifetime;\n    }\n    function getTime() constant returns (uint) {\n        return block.timestamp;\n    }\n    function isClosed() constant returns (bool closed) {\n        return (getTime() > close_time);\n    }\n\n    // after market lifetime has elapsed, no new offers are allowed\n    modifier can_offer {\n        assert(!isClosed());\n        _\n    }\n    // after close, no new buys are allowed\n    modifier can_buy(uint id) {\n        assert(isActive(id));\n        assert(!isClosed());\n        _\n    }\n    // after close, anyone can cancel an offer\n    modifier can_cancel(uint id) {\n        assert(isActive(id));\n        assert(isClosed() || (msg.sender == getOwner(id)));\n        _\n    }\n}\n\n// Flat file implementation of `dappsys/token/base.sol::DSTokenBase`\n\n// Everything throws instead of returning false on failure.\n\ncontract ERC20Base is ERC20\n{\n    mapping( address => uint ) _balances;\n    mapping( address => mapping( address => uint ) ) _approvals;\n    uint _supply;\n    function ERC20Base( uint initial_balance ) {\n        _balances[msg.sender] = initial_balance;\n        _supply = initial_balance;\n    }\n    function totalSupply() constant returns (uint supply) {\n        return _supply;\n    }\n    function balanceOf( address who ) constant returns (uint value) {\n        return _balances[who];\n    }\n    function transfer( address to, uint value) returns (bool ok) {\n        if( _balances[msg.sender] < value ) {\n            throw;\n        }\n        if( !safeToAdd(_balances[to], value) ) {\n            throw;\n        }\n        _balances[msg.sender] -= value;\n        _balances[to] += value;\n        Transfer( msg.sender, to, value );\n        return true;\n    }\n    function transferFrom( address from, address to, uint value) returns (bool ok) {\n        // if you don't have enough balance, throw\n        if( _balances[from] < value ) {\n            throw;\n        }\n        // if you don't have approval, throw\n        if( _approvals[from][msg.sender] < value ) {\n            throw;\n        }\n        if( !safeToAdd(_balances[to], value) ) {\n            throw;\n        }\n        // transfer and return true\n        _approvals[from][msg.sender] -= value;\n        _balances[from] -= value;\n        _balances[to] += value;\n        Transfer( from, to, value );\n        return true;\n    }\n    function approve(address spender, uint value) returns (bool ok) {\n        _approvals[msg.sender][spender] = value;\n        Approval( msg.sender, spender, value );\n        return true;\n    }\n    function allowance(address owner, address spender) constant returns (uint _allowance) {\n        return _approvals[owner][spender];\n    }\n    function safeToAdd(uint a, uint b) internal returns (bool) {\n        return (a + b >= a);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1931041,0x96925af6fec57baebf06cd9268fd93c3ffc066a6,false,false,,,,TOO_SHORT
1931342,0xd7155d5da0fa58ce3b813999de1de61f67726d21,false,false,,,,TOO_SHORT
1931347,0xa67317119383a1045ecc87cd133431594f04bcda,false,false,,,,TOO_SHORT
1931398,0x5129710d57171c3a9bc498bc794e549c5d70286d,false,false,,,,TOO_SHORT
1931504,0x66283d45b161ee574edc94a863522c42d95fa18a,false,false,,,,TOO_SHORT
1931550,0x3e03a938c6fce7489302c8c65ae2e9b78d4ef4eb,false,false,,,,TOO_SHORT
1931554,0x458677b35b0ebb2e641deeb4f1e1db4e3e0eeb02,false,false,,,,TOO_SHORT
1931718,0x681de3e040982e6872a004572a4e9e7f1f8a4f09,false,false,,,,TOO_SHORT
1931758,0xebdae3c0b8c331a2745264331103368a835583d3,false,false,,,,TOO_SHORT
1931797,0x072023922c6fa659c9b8376639a73e72e75557ff,false,false,,,,TOO_SHORT
1931892,0x9db5fddad0d99cd57b1540cd126e08e155ed7222,false,false,,,,TOO_SHORT
1931896,0x6d46899eed65e67df468960811bb149a9d9ec6d9,false,false,,,,TOO_SHORT
1932100,0x3673a5a095828c7bc042773710fe7992a1add205,false,false,,,,TOO_SHORT
1932213,0x2cbf62dc6fea355b21f8278eb02fa8d33fc365b6,false,false,,,,TOO_SHORT
1932225,0xbdfc46ee6a317f259146a077f83ca2850c6ff32e,false,false,,,,TOO_SHORT
1932283,0x41c31f6158f740bb6d19e2c25bdabd52c74dd32f,false,false,,,,TOO_SHORT
1932378,0x0796c1ad1cef8c9ee5be38497694e9e486869d75,false,false,,,,TOO_SHORT
1932435,0xbde5111e19d9b3f4fa2558585fbffc8e05f59636,false,false,,,,TOO_SHORT
1932570,0xadb523b147b73a3f45f0f1bbba67da2656f57666,false,false,,,,TOO_SHORT
1932624,0xbf8afc77cc34407a5d1b26ddf8fa9e3227da9077,false,false,,,,TOO_SHORT
1932672,0x4790da50733a4ad5f83222c4c2fa795ab95fa5bf,false,false,,,,TOO_SHORT
1932869,0x83c78395edff5ffdc1ea4d53f4884f012d27c5d1,false,false,,,,TOO_SHORT
1932876,0x78207ac33ebee5a035e6152076bb8e6a7071149c,false,false,,,,TOO_SHORT
1933005,0x8ea72902eb9502650a61e6d5aa6b1cd691af67ee,false,false,,,,TOO_SHORT
1933314,0xae42b95850bee3b00daff72b0153be59d4e11450,false,false,,,,TOO_SHORT
1933452,0x0a5c19a0f6e071ce1ab6ab41a91e8d02770638b6,false,false,,,,TOO_SHORT
1933542,0x19a81d6871c857e9369df2cf90de250bde5259ac,false,false,,,,TOO_SHORT
1933693,0x92aa09922ef82cbc347a3feb54f095ee9cc93a86,false,false,,,,TOO_SHORT
1933697,0x4e279becf0be1d296cce7be2c989f37c4cd903c2,false,false,,,,TOO_SHORT
1933710,0x1d796d4ed1a2382aeddb633b7f611e6dfa27eccd,false,false,,,,TOO_SHORT
1933863,0x835a661e6c4e5a26c488ade4fa0da08c1a7b434a,false,false,,,,TOO_SHORT
1933877,0xa76e19c46b8638f37ba8cd363fb12da67c125822,false,false,,,,TOO_SHORT
1933997,0xbccef848bf16b24b23e33badee9600c6aa506c86,false,false,,,,TOO_SHORT
1934007,0xc70cfccaa2d7780c87af29a0b380be0246497f9a,false,false,,,,TOO_SHORT
1934163,0x50dc6c572c3f18ffcdcc5812527f0251b9b060b0,false,false,,,,TOO_SHORT
1934332,0xb5745f306a518a574d6a5accbb666102d928d5e2,false,false,,,,TOO_SHORT
1934592,0xa7dc9950d01efc0c84f6b13a16531a1e86126dce,false,false,,,,TOO_SHORT
1935128,0xe84348e57eec456915e725b9035f9e103f94dd31,false,false,,,,TOO_SHORT
1935268,0xe9aeecc1099218d92a7ca9a321c39b99ff1ac38c,false,false,,,,TOO_SHORT
1935292,0x6743aa5ad5443f97c54a6d5cad5e7d8d03f599c1,false,false,,,,TOO_SHORT
1935336,0x89f607b4c5166b8e79947ff16b1f68b4b0f5c51a,false,false,,,,TOO_SHORT
1935337,0x0a9f78d42700aab1ed7eb0719ce1454faba4d2d5,false,false,,,,TOO_SHORT
1935683,0x56ba4355fddfe0bcbf286d40829cde4ccce30c72,false,false,,,,TOO_SHORT
1936050,0x3ad9fd63cfc209c5fd71476bb6ef7a3e19e4d5f5,false,false,,,,TOO_SHORT
1936083,0xa6e26b2cfd7811b0adb3a2bc60eaa0ed4a7f9eeb,false,false,,,,TOO_SHORT
1936235,0x0eb286f77e49d6d101b36f914c60fae3c23d19ed,false,false,,,,TOO_SHORT
1936263,0x35ffce42754b8b0dcfe688a85448e34339b3fd4d,false,false,,,,TOO_SHORT
1937103,0xe53197ddd76b1de382fccbef54dae972630652ce,false,false,,,,TOO_SHORT
1937127,0xc7050fa3ce654c3f39e4be89ff0fe5668d4f77ba,false,false,,,,TOO_SHORT
1937537,0x589134bde1253e666425ad7d3c361a8e42a4ad18,false,false,,,,TOO_SHORT
1938255,0x978ce1c9d3d8cef831d648f55afd629ae6e3ecc5,false,false,,,,TOO_SHORT
1938256,0x9be0722e78011ee39a2689cb3dc40a2eead23c07,false,false,,,,TOO_SHORT
1938285,0x1e4f10814f72b7f2cdb0c09d7e1fff7f8569c37d,false,false,,,,TOO_SHORT
1938315,0x6cef0ec77bcb3af5b7a0919755105e1a89f5b67c,false,false,,,,TOO_SHORT
1938414,0xec02c65e60ad85acc467a19dce0cc4e73f9ae855,false,false,,,,TOO_SHORT
1938539,0x6ca1b460264e998dbc5bc16eb789eb8a872f5782,false,false,,,,TOO_SHORT
1938540,0x453000460343fa39696895fcd65d4c3ecfb1f75c,false,false,,,,TOO_SHORT
1938567,0x32ef4b2393b24f50dc823006678bd410547f0a99,false,false,,,,TOO_SHORT
1938589,0x541577cc3aea570383fcd948030f8259718c4534,false,false,,,,TOO_SHORT
1938630,0x677538cac31e77083f76300fd09bdf4e068370a7,false,false,,,,TOO_SHORT
1938804,0x3b90b70dd6a7ec95f0bb40ebe3b66cd722a4dc47,false,false,,,,TOO_SHORT
1939033,0xc75bb295b2ff736b3aec1c7d4a5559801eeb03f0,false,false,,,,TOO_SHORT
1939062,0xe1f5972155a937b283fdd14f34229d046f6b0d1a,false,false,,,,TOO_SHORT
1939102,0x5a0d3c602622bdeb704d31a7cb5b9b0af7a6dedf,false,false,,,,TOO_SHORT
1939104,0x75f21d5012f757be6348b2c38dddfe14d4301a29,false,false,,,,TOO_SHORT
1939244,0x415c5119fda92fde83b6fc669747e01ca19822f3,false,false,,,,TOO_SHORT
1939353,0xa4fce645276161cf340a2f113552b9f18031c7c0,false,false,,,,TOO_SHORT
1939468,0xe5a078fcaca3d27e5a3f6c1843175358a1122844,false,false,,,,TOO_SHORT
1939480,0x02ac59b04fa99169e88a50c6febd1787daf0e4bf,false,false,,,,TOO_SHORT
1939965,0x8678bab5e20500e0ec1f16ba8c9a4d19c7956389,false,false,,,,TOO_SHORT
1940022,0xfcf1d913d3c620d713df11ca34bb0175a9f58aad,false,false,,,,TOO_SHORT
1940431,0x162cf1c6c752c6a916bacba1aa3ba7813161c815,false,false,,,,TOO_SHORT
1940529,0x02236a5c9250e629a19d9623e653086d39c3c1d9,false,false,,,,TOO_SHORT
1940759,0x07d0fedb4e5601f0167df8a69f12ac5cef106f81,false,false,,,,TOO_SHORT
1941259,0x0a525f367abeb32fe24f7f28a4ca813319dc6278,false,false,,,,TOO_SHORT
1941446,0x6f9255b4e2b1f5aa633aec48d81eaa490e7a7752,false,false,,,,TOO_SHORT
1941502,0xd4b9bda1448ca6cb73db013feaa9c295068fb99e,false,false,,,,TOO_SHORT
1941542,0xda347810cb42e75f203dbce6fa1948e5907b0706,false,false,,,,TOO_SHORT
1941627,0xb9d6de3f32460d1dd637f48e3879aa825b973b7d,false,false,,,,TOO_SHORT
1941643,0x1bff43a1846f3f5de6db238e7ee3694d17145254,false,false,,,,0x408b8fbc19bb5ffff7d5e5c430f765524fae77c5
1942057,0x3fa6040c4e875631de2e477ee7f8970a0f8720fe,false,false,,,,TOO_SHORT
1942149,0xb0bdde55ca3185b6c0e8d27f744d993e41cafe50,false,false,,,,TOO_SHORT
1942677,0x6773585fbe616152bcab17972c179553d8e88a90,false,false,,,,TOO_SHORT
1942977,0x2533b641e2f5c49208d1182684887e01be7b0d6f,false,false,,,,TOO_SHORT
1943149,0xdf87848bfb3d0e3089245c21c035d673434f7080,false,false,,,,TOO_SHORT
1943206,0xca0818d0c0176a217b740d368368edcee7b455d5,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1943237,0x066211987e4e3b7acefa10e982331c872123fa2c,false,false,,,,TOO_SHORT
1943351,0xcf1901ea377ecae29249dfc255ee80d866e3f7b7,false,false,,,,TOO_SHORT
1943596,0xb8ed0f47fe1542b42a71e57747934ec735898e83,false,false,,,,TOO_SHORT
1943645,0x6ff323e36bfdb20502b23780695f4e77e36cde95,false,false,"// Single-owner wallet that keeps ETC and ETH separately and helps preventing\n// replaying both, incoming and outgoing transactions.\n//\n// Once instantiated, the contract sets up three addressed:\n// 1. Address to be used to send and receive ETC.  This address will reject all\n//    incoming ETH transfers, so its ETH balance will always be zero;\n// 2. Address to be used to send and receive ETH.  This address will reject all\n//    incoming ETC transfers, so its ETC balance will always be zero;\n// 3. Address to be used to receive payments in both flavors of ether or even\n//    unsplit replayable ETC+ETH payments.  Ether coming to this address will\n//    be automatically classified and distributed among address 1 and address 2.\ncontract TriWallet {\n  // Is set to true in the forked branch and to false in classic branch.\n  bool public thisIsFork;\n\n  // Address of ETC subwallet.\n  address public etcWallet;\n\n  // Address of ETH subwallet.\n  address public ethWallet;\n\n  // Log address of ETC subwallet\n  event ETCWalletCreated(address etcWalletAddress);\n\n  // Log address of ETH subwallet\n  event ETHWalletCreated(address ethWalletAddress);\n\n  // Instantiate the contract.\n  function TriWallet () {\n    // Check whether we are in fork branch or in classic one\n    thisIsFork = BranchSender (0x23141df767233776f7cbbec497800ddedaa4c684).isRightBranch ();\n    \n    // Create ETC subwallet\n    etcWallet = new BranchWallet (msg.sender, !thisIsFork);\n    \n    // Create ETH subwallet\n    ethWallet = new BranchWallet (msg.sender, thisIsFork);\n  \n    // Log address of ETC subwallet\n    ETCWalletCreated (etcWallet);\n\n    // Log address of ETH subwallet\n    ETHWalletCreated (ethWallet);\n  }\n\n  // Distribute pending balance between ETC and ETH subwallets.\n  function distribute () {\n    if (thisIsFork) {\n      // Send all ETH to ETH subwallet\n      if (!ethWallet.send (this.balance)) throw;\n    } else {\n      // Send all ETC to ETC subwallet\n      if (!etcWallet.send (this.balance)) throw;\n    }\n  }\n}\n\n// Wallet contract that operates only in ""right"" branch.\ncontract BranchWallet {\n  // Owner of the wallet\n  address public owner;\n    \n  // Is set to true if and only if we are currently in the ""right"" branch of\n  // the blockchain, i.e. the branch this wallet is operating in.\n  bool public isRightBranch;\n\n  // Instantiate the contract.\n  //\n  // @param owner owner of the contract\n  // @isRightBranch whether we are currently in the ""right"" branch\n  function BranchWallet (address _owner, bool _isRightBranch) {\n    owner = _owner;\n    isRightBranch = _isRightBranch;\n  }\n\n  // Only accept money in ""right"" branch.\n  function () {\n    if (!isRightBranch) throw;\n  }\n\n  // Execute a transaction using money from this wallet.\n  //\n  // @param to transaction destination\n  // @param value transaction value\n  // @param data transaction data\n  function send (address _to, uint _value) {\n    if (!isRightBranch) throw;\n    if (msg.sender != owner) throw;\n    if (!_to.send (_value)) throw;\n  }\n\n  // Execute a transaction using money from this wallet.\n  //\n  // @param to transaction destination\n  // @param value transaction value\n  // @param data transaction data\n  function execute (address _to, uint _value, bytes _data) {\n    if (!isRightBranch) throw;\n    if (msg.sender != owner) throw;\n    if (!_to.call.value (_value)(_data)) throw;\n  }\n}\n\n// Simple smart contract that allows anyone to tell where we are currently in the\n// ""right"" branch of blockchain.\ncontract BranchSender {\n  // Is set to true if and only if we are currently in the ""right"" branch of\n  // the blockchain.\n  bool public isRightBranch;\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1943645,0x7a7e817d2f553d39684b745bd34a06edf9a1fea9,false,false,"// Wallet contract that operates only in ""right"" branch.\ncontract BranchWallet {\n  // Owner of the wallet\n  address public owner;\n    \n  // Is set to true if and only if we are currently in the ""right"" branch of\n  // the blockchain, i.e. the branch this wallet is operating in.\n  bool public isRightBranch;\n\n  // Instantiate the contract.\n  //\n  // @param owner owner of the contract\n  // @isRightBranch whether we are currently in the ""right"" branch\n  function BranchWallet (address _owner, bool _isRightBranch) {\n    owner = _owner;\n    isRightBranch = _isRightBranch;\n  }\n\n  // Only accept money in ""right"" branch.\n  function () {\n    if (!isRightBranch) throw;\n  }\n\n  // Execute a transaction using money from this wallet.\n  //\n  // @param to transaction destination\n  // @param value transaction value\n  // @param data transaction data\n  function send (address _to, uint _value) {\n    if (!isRightBranch) throw;\n    if (msg.sender != owner) throw;\n    if (!_to.send (_value)) throw;\n  }\n\n  // Execute a transaction using money from this wallet.\n  //\n  // @param to transaction destination\n  // @param value transaction value\n  // @param data transaction data\n  function execute (address _to, uint _value, bytes _data) {\n    if (!isRightBranch) throw;\n    if (msg.sender != owner) throw;\n    if (!_to.call.value (_value)(_data)) throw;\n  }\n}\n\n// Simple smart contract that allows anyone to tell where we are currently in the\n// ""right"" branch of blockchain.\ncontract BranchSender {\n  // Is set to true if and only if we are currently in the ""right"" branch of\n  // the blockchain.\n  bool public isRightBranch;\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1943645,0xc1caec30b787711108957660a3f9306a5d967f66,false,false,,,,0x7a7e817d2f553d39684b745bd34a06edf9a1fea9
1943656,0x536c2622748118a82bc9fb15a450d828966d9761,false,false,contract Prism {\n    address constant theWithdraw = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\n    function Prism() {\n        forked = theWithdraw.balance > 1 ether;\n    }\n    \n    function transferETC(address to) {\n        if (forked)\n            throw;\n        if (!to.send(msg.value))\n            throw;\n    }\n\n    function transferETH(address to) {\n        if (!forked)\n            throw;\n        if (!to.send(msg.value))\n            throw;\n    }\n    \n    bool public forked;\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1943774,0x0bfd07b78193cdd5dea0a98568da48a24c9ce35e,false,false,,,,TOO_SHORT
1943808,0x3ba654ed60b3419cf054c2045b07c0d68be94b45,false,false,,,,TOO_SHORT
1943849,0x24d3b1721c693d392e60a8fef4059a3a6141e2ba,false,false,,,,TOO_SHORT
1943868,0x9123a2f17a83b79b8f4bcbba96f4c4e8be7a81e4,false,false,,,,TOO_SHORT
1943980,0x9d09764dcad96242b7b278313c4bf515bb188498,false,false,,,,TOO_SHORT
1944145,0x443b41bcead8e2b81654b3d87264ea57fad7d886,false,false,,,,TOO_SHORT
1944169,0x0ed05f26a4e35e7a77aef8be49cc76841883283f,false,false,,,,TOO_SHORT
1944170,0x5d95f4df284130083cae9dca9faba59aaadaea3c,false,false,,,,TOO_SHORT
1944178,0xc1ab3acc2aeab6669a1cfd74f6df7304c4c8a5ff,false,false,,,,TOO_SHORT
1944307,0xc1eeede2095b2cd8b1b41998be091851d0233e3d,false,false,,,,TOO_SHORT
1945045,0x8bf67c6cc38c0d2bc68aa6b0c7b5f1b709d877d4,false,false,,,,TOO_SHORT
1945208,0xf428b0641a4c1ce1d2f360e46180015a5bcc2346,false,false,,,,0xb671c3883307cf05bb3dff77a9754e87b4347195
1945232,0xcd3f1fa4951df69549d258832bfffa8b9047fa82,false,false,,,,TOO_SHORT
1945235,0x608734628a36365d2f3a22678346cb2e33f245cd,false,false,,,,0xb671c3883307cf05bb3dff77a9754e87b4347195
1945259,0xb4b7671c3b15c17ec0d233681645e477a06a5024,false,false,,,,TOO_SHORT
1945332,0x78f5fe197dc3f43303eebbd020cdce841b9d02a0,false,false,,,,TOO_SHORT
1945366,0xe6450a1f82496971297d497a4e41cbe33317a57d,false,false,,,,TOO_SHORT
1945377,0x5821a8d8b5f643071c7a9b032e8a508a0bded8cc,false,false,,,,TOO_SHORT
1945507,0x8e7a0f8eeffb4bd0d1e9acc1cc63bd0c65eb953d,false,false,,,,TOO_SHORT
1945534,0x6dd3ea7018f2113f0f6527407b932cd1125ef9ce,false,false,,,,TOO_SHORT
1945540,0x2d8908deb89f17849552b91ea40a849c346ae43a,false,false,,,,TOO_SHORT
1945549,0x8ab532b72ddc7261585c88e7730edf0a1ec587f9,false,false,,,,TOO_SHORT
1945559,0x8dab6a5c27c906dd570511dffe33339d6be95319,false,false,,,,TOO_SHORT
1945564,0x5aaa97e84ce49903c5f4cf0ff4be83eea304cd90,false,false,,,,TOO_SHORT
1945637,0xb05fae56ef3151297265f49548c51452a1bb56b3,false,false,,,,TOO_SHORT
1945761,0x3843011b99abcc9409058733694a975360c4b79c,false,false,,,,TOO_SHORT
1946127,0x4231f2a7f72e35b710ee7e2d603927896598c915,false,false,,,,TOO_SHORT
1946447,0x4209de6211ee1226f9a0da2d2a18629ef28df843,false,false,,,,TOO_SHORT
1946554,0xa777b2ecb006891e7773790c49857cae8274ef4e,false,false,,,,TOO_SHORT
1946708,0xe94b04a0fed112f3664e45adb2b8915693dd5ff3,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract ReplaySafeSplit {\n    // Fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    event e(address a);\n	\n    // Splits the funds into 2 addresses\n    function split(address targetFork, address targetNoFork) returns(bool) {\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\n			e(targetFork);\n            return true;\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\n			e(targetNoFork);		\n            return true;\n        }\n        throw; // don't accept value transfer, otherwise it would be trapped.\n    }\n\n    // Reject value transfers.\n    function() {\n        throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1946748,0xed25f84c9c09afbe0d9227ccdb05eb46ed2b1ca4,false,false,,,,TOO_SHORT
1946989,0xc8c10ca4d41256ef70f89a540071e41255c64a28,false,false,,,,TOO_SHORT
1947214,0x01e6a4e2a548f9ca167002973f8db520670dd899,false,false,,,,TOO_SHORT
1947276,0x930e8c46e0acb5a9047d46556620c2153211d4e1,false,false,,,,TOO_SHORT
1947298,0x62a7fe52b83c2c86f93ee9096f0ae5bf401561bb,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1947315,0xd3e20100b8196ab6b7582827becea59f6858ff2a,false,false,,,,TOO_SHORT
1947320,0x29fe8985c18d279bb5d57fc4de59d79d27189678,false,false,,,,TOO_SHORT
1947369,0x064da6320b7b1ef659b1b484bf85136b775d900e,false,false,,,,TOO_SHORT
1947469,0x11544f6c015897d2c5e6fa0188f0738f0e9537b4,false,false,,,,TOO_SHORT
1947627,0xdc79cdf0f5ce723c6ebde2616e2f20128fbd70ee,false,false,,,,TOO_SHORT
1947756,0x3e6bf97dcdef5be6d7c9093df345d8943ada72ba,false,false,,,,TOO_SHORT
1947841,0x6f983e380592d7331e0984c3c69fd1c1e615c831,false,false,,,,TOO_SHORT
1948071,0x2ca93ae29a6a968a9a801cd67329b691e2108f6c,false,false,,,,TOO_SHORT
1948376,0x826835bad37bc84c2bc3f7f0758affc95bcb1c10,false,false,,,,TOO_SHORT
1948550,0x05a7d1d5d8d0c1930d8e49714351571baf476f4c,false,false,,,,TOO_SHORT
1949081,0xaddcda88581df3d7a4ba8cc98f35aa9026b29420,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1949322,0x2970588429a04598a8f94ed484968dd3d8cf8e87,false,false,,,,TOO_SHORT
1949340,0xbe16dc70864652ec1985ef3c9086eafda71a2194,false,false,,,,TOO_SHORT
1949393,0x1a24d1d75670f64b76f03d95c92d28981b21729f,false,false,,,,TOO_SHORT
1949490,0xe2609cd1a58cd4f5dd651356a0adfce62a0489ec,false,false,,,,TOO_SHORT
1949505,0xf93ded5370a76fa139445c85513a92b85e29b41b,false,false,,,,TOO_SHORT
1949506,0xc56c020b8bf70f3bf309d6544ac3d4303ff9e9f0,false,false,,,,TOO_SHORT
1949514,0x37dc9dd3f76e9bbf6b47849e6094a8c8be9d0726,false,false,,,,TOO_SHORT
1949520,0x48c37441c92170f26df8261b9b9dfe240b41f263,false,false,,,,0x536c2622748118a82bc9fb15a450d828966d9761
1949727,0x42d515b450ee1933455aed03671a90755f5c35af,false,false,,,,TOO_SHORT
1949852,0x9c9a0fa38af9a1cbcbec50eeb563d8fe52f78f3d,false,false,,,,TOO_SHORT
1949884,0x5587f48d1e225b0cfeb41ca63c289c1e522befaf,false,false,,,,TOO_SHORT
1949893,0xaad38ee9ff04a9b266882f14d869a8293829bc8f,false,false,,,,TOO_SHORT
1949952,0x7ff9ad56419194f55f4d9bf8a7febd7b4b4d3142,false,false,,,,TOO_SHORT
1949965,0x876215bcebd2629b0a1a65a7bd9f5a3329e6da18,false,false,,,,TOO_SHORT
1950094,0x0cad1a06bc1e4a7b4c2fc098f56f6b6a20ba48a3,false,false,,,,TOO_SHORT
1950174,0x0255c712a500e37a868edc4b55ce5fcfd7d73855,false,false,,,,TOO_SHORT
1950175,0xd4f3447890e86a997c5b3a6a4679b69161033cb2,false,false,,,,TOO_SHORT
1950296,0xb3d172282f049875ecf8f24c97a8c109271fe842,false,false,,,,TOO_SHORT
1950446,0x003fb5a6f74e566f0a63cea3a0d00c1a91885d6a,false,false,,,,TOO_SHORT
1950475,0x2c05218d906f7d1bec782d4cba59511e20f15aa4,false,false,,,,TOO_SHORT
1950489,0x8a4e81eed0576abf40db2a8049e844f85e52bbb8,false,false,,,,TOO_SHORT
1950513,0x07bee34e18143cf9fafc19c983b982c4dd03f992,false,false,,,,TOO_SHORT
1950583,0x40c5f42f0b18052380f3e40279b479762167a639,false,false,,,,TOO_SHORT
1950608,0x65f30250a3e2a255f07edfbba80516bdca7ad78c,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1950651,0x68d1281491a1477b983fd0e998534d1c3f50b2e8,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1950652,0x38b3cbbc2cc4502e0f8ddc50b1a54ca3f82afd04,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1950740,0x8b780b12f26e5e4e91da4cda5f14d2998ed7a162,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1950763,0xb14b865ae12c00ef902a02d63b03f3bb5c1bba42,false,false,,,,TOO_SHORT
1950772,0x69510cdf7ffb12dd3a2179fff8224021107e2268,false,false,,,,TOO_SHORT
1950940,0x424ad74af206824bb64aef3f9a4a7756a3812bee,false,false,,,,0x536c2622748118a82bc9fb15a450d828966d9761
1950958,0xc2557a084aee847b72e1d41942c323eb2d086de2,false,false,,,,0x536c2622748118a82bc9fb15a450d828966d9761
1951004,0xf4978ecefbc17063748eb28e25d1a94a2c06d9aa,false,false,,,,TOO_SHORT
1951176,0x2f0aebf4d9a71158155c931bcbc9850848aa2b84,false,false,,,,TOO_SHORT
1951285,0x48c1afa27188dd4ee1a461e1cdc169ab95e32c39,false,false,contract Switch {\n    address constant theWithdraw = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\n    function Switch() {\n        forked = theWithdraw.balance > 10000 ether;\n    }\n    \n    function transferringETC(address to) {\n        if (forked)\n            throw;\n        if (!to.send(msg.value))\n            throw;\n    }\n\n    function transferringETH(address to) {\n        if (!forked)\n            throw;\n        if (!to.send(msg.value))\n            throw;\n    }\n    \n    bool public forked;\n},1,実用的なコードで、特定の条件で資金を送信するシンプルなスマートコントラクトです。,
1951352,0xee513c12d91a7f4cb836145ebb1f5c5055ccd248,false,false,,,,TOO_SHORT
1951413,0x598924e41808f3232ae1aa14b885976043e1a2dc,false,false,,,,TOO_SHORT
1951438,0x9316a8edb2cfeceddab20304d8be8fa92b58f569,false,false,,,,TOO_SHORT
1951475,0x1fc881eb74269de0170f3ca6fa82a4d6ac4cf1a7,false,false,,,,TOO_SHORT
1951489,0x5f0d0c4c159970fda5adc93a6b7f17706fd3255c,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract SellETCSafely {\n    // fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    \n    // recipient of the 1 % fee on the ETC side\n    address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54;\n    \n    function split(address ethDestination, address etcDestination) {\n        if (amIOnTheFork.forked()) {\n            // The following happens on the forked chain:\n            // 100 % is forwarded to the provided destination for ETH\n            ethDestination.call.value(msg.value);\n        } else {\n            // The following happens on the classic chain:\n            // 1 % is forwarded to the fee recipient\n            // 99 % is forwarded to the provided destination for ETC\n            uint fee = msg.value / 100;\n            feeRecipient.send(fee);\n            etcDestination.call.value(msg.value - fee)();\n        }\n    }\n    \n    function () {\n        throw;  // do not accept value transfers\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1951552,0xe7aa95217eb415b2c400c81e2b65359e720ab936,false,false,,,,0x48c1afa27188dd4ee1a461e1cdc169ab95e32c39
1951618,0x1145472d3d306f128eadca313c685b71a03134ff,false,false,,,,TOO_SHORT
1951655,0xaeffa1c066f4fd52dab5282b39b863c10862e70e,false,false,,,,TOO_SHORT
1951697,0x8086fb1d6457b94c920cfcd7fb4ca14ef2218108,false,false,contract ClassicCheck {\n    \n    bool public classic;\n \n    function ClassicCheck(){\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance > 1000000 ether)\n            classic = false;\n        else\n            classic = true;\n    }   \n    \n    function isClassic() constant returns (bool isClassic) {\n        return classic;\n    }\n},1,実用的な構造で、特定のアドレスのETH残高をチェックするシンプルな機能を持つ。,
1951740,0x4e144657cd8d8c41d2b5da5c21341f2c8554517d,false,false,,,,0x8086fb1d6457b94c920cfcd7fb4ca14ef2218108
1951744,0x882fb4240f9a11e197923d0507de9a983ed69239,false,false,,,,0x8086fb1d6457b94c920cfcd7fb4ca14ef2218108
1951760,0xe0cdf996160330f091cac265563e783a8079ab22,false,false,,,,TOO_SHORT
1951878,0xde79bd33ba8133f1fab8c67a576dd7a88095a4a4,false,false,,,,TOO_SHORT
1952094,0xa26b0a2fc7702ac3cdd4d578df7ef87ecf17908e,false,false,,,,0x2a53f42ad8bba138c21b50a4e5711f18381a61e9
1952206,0xa03f3bf58e4b97358d4b6332e77db12be268c8ee,false,false,,,,TOO_SHORT
1952428,0x1e143b2588705dfea63a17f2032ca123df995ce0,false,false,contract ClassicCheck {\n       function isClassic() constant returns (bool isClassic);\n}\n\ncontract SafeConditionalHFTransfer {\n\n    bool classic;\n    \n    function SafeConditionalHFTransfer() {\n        classic = ClassicCheck(0x882fb4240f9a11e197923d0507de9a983ed69239).isClassic();\n    }\n    \n    function classicTransfer(address to) {\n        if (!classic) \n            msg.sender.send(msg.value);\n        else\n            to.send(msg.value);\n    }\n    \n    function transfer(address to) {\n        if (classic)\n            msg.sender.send(msg.value);\n        else\n            to.send(msg.value);\n    }\n    \n},1,実用的な構造で、特に芸術的な要素は見られません。,
1952445,0x52173c01cc7fd985e93847cd1431cbb088b978f3,false,false,,,,TOO_SHORT
1952568,0x9dc4ed66ca137803d4c70e4ec7d7a0d7a1a92dd0,false,false,,,,TOO_SHORT
1952705,0xab7d97f424d3c883d28d134e558753d9d82c72d1,false,false,,,,TOO_SHORT
1952936,0xfb1e66a7b36d251efc9a0479978c403f2c347c79,false,false,,,,TOO_SHORT
1952942,0x91501c81c73b0bc3009050e112ec51f41ec1c920,false,false,,,,TOO_SHORT
1953251,0xf49430d73f8762579427d18b9f381de33bcb5192,false,false,,,,TOO_SHORT
1953296,0x233e46758ae1ede6781cafffe9ed1c9db1657c2d,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1953482,0x637483355da10c5f50672b77ae3304ee26326ce1,false,false,,,,TOO_SHORT
1953741,0xdaffd02727e9447aa7999212306e915fcaf19acf,false,false,,,,TOO_SHORT
1953768,0xa8c62fab24434af8e42a0f28cad2911efc9e8aed,false,false,,,,TOO_SHORT
1953933,0x5f7df3ea9e44d4ead31eff7c7502ab5f6bcfaab0,false,false,,,,TOO_SHORT
1954103,0x6b39faedc35139a23ac3f66f27c78e6a1cb6edcd,false,false,,,,TOO_SHORT
1954725,0x9f81fe0cba61bf49ae26f3dab0afae32f2665271,false,false,,,,TOO_SHORT
1954805,0x990adad5a4714a2946b460b9cbbfeae68d591e7c,false,false,,,,TOO_SHORT
1954818,0x973faa70ffc03bc8d2dc953051e66882cc5230a6,false,false,,,,TOO_SHORT
1954847,0x778c4be6b77018998623582d530c2e8f8dfbf57f,false,false,,,,TOO_SHORT
1954973,0x12b0d0d8e8a677a133f29c27996ba266ee165765,false,false,,,,TOO_SHORT
1955043,0xc8d9890df1ff2e87be05e9edab3cca26f054b611,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract SellETCSafely {\n    // fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    // recipient of the 1 % fee on the ETC side\n    address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54;\n\n    function split(address ethDestination, address etcDestination) {\n        if (amIOnTheFork.forked()) {\n            // The following happens on the forked chain:\n            // 100 % is forwarded to the provided destination for ETH\n            ethDestination.call.value(msg.value)();\n        } else {\n            // The following happens on the classic chain:\n            // 1 % is forwarded to the fee recipient\n            // 99 % is forwarded to the provided destination for ETC\n            uint fee = msg.value / 100;\n            feeRecipient.send(fee);\n            etcDestination.call.value(msg.value - fee)();\n        }\n    }\n\n    function () {\n        throw;  // do not accept value transfers\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1955195,0x9e25444e990e8bc7dc0627157ed8b0408991ab9c,false,false,,,,TOO_SHORT
1955239,0x5348aa57f9af58ae88f3cc1a456a40d4c86786e8,false,false,,,,TOO_SHORT
1955465,0xbc41fbe3f9b5ee635ee1fcb5231b04fd531f6390,false,false,,,,TOO_SHORT
1955674,0x3f8e4149936ef5df6e6f2be939aa3b7421eeb7f6,false,false,,,,TOO_SHORT
1955734,0xe0eccf1865e66e5ce3c3b7d5ee65b279173c856f,false,false,,,,TOO_SHORT
1955735,0x870ebf53910ed92b05635715ead3f1114ae71278,false,false,,,,TOO_SHORT
1955776,0x163afbcc062f8959c4c43c7711404002e404f7b0,false,false,,,,TOO_SHORT
1955797,0x62c617accfd87139bbfc26231c352a1581ae9edd,false,false,,,,TOO_SHORT
1955930,0x322cf4fa555cce299b119788e62725f5cbcbf662,false,false,,,,TOO_SHORT
1956104,0x7f7428ea7e42b3154649856d6a313d659783a335,false,false,,,,TOO_SHORT
1956121,0xb1727b6d166368cbdb55abfee4cc01e7666e9c0e,false,false,,,,TOO_SHORT
1956134,0xffa8bbf3d7d683c4f7ab52cb05ac081a5cc7d61a,false,false,,,,TOO_SHORT
1956180,0x2916b38b64a55befb7c09551954b5f1c717e281a,false,false,,,,TOO_SHORT
1956187,0x66ecf0e77ba6b5b1e076d5c7007a668e6d43a47b,false,false,,,,0xb671c3883307cf05bb3dff77a9754e87b4347195
1956198,0x0296a097e0261ddd8a22c24f395a9e096e369422,false,false,,,,TOO_SHORT
1956215,0x2a86b5187ef51179327dca8efa1f5793aeb540bb,false,false,,,,TOO_SHORT
1956223,0x9d271796e852803901ade4f053bad44d41e093a3,false,false,,,,0xb671c3883307cf05bb3dff77a9754e87b4347195
1956288,0x48bb19b8fa4f5d0e76a15736cb942b8640cb1034,false,false,,,,TOO_SHORT
1956399,0x1d663988c14686827704a2b0bebd317fcff9a142,false,false,,,,TOO_SHORT
1956430,0xb6fa1423826a2a1e8c69e6729c8136dd98a46ecc,false,false,,,,TOO_SHORT
1956488,0x4f94b508017850b957a400783de538d889b125bb,false,false,,,,TOO_SHORT
1956543,0x76025bb7b0d56fef4f0a27000655bbc3740f8ea9,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1956592,0xe233a0ce7e4ec6163a142419cc7fdd86c5ae3854,false,false,,,,TOO_SHORT
1956601,0xf89c307a265e9fcc475c3fd2f05f9faf5fffa407,false,false,,,,TOO_SHORT
1956619,0x87e3517546cfe4ad164522eaea87153d2fe7163c,false,false,,,,TOO_SHORT
1956705,0x5f69909b17a46e2273aef271a29069d739ce6973,false,false,,,,TOO_SHORT
1956823,0x9f00b1292d32f0f812e0b767f075fae9ba6b17ba,false,false,,,,TOO_SHORT
1956835,0x69f82da2eaaad551686d8d2889d00f34984e8a30,false,false,,,,TOO_SHORT
1956842,0xfda3bb532b99ed453db309d674d982f720f4a7fc,false,false,,,,TOO_SHORT
1956882,0x3e2467be1711659b39ef21ca6c2404e089a44f77,false,false,,,,TOO_SHORT
1956904,0xbc89218d9ab171cc19652898cf7e411f17d08da5,false,false,,,,TOO_SHORT
1956915,0x815150cecdea6cbf74c7b7fa3db5aa290396b23a,false,false,,,,TOO_SHORT
1956967,0x7be497b3440ded0b0ee3c7240e08ee5466106254,false,false,,,,TOO_SHORT
1957001,0x8d24f586f922be88f58a673e3d844e69e740e527,false,false,,,,TOO_SHORT
1957084,0x0f475b639b356094441b17cafa0aa6e6d065abd8,false,false,,,,TOO_SHORT
1957103,0x6ba1d20d6e614f03e63ff666e77f7323ca30db92,false,false,,,,TOO_SHORT
1957143,0x14307e2382c7de97e29f126a48222a6fee4b973b,false,false,,,,TOO_SHORT
1957152,0x0d727460b1531b0a33cbd0e8ab28afe0712d3711,false,false,,,,TOO_SHORT
1957415,0xdc2738e9dbece431db5183fed6d3cfba0456d388,false,false,,,,TOO_SHORT
1957481,0x2d5c4264f019e3ad306beb6bad825eabde7ac1e3,false,false,,,,TOO_SHORT
1957486,0xf111117a0eaa2d478c617784b4bee466b1621ba6,false,false,,,,TOO_SHORT
1957519,0x6825bd62268f501fe189763a5d3baa1fa3e22db5,false,false,,,,TOO_SHORT
1957601,0x40ebf2d6e998a76a848c41908733b26e04adffe2,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract ReplaySafeSend {\n    // Fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    function safeSend(address etcAddress) returns(bool) {\n        if (!amIOnTheFork.forked() && etcAddress.send(msg.value)) {\n            return true;\n        }\n        throw; // don't accept value transfer, otherwise it would be trapped.\n    }\n\n    // Reject value transfers.\n    function() {\n        throw;\n    }\n}",1,フォーク検出と安全送金を扱う実用的なスマートコントラクト。,
1957625,0x16bb51341b2d55455dfeba8383e6ca094a9d11c6,false,false,,,,TOO_SHORT
1957651,0x125311967eb0d1f20343ff781d77e1dc1c5e726e,false,false,,,,TOO_SHORT
1957658,0x4139c3b8cca11221ce13ec3735a5bea07aa81b40,false,false,,,,TOO_SHORT
1957770,0xd6c791fd881bedc98cdf40c7e678a41b512c4d99,false,false,,,,TOO_SHORT
1957823,0x4e3610b4d5d43e6d2d7af336e2361012d8fe8e17,false,false,,,,TOO_SHORT
1957868,0xa551fe0c463d0692b0361833d1848104cfb99199,false,false,,,,TOO_SHORT
1957876,0x2e84e67ad3c3e69d2db755c4262971e052a8f315,false,false,,,,TOO_SHORT
1957890,0xf23305366980cdb2601f68e1bc335adc2ed102de,false,false,,,,TOO_SHORT
1957894,0xf243fe245a52dd43269c775bfb048331f026069d,false,false,,,,TOO_SHORT
1957916,0xfd72adc546e0fdbecfe02918167b39f73d60ae1f,false,false,,,,TOO_SHORT
1957945,0x29369ef32aadb17cce436cdaebd99cabd091c167,false,false,,,,TOO_SHORT
1957946,0x99e2bd1ea2fc45f05c6de08e0bb2e2c22ca593b5,false,false,,,,TOO_SHORT
1957949,0x9a4b1a7f2590a9fc87dafaf5ed5ac93d7cd43298,false,false,,,,TOO_SHORT
1957978,0x45dc77d2a6dac449aa221b328d590939e071804f,false,false,,,,TOO_SHORT
1958068,0xb2719d5d4c8ea7a049ddb3490bde5d67125aa097,false,false,,,,TOO_SHORT
1958187,0x7b690210341c1a9346b9acf74e42fd9482351a11,false,false,,,,TOO_SHORT
1958338,0x89d02dc620d253424bb4b9d893b196d7a2e02567,false,false,,,,TOO_SHORT
1958364,0x26c52c00fbddea48fcd10f1d9749890c1109874c,false,false,,,,TOO_SHORT
1958384,0x5da3dd4da6f3b1e9f3fbb7839de9a8de78019745,false,false,,,,TOO_SHORT
1958666,0xb35c85c7a16ae3d88268f088f5f25ca6f8537c39,false,false,,,,TOO_SHORT
1959965,0x26e5570521bd00565a60aa251b81ee92cdac5b84,false,false,,,,TOO_SHORT
1960070,0x0c7c0b72004a7a66ffa780637427fed0c4faac47,false,false,,,,TOO_SHORT
1960139,0xc010f9320125318d992c86e990f66b2195370df7,false,false,,,,TOO_SHORT
1960238,0x361ff02a5e5596899bc72b2759a964b6ae2fb72a,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1960240,0x4bb558e58629b27d2c82bf223b52927402387319,false,false,,,,TOO_SHORT
1960243,0xf4e57edb01ab2860f05a42597d27e7a2f5601f96,false,false,,,,TOO_SHORT
1960246,0x8af7a0054cfeb752faab91599e3d68400c814808,false,false,,,,TOO_SHORT
1960270,0xc9bcd1d9494403b23d6f73fe14213fcaf3840526,false,false,,,,TOO_SHORT
1960301,0x23f1f41839b78d953e03fb97da397925497374d0,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1960429,0x5f8922c1d1da512a73a6922bb3a096f2e5b9330b,false,false,,,,TOO_SHORT
1960465,0x5c265a43aa42c20cd6426ec3adaaf0fea0141fce,false,false,,,,TOO_SHORT
1960819,0xd57871738da86e242b5dc1b2352176c4f8557076,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1960891,0x3f54b3263406a1b0b6f9bc8c55d1fbe93be751d7,false,false,,,,TOO_SHORT
1960947,0xc43b0c99277babf982b574fad0d27bdccb18a3a8,false,false,,,,TOO_SHORT
1961262,0xa9b192ff49b69ac99c55ba7fecb9dbc691ce55d8,false,false,,,,0x4bd4afa9b213b5184c995aaef4982ce564121d20
1961290,0x45d8693db589ee241c4831a9320eeaf18bf35d26,false,false,,,,TOO_SHORT
1961391,0x96f65700904cb464f3d153a2744b84fca27abf9c,false,false,,,,TOO_SHORT
1961461,0xb83a1b0a8bba5000c24baebaf73c98eab82b00bb,false,false,,,,TOO_SHORT
1961492,0xc73b1f928ed41564fafb7d7158285d5b604c97a7,false,false,,,,TOO_SHORT
1961520,0x349932f645eb706d622256f8a7df411eb8843aee,false,false,,,,TOO_SHORT
1961614,0xff43b999ebb110d9b192cd55c3c8a13539e019d9,false,false,,,,TOO_SHORT
1961731,0x8629fd66d77f007f073e2d3eb994714a75c4549f,false,false,,,,TOO_SHORT
1961846,0x059a4a6586fe483237ca9b085497e23454c00612,false,false,,,,TOO_SHORT
1961916,0x3deb4cfed140d4541492e6293fdf91c5e88699b0,false,false,,,,TOO_SHORT
1961922,0x7ef74f0cad1e94817f140584822a5fa831a2958f,false,false,,,,TOO_SHORT
1962007,0x5eb386337ae25c65a0d4921a16fab312ccadcbe7,false,false,,,,TOO_SHORT
1962023,0xca95805e033e6f36d34a530e7c7e105f4a7c4491,false,false,,,,TOO_SHORT
1962112,0x9311d4416fa4e666d177d9fbad302afd37c7ae56,false,false,,,,TOO_SHORT
1962298,0x6c8060507273a0ff175361c6bf9f86e97f8cf2c8,false,false,"// version 1.0\ncontract Randao {\n  struct Participant {\n      uint256   secret;\n      bytes32   commitment;\n      uint256   reward;\n      bool      revealed;\n      bool      rewarded;\n  }\n\n  struct Consumer {\n    address caddr;\n    uint256 bountypot;\n  }\n\n  struct Campaign {\n      uint32    bnum;\n      uint96    deposit;\n      uint16    commitBalkline;\n      uint16    commitDeadline;\n\n      uint256   random;\n      bool      settled;\n      uint256   bountypot;\n      uint32    commitNum;\n      uint32    revealsNum;\n\n      mapping (address => Consumer) consumers;\n      mapping (address => Participant) participants;\n  }\n\n  uint256 public numCampaigns;\n  Campaign[] public campaigns;\n  address public founder;\n\n  uint256 public bounty          = 1 ether;\n\n  // Prevents methods from perfoming any value transfer\n  modifier noEther() { if (msg.value > 0) throw; _}\n\n  modifier blankAddress(address _n) { if (_n != 0) throw; _}\n\n  modifier checkBounty { if (msg.value < bounty) throw; _}\n\n  modifier moreThanZero(uint256 _deposit) { if (_deposit <= 0) throw; _}\n\n  modifier notBeBlank(bytes32 _s) { if (_s == """") throw;  _}\n\n  modifier beBlank(bytes32 _s) { if (_s != """") throw; _}\n\n  modifier beFalse(bool _t) { if (_t) throw; _}\n\n  function Randao() {\n      founder = msg.sender;\n  }\n\n  event CampaignAdded(uint256 indexed campaignID,\n                      address indexed from,\n                      uint32 indexed bnum,\n                      uint96 deposit,\n                      uint16 commitBalkline,\n                      uint16 commitDeadline,\n                      uint256 bountypot);\n\n  modifier timeLineCheck(uint32 _bnum, uint16 _commitBalkline, uint16 _commitDeadline) {\n      if (block.number >= _bnum) throw;\n      if (_commitBalkline <= 0) throw;\n      if (_commitDeadline <= 0) throw;\n      if (_commitDeadline >= _commitBalkline) throw;\n      if (block.number >= _bnum - _commitBalkline) throw;\n      _\n  }\n\n  function newCampaign(\n      uint32 _bnum,\n      uint96 _deposit,\n      uint16 _commitBalkline,\n      uint16 _commitDeadline\n  ) timeLineCheck(_bnum, _commitBalkline, _commitDeadline)\n    checkBounty moreThanZero(_deposit) external returns (uint256 _campaignID) {\n      _campaignID = campaigns.length++;\n      Campaign c = campaigns[_campaignID];\n      numCampaigns++;\n      c.bnum = _bnum;\n      c.deposit = _deposit;\n      c.commitBalkline = _commitBalkline;\n      c.commitDeadline = _commitDeadline;\n      c.bountypot = msg.value;\n      c.consumers[msg.sender] = Consumer(msg.sender, msg.value);\n      CampaignAdded(_campaignID, msg.sender, _bnum, _deposit, _commitBalkline, _commitDeadline, msg.value);\n  }\n\n  event Follow(uint256 indexed CampaignId, address indexed from, uint256 bountypot);\n\n  function follow(uint256 _campaignID)\n    checkBounty external returns (bool) {\n      Campaign c = campaigns[_campaignID];\n      Consumer consumer = c.consumers[msg.sender];\n      return followCampaign(_campaignID, c, consumer);\n  }\n\n  modifier checkFollowPhase(uint256 _bnum, uint16 _commitDeadline) {\n      if (block.number > _bnum - _commitDeadline) throw;\n      _\n  }\n\n  function followCampaign(\n      uint256 _campaignID,\n      Campaign storage c,\n      Consumer storage consumer\n  ) checkFollowPhase(c.bnum, c.commitDeadline)\n    blankAddress(consumer.caddr) internal returns (bool) {\n      c.bountypot += msg.value;\n      c.consumers[msg.sender] = Consumer(msg.sender, msg.value);\n      Follow(_campaignID, msg.sender, msg.value);\n      return true;\n  }\n\n  event Commit(uint256 indexed CampaignId, address indexed from, bytes32 commitment);\n\n  function commit(uint256 _campaignID, bytes32 _hs) notBeBlank(_hs) external {\n      Campaign c = campaigns[_campaignID];\n      commitmentCampaign(_campaignID, _hs, c);\n  }\n\n  modifier checkDeposit(uint256 _deposit) { if (msg.value != _deposit) throw; _}\n\n  modifier checkCommitPhase(uint256 _bnum, uint16 _commitBalkline, uint16 _commitDeadline) {\n      if (block.number < _bnum - _commitBalkline) throw;\n      if (block.number > _bnum - _commitDeadline) throw;\n      _\n  }\n\n  function commitmentCampaign(\n      uint256 _campaignID,\n      bytes32 _hs,\n      Campaign storage c\n  ) checkDeposit(c.deposit)\n    checkCommitPhase(c.bnum, c.commitBalkline, c.commitDeadline)\n    beBlank(c.participants[msg.sender].commitment) internal {\n      c.participants[msg.sender] = Participant(0, _hs, 0, false, false);\n      c.commitNum++;\n      Commit(_campaignID, msg.sender, _hs);\n  }\n\n  // For test\n  function getCommitment(uint256 _campaignID) noEther external returns (bytes32) {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      return p.commitment;\n  }\n\n  event Reveal(uint256 indexed CampaignId, address indexed from, uint256 secret);\n\n  function reveal(uint256 _campaignID, uint256 _s) noEther external {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      revealCampaign(_campaignID, _s, c, p);\n  }\n\n  modifier checkRevealPhase(uint256 _bnum, uint16 _commitDeadline) {\n      if (block.number <= _bnum - _commitDeadline) throw;\n      if (block.number >= _bnum) throw;\n      _\n  }\n\n  modifier checkSecret(uint256 _s, bytes32 _commitment) {\n      if (sha3(_s) == _commitment) throw;\n      _\n  }\n\n  function revealCampaign(\n    uint256 _campaignID,\n    uint256 _s,\n    Campaign storage c,\n    Participant storage p\n  ) checkRevealPhase(c.bnum, c.commitDeadline)\n    checkSecret(_s, p.commitment)\n    beFalse(p.revealed) internal {\n      p.secret = _s;\n      p.revealed = true;\n      c.revealsNum++;\n      c.random ^= p.secret;\n      Reveal(_campaignID, msg.sender, _s);\n  }\n\n  modifier bountyPhase(uint256 _bnum){ if (block.number < _bnum) throw; _}\n\n  function getRandom(uint256 _campaignID) noEther external returns (uint256) {\n      Campaign c = campaigns[_campaignID];\n      return returnRandom(c);\n  }\n\n  function returnRandom(Campaign storage c) bountyPhase(c.bnum) internal returns (uint256) {\n      if (c.revealsNum == c.commitNum) {\n          c.settled = true;\n          return c.random;\n      }\n  }\n\n  // The commiter get his bounty and deposit, there are three situations\n  // 1. Campaign succeeds.Every revealer gets his deposit and the bounty.\n  // 2. Someone revels, but some does not,Campaign fails.\n  // The revealer can get the deposit and the fines are distributed.\n  // 3. Nobody reveals, Campaign fails.Every commiter can get his deposit.\n  function getMyBounty(uint256 _campaignID) noEther external {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      transferBounty(c, p);\n  }\n\n  function transferBounty(\n      Campaign storage c,\n      Participant storage p\n    ) bountyPhase(c.bnum)\n      beFalse(p.rewarded) internal {\n      if (c.revealsNum > 0) {\n          if (p.revealed) {\n              uint256 share = calculateShare(c);\n              returnReward(share, c, p);\n          }\n      // Nobody reveals\n      } else {\n          returnReward(0, c, p);\n      }\n  }\n\n  function calculateShare(Campaign c) internal returns (uint256 _share) {\n      // Someone does not reveal. Campaign fails.\n      if (c.commitNum > c.revealsNum) {\n          _share = fines(c) / c.revealsNum;\n      // Campaign succeeds.\n      } else {\n          _share = c.bountypot / c.revealsNum;\n      }\n  }\n\n  function returnReward(\n      uint256 _share,\n      Campaign storage c,\n      Participant storage p\n  ) internal {\n      p.reward = _share;\n      p.rewarded = true;\n      if (!msg.sender.send(_share + c.deposit)) {\n          p.reward = 0;\n          p.rewarded = false;\n      }\n  }\n\n  function fines(Campaign c) internal returns (uint256) {\n      return (c.commitNum - c.revealsNum) * c.deposit;\n  }\n\n  // If the campaign fails, the consumers can get back the bounty.\n  function refundBounty(uint256 _campaignID) noEther external {\n      Campaign c = campaigns[_campaignID];\n      returnBounty(_campaignID, c);\n  }\n\n  modifier campaignFailed(uint32 _commitNum, uint32 _revealsNum) {\n      if (_commitNum == _revealsNum && _commitNum != 0) throw;\n      _\n  }\n\n  modifier beConsumer(address _caddr) {\n      if (_caddr != msg.sender) throw;\n      _\n  }\n\n  function returnBounty(uint256 _campaignID, Campaign storage c)\n    bountyPhase(c.bnum)\n    campaignFailed(c.commitNum, c.revealsNum)\n    beConsumer(c.consumers[msg.sender].caddr) internal {\n      uint256 bountypot = c.consumers[msg.sender].bountypot;\n      c.consumers[msg.sender].bountypot = 0;\n      if (!msg.sender.send(bountypot)) {\n          c.consumers[msg.sender].bountypot = bountypot;\n      }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1962313,0x76fdf12a190e5c312a1bce1926efa108cc5016f0,false,false,,,,TOO_SHORT
1962339,0x97c9061729ef2823531d80c74ae903cf680750e6,false,false,,,,TOO_SHORT
1962460,0xf868a1d3de6edf1f33065da994580b4e82a40044,true,false,"contract MultiAsset {\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function owner(bytes32 _symbol) constant returns(address);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\ncontract KUNA_SHARES is Safe {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) noValue() immutable(address(multiAsset)) returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (!ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return __transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        return __transferWithReference(_to, _value, _reference);\n    }\n\n    function __transferWithReference(address _to, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) :\n            multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference);\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) :\n            multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference);\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference);\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function __transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function approve(address _spender, uint _value) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyApprove(_spender, _value, symbol);\n    }\n\n    function setCosignerAddress(address _cosigner) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxySetCosignerAddress(_cosigner, symbol);\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() noValue() returns(bool) {\n        address owner = multiAsset.owner(symbol);\n        uint balance = this.balance;\n        bool success = true;\n        if (balance > 0) {\n            success = _unsafeSend(owner, balance);\n        }\n        return multiAsset.transfer(owner, balanceOf(owner), symbol) && success;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1962555,0x7340a86272757d25f58fa7a06dd1b2e53da7a7d1,false,false,,,,0xfdf5ecefd831a3e5f2b1a667d92d8796dd53f0ec
1962562,0x77c0c728a4a0fa8130b9d9fd402ac13c3b4d40fa,false,false,,,,TOO_SHORT
1962613,0xdbe8f7cd5bf95d70d7388420a3063d4393078a77,false,false,,,,TOO_SHORT
1962636,0xac4539b8974ad318e34790719529ee2297da10b2,false,false,,,,TOO_SHORT
1962637,0xab38f97abfaa0f8a9547711ab2d7373b2ce967ee,false,false,,,,TOO_SHORT
1962662,0xaf71bbb6e55f986f19d6c964497dcc90b335521e,false,false,,,,TOO_SHORT
1962757,0xe404afa93b7add7731980b160601ce31c8a57908,false,false,,,,TOO_SHORT
1962816,0xb849c3f7e0991ac80b6ae8b9d5e6e02b5636bcaa,false,false,,,,TOO_SHORT
1962824,0x48c19cae5dc6b3f325708c4901fdface322e186b,false,false,,,,TOO_SHORT
1962840,0xa157e95ff4c621c2c4952973a9fea8073fd14fa6,false,false,,,,TOO_SHORT
1962860,0x6bda9d5ca1cd22c55e0aa2c9869d537388a9e0b4,false,false,,,,TOO_SHORT
1962908,0x25b930c57cca8ca2e3fa0bf6c85e0898e64329a1,false,false,,,,TOO_SHORT
1962910,0x271b29419c61addf89fc1ba718597b6e428df1a3,false,false,,,,TOO_SHORT
1963113,0x7a4b31ac7b7db680dc720eb3b4c50d9228533573,false,false,,,,TOO_SHORT
1963148,0xae0680c49df146e18b2bc19635e5e402494b5d67,false,false,"contract DaoAccount\n{\n	/**************************\n			    Constants\n	***************************/\n\n	/**************************\n					Events\n	***************************/\n\n	// No events\n\n	/**************************\n	     Public variables\n	***************************/\n\n\n	/**************************\n	     Private variables\n	***************************/\n\n	uint256 tokenBalance; // number of tokens in this account\n  address owner;        // owner of the otkens\n	address daoChallenge; // the DaoChallenge this account belongs to\n	uint256 tokenPrice;\n\n  // Owner of the challenge with backdoor access.\n  // Remove for a real DAO contract:\n  address challengeOwner;\n\n	/**************************\n			     Modifiers\n	***************************/\n\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	modifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _}\n\n	modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\n\n	/**************************\n	 Constructor and fallback\n	**************************/\n\n  function DaoAccount (address _owner, uint256 _tokenPrice, address _challengeOwner) noEther {\n    owner = _owner;\n		tokenPrice = _tokenPrice;\n    daoChallenge = msg.sender;\n		tokenBalance = 0;\n\n    // Remove for a real DAO contract:\n    challengeOwner = _challengeOwner;\n	}\n\n	function () {\n		throw;\n	}\n\n	/**************************\n	     Private functions\n	***************************/\n\n	/**************************\n			 Public functions\n	***************************/\n\n	function getTokenBalance() constant returns (uint256 tokens) {\n		return tokenBalance;\n	}\n\n	function buyTokens() onlyDaoChallenge returns (uint256 tokens) {\n		uint256 amount = msg.value;\n\n		// No free tokens:\n		if (amount == 0) throw;\n\n		// No fractional tokens:\n		if (amount % tokenPrice != 0) throw;\n\n		tokens = amount / tokenPrice;\n\n		tokenBalance += tokens;\n\n		return tokens;\n	}\n\n	function withdraw(uint256 tokens) noEther onlyDaoChallenge {\n		if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\n		tokenBalance -= tokens;\n		if(!owner.call.value(tokens * tokenPrice)()) throw;\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyChallengeOwner {\n		suicide(challengeOwner);\n	}\n}\n\ncontract DaoChallenge\n{\n	/**************************\n					Constants\n	***************************/\n\n	uint256 constant public tokenPrice = 1000000000000000; // 1 finney\n\n	/**************************\n					Events\n	***************************/\n\n	event notifyTerminate(uint256 finalBalance);\n\n	event notifyNewAccount(address owner, address account);\n	event notifyBuyToken(address owner, uint256 tokens, uint256 price);\n	event notifyWithdraw(address owner, uint256 tokens);\n\n	/**************************\n	     Public variables\n	***************************/\n\n	mapping (address => DaoAccount) public daoAccounts;\n\n	/**************************\n			 Private variables\n	***************************/\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address challengeOwner;\n\n	/**************************\n					 Modifiers\n	***************************/\n\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\n\n	/**************************\n	 Constructor and fallback\n	**************************/\n\n	function DaoChallenge () {\n		challengeOwner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () noEther {\n	}\n\n	/**************************\n	     Private functions\n	***************************/\n\n	function accountFor (address accountOwner, bool createNew) private returns (DaoAccount) {\n		DaoAccount account = daoAccounts[accountOwner];\n\n		if(account == DaoAccount(0x00) && createNew) {\n			account = new DaoAccount(accountOwner, tokenPrice, challengeOwner);\n			daoAccounts[accountOwner] = account;\n			notifyNewAccount(accountOwner, address(account));\n		}\n\n		return account;\n	}\n\n	/**************************\n	     Public functions\n	***************************/\n\n	function getTokenBalance () constant noEther returns (uint256 tokens) {\n		DaoAccount account = accountFor(msg.sender, false);\n		if (account == DaoAccount(0x00)) return 0;\n		return account.getTokenBalance();\n	}\n\n	function buyTokens () returns (uint256 tokens) {\n	  DaoAccount account = accountFor(msg.sender, true);\n		tokens = account.buyTokens.value(msg.value)();\n\n		notifyBuyToken(msg.sender, tokens, msg.value);\n		return tokens;\n 	}\n\n	function withdraw(uint256 tokens) noEther {\n		DaoAccount account = accountFor(msg.sender, false);\n		if (account == DaoAccount(0x00)) throw;\n\n		account.withdraw(tokens);\n		notifyWithdraw(msg.sender, tokens);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyChallengeOwner {\n		notifyTerminate(this.balance);\n		suicide(challengeOwner);\n	}\n}",1,実用的なDAOスマートコントラクトで、特に芸術的な要素は見られません。,
1963233,0x37c725c029a27d44031f94118facc245ad6298b5,false,false,,,,TOO_SHORT
1963541,0x70612dca2423ce174d3eeedbd4422eae146b8d69,false,false,,,,TOO_SHORT
1963696,0x1a084b2340d6d5017939c22a323ce6bfaf4703d7,false,false,,,,TOO_SHORT
1964043,0x9cf14e99254f5972a737bc3c9e081d93ca2bb0ed,false,false,,,,TOO_SHORT
1964199,0x6755bcda68f598a85edc47b9194cc13e7e828927,false,false,,,,TOO_SHORT
1964249,0x419a7ea65ec26d8d452f1ac6368d59557ba9329c,false,false,,,,TOO_SHORT
1964272,0x996ccbca26f94d3149ae89bf6fcc4c37d2e04cdb,false,false,,,,TOO_SHORT
1964411,0x901d23734dc8dbf3725cdac3e102939ac19615ea,false,false,,,,TOO_SHORT
1964497,0x802f3f16695cd69a62317b2fb4630a04b2ea70ba,false,false,,,,TOO_SHORT
1964677,0xcf00354366bca2f2cd49007bfaeac49d97463200,false,false,"contract ConnectSix {\n\n  uint8 constant public board_size = 19;\n\n  Game[] public games;\n\n  struct Game {\n      mapping(uint8 => mapping(uint8 => uint8)) board;\n      uint8[] move_history;\n      address[3] players;\n      // 0 means game did not start yet\n      uint8 turn;\n      // Either 1 or 2. 0 means not finished\n      uint8 winner;\n      // true if players agreed to a draw\n      uint time_per_move;\n      // if move is not made by this time, opponent can claim victory\n      uint deadline;\n      // amount player 1 put in\n      uint player_1_stake;\n      // amount player 2 must send to join\n      uint player_2_stake;\n  }\n\n  event LogGameCreated(uint game_num);\n  event LogGameStarted(uint game_num);\n  event LogVictory(uint game_num, uint8 winner);\n  event LogMoveMade(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2);\n\n  function new_game(uint _time_per_move, uint opponent_stake) {\n    games.length++;\n    Game g = games[games.length - 1];\n    g.players[1] = msg.sender;\n    g.time_per_move = _time_per_move;\n    g.player_1_stake = msg.value;\n    g.player_2_stake = opponent_stake;\n    // make the first move in the center of the board\n    g.board[board_size / 2][board_size / 2] = 1;\n    LogGameCreated(games.length - 1);\n  }\n\n  function join_game(uint game_num) {\n    Game g = games[game_num];\n    if (g.turn != 0 || g.player_2_stake != msg.value) {\n      throw;\n    }\n    g.players[2] = msg.sender;\n    // It's the second player's turn because the first player automatically makes a single move in the center\n    g.turn = 2;\n    g.deadline = now + g.time_per_move;\n    LogGameStarted(game_num);\n  }\n\n  function player_1(uint game_num) constant returns (address) {\n    return games[game_num].players[1];\n  }\n  \n  function player_2(uint game_num) constant returns (address) {\n    return games[game_num].players[2];\n  }\n\n  function board(uint game_num, uint8 x, uint8 y) constant returns (uint8) {\n    return games[game_num].board[x][y];\n  }\n\n  function move_history(uint game_num) constant returns (uint8[]) {\n      return games[game_num].move_history;\n  }\n\n  function single_move(uint game_num, uint8 x, uint8 y) internal {\n    if (x > board_size || y > board_size) {\n      throw;\n    }\n    Game g = games[game_num];\n    if (g.board[x][y] != 0) {\n      throw;\n    }\n    g.board[x][y] = g.turn;\n  }\n\n  function make_move(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2) {\n    Game g = games[game_num];\n    if (g.winner != 0 || msg.sender != g.players[g.turn]) {\n      throw;\n    }\n    single_move(game_num, x1, y1);\n    single_move(game_num, x2, y2);\n    g.turn = 3 - g.turn;\n    g.deadline = now + g.time_per_move;\n    g.move_history.length++;\n    g.move_history[g.move_history.length - 1] = x1;\n    g.move_history.length++;\n    g.move_history[g.move_history.length - 1] = y1;\n    g.move_history.length++;\n    g.move_history[g.move_history.length - 1] = x2;\n    g.move_history.length++;\n    g.move_history[g.move_history.length - 1] = y2;\n    LogMoveMade(game_num, x1, y1, x2, y2);\n  }\n\n  function make_move_and_claim_victory(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2, uint8 wx, uint8 wy, uint8 dir) {\n    make_move(game_num, x1, y1, x2, y2);\n    claim_victory(game_num, wx, wy, dir);\n  }\n  \n  function pay_winner(uint game_num) internal {\n    Game g = games[game_num];\n    uint amount = g.player_1_stake + g.player_2_stake;\n    if (amount > 0 && !g.players[g.winner].send(amount)) {\n      throw;\n    }\n  }\n\n  function claim_time_victory(uint game_num) {\n    Game g = games[game_num];\n    if (g.winner != 0 || g.deadline == 0 || now <= g.deadline) {\n      throw;\n    }\n    g.winner = 3 - g.turn;\n    pay_winner(game_num);\n    LogVictory(game_num, g.winner);\n  }\n\n  function claim_victory(uint game_num, uint8 x, uint8 y, uint8 dir) {\n    Game g = games[game_num];\n    if (x > board_size \n        || y > board_size\n        || g.winner != 0\n        || g.board[x][y] == 0\n        || dir > 3) {\n      throw;\n    }\n    // We don't have to worry about overflow and underflows here because all the values outside the \n    // 19 x 19 board are 0\n    if (dir == 3) {\n      // this is going diagonal (10:30pm)\n      for (uint8 j = 1; j < 6; j++) {\n        if (g.board[x - j*dx][y + j*dy] != g.board[x][y]) {\n          throw;\n        }\n      }\n    } else {\n      uint8 dx = 0;\n      uint8 dy = 0;\n      if (dir == 2) {\n        // diagonal - 1:30pm\n        dx = 1;\n        dy = 1;\n      } else if (dir == 1) {\n        // 12:00pm\n        dy = 1;\n      } else {\n        // 3 pm\n        dx = 1;\n      }\n      for (uint8 i = 1; i < 6; i++) {\n        if (g.board[x + i*dx][y + i*dy] != g.board[x][y]) {\n          throw;\n        }\n      }\n    }\n    g.winner = g.board[x][y];\n    pay_winner(game_num);\n    LogVictory(game_num, g.winner);\n  }\n}",1,ConnectSixゲームの実装で、実用的なスマートコントラクトとしての構造を持っています。,
1964694,0xaf65b0737169c1e5f249ced935fb0a785492150d,false,false,,,,TOO_SHORT
1964706,0xc500916c9506f7786b224f7abf9f10089a3adf8c,false,false,,,,0xcf00354366bca2f2cd49007bfaeac49d97463200
1964717,0xa35fc4d3ea15e0d9272dc181ee1c2761d5d0cabd,false,false,contract UsernameRegistry {\n\n  mapping(address => string) addr_to_str;\n  mapping(string => address) str_to_addr;\n\n  function register(string username) {\n    if (str_to_addr[username] != address(0)) {\n      // username taken\n      throw;\n    }\n    str_to_addr[addr_to_str[msg.sender]] = address(0);\n    addr_to_str[msg.sender] = username;\n    str_to_addr[username] = msg.sender;\n  }\n\n  function get_username(address addr) constant returns (string) {\n    return addr_to_str[addr];\n  }\n\n  function get_address(string username) constant returns (address) {\n    return str_to_addr[username];\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1964718,0x686983486aace29a153b463e23d38ad270a0e512,false,false,,,,0xa35fc4d3ea15e0d9272dc181ee1c2761d5d0cabd
1964745,0x2f324d8b3806463987a0fa4fc3535dec4ef18012,false,false,,,,TOO_SHORT
1964772,0xaedf8d463c3089ae3cda153d8855b71490b76fac,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1964886,0xab8d854ad7dfe1195972541176e04a6cf792cfba,false,false,,,,TOO_SHORT
1965087,0x6a6f1aac0483432ef170f005b28b9b7d089cd5ff,false,false,,,,TOO_SHORT
1965108,0x504d0373cf7439947b19d7bb2f0b44c041a5c286,false,false,,,,TOO_SHORT
1965204,0xa48aa621aace64ae6725768de113ef5814427a31,false,false,,,,TOO_SHORT
1965307,0x5d43d0ccbb55d76743ae5a7a3de228e1247cca95,false,false,,,,TOO_SHORT
1965413,0x9a42b515e195525e87007552b5eee3f038620e68,false,false,,,,TOO_SHORT
1965424,0x72f336ba708fe8638439676b0cb32177d8322cdf,false,false,,,,TOO_SHORT
1965593,0x7b5c0a4bdde926e3d6af2d44f3a890adb1e42765,false,false,,,,TOO_SHORT
1965751,0x3b5a8f8b3d94f5d2f2d6e9ab28adb4f0d80688f6,false,false,,,,TOO_SHORT
1965864,0x39e8af2aaaf30af5e0d0d19644894e78fd94539f,false,false,,,,TOO_SHORT
1965937,0xd2db8a9aae5b24bf2bc4d50c436ef9c007f762e9,false,false,,,,TOO_SHORT
1965959,0xf955fbc53f979e72cf9f074e14da7379045c1eb2,false,false,,,,TOO_SHORT
1965964,0xb6547a1a8e71dea8e2f26112245628f09d884cbf,false,false,,,,TOO_SHORT
1966067,0xbed4a346c506d2bc238a450eda5452a2602007c1,false,false,,,,TOO_SHORT
1966120,0xb403cf62b6fcfdf5ff70228bfa50cd532fa1843c,false,false,,,,TOO_SHORT
1966142,0x464e3a9ea8ee690d056932ec734842297b67cefe,false,false,,,,TOO_SHORT
1966176,0x51ec8ad7255201588a00de9edb00c707b72559ce,false,false,,,,TOO_SHORT
1966276,0x9ed46f4274367bf26ffe5549b87dea3b75f889fc,false,false,,,,TOO_SHORT
1966315,0x27d7235b9df6e6863806e61a95cc0fb2df181443,false,false,,,,TOO_SHORT
1966351,0xebf2bf80c3ddb0b6ac2f88be8dceec7bf12dff22,false,false,,,,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444
1966414,0x689f99b9abfab0f968973b7e275d3c35ad9a823c,false,false,,,,TOO_SHORT
1967041,0x87820228aaf1f6a51b609e453cc35c3c5d43d21a,false,false,,,,TOO_SHORT
1967045,0xf5b1542d5c05a004923268ef86a4209ff6245111,false,false,,,,TOO_SHORT
1967208,0xa45093f83898ccae12c882d423d13578598f9f03,false,false,,,,TOO_SHORT
1967503,0xb2a1ac7f7253b0ebf6410920ed1342c974bca67a,false,false,"// version 1.0\ncontract Randao {\n  struct Participant {\n      uint256   secret;\n      bytes32   commitment;\n      uint256   reward;\n      bool      revealed;\n      bool      rewarded;\n  }\n\n  struct Consumer {\n    address caddr;\n    uint256 bountypot;\n  }\n\n  struct Campaign {\n      uint32    bnum;\n      uint96    deposit;\n      uint16    commitBalkline;\n      uint16    commitDeadline;\n\n      uint256   random;\n      bool      settled;\n      uint256   bountypot;\n      uint32    commitNum;\n      uint32    revealsNum;\n\n      mapping (address => Consumer) consumers;\n      mapping (address => Participant) participants;\n  }\n\n  uint256 public numCampaigns;\n  Campaign[] public campaigns;\n  address public founder;\n\n  // Prevents methods from perfoming any value transfer\n  modifier noEther() { if (msg.value > 0) throw; _}\n\n  modifier blankAddress(address _n) { if (_n != 0) throw; _}\n\n  modifier moreThanZero(uint256 _deposit) { if (_deposit <= 0) throw; _}\n\n  modifier notBeBlank(bytes32 _s) { if (_s == """") throw;  _}\n\n  modifier beBlank(bytes32 _s) { if (_s != """") throw; _}\n\n  modifier beFalse(bool _t) { if (_t) throw; _}\n\n  function Randao() {\n      founder = msg.sender;\n  }\n\n  event CampaignAdded(uint256 indexed campaignID,\n                      address indexed from,\n                      uint32 indexed bnum,\n                      uint96 deposit,\n                      uint16 commitBalkline,\n                      uint16 commitDeadline,\n                      uint256 bountypot);\n\n  modifier timeLineCheck(uint32 _bnum, uint16 _commitBalkline, uint16 _commitDeadline) {\n      if (block.number >= _bnum) throw;\n      if (_commitBalkline <= 0) throw;\n      if (_commitDeadline <= 0) throw;\n      if (_commitDeadline >= _commitBalkline) throw;\n      if (block.number >= _bnum - _commitBalkline) throw;\n      _\n  }\n\n  function newCampaign(\n      uint32 _bnum,\n      uint96 _deposit,\n      uint16 _commitBalkline,\n      uint16 _commitDeadline\n  ) timeLineCheck(_bnum, _commitBalkline, _commitDeadline)\n    moreThanZero(_deposit) external returns (uint256 _campaignID) {\n      _campaignID = campaigns.length++;\n      Campaign c = campaigns[_campaignID];\n      numCampaigns++;\n      c.bnum = _bnum;\n      c.deposit = _deposit;\n      c.commitBalkline = _commitBalkline;\n      c.commitDeadline = _commitDeadline;\n      c.bountypot = msg.value;\n      c.consumers[msg.sender] = Consumer(msg.sender, msg.value);\n      CampaignAdded(_campaignID, msg.sender, _bnum, _deposit, _commitBalkline, _commitDeadline, msg.value);\n  }\n\n  event Follow(uint256 indexed CampaignId, address indexed from, uint256 bountypot);\n\n  function follow(uint256 _campaignID)\n    external returns (bool) {\n      Campaign c = campaigns[_campaignID];\n      Consumer consumer = c.consumers[msg.sender];\n      return followCampaign(_campaignID, c, consumer);\n  }\n\n  modifier checkFollowPhase(uint256 _bnum, uint16 _commitDeadline) {\n      if (block.number > _bnum - _commitDeadline) throw;\n      _\n  }\n\n  function followCampaign(\n      uint256 _campaignID,\n      Campaign storage c,\n      Consumer storage consumer\n  ) checkFollowPhase(c.bnum, c.commitDeadline)\n    blankAddress(consumer.caddr) internal returns (bool) {\n      c.bountypot += msg.value;\n      c.consumers[msg.sender] = Consumer(msg.sender, msg.value);\n      Follow(_campaignID, msg.sender, msg.value);\n      return true;\n  }\n\n  event Commit(uint256 indexed CampaignId, address indexed from, bytes32 commitment);\n\n  function commit(uint256 _campaignID, bytes32 _hs) notBeBlank(_hs) external {\n      Campaign c = campaigns[_campaignID];\n      commitmentCampaign(_campaignID, _hs, c);\n  }\n\n  modifier checkDeposit(uint256 _deposit) { if (msg.value != _deposit) throw; _}\n\n  modifier checkCommitPhase(uint256 _bnum, uint16 _commitBalkline, uint16 _commitDeadline) {\n      if (block.number < _bnum - _commitBalkline) throw;\n      if (block.number > _bnum - _commitDeadline) throw;\n      _\n  }\n\n  function commitmentCampaign(\n      uint256 _campaignID,\n      bytes32 _hs,\n      Campaign storage c\n  ) checkDeposit(c.deposit)\n    checkCommitPhase(c.bnum, c.commitBalkline, c.commitDeadline)\n    beBlank(c.participants[msg.sender].commitment) internal {\n      c.participants[msg.sender] = Participant(0, _hs, 0, false, false);\n      c.commitNum++;\n      Commit(_campaignID, msg.sender, _hs);\n  }\n\n  // For test\n  function getCommitment(uint256 _campaignID) noEther external returns (bytes32) {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      return p.commitment;\n  }\n\n  event Reveal(uint256 indexed CampaignId, address indexed from, uint256 secret);\n\n  function reveal(uint256 _campaignID, uint256 _s) noEther external {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      revealCampaign(_campaignID, _s, c, p);\n  }\n\n  modifier checkRevealPhase(uint256 _bnum, uint16 _commitDeadline) {\n      if (block.number <= _bnum - _commitDeadline) throw;\n      if (block.number >= _bnum) throw;\n      _\n  }\n\n  modifier checkSecret(uint256 _s, bytes32 _commitment) {\n      if (sha3(_s) != _commitment) throw;\n      _\n  }\n\n  function revealCampaign(\n    uint256 _campaignID,\n    uint256 _s,\n    Campaign storage c,\n    Participant storage p\n  ) checkRevealPhase(c.bnum, c.commitDeadline)\n    checkSecret(_s, p.commitment)\n    beFalse(p.revealed) internal {\n      p.secret = _s;\n      p.revealed = true;\n      c.revealsNum++;\n      c.random ^= p.secret;\n      Reveal(_campaignID, msg.sender, _s);\n  }\n\n  modifier bountyPhase(uint256 _bnum){ if (block.number < _bnum) throw; _}\n\n  function getRandom(uint256 _campaignID) noEther external returns (uint256) {\n      Campaign c = campaigns[_campaignID];\n      return returnRandom(c);\n  }\n\n  function returnRandom(Campaign storage c) bountyPhase(c.bnum) internal returns (uint256) {\n      if (c.revealsNum == c.commitNum) {\n          c.settled = true;\n          return c.random;\n      }\n  }\n\n  // The commiter get his bounty and deposit, there are three situations\n  // 1. Campaign succeeds.Every revealer gets his deposit and the bounty.\n  // 2. Someone revels, but some does not,Campaign fails.\n  // The revealer can get the deposit and the fines are distributed.\n  // 3. Nobody reveals, Campaign fails.Every commiter can get his deposit.\n  function getMyBounty(uint256 _campaignID) noEther external {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      transferBounty(c, p);\n  }\n\n  function transferBounty(\n      Campaign storage c,\n      Participant storage p\n    ) bountyPhase(c.bnum)\n      beFalse(p.rewarded) internal {\n      if (c.revealsNum > 0) {\n          if (p.revealed) {\n              uint256 share = calculateShare(c);\n              returnReward(share, c, p);\n          }\n      // Nobody reveals\n      } else {\n          returnReward(0, c, p);\n      }\n  }\n\n  function calculateShare(Campaign c) internal returns (uint256 _share) {\n      // Someone does not reveal. Campaign fails.\n      if (c.commitNum > c.revealsNum) {\n          _share = fines(c) / c.revealsNum;\n      // Campaign succeeds.\n      } else {\n          _share = c.bountypot / c.revealsNum;\n      }\n  }\n\n  function returnReward(\n      uint256 _share,\n      Campaign storage c,\n      Participant storage p\n  ) internal {\n      p.reward = _share;\n      p.rewarded = true;\n      if (!msg.sender.send(_share + c.deposit)) {\n          p.reward = 0;\n          p.rewarded = false;\n      }\n  }\n\n  function fines(Campaign c) internal returns (uint256) {\n      return (c.commitNum - c.revealsNum) * c.deposit;\n  }\n\n  // If the campaign fails, the consumers can get back the bounty.\n  function refundBounty(uint256 _campaignID) noEther external {\n      Campaign c = campaigns[_campaignID];\n      returnBounty(_campaignID, c);\n  }\n\n  modifier campaignFailed(uint32 _commitNum, uint32 _revealsNum) {\n      if (_commitNum == _revealsNum && _commitNum != 0) throw;\n      _\n  }\n\n  modifier beConsumer(address _caddr) {\n      if (_caddr != msg.sender) throw;\n      _\n  }\n\n  function returnBounty(uint256 _campaignID, Campaign storage c)\n    bountyPhase(c.bnum)\n    campaignFailed(c.commitNum, c.revealsNum)\n    beConsumer(c.consumers[msg.sender].caddr) internal {\n      uint256 bountypot = c.consumers[msg.sender].bountypot;\n      c.consumers[msg.sender].bountypot = 0;\n      if (!msg.sender.send(bountypot)) {\n          c.consumers[msg.sender].bountypot = bountypot;\n      }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1967587,0xdff542ed15c89b5824bfb1f8aeb1c7d8f2305d42,false,false,,,,TOO_SHORT
1967889,0x7a0bf02af836d5cd68522c78493491561885204f,false,false,,,,TOO_SHORT
1968009,0x04bb2442076fce5662d21f46d51cdce30aef67c2,false,false,,,,TOO_SHORT
1968037,0x0f0b5fc2659e340a4a2c2e15b58331853b463d51,false,false,,,,TOO_SHORT
1968088,0xfde8d5f77ef48bb7bf5766c7404691b9ee1dfca7,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1968088,0xc44e3857716199b3506bfcc949f2ae71490840c1,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1968088,0x569eb5247b2595a46852d146d0726c5356e68170,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1968088,0x10abb5efecdc09581f8b7cb95791fe2936790b4e,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1968147,0x260f7377ea874cfb6d4602769b635e9846f198b9,false,false,,,,TOO_SHORT
1968152,0xcdbccb3645bd9ff1dd37da172d76d850e4d2180a,false,false,,,,TOO_SHORT
1968183,0xe2839b4df4168b5fddc813883844162ba4a8bc6f,false,false,,,,TOO_SHORT
1968484,0x5b938b04f7f779f9339462ec5355c084ed897533,false,false,,,,TOO_SHORT
1968511,0x7c1986339b639d148cfeff0d6dcbaf046904e25e,false,false,,,,TOO_SHORT
1968531,0xe993348fa494282b7ea869e3d7a019f09fdd2c6a,false,false,,,,TOO_SHORT
1968533,0xe03a4b6771650258efb64dbd38332315624aab59,false,false,,,,TOO_SHORT
1968744,0x0f112f6698b23dd44060eca9c09f4b3463feb07f,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1968744,0xd4db9a4e7852d4424ef7ff5cfd8aa296bb7db705,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1968744,0xe0d0b2b8f0b22d44ffcc58423ab3bf6d457292f9,false,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1968744,0x39771e2d34eda36a49ff4fa4194d7fcb839165da,true,false,,,,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb
1969158,0xfbb6b81e57fb7747180a64fbcfc6f39109da0fdb,false,false,,,,TOO_SHORT
1969209,0xa73ea2f2c9e21c79f69816b2445a350d5b6589c1,false,false,,,,TOO_SHORT
1969449,0x720c5163c2fa8288855da1ec2c942c0d790bee97,false,false,,,,TOO_SHORT
1969450,0xf0af3fc587d38cd4d390800b240c92b7b546619f,false,false,,,,TOO_SHORT
1969523,0xa7bb597a0a7c760177d71dc1e4d759d7c0b7eb85,false,false,,,,TOO_SHORT
1969917,0x0d27e68ae3805f57389d7ca3b90b9740cbf2b1aa,false,false,,,,TOO_SHORT
1969965,0x3edff908a66564919601ba1b097da9216237969c,false,false,,,,TOO_SHORT
1970027,0xafe2783d0daf38d8569db4683253dff2f46e5bf6,false,false,,,,TOO_SHORT
1970042,0xdb9319e903ff655c8663c90d699fe094f6d1df69,false,false,,,,TOO_SHORT
1970062,0x049e4ef528d646f79d954d3f06ee119bfb5b4da3,false,false,,,,TOO_SHORT
1970363,0x3474627d4f63a678266bc17171d87f8570936622,false,false,"contract Splitter {\n    \n    bool _classic;\n    address _owner;\n    \n    function Splitter() {\n        _owner = msg.sender;\n\n        // Balance on classic is 0.000007625764205414 (at the time of this contract)\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance < 1 ether) {\n            _classic = true;\n        }\n    }\n\n    function isClassic() constant returns (bool) {\n        return _classic;\n    }\n    \n    // Returns the ether on the real network to the sender, while forwarding\n    // the classic ether to a new address.\n    function split(address classicAddress) {\n        if (_classic){\n            if (!(classicAddress.send(msg.value))) {\n                throw;\n            }\n        } else {\n            if (!(msg.sender.send(msg.value))) {\n                throw;\n            }\n        }\n    }\n\n    function claimDonations(uint balance) {\n        if (_owner != msg.sender) { return; }\n        if (!(_owner.send(balance))) {\n            throw;\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1970384,0xee1b0af7cc25184a9a9a16d9cb233e6e578bb814,false,false,,,,TOO_SHORT
1970648,0x400a464f72709c0c8702ebe746e649b09ccfef95,false,false,,,,TOO_SHORT
1970660,0x3bd619a80ca0924c1881d484981e84c1a2cad790,false,false,,,,TOO_SHORT
1970775,0xe2bb4e8a77fdf37c45a6cf0cb34f796e6b2bbd89,false,false,,,,TOO_SHORT
1970857,0x480cc6489c2a6dc00e74f41af526549d028db210,false,false,,,,TOO_SHORT
1970901,0xd57d34cb42ae8d22ef9da5eabd31f882aaffe14e,false,false,,,,TOO_SHORT
1971193,0x4a03c59ed41a4b9a57ad5e1f77ddac4ef6b09d62,false,false,,,,TOO_SHORT
1971278,0xec1a491d4edada15180c231b385a7088487be82f,false,false,,,,TOO_SHORT
1971304,0xa809d9847d13404746446b51356df963c2a7e788,false,false,,,,TOO_SHORT
1971345,0x838144721e2dc7c77d1fa476678262e50a659be5,false,false,,,,TOO_SHORT
1971382,0x62d69ef1038ec6b131566016a1de7569934b51da,false,false,,,,TOO_SHORT
1971392,0x77a76e328318e220f36164a2fddb4ccd1211b787,false,false,,,,TOO_SHORT
1971409,0x58c2e5ba3add79a44477d591f62c1424dcee1c8a,false,false,,,,TOO_SHORT
1971414,0x4e8fe1069d7a5eebe10506a2985967d22b5491db,false,false,,,,TOO_SHORT
1971422,0xeb1a56e623ab04fd9bdbcd3c6328192d5648c050,false,false,,,,TOO_SHORT
1971714,0x8a8f2885723775803ed1cb8efd72858822dd6d8a,false,false,,,,TOO_SHORT
1972044,0x3d55ac7a8ff94f6de8b4df162fd142a76893a62e,false,false,,,,TOO_SHORT
1972161,0x3be64d3e039ad16213f31c2972667eb9cf85bcbc,false,false,,,,TOO_SHORT
1972293,0x228f5aecdeb020c4428cf47eb5ba860cc9f7450e,false,false,,,,TOO_SHORT
1972804,0x73f535401a37f7116146ef99eeb5e2c91a85a070,false,false,,,,TOO_SHORT
1972845,0x8b1d89b19423a343e12f3bd2ab3b5ba8ba65aa38,false,false,,,,TOO_SHORT
1973116,0x78be431bd9c55c60689709b90547db65f3cda563,false,false,,,,0x5c353a8dde7c400a84a673719cc0a0800108ea73
1973528,0x36af6a3ef457d3d88d2d47e086e1b8892bbd6bd6,false,false,,,,TOO_SHORT
1973879,0xca16877ebc41bb407d25ecac234631182e6042fa,false,false,,,,TOO_SHORT
1973903,0xd3b370d81500a86fe6e571da496e39c181feaeec,false,false,,,,TOO_SHORT
1973920,0x50a446cabfb9121592466ed4b0f58ee9fe3aaefa,false,false,,,,TOO_SHORT
1974140,0xc436e00511e949f3aa47b7b618144e8ad3b1b0a5,false,false,,,,TOO_SHORT
1974367,0xe608a65c059dfa118b3bd3c2794b1d8218d5b33d,false,false,,,,TOO_SHORT
1974383,0x5d4c95284d7b0a271c2c030cf803b24646ee0dcb,false,false,"// This MasterRegistry keeps a list of all registries created using Regis.\n// From it, you can search registries by its name, tags or owner and retrieve\n// registries info.\n\ncontract MasterRegistry {\n\n    // This struct keeps a list of attributes that all registries have.\n    struct RegistryAttributes {\n        uint      creationTime;\n        string    description;\n        address   owner;\n        string    name;\n        bytes32[] tags;\n        uint      version; // To keep backward compatibility\n        uint      addressIndex; // Index in the addresses array for quick lookup.\n\n        // Keeps the solidity source of the registry\n        // Storing the source on the blockchain is expensive but it is worth it. \n        // Previous version didn't store and was able to rebuild the registry\n        // source from its parameters. But this showed to be problematic in \n        // some cases.\n        string source; \n        // To keep backward compatibility with version 1, source will have \n        // keyType and recordAttributes stored in the source variable and the\n        // solidity source for those old registries will be unavailable.\n    }\n\n    // Maps registry's address to its record.\n    mapping (address => RegistryAttributes) public registries;\n    uint public numRegistries;\n\n    // Keeps a list of all registries' addresses\n    address[] public addresses;\n\n    // maps owner -> list of registries' addresses\n    mapping (address => address[]) public indexedByOwner;\n\n    // maps tag -> list of registries' addresses\n    mapping (bytes32 => address[]) public indexedByTag;\n\n    // maps name -> list of registries' addresses\n    mapping (string => address[]) indexedByName; // cant use public here because it's indexed by string\n\n    modifier onlyOwner(address regAddress) {\n        if (registries[regAddress].owner != msg.sender) throw;\n        _\n    }\n\n    function addRegistryIntoOwnerIndex(address regAddress, address owner) internal {\n        address[] regs = indexedByOwner[owner];\n        regs.length++;\n        regs[regs.length - 1] = regAddress;\n    }\n\n    function addRegistryIntoNameIndex(address regAddress) internal {\n        address[] regs = indexedByName[registries[regAddress].name];\n        regs.length++;\n        regs[regs.length - 1] = regAddress;\n    }\n\n    function addRegistryIntoTagsIndex(address regAddress) internal {\n        bytes32[] tags = registries[regAddress].tags;\n        for (uint i = 0; i < tags.length; i++) {\n            address[] regs = indexedByTag[tags[i]];\n            regs.length++;\n            regs[regs.length - 1] = regAddress;\n        }\n    }\n\n    function register(address regAddress, address owner, string name, string description, \n                      bytes32[] tags, uint version, string source) {\n\n        if (registries[regAddress].creationTime != 0) {\n            // throw;\n            return;\n        }\n\n        registries[regAddress].creationTime = now;\n        //registries[regAddress].owner        = msg.sender;\n        registries[regAddress].owner        = owner;\n        registries[regAddress].description  = description;\n        registries[regAddress].name         = name;\n        registries[regAddress].version      = version;\n        registries[regAddress].tags         = tags;\n        registries[regAddress].source       = source;\n        registries[regAddress].addressIndex = numRegistries;\n        numRegistries++;\n\n        addresses.length++;\n        addresses[numRegistries - 1] = regAddress;\n\n        addRegistryIntoOwnerIndex(regAddress, owner);\n\n        addRegistryIntoNameIndex(regAddress);\n\n        addRegistryIntoTagsIndex(regAddress);\n\n    }\n\n    function removeRegistryFromOwnerIndex(address regAddress) internal {\n        address[] regs = indexedByOwner[msg.sender];\n        for (uint i = 0; i < regs.length; i++) {\n            if (regs[i] == regAddress) {\n                regs[i] = regs[regs.length - 1];\n                regs.length--;\n                break;\n            }\n        }\n    }\n\n    function removeRegistryFromNameIndex(address regAddress) internal {\n        address[] regs = indexedByName[registries[regAddress].name];\n        for (uint j = 0; j < regs.length; j++) {\n            if (regs[j] == regAddress) {\n                regs[j] = regs[regs.length - 1];\n                regs.length--;\n                break;\n            }\n        }\n    }\n\n    function removeRegistryFromTagsIndex(address regAddress) internal {\n        uint numTags = registries[regAddress].tags.length;\n        for (uint k = 0; k < numTags; k++) {\n            address[] regs = indexedByTag[registries[regAddress].tags[k]];\n            for (uint l = 0; l < regs.length; l++) {\n                if (regs[l] == regAddress) {\n                    regs[l] = regs[regs.length - 1];\n                    regs.length--;\n                    break;\n                }\n            }\n        }\n    }\n\n    function unregister(address regAddress) onlyOwner(regAddress) {\n\n        removeRegistryFromOwnerIndex(regAddress);\n        removeRegistryFromNameIndex(regAddress);\n        removeRegistryFromTagsIndex(regAddress);\n\n        addresses[registries[regAddress].addressIndex] = addresses[addresses.length - 1];\n        addresses.length--;\n\n        delete registries[regAddress];\n        numRegistries--;\n    }\n\n    function changeDescription(address regAddress, string newDescription) onlyOwner(regAddress) {\n        registries[regAddress].description = newDescription;\n    }\n\n    function changeName(address regAddress, string newName) onlyOwner(regAddress) {\n        removeRegistryFromNameIndex(regAddress);\n        registries[regAddress].name = newName;\n        addRegistryIntoNameIndex(regAddress);\n    }\n\n    function transfer(address regAddress, address newOwner) onlyOwner(regAddress) {\n        removeRegistryFromOwnerIndex(regAddress);\n        registries[regAddress].owner = newOwner;\n        addRegistryIntoOwnerIndex(regAddress, newOwner);\n    }\n\n    function searchByName(string name) constant returns (address[]) {\n        return indexedByName[name];\n    }\n\n    function searchByTag(bytes32 tag) constant returns (address[]) {\n        return indexedByTag[tag];\n    }\n\n    function searchByOwner(address owner) constant returns (address[]) {\n        return indexedByOwner[owner];\n    }\n\n    function getRegInfo(address regAddress) constant returns (address owner, uint creationTime, \n                        string name, string description, uint version, bytes32[] tags, string source) {\n        owner        = registries[regAddress].owner;\n        creationTime = registries[regAddress].creationTime;\n        name         = registries[regAddress].name;\n        description  = registries[regAddress].description;\n        version      = registries[regAddress].version;\n        tags         = registries[regAddress].tags;\n        source       = registries[regAddress].source;\n    }\n\n    // This function is only valid for a very small amount of time\n    // after which it will become useless!\n    // It was used to migrate registries from old MasterRegistry\n    // into this new one and fix old registries creation_time (which\n    // are now inside the registry itself).\n    function setTime(address regAddress, uint time) {\n        if (now < 1469830946) { // Valid up to 29-Jul-2016 19:22:26\n            registries[regAddress].creationTime = time;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。データ管理に焦点を当てた設計。,
1974475,0xc5bdb9a2b3e519ef917aaf128474785e9e53e5ad,false,false,,,,TOO_SHORT
1974593,0xb562bd22ede8ddf212eac3843d326c0aa039753a,false,false,,,,TOO_SHORT
1975020,0x74c1e4b8cae59269ec1d85d3d4f324396048f4ac,true,false,"/**\n * Author: Nick Johnson (arachnid at notdot.net)\n * Copyright 2016; licensed CC-BY-SA.\n * \n * BeerCoin is a new cryptocurrency intended to encapsulate and record the\n * concept of ""I owe you a beer"". Did someone answer a difficult question you\n * had? Send them a BeerCoin. Did they help you carry something heavy? Send\n * them a BeerCoin. Someone buy you a beer? Send them a BeerCoin.\n * \n * Unlike traditional currency, anyone can issue BeerCoin simply by sending it\n * to someone else. A person's BeerCoin is only as valuable as the recipient's\n * belief that they're good for the beer, should it ever be redeemed; a beer\n * owed to you by Vitalik Buterin is probably worth more than a beer owed to you\n * by the DAO hacker (but your opinions may differ on that point).\n * \n * BeerCoin is implemented as an ERC20 compatible token, with a few extensions.\n * Regular ERC20 transfers will create or resolve obligations between the two\n * parties; they will never transfer third-party BeerCoins. Additional methods\n * are provided to allow you transfer beers someone owes you to a third party;\n * if Satoshi Nakamoto owes you a beer, you can transfer that obligation to your\n * friend who just bought you one down at the pub. Methods are also provided for\n * determining the total number of beers a person owes, to help determine if\n * they're good for it, and for getting a list of accounts that owe someone a\n * beer.\n * \n * BeerCoin may confuse some wallets, such as Mist, that expect you can only\n * send currency up to your current total balance; since BeerCoin operates as\n * individual IOUs, that restriction doesn't apply. As a result, you will\n * sometimes need to call the 'transfer' function on the contract itself\n * instead of using the wallet's built in token support.\n * \n * If anyone finds a bug in the contract, I'll buy you a beer. If you find a bug\n * you can exploit to adjust balances without users' consent, I'll buy you two\n * (or more).\n * \n * If you feel obliged to me for creating this, send me a ? at\n * 0x5fC8A61e097c118cE43D200b3c4dcf726Cf783a9. Don't do it unless you mean it;\n * if we meet I'll surely redeem it.\n */\ncontract BeerCoin {\n    using Itmap for Itmap.AddressUintMap;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    struct UserAccount {\n        bool exists;\n        Itmap.AddressUintMap debtors; // People who owe you a beer\n        mapping(address=>uint) allowances;\n        uint maxCredit; // Most beers any individual may owe you\n        uint beersOwed; // Beers owed by this person\n        uint beersOwing; // Beers owed to this person\n    }\n    uint beersOwing;\n    uint defaultMaxCredit;\n    \n    function() {\n        throw;\n    }\n    \n    function BeerCoin(uint _defaultMaxCredit) {\n        defaultMaxCredit = _defaultMaxCredit;\n    }\n    \n    mapping(address=>UserAccount) accounts;\n\n    function maximumCredit(address owner) constant returns (uint) {\n        if(accounts[owner].exists) {\n            return accounts[owner].maxCredit;\n        } else {\n            return defaultMaxCredit;\n        }\n    }\n\n    function setMaximumCredit(uint credit) {\n        //640k ought to be enough for anyone\n        if(credit > 655360)\n            return;\n\n        if(!accounts[msg.sender].exists)\n            accounts[msg.sender].exists = true;\n        accounts[msg.sender].maxCredit = credit;\n    }\n    \n    function numDebtors(address owner) constant returns (uint) {\n        return accounts[owner].debtors.size();\n    }\n    \n    function debtor(address owner, uint idx) constant returns (address) {\n        return accounts[owner].debtors.index(idx);\n    }\n    \n    function debtors(address owner) constant returns (address[]) {\n        return accounts[owner].debtors.keys;\n    }\n\n    function totalSupply() constant returns (uint256 supply) {\n        return beersOwing;   \n    }\n    \n    function balanceOf(address owner) constant returns (uint256 balance) {\n        return accounts[owner].beersOwing;\n    }\n    \n    function balanceOf(address owner, address debtor) constant returns (uint256 balance) {\n        return accounts[owner].debtors.get(debtor);\n    }\n    \n    function totalDebt(address owner) constant returns (uint256 balance) {\n        return accounts[owner].beersOwed;\n    }\n    \n    function transfer(address to, uint256 value) returns (bool success) {\n        return doTransfer(msg.sender, to, value);\n    }\n    \n    function transferFrom(address from, address to, uint256 value) returns (bool) {\n        if(accounts[from].allowances[msg.sender] >= value && doTransfer(from, to, value)) {\n            accounts[from].allowances[msg.sender] -= value;\n            return true;\n        }\n        return false;\n    }\n    \n    function doTransfer(address from, address to, uint value) internal returns (bool) {\n        if(from == to)\n            return false;\n            \n        if(!accounts[to].exists) {\n            accounts[to].exists = true;\n            accounts[to].maxCredit = defaultMaxCredit;\n        }\n        \n        // Don't allow transfers that would exceed the recipient's credit limit.\n        if(value > accounts[to].maxCredit + accounts[from].debtors.get(to))\n            return false;\n        \n        Transfer(from, to, value);\n\n        value -= reduceDebt(to, from, value);\n        createDebt(from, to, value);\n\n        return true;\n    }\n    \n    // Transfers beers owed to you by `debtor` to `to`.\n    function transferOther(address to, address debtor, uint value) returns (bool) {\n        return doTransferOther(msg.sender, to, debtor, value);\n    }\n\n    // Allows a third party to transfer debt owed to you by `debtor` to `to`.    \n    function transferOtherFrom(address from, address to, address debtor, uint value) returns (bool) {\n        if(accounts[from].allowances[msg.sender] >= value && doTransferOther(from, to, debtor, value)) {\n            accounts[from].allowances[msg.sender] -= value;\n            return true;\n        }\n        return false;\n    }\n    \n    function doTransferOther(address from, address to, address debtor, uint value) internal returns (bool) {\n        if(from == to || to == debtor)\n            return false;\n            \n        if(!accounts[to].exists) {\n            accounts[to].exists = true;\n            accounts[to].maxCredit = defaultMaxCredit;\n        }\n        \n        if(transferDebt(from, to, debtor, value)) {\n            Transfer(from, to, value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    // Creates debt owed by `debtor` to `creditor` of amount `value`.\n    // Returns false without making changes if this would exceed `creditor`'s\n    // credit limit.\n    function createDebt(address debtor, address creditor, uint value) internal returns (bool) {\n        if(value == 0)\n            return true;\n        \n        if(value > accounts[creditor].maxCredit)\n            return false;\n\n        accounts[creditor].debtors.set(\n            debtor, accounts[creditor].debtors.get(debtor) + value);\n        accounts[debtor].beersOwed += value;\n        accounts[creditor].beersOwing += value;\n        beersOwing += value;\n        \n        return true;\n    }\n    \n    // Reduces debt owed by `debtor` to `creditor` by `value` or the total amount,\n    // whichever is less. Returns the amount of debt erased.\n    function reduceDebt(address debtor, address creditor, uint value) internal returns (uint) {\n        var owed = accounts[creditor].debtors.get(debtor);\n        if(value >= owed) {\n            value = owed;\n            \n            accounts[creditor].debtors.remove(debtor);\n        } else {\n            accounts[creditor].debtors.set(debtor, owed - value);\n        }\n        \n        accounts[debtor].beersOwed -= value;\n        accounts[creditor].beersOwing -= value;\n        beersOwing -= value;\n        \n        return value;\n    }\n    \n    // Transfers debt owed by `debtor` from `oldCreditor` to `newCreditor`.\n    // Returns false without making any changes if `value` exceeds the amount\n    // owed or if the transfer would exceed `newCreditor`'s credit limit.\n    function transferDebt(address oldCreditor, address newCreditor, address debtor, uint value) internal returns (bool) {\n        var owedOld = accounts[oldCreditor].debtors.get(debtor);\n        if(owedOld < value)\n            return false;\n        \n        var owedNew = accounts[newCreditor].debtors.get(debtor);\n        if(value + owedNew > accounts[newCreditor].maxCredit)\n            return false;\n        \n        \n        if(owedOld == value) {\n            accounts[oldCreditor].debtors.remove(debtor);\n        } else {\n            accounts[oldCreditor].debtors.set(debtor, owedOld - value);\n        }\n        accounts[oldCreditor].beersOwing -= value;\n        \n        accounts[newCreditor].debtors.set(debtor, owedNew + value);\n        accounts[newCreditor].beersOwing += value;\n        \n        return true;\n    }\n\n    function approve(address spender, uint256 value) returns (bool) {\n        accounts[msg.sender].allowances[spender] = value;\n        Approval(msg.sender, spender, value);\n        return true;\n    }\n    \n    function allowance(address owner, address spender) constant returns (uint256) {\n        return accounts[owner].allowances[spender];\n    }\n}\n\n\nlibrary Itmap {\n    struct AddressUintMapEntry {\n        uint value;\n        uint idx;\n    }\n    \n    struct AddressUintMap {\n        mapping(address=>AddressUintMapEntry) entries;\n        address[] keys;\n    }\n    \n    function set(AddressUintMap storage self, address k, uint v) internal {\n        var entry = self.entries[k];\n        if(entry.idx == 0) {\n            entry.idx = self.keys.length + 1;\n            self.keys.push(k);\n        }\n        entry.value = v;\n    }\n    \n    function get(AddressUintMap storage self, address k) internal returns (uint) {\n        return self.entries[k].value;\n    }\n    \n    function contains(AddressUintMap storage self, address k) internal returns (bool) {\n        return self.entries[k].idx > 0;\n    }\n    \n    function remove(AddressUintMap storage self, address k) internal {\n        var entry = self.entries[k];\n        if(entry.idx > 0) {\n            var otherkey = self.keys[self.keys.length - 1];\n            self.keys[entry.idx - 1] = otherkey;\n            self.keys.length -= 1;\n            \n            self.entries[otherkey].idx = entry.idx;\n            entry.idx = 0;\n            entry.value = 0;\n        }\n    }\n    \n    function size(AddressUintMap storage self) internal returns (uint) {\n        return self.keys.length;\n    }\n    \n    function index(AddressUintMap storage self, uint idx) internal returns (address) {\n        return self.keys[idx];\n    }\n}",2,ビールをテーマにしたユニークなコンセプトが詩的で、実用性と遊び心を兼ね備えています。,
1975228,0xa59115c42955dfba81d92b888ac745ce8f526c42,false,false,,,,TOO_SHORT
1975314,0xc6c6a391273f7e772fd83688559263a5660f80e7,false,false,,,,TOO_SHORT
1975354,0x52c312631d5593d9164a257abcd5c58d14b96600,false,false,,,,TOO_SHORT
1975405,0xdb1e011aec326ad94785c1941b34aa1981d26267,false,false,,,,TOO_SHORT
1975642,0x92fb112698b377023f3d076007b04608c03cf9d0,false,false,,,,TOO_SHORT
1975953,0x0a4f90f48b2b391c08ef10c6118d894c22051f09,false,false,,,,TOO_SHORT
1976062,0x7929dde8e5cb39cd14d43158dfb72d152046c5d0,false,false,,,,TOO_SHORT
1976102,0xdb5a19b797fc8b4a413c145a8344d77e4dcfe2e6,false,false,,,,TOO_SHORT
1976215,0x9516e448780f6d7be815a05f7aa7fb5367111dd0,false,false,,,,TOO_SHORT
1976267,0x945c3b07da1ad9aebbbc05aad56053ea7de0cac1,false,false,,,,TOO_SHORT
1976343,0xf258faa3a47db9c4adf9ef3393d5dcff4b386a2d,false,false,,,,TOO_SHORT
1976345,0xe9b136dc16fe37589c17cb1b5c319bcf4c12e47e,false,false,,,,TOO_SHORT
1976640,0x4079bda80d420f2503d9b846a637471651decceb,false,false,,,,0xc8d9890df1ff2e87be05e9edab3cca26f054b611
1976647,0x122a724f8de9ea2806cbc21b68833068c0945225,false,false,,,,TOO_SHORT
1976675,0x863309a2f8e437b7304135ed3e9f88e3543d7f26,false,false,,,,TOO_SHORT
1976951,0xfb438128dc7e2e78f65f0ca92055fc6d3a5e60d0,false,false,,,,TOO_SHORT
1977161,0x7f9af66163461009e9a4c57f6d3c6421bc47a663,false,false,contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract ClassicOnlyTransfer {\n\n  // Fork oracle to use\n  AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n  address public transferTo = 0x502f9aa95d45426915bff7b92ef90468b100cc9b;\n  \n  function () {\n    if ( amIOnTheFork.forked() ) throw;\n\n    transferTo.send( msg.value );\n  }\n  \n},1,フォーク検出と送金を行う実用的なスマートコントラクト。標準的な構造です。,
1977549,0x66b489a8481bf812c1c8d4dabc59e595c9dff81a,false,false,,,,TOO_SHORT
1977769,0x447c37430dde92b5203702fdd2fc48c82a06385a,false,false,,,,TOO_SHORT
1977826,0x753e1540934474162a7a1c7a3c865301b73a455b,false,false,,,,0xc8d9890df1ff2e87be05e9edab3cca26f054b611
1977876,0x85a6eccd5878608bba0d8b443b0ba0f052f84ff3,false,false,,,,TOO_SHORT
1977899,0x7ea1950d7fa5167d5dc92c26e537d7875553b88e,false,false,,,,TOO_SHORT
1978032,0x31fb20e476398cbd93ae03985d9a6cc0135ed98e,false,false,,,,TOO_SHORT
1978319,0xacbbcf1d039125f01e5a1c77d5220785e842c1da,false,false,,,,TOO_SHORT
1978437,0x9d0135658dd0472310e44bcd520fd0a141db0bbb,false,false,"contract DAO {\n    function balanceOf(address addr) returns (uint);\n    function transferFrom(address from, address to, uint balance) returns (bool);\n    function getNewDAOAddress(uint _proposalID) constant returns(address _newDAO);\n    uint public totalSupply;\n}\n\n/**\n * @title trustedChildRefund\n * @author Paul Szczesny, Alexey Akhunov\n * A simple refund contract for trusted childDAOs affected by the hard fork.\n * Based on the official WithdrawDAO contract found here: https://etherscan.io/address/0xbf4ed7b27f1d666546e30d74d50d173d20bca754#code\n */\ncontract trustedChildRefund {\n\n  DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);\n  uint[] public trustedProposals = [7, 10, 16, 20, 23, 26, 27, 28, 29, 31, 34, 37, 39, 41, 44, 52, 54, 56, 57, 60, 61, 63, 64, 65, 66];\n  mapping (uint => DAO) public whiteList;\n\n  /**\n  * Populates the whiteList based on the list of trusted proposal Ids.\n  */\n  function trustedChildRefund() {\n      for(uint i=0; i<trustedProposals.length; i++) {\n          uint proposalId = trustedProposals[i];\n          whiteList[proposalId] = DAO(mainDAO.getNewDAOAddress(proposalId));\n      }\n  }\n\n  /**\n  * Convienience function for the Curator to calculate the required amount of Wei\n  * that needs to be transferred to this contract.\n  */\n  function requiredEndowment() constant returns (uint endowment) {\n      uint sum = 0;\n      for(uint i=0; i<trustedProposals.length; i++) {\n          uint proposalId = trustedProposals[i];\n          DAO childDAO = whiteList[proposalId];\n          sum += childDAO.totalSupply();\n      }\n      return sum;\n  }\n\n  /**\n   * Function call to refund ETH by burning childDao tokens.\n   * @param proposalId The split proposal ID which created the childDao\n   * @dev This requires that the token-holder authorizes this contract's address using the approve() function.\n   */\n  function refund(uint proposalId) {\n    //Check the token balance\n    uint balance = whiteList[proposalId].balanceOf(msg.sender);\n\n    // Transfer childDao tokens first, then send Ether back in return\n    if (!whiteList[proposalId].transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))\n      throw;\n  }\n\n}",1,実用的なコードで、特定の目的を持つ標準的なスマートコントラクトです。,
1979010,0x681cfa128bc482612943488900e472534c162106,false,false,,,,TOO_SHORT
1979013,0x1f18d9e7058fc4becc96c6ce8e1dd7e712dd6d7d,false,false,,,,TOO_SHORT
1979062,0x0ce2af0a6d284dd3a58eb4ace4cc9b0700fc0aa3,false,false,,,,TOO_SHORT
1979207,0xfbc7239cf3e56aa335814ff390c6747c915e91b7,false,false,,,,TOO_SHORT
1980171,0x23b29c92e749e690d280c3606398b655a616c673,false,false,,,,TOO_SHORT
1980299,0xf6a24c43ffd55721608b96998a84d94413a54b97,false,false,,,,TOO_SHORT
1980372,0xe25d09a11f351c5c4e5250a95bb023448ecbc04c,false,false,,,,TOO_SHORT
1980513,0xa64a9976aafeca530d568ab3b6dc7cc130e34fe9,false,false,,,,TOO_SHORT
1980532,0x31a15253d6b595e0e6aacadb2cfc5a263ca61ebe,false,false,,,,TOO_SHORT
1980544,0xe3b90df49ee331d4e7c0d1d38be5863897cf1e78,false,false,,,,TOO_SHORT
1980763,0x7771f6c6c09e3c870c5f7e7623d1e883b72da746,false,false,,,,TOO_SHORT
1980765,0xd2c7b745fa0155b6ed8771c32f26cd2f780561f4,false,false,,,,TOO_SHORT
1980916,0xe9a670ce73db9ff80a2200a6c0cf410f3b144c88,false,false,,,,TOO_SHORT
1981025,0xdfb1fcc7fdbdadabb70b67382da37b519dad8081,false,false,,,,TOO_SHORT
1981189,0xa71ae82de24f8e89b07580dadfc65728ef77202d,false,false,,,,TOO_SHORT
1981227,0xc5b2508e878af367ba4957bdbeb2bbc6da5bb349,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract Ethsplit {\n\n    function split(address ethAddress, address etcAddress) {\n\n        if (amIOnTheFork.forked()) {\n            // if on the forked chain send ETH to ethAddress\n            ethAddress.call.value(msg.value)();\n        } \n        else {\n            // if not on the forked chain send ETC to etcAddress less fee\n            uint fee = msg.value/100;\n            fees.send(fee);\n            etcAddress.call.value(msg.value-fee)();\n        }\n    }\n\n    // Reject deposits to the contract\n    function () {\n        throw;  \n    }\n\n    // AmIOnTheFork oracle by _tr\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;\n}",1,フォークチェーンの判定と送金を行う実用的なスマートコントラクト。標準的な構造です。,
1981308,0xe0a773196d6c83595457f2f3f6fe4a459f7a85d7,false,false,,,,TOO_SHORT
1981389,0x170f555f612c5ac27c5a507d48e8d0ac77cd81e4,false,false,,,,TOO_SHORT
1981528,0x9bcdd9acededcf16ce8c51eb53029f92e66db9a0,false,false,,,,TOO_SHORT
1981635,0xc9f8db505c89881a27c941e2aae8ae0cc0b4432b,false,false,,,,TOO_SHORT
1981932,0xcc9724b345887827cb5eae025cad9f4ccc3c90f6,false,false,"// King of the Ether Throne Contracts.\n// Copyright (c) 2016 Kieran Elby. Released under the MIT License.\n// Version 0.9.9.2, July 2016.\n//\n// See also http://www.kingoftheether.com and\n// https://github.com/kieranelby/KingOfTheEtherThrone .\n// \n// This file contains a number of contracts, of which only\n// these three are normally created:\n//\n// - Kingdom        = maintains the throne for a kingdom\n// - World          = runs the world, which is a collection of kingdoms\n// - KingdomFactory = used internally by the World contract\n//\n// The ""Mixin"" contracts (ThroneRulesMixin, ReentryProtectorMixin,\n// CarefulSenderMixin, FundsHolderMixin, MoneyRounderMixin,\n// NameableMixin) contain functions / data / structures used\n// by the three main contracts.\n// The ExposedInternalsForTesting contract is used by automated tests.\n\n\n/// @title Mixin to help avoid recursive-call attacks.\ncontract ReentryProtectorMixin {\n\n    // true if we are inside an external function\n    bool reentryProtector;\n\n    // Mark contract as having entered an external function.\n    // Throws an exception if called twice with no externalLeave().\n    // For this to work, Contracts MUST:\n    //  - call externalEnter() at the start of each external function\n    //  - call externalLeave() at the end of each external function\n    //  - never use return statements in between enter and leave\n    //  - never call an external function from another function\n    // WARN: serious risk of contract getting stuck if used wrongly.\n    function externalEnter() internal {\n        if (reentryProtector) {\n            throw;\n        }\n        reentryProtector = true;\n    }\n\n    // Mark contract as having left an external function.\n    // Do this after each call to externalEnter().\n    function externalLeave() internal {\n        reentryProtector = false;\n    }\n\n}\n\n\n/// @title Mixin to help send ether to untrusted addresses.\ncontract CarefulSenderMixin {\n\n    // Seems a reasonable amount for a well-written fallback function.\n    uint constant suggestedExtraGasToIncludeWithSends = 23000;\n\n    // Send `_valueWei` of our ether to `_toAddress`, including\n    // `_extraGasIncluded` gas above the usual 2300 gas stipend\n    // with the send call.\n    //\n    // This needs care because there is no way to tell if _toAddress\n    // is externally owned or is another contract - and sending ether\n    // to a contract address will invoke its fallback function; this\n    // has three implications:\n    //\n    // 1) Danger of recursive attack.\n    //  The destination contract's fallback function (or another\n    //  contract it calls) may call back into this contract (including\n    //  our fallback function and external functions inherited, or into\n    //  other contracts in our stack), leading to unexpected behaviour.\n    //  Mitigations:\n    //   - protect all external functions against re-entry into\n    //     any of them (see ReentryProtectorMixin);\n    //   - program very defensively (e.g. debit balance before send).\n    //\n    // 2) Destination fallback function can fail.\n    //  If the destination contract's fallback function fails, ether\n    //  will not be sent and may be locked into the sending contract.\n    //  Unlike most errors, it will NOT cause this contract to throw.\n    //  Mitigations:\n    //   - check the return value from this function (see below).\n    //\n    // 3) Gas usage.\n    //  The destination fallback function will consume the gas supplied\n    //  in this transaction (which is fixed and set by the transaction\n    //  starter, though some clients do a good job of estimating it.\n    //  This is a problem for lottery-type contracts where one very\n    //  expensive-to-call receiving contract could 'poison' the lottery\n    //  contract by preventing it being invoked by another person who\n    //  cannot supply enough gas.\n    //  Mitigations:\n    //    - choose sensible value for _extraGasIncluded (by default\n    //      only 2300 gas is supplied to the destination function);\n    //    - if call fails consider whether to throw or to ring-fence\n    //      funds for later withdrawal.\n    //\n    // Returns:\n    //\n    //  True if-and-only-if the send call was made and did not throw\n    //  an error. In this case, we will no longer own the _valueWei\n    //  ether. Note that we cannot get the return value of the fallback\n    //  function called (if any).\n    //\n    //  False if the send was made but the destination fallback function\n    //  threw an error (or ran out of gas). If this hapens, we still own\n    //  _valueWei ether and the destination's actions were undone.\n    //\n    //  This function should not normally throw an error unless:\n    //    - not enough gas to make the send/call\n    //    - max call stack depth reached\n    //    - insufficient ether\n    //\n    function carefulSendWithFixedGas(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGasIncluded\n    ) internal returns (bool success) {\n        return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();\n    }\n\n}\n\n\n/// @title Mixin to help track who owns our ether and allow withdrawals.\ncontract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {\n\n    // Record here how much wei is owned by an address.\n    // Obviously, the entries here MUST be backed by actual ether\n    // owned by the contract - we cannot enforce that in this mixin.\n    mapping (address => uint) funds;\n\n    event FundsWithdrawnEvent(\n        address fromAddress,\n        address toAddress,\n        uint valueWei\n    );\n\n    /// @notice Amount of ether held for `_address`.\n    function fundsOf(address _address) constant returns (uint valueWei) {\n        return funds[_address];\n    }\n\n    /// @notice Send the caller (`msg.sender`) all ether they own.\n    function withdrawFunds() {\n        externalEnter();\n        withdrawFundsRP();\n        externalLeave();\n    }\n\n    /// @notice Send `_valueWei` of the ether owned by the caller\n    /// (`msg.sender`) to `_toAddress`, including `_extraGas` gas\n    /// beyond the normal stipend.\n    function withdrawFundsAdvanced(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGas\n    ) {\n        externalEnter();\n        withdrawFundsAdvancedRP(_toAddress, _valueWei, _extraGas);\n        externalLeave();\n    }\n\n    /// @dev internal version of withdrawFunds()\n    function withdrawFundsRP() internal {\n        address fromAddress = msg.sender;\n        address toAddress = fromAddress;\n        uint allAvailableWei = funds[fromAddress];\n        withdrawFundsAdvancedRP(\n            toAddress,\n            allAvailableWei,\n            suggestedExtraGasToIncludeWithSends\n        );\n    }\n\n    /// @dev internal version of withdrawFundsAdvanced(), also used\n    /// by withdrawFundsRP().\n    function withdrawFundsAdvancedRP(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGasIncluded\n    ) internal {\n        if (msg.value != 0) {\n            throw;\n        }\n        address fromAddress = msg.sender;\n        if (_valueWei > funds[fromAddress]) {\n            throw;\n        }\n        funds[fromAddress] -= _valueWei;\n        bool sentOk = carefulSendWithFixedGas(\n            _toAddress,\n            _valueWei,\n            _extraGasIncluded\n        );\n        if (!sentOk) {\n            throw;\n        }\n        FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);\n    }\n\n}\n\n\n/// @title Mixin to help make nicer looking ether amounts.\ncontract MoneyRounderMixin {\n\n    /// @notice Make `_rawValueWei` into a nicer, rounder number.\n    /// @return A value that:\n    ///   - is no larger than `_rawValueWei`\n    ///   - is no smaller than `_rawValueWei` * 0.999\n    ///   - has no more than three significant figures UNLESS the\n    ///     number is very small or very large in monetary terms\n    ///     (which we define as < 1 finney or > 10000 ether), in\n    ///     which case no precision will be lost.\n    function roundMoneyDownNicely(uint _rawValueWei) constant internal\n    returns (uint nicerValueWei) {\n        if (_rawValueWei < 1 finney) {\n            return _rawValueWei;\n        } else if (_rawValueWei < 10 finney) {\n            return 10 szabo * (_rawValueWei / 10 szabo);\n        } else if (_rawValueWei < 100 finney) {\n            return 100 szabo * (_rawValueWei / 100 szabo);\n        } else if (_rawValueWei < 1 ether) {\n            return 1 finney * (_rawValueWei / 1 finney);\n        } else if (_rawValueWei < 10 ether) {\n            return 10 finney * (_rawValueWei / 10 finney);\n        } else if (_rawValueWei < 100 ether) {\n            return 100 finney * (_rawValueWei / 100 finney);\n        } else if (_rawValueWei < 1000 ether) {\n            return 1 ether * (_rawValueWei / 1 ether);\n        } else if (_rawValueWei < 10000 ether) {\n            return 10 ether * (_rawValueWei / 10 ether);\n        } else {\n            return _rawValueWei;\n        }\n    }\n    \n    /// @notice Convert `_valueWei` into a whole number of finney.\n    /// @return The smallest whole number of finney which is equal\n    /// to or greater than `_valueWei` when converted to wei.\n    /// WARN: May be incorrect if `_valueWei` is above 2**254.\n    function roundMoneyUpToWholeFinney(uint _valueWei) constant internal\n    returns (uint valueFinney) {\n        return (1 finney + _valueWei - 1 wei) / 1 finney;\n    }\n\n}\n\n\n/// @title Mixin to help allow users to name things.\ncontract NameableMixin {\n\n    // String manipulation is expensive in the EVM; keep things short.\n\n    uint constant minimumNameLength = 1;\n    uint constant maximumNameLength = 25;\n    string constant nameDataPrefix = ""NAME:"";\n\n    /// @notice Check if `_name` is a reasonable choice of name.\n    /// @return True if-and-only-if `_name_` meets the criteria\n    /// below, or false otherwise:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    ///   - at least one non-punctuation character\n    /// Note that we deliberately exclude characters which may cause\n    /// security problems for websites and databases if escaping is\n    /// not performed correctly, such as < > "" and '.\n    /// Apologies for the lack of non-English language support.\n    function validateNameInternal(string _name) constant internal\n    returns (bool allowed) {\n        bytes memory nameBytes = bytes(_name);\n        uint lengthBytes = nameBytes.length;\n        if (lengthBytes < minimumNameLength ||\n            lengthBytes > maximumNameLength) {\n            return false;\n        }\n        bool foundNonPunctuation = false;\n        for (uint i = 0; i < lengthBytes; i++) {\n            byte b = nameBytes[i];\n            if (\n                (b >= 48 && b <= 57) || // 0 - 9\n                (b >= 65 && b <= 90) || // A - Z\n                (b >= 97 && b <= 122)   // a - z\n            ) {\n                foundNonPunctuation = true;\n                continue;\n            }\n            if (\n                b == 32 || // space\n                b == 33 || // !\n                b == 40 || // (\n                b == 41 || // )\n                b == 45 || // -\n                b == 46 || // .\n                b == 95    // _\n            ) {\n                continue;\n            }\n            return false;\n        }\n        return foundNonPunctuation;\n    }\n\n    // Extract a name from bytes `_data` (presumably from `msg.data`),\n    // or throw an exception if the data is not in the expected format.\n    // \n    // We want to make it easy for people to name things, even if\n    // they're not comfortable calling functions on contracts.\n    //\n    // So we allow names to be sent to the fallback function encoded\n    // as message data.\n    //\n    // Unfortunately, the way the Ethereum Function ABI works means we\n    // must be careful to avoid clashes between message data that\n    // represents our names and message data that represents a call\n    // to an external function - otherwise:\n    //   a) some names won't be usable;\n    //   b) small possibility of a phishing attack where users are\n    //     tricked into using certain names which cause an external\n    //     function call - e.g. if the data sent to the contract is\n    //     keccak256(""withdrawFunds()"") then a withdrawal will occur.\n    //\n    // So we require a prefix ""NAME:"" at the start of the name (encoded\n    // in ASCII) when sent via the fallback function - this prefix\n    // doesn't clash with any external function signature hashes.\n    //\n    // e.g. web3.fromAscii('NAME:' + 'Joe Bloggs')\n    //\n    // WARN: this does not check the name for ""reasonableness"";\n    // use validateNameInternal() for that.\n    //\n    function extractNameFromData(bytes _data) constant internal\n    returns (string extractedName) {\n        // check prefix present\n        uint expectedPrefixLength = (bytes(nameDataPrefix)).length;\n        if (_data.length < expectedPrefixLength) {\n            throw;\n        }\n        uint i;\n        for (i = 0; i < expectedPrefixLength; i++) {\n            if ((bytes(nameDataPrefix))[i] != _data[i]) {\n                throw;\n            }\n        }\n        // copy data after prefix\n        uint payloadLength = _data.length - expectedPrefixLength;\n        if (payloadLength < minimumNameLength ||\n            payloadLength > maximumNameLength) {\n            throw;\n        }\n        string memory name = new string(payloadLength);\n        for (i = 0; i < payloadLength; i++) {\n            (bytes(name))[i] = _data[expectedPrefixLength + i];\n        }\n        return name;\n    }\n\n    // Turn a short name into a ""fuzzy hash"" with the property\n    // that extremely similar names will have the same fuzzy hash.\n    //\n    // This is useful to:\n    //  - stop people choosing names which differ only in case or\n    //    punctuation and would lead to confusion.\n    //  - faciliate searching by name without needing exact match\n    //\n    // For example, these names all have the same fuzzy hash:\n    //\n    //  ""Banana""\n    //  ""BANANA""\n    //  ""Ba-na-na""\n    //  ""  banana  ""\n    //  ""Banana                        .. so long the end is ignored""\n    //\n    // On the other hand, ""Banana1"" and ""A Banana"" are different to\n    // the above.\n    //\n    // WARN: this is likely to work poorly on names that do not meet\n    // the validateNameInternal() test.\n    //\n    function computeNameFuzzyHash(string _name) constant internal\n    returns (uint fuzzyHash) {\n        bytes memory nameBytes = bytes(_name);\n        uint h = 0;\n        uint len = nameBytes.length;\n        if (len > maximumNameLength) {\n            len = maximumNameLength;\n        }\n        for (uint i = 0; i < len; i++) {\n            uint mul = 128;\n            byte b = nameBytes[i];\n            uint ub = uint(b);\n            if (b >= 48 && b <= 57) {\n                // 0-9\n                h = h * mul + ub;\n            } else if (b >= 65 && b <= 90) {\n                // A-Z\n                h = h * mul + ub;\n            } else if (b >= 97 && b <= 122) {\n                // fold a-z to A-Z\n                uint upper = ub - 32;\n                h = h * mul + upper;\n            } else {\n                // ignore others\n            }\n        }\n        return h;\n    }\n\n}\n\n\n/// @title Mixin to help define the rules of a throne.\ncontract ThroneRulesMixin {\n\n    // See World.createKingdom(..) for documentation.\n    struct ThroneRules {\n        uint startingClaimPriceWei;\n        uint maximumClaimPriceWei;\n        uint claimPriceAdjustPercent;\n        uint curseIncubationDurationSeconds;\n        uint commissionPerThousand;\n    }\n\n}\n\n\n/// @title Maintains the throne of a kingdom.\ncontract Kingdom is\n  ReentryProtectorMixin,\n  CarefulSenderMixin,\n  FundsHolderMixin,\n  MoneyRounderMixin,\n  NameableMixin,\n  ThroneRulesMixin {\n\n    // e.g. ""King of the Ether""\n    string public kingdomName;\n\n    // The World contract used to create this kingdom, or 0x0 if none.\n    address public world;\n\n    // The rules that govern this kingdom - see ThroneRulesMixin.\n    ThroneRules public rules;\n\n    // Someone who has ruled (or is ruling) our kingdom.\n    struct Monarch {\n        // where to send their compensation\n        address compensationAddress;\n        // their name\n        string name;\n        // when they became our ruler\n        uint coronationTimestamp;\n        // the claim price paid (excluding any over-payment)\n        uint claimPriceWei;\n        // the compensation sent to or held for them so far\n        uint compensationWei;\n    }\n\n    // The first ruler is number 1; the zero-th entry is a dummy entry.\n    Monarch[] public monarchsByNumber;\n\n    // The topWizard earns half the commission.\n    // They are normally the owner of the World contract.\n    address public topWizard;\n\n    // The subWizard earns half the commission.\n    // They are normally the creator of this Kingdom.\n    // The topWizard and subWizard can be the same address.\n    address public subWizard;\n\n    // NB: we also have a `funds` mapping from FundsHolderMixin,\n    // and a rentryProtector from ReentryProtectorMixin.\n\n    event ThroneClaimedEvent(uint monarchNumber);\n    event CompensationSentEvent(address toAddress, uint valueWei);\n    event CompensationFailEvent(address toAddress, uint valueWei);\n    event CommissionEarnedEvent(address byAddress, uint valueWei);\n    event WizardReplacedEvent(address oldWizard, address newWizard);\n    // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin\n\n    // WARN - does NOT validate arguments; you MUST either call\n    // KingdomFactory.validateProposedThroneRules() or create\n    // the Kingdom via KingdomFactory/World's createKingdom().\n    // See World.createKingdom(..) for parameter documentation.\n    function Kingdom(\n        string _kingdomName,\n        address _world,\n        address _topWizard,\n        address _subWizard,\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) {\n        kingdomName = _kingdomName;\n        world = _world;\n        topWizard = _topWizard;\n        subWizard = _subWizard;\n        rules = ThroneRules(\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n        // We number the monarchs starting from 1; it's sometimes useful\n        // to use zero = invalid, so put in a dummy entry for number 0.\n        monarchsByNumber.push(\n            Monarch(\n                0,\n                """",\n                0,\n                0,\n                0\n            )\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint totalCount) {\n        // zero-th entry is invalid\n        return monarchsByNumber.length - 1;\n    }\n\n    // False if either there are no monarchs, or if the latest monarch\n    // has reigned too long and been struck down by the curse.\n    function isLivingMonarch() constant returns (bool alive) {\n        if (numberOfMonarchs() == 0) {\n            return false;\n        }\n        uint reignStartedTimestamp = latestMonarchInternal().coronationTimestamp;\n        if (now < reignStartedTimestamp) {\n            // Should not be possible, think miners reject blocks with\n            // timestamps that go backwards? But some drift possible and\n            // it needs handling for unsigned overflow audit checks ...\n            return true;\n        }\n        uint elapsedReignDurationSeconds = now - reignStartedTimestamp;\n        if (elapsedReignDurationSeconds > rules.curseIncubationDurationSeconds) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice How much you must pay to claim the throne now, in wei.\n    function currentClaimPriceWei() constant returns (uint priceInWei) {\n        if (!isLivingMonarch()) {\n            return rules.startingClaimPriceWei;\n        } else {\n            uint lastClaimPriceWei = latestMonarchInternal().claimPriceWei;\n            // no danger of overflow because claim price never gets that high\n            uint newClaimPrice =\n              (lastClaimPriceWei * (100 + rules.claimPriceAdjustPercent)) / 100;\n            newClaimPrice = roundMoneyDownNicely(newClaimPrice);\n            if (newClaimPrice < rules.startingClaimPriceWei) {\n                newClaimPrice = rules.startingClaimPriceWei;\n            }\n            if (newClaimPrice > rules.maximumClaimPriceWei) {\n                newClaimPrice = rules.maximumClaimPriceWei;\n            }\n            return newClaimPrice;\n        }\n    }\n\n    /// @notice How much you must pay to claim the throne now, in finney.\n    function currentClaimPriceInFinney() constant\n    returns (uint priceInFinney) {\n        uint valueWei = currentClaimPriceWei();\n        return roundMoneyUpToWholeFinney(valueWei);\n    }\n\n    /// @notice Check if a name can be used as a monarch name.\n    /// @return True if the name satisfies the criteria of:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    function validateProposedMonarchName(string _monarchName) constant\n    returns (bool allowed) {\n        return validateNameInternal(_monarchName);\n    }\n\n    // Get details of the latest monarch (even if they are dead).\n    //\n    // We don't expose externally because returning structs is not well\n    // supported in the ABI (strange that monarchsByNumber array works\n    // fine though). Note that the reference returned is writable - it\n    // can be used to update details of the latest monarch.\n    // WARN: you should check numberOfMonarchs() > 0 first.\n    function latestMonarchInternal() constant internal\n    returns (Monarch storage monarch) {\n        return monarchsByNumber[monarchsByNumber.length - 1];\n    }\n\n    /// @notice Claim throne by sending funds to the contract.\n    /// Any future compensation earned will be sent to the sender's\n    /// address (`msg.sender`).\n    /// Sending from a contract is not recommended unless you know\n    /// what you're doing (and you've tested it).\n    /// If no message data is supplied, the throne will be claimed in\n    /// the name of ""Anonymous"". To supply a name, send data encoded\n    /// using web3.fromAscii('NAME:' + 'your_chosen_valid_name').\n    /// Sender must include payment equal to currentClaimPriceWei().\n    /// Will consume up to ~300,000 gas.\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedMonarchName(string)`)\n    ///   - payment is too low or too high\n    /// Produces events:\n    ///   - `ThroneClaimedEvent`\n    ///   - `CompensationSentEvent` / `CompensationFailEvent`\n    ///   - `CommissionEarnedEvent`\n    function () {\n        externalEnter();\n        fallbackRP();\n        externalLeave();\n    }\n\n    /// @notice Claim throne in the given `_monarchName`.\n    /// Any future compensation earned will be sent to the caller's\n    /// address (`msg.sender`).\n    /// Caller must include payment equal to currentClaimPriceWei().\n    /// Calling from a contract is not recommended unless you know\n    /// what you're doing (and you've tested it).\n    /// Will consume up to ~300,000 gas.\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedMonarchName(string)`)\n    ///   - payment is too low or too high\n    /// Produces events:\n    ///   - `ThroneClaimedEvent\n    ///   - `CompensationSentEvent` / `CompensationFailEvent`\n    ///   - `CommissionEarnedEvent`\n    function claimThrone(string _monarchName) {\n        externalEnter();\n        claimThroneRP(_monarchName);\n        externalLeave();\n    }\n\n    /// @notice Used by either the topWizard or subWizard to transfer\n    /// all rights to future commissions to the `_replacement` wizard.\n    /// WARN: The original wizard retains ownership of any past\n    /// commission held for them in the `funds` mapping, which they\n    /// can still withdraw.\n    /// Produces event WizardReplacedEvent.\n    function replaceWizard(address _replacement) {\n        externalEnter();\n        replaceWizardRP(_replacement);\n        externalLeave();\n    }\n\n    function fallbackRP() internal {\n        if (msg.data.length == 0) {\n            claimThroneRP(""Anonymous"");\n        } else {\n            string memory _monarchName = extractNameFromData(msg.data);\n            claimThroneRP(_monarchName);\n        }\n    }\n    \n    function claimThroneRP(\n        string _monarchName\n    ) internal {\n\n        address _compensationAddress = msg.sender;\n\n        if (!validateNameInternal(_monarchName)) {\n            throw;\n        }\n\n        if (_compensationAddress == 0 ||\n            _compensationAddress == address(this)) {\n            throw;\n        }\n\n        uint paidWei = msg.value;\n        uint priceWei = currentClaimPriceWei();\n        if (paidWei < priceWei) {\n            throw;\n        }\n        // Make it easy for people to pay using a whole number of finney,\n        // which could be a teeny bit higher than the raw wei value.\n        uint excessWei = paidWei - priceWei;\n        if (excessWei > 1 finney) {\n            throw;\n        }\n        \n        uint compensationWei;\n        uint commissionWei;\n        if (!isLivingMonarch()) {\n            // dead men get no compensation\n            commissionWei = paidWei;\n            compensationWei = 0;\n        } else {\n            commissionWei = (paidWei * rules.commissionPerThousand) / 1000;\n            compensationWei = paidWei - commissionWei;\n        }\n\n        if (commissionWei != 0) {\n            recordCommissionEarned(commissionWei);\n        }\n\n        if (compensationWei != 0) {\n            compensateLatestMonarch(compensationWei);\n        }\n\n        // In case of any teeny excess, we use the official price here\n        // since that should determine the new claim price, not paidWei.\n        monarchsByNumber.push(Monarch(\n            _compensationAddress,\n            _monarchName,\n            now,\n            priceWei,\n            0\n        ));\n\n        ThroneClaimedEvent(monarchsByNumber.length - 1);\n    }\n\n    function replaceWizardRP(address replacement) internal {\n        if (msg.value != 0) {\n            throw;\n        }\n        bool replacedOk = false;\n        address oldWizard;\n        if (msg.sender == topWizard) {\n            oldWizard = topWizard;\n            topWizard = replacement;\n            WizardReplacedEvent(oldWizard, replacement);\n            replacedOk = true;\n        }\n        // Careful - topWizard and subWizard can be the same address,\n        // in which case we must replace both.\n        if (msg.sender == subWizard) {\n            oldWizard = subWizard;\n            subWizard = replacement;\n            WizardReplacedEvent(oldWizard, replacement);\n            replacedOk = true;\n        }\n        if (!replacedOk) {\n            throw;\n        }\n    }\n\n    // Allow commission funds to build up in contract for the wizards\n    // to withdraw (carefully ring-fenced).\n    function recordCommissionEarned(uint _commissionWei) internal {\n        // give the subWizard any ""odd"" single wei\n        uint topWizardWei = _commissionWei / 2;\n        uint subWizardWei = _commissionWei - topWizardWei;\n        funds[topWizard] += topWizardWei;\n        CommissionEarnedEvent(topWizard, topWizardWei);\n        funds[subWizard] += subWizardWei;\n        CommissionEarnedEvent(subWizard, subWizardWei);\n    }\n\n    // Send compensation to latest monarch (or hold funds for them\n    // if cannot through no fault of current caller).\n    function compensateLatestMonarch(uint _compensationWei) internal {\n        address compensationAddress =\n          latestMonarchInternal().compensationAddress;\n        // record that we compensated them\n        latestMonarchInternal().compensationWei = _compensationWei;\n        // WARN: if the latest monarch is a contract whose fallback\n        // function needs more 25300 gas than then they will NOT\n        // receive compensation automatically.\n        bool sentOk = carefulSendWithFixedGas(\n            compensationAddress,\n            _compensationWei,\n            suggestedExtraGasToIncludeWithSends\n        );\n        if (sentOk) {\n            CompensationSentEvent(compensationAddress, _compensationWei);\n        } else {\n            // This should only happen if the latest monarch is a contract\n            // whose fallback-function failed or ran out of gas (despite\n            // us including a fair amount of gas).\n            // We do not throw since we do not want the throne to get\n            // 'stuck' (it's not the new usurpers fault) - instead save\n            // the funds we could not send so can be claimed later.\n            // Their monarch contract would need to have been designed\n            // to call our withdrawFundsAdvanced(..) function mind you.\n            funds[compensationAddress] += _compensationWei;\n            CompensationFailEvent(compensationAddress, _compensationWei);\n        }\n    }\n\n}\n\n\n/// @title Used by the World contract to create Kingdom instances.\n/// @dev Mostly exists so topWizard can potentially replace this\n/// contract to modify the Kingdom contract and/or rule validation\n/// logic to be used for *future* Kingdoms created by the World.\n/// We do not implement rentry protection because we don't send/call.\n/// We do not charge a fee here - but if you bypass the World then\n/// you won't be listed on the official World page of course.\ncontract KingdomFactory {\n\n    function KingdomFactory() {\n    }\n\n    function () {\n        // this contract should never have a balance\n        throw;\n    }\n\n    // See World.createKingdom(..) for parameter documentation.\n    function validateProposedThroneRules(\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) constant returns (bool allowed) {\n        // I suppose there is a danger that massive deflation/inflation could\n        // change the real-world sanity of these checks, but in that case we\n        // can deploy a new factory and update the world.\n        if (_startingClaimPriceWei < 1 finney ||\n            _startingClaimPriceWei > 100 ether) {\n            return false;\n        }\n        if (_maximumClaimPriceWei < 1 ether ||\n            _maximumClaimPriceWei > 100000 ether) {\n            return false;\n        }\n        if (_startingClaimPriceWei * 20 > _maximumClaimPriceWei) {\n            return false;\n        }\n        if (_claimPriceAdjustPercent < 1 ||\n            _claimPriceAdjustPercent > 900) {\n            return false;\n        }\n        if (_curseIncubationDurationSeconds < 2 hours ||\n            _curseIncubationDurationSeconds > 10000 days) {\n            return false;\n        }\n        if (_commissionPerThousand < 10 ||\n            _commissionPerThousand > 100) {\n            return false;\n        }\n        return true;\n    }\n\n    /// @notice Create a new Kingdom. Normally called by World contract.\n    /// WARN: Does NOT validate the _kingdomName or _world arguments.\n    /// Will consume up to 1,800,000 gas (!)\n    /// Will throw an error if:\n    ///   - rules invalid (see validateProposedThroneRules)\n    ///   - wizard addresses ""obviously"" wrong\n    ///   - out of gas quite likely (perhaps in future should consider\n    ///     using solidity libraries to reduce Kingdom size?)\n    // See World.createKingdom(..) for parameter documentation.\n    function createKingdom(\n        string _kingdomName,\n        address _world,\n        address _topWizard,\n        address _subWizard,\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) returns (Kingdom newKingdom) {\n        if (msg.value > 0) {\n            // this contract should never have a balance\n            throw;\n        }\n        // NB: topWizard and subWizard CAN be the same as each other.\n        if (_topWizard == 0 || _subWizard == 0) {\n            throw;\n        }\n        if (_topWizard == _world || _subWizard == _world) {\n            throw;\n        }\n        if (!validateProposedThroneRules(\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        )) {\n            throw;\n        }\n        return new Kingdom(\n            _kingdomName,\n            _world,\n            _topWizard,\n            _subWizard,\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n    }\n\n}\n\n\n/// @title Runs the world, which is a collection of Kingdoms.\ncontract World is\n  ReentryProtectorMixin,\n  NameableMixin,\n  MoneyRounderMixin,\n  FundsHolderMixin,\n  ThroneRulesMixin {\n\n    // The topWizard runs the world. They charge for the creation of\n    // kingdoms and become the topWizard in each kingdom created.\n    address public topWizard;\n\n    // How much one must pay to create a new kingdom (in wei).\n    // Can be changed by the topWizard.\n    uint public kingdomCreationFeeWei;\n\n    struct KingdomListing {\n        uint kingdomNumber;\n        string kingdomName;\n        address kingdomContract;\n        address kingdomCreator;\n        uint creationTimestamp;\n        address kingdomFactoryUsed;\n    }\n    \n    // The first kingdom is number 1; the zero-th entry is a dummy.\n    KingdomListing[] public kingdomsByNumber;\n\n    // For safety, we cap just how high the price can get.\n    // Can be changed by the topWizard, though it will only affect\n    // kingdoms created after that.\n    uint public maximumClaimPriceWei;\n\n    // Helper contract for creating Kingdom instances. Can be\n    // upgraded by the topWizard (won't affect existing ones).\n    KingdomFactory public kingdomFactory;\n\n    // Avoids duplicate kingdom names and allows searching by name.\n    mapping (uint => uint) kingdomNumbersByfuzzyHash;\n\n    // NB: we also have a `funds` mapping from FundsHolderMixin,\n    // and a rentryProtector from ReentryProtectorMixin.\n\n    event KingdomCreatedEvent(uint kingdomNumber);\n    event CreationFeeChangedEvent(uint newFeeWei);\n    event FactoryChangedEvent(address newFactory);\n    event WizardReplacedEvent(address oldWizard, address newWizard);\n    // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin\n\n    // Create the world with no kingdoms yet.\n    // Costs about 1.9M gas to deploy.\n    function World(\n        address _topWizard,\n        uint _kingdomCreationFeeWei,\n        KingdomFactory _kingdomFactory,\n        uint _maximumClaimPriceWei\n    ) {\n        if (_topWizard == 0) {\n            throw;\n        }\n        if (_maximumClaimPriceWei < 1 ether) {\n            throw;\n        }\n        topWizard = _topWizard;\n        kingdomCreationFeeWei = _kingdomCreationFeeWei;\n        kingdomFactory = _kingdomFactory;\n        maximumClaimPriceWei = _maximumClaimPriceWei;\n        // We number the kingdoms starting from 1 since it's sometimes\n        // useful to use zero = invalid. Create dummy zero-th entry.\n        kingdomsByNumber.push(KingdomListing(0, """", 0, 0, 0, 0));\n    }\n\n    function numberOfKingdoms() constant returns (uint totalCount) {\n        return kingdomsByNumber.length - 1;\n    }\n\n    /// @return index into kingdomsByNumber if found, or zero if not. \n    function findKingdomCalled(string _kingdomName) constant\n    returns (uint kingdomNumber) {\n        uint fuzzyHash = computeNameFuzzyHash(_kingdomName);\n        return kingdomNumbersByfuzzyHash[fuzzyHash];\n    }\n\n    /// @notice Check if a name can be used as a kingdom name.\n    /// @return True if the name satisfies the criteria of:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    ///\n    /// WARN: does not check if the name is already in use;\n    /// use `findKingdomCalled(string)` for that afterwards.\n    function validateProposedKingdomName(string _kingdomName) constant\n    returns (bool allowed) {\n        return validateNameInternal(_kingdomName);\n    }\n\n    // Check if rules would be allowed for a new custom Kingdom.\n    // Typically used before calling `createKingdom(...)`.\n    function validateProposedThroneRules(\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) constant returns (bool allowed) {\n        return kingdomFactory.validateProposedThroneRules(\n            _startingClaimPriceWei,\n            maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n    }\n\n    // How much one must pay to create a new kingdom (in finney).\n    // Can be changed by the topWizard.\n    function kingdomCreationFeeInFinney() constant\n    returns (uint feeInFinney) {\n        return roundMoneyUpToWholeFinney(kingdomCreationFeeWei);\n    }\n\n    // Reject funds sent to the contract - wizards who cannot interact\n    // with it via the API won't be able to withdraw their commission.\n    function () {\n        throw;\n    }\n\n    /// @notice Create a new kingdom using custom rules.\n    /// @param _kingdomName \\n    ///   e.g. ""King of the Ether Throne""\n    /// @param _startingClaimPriceWei \\n    ///   How much it will cost the first monarch to claim the throne\n    ///   (and also the price after the death of a monarch).\n    /// @param _claimPriceAdjustPercent \\n    ///   Percentage increase after each claim - e.g. if claim price\n    ///   was 200 ETH, and `_claimPriceAdjustPercent` is 50, the next\n    ///   claim price will be 200 ETH + (50% of 200 ETH) => 300 ETH.\n    /// @param _curseIncubationDurationSeconds \\n    ///   The maximum length of a time a monarch can rule before the\n    ///   curse strikes and they are removed without compensation.\n    /// @param _commissionPerThousand \\n    ///   How much of each payment is given to the wizards to share,\n    ///   expressed in parts per thousand - e.g. 25 means 25/1000,\n    ///   or 2.5%.\n    /// \n    /// Caller must include payment equal to kingdomCreationFeeWei.\n    /// The caller will become the 'sub-wizard' and will earn half\n    /// any commission charged by the Kingdom.  Note however they\n    /// will need to call withdrawFunds() on the Kingdom contract\n    /// to get their commission - it's not send automatically.\n    ///\n    /// Will consume up to 1,900,000 gas (!)\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedKingdomName(string)`)\n    ///   - name is already in use (see `findKingdomCalled(string)`)\n    ///   - rules are invalid (see `validateProposedKingdomRules(...)`)\n    ///   - payment is too low or too high\n    ///   - insufficient gas (quite likely!)\n    /// Produces event KingdomCreatedEvent.\n    function createKingdom(\n        string _kingdomName,\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) {\n        externalEnter();\n        createKingdomRP(\n            _kingdomName,\n            _startingClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to transfer all rights to future\n    /// fees and future kingdom wizardships to `_replacement` wizard.\n    /// WARN: The original wizard retains ownership of any past fees\n    /// held for them in the `funds` mapping, which they can still\n    /// withdraw. They also remain topWizard in any existing Kingdoms.\n    /// Produces event WizardReplacedEvent.\n    function replaceWizard(address _replacement) {\n        externalEnter();\n        replaceWizardRP(_replacement);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the fee for creating kingdoms.\n    function setKingdomCreationFeeWei(uint _kingdomCreationFeeWei) {\n        externalEnter();\n        setKingdomCreationFeeWeiRP(_kingdomCreationFeeWei);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the cap on claim price.\n    function setMaximumClaimPriceWei(uint _maximumClaimPriceWei) {\n        externalEnter();\n        setMaximumClaimPriceWeiRP(_maximumClaimPriceWei);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the factory contract which\n    /// will be used to create future Kingdoms.\n    function setKingdomFactory(KingdomFactory _kingdomFactory) {\n        externalEnter();\n        setKingdomFactoryRP(_kingdomFactory);\n        externalLeave();\n    }\n\n    function createKingdomRP(\n        string _kingdomName,\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) internal {\n\n        address subWizard = msg.sender;\n\n        if (!validateNameInternal(_kingdomName)) {\n            throw;\n        }\n\n        uint newKingdomNumber = kingdomsByNumber.length;\n        checkUniqueAndRegisterNewKingdomName(\n            _kingdomName,\n            newKingdomNumber\n        );\n\n        uint paidWei = msg.value;\n        if (paidWei < kingdomCreationFeeWei) {\n            throw;\n        }\n        // Make it easy for people to pay using a whole number of finney,\n        // which could be a teeny bit higher than the raw wei value.\n        uint excessWei = paidWei - kingdomCreationFeeWei;\n        if (excessWei > 1 finney) {\n            throw;\n        }\n        funds[topWizard] += paidWei;\n        \n        // This will perform rule validation.\n        Kingdom kingdomContract = kingdomFactory.createKingdom(\n            _kingdomName,\n            address(this),\n            topWizard,\n            subWizard,\n            _startingClaimPriceWei,\n            maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n\n        kingdomsByNumber.push(KingdomListing(\n            newKingdomNumber,\n            _kingdomName,\n            kingdomContract,\n            msg.sender,\n            now,\n            kingdomFactory\n        ));\n    }\n\n    function replaceWizardRP(address replacement) internal { \n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        address oldWizard = topWizard;\n        topWizard = replacement;\n        WizardReplacedEvent(oldWizard, replacement);\n    }\n\n    function setKingdomCreationFeeWeiRP(uint _kingdomCreationFeeWei) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        kingdomCreationFeeWei = _kingdomCreationFeeWei;\n        CreationFeeChangedEvent(kingdomCreationFeeWei);\n    }\n\n    function setMaximumClaimPriceWeiRP(uint _maximumClaimPriceWei) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (_maximumClaimPriceWei < 1 ether) {\n            throw;\n        }\n        maximumClaimPriceWei = _maximumClaimPriceWei;\n    }\n\n    function setKingdomFactoryRP(KingdomFactory _kingdomFactory) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        kingdomFactory = _kingdomFactory;\n        FactoryChangedEvent(kingdomFactory);\n    }\n\n    // If there is no existing kingdom called `_kingdomName`, create\n    // a record mapping that name to kingdom no. `_newKingdomNumber`.\n    // Throws an error if an existing kingdom with the same (or\n    // fuzzily similar - see computeNameFuzzyHash) name exists.\n    function checkUniqueAndRegisterNewKingdomName(\n        string _kingdomName,\n        uint _newKingdomNumber\n    ) internal {\n        uint fuzzyHash = computeNameFuzzyHash(_kingdomName);\n        if (kingdomNumbersByfuzzyHash[fuzzyHash] != 0) {\n            throw;\n        }\n        kingdomNumbersByfuzzyHash[fuzzyHash] = _newKingdomNumber;\n    }\n\n}\n\n\n/// @title Used on the testnet to allow automated testing of internals.\ncontract ExposedInternalsForTesting is\n  MoneyRounderMixin, NameableMixin {\n\n    function roundMoneyDownNicelyET(uint _rawValueWei) constant\n    returns (uint nicerValueWei) {\n        return roundMoneyDownNicely(_rawValueWei);\n    }\n\n    function roundMoneyUpToWholeFinneyET(uint _valueWei) constant\n    returns (uint valueFinney) {\n        return roundMoneyUpToWholeFinney(_valueWei);\n    }\n\n    function validateNameInternalET(string _name) constant\n    returns (bool allowed) {\n        return validateNameInternal(_name);\n    }\n\n    function extractNameFromDataET(bytes _data) constant\n    returns (string extractedName) {\n        return extractNameFromData(_data);\n    }\n    \n    function computeNameFuzzyHashET(string _name) constant\n    returns (uint fuzzyHash) {\n        return computeNameFuzzyHash(_name);\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。多くの機能を持つが、芸術的表現はない。,
1981947,0xe15551395a6832439b54d21e892ebe6c90a49b5a,false,false,,,,0xcc9724b345887827cb5eae025cad9f4ccc3c90f6
1981966,0xa529402b3e58b955ee7ba49fe853cfcf1bbd75fa,false,false,,,,TOO_SHORT
1982105,0x9c3c1f05dc5d1205c1824cfad15307f9bf1fd72d,false,false,,,,TOO_SHORT
1982189,0xc73b2ce51077c9c45e42c28bd44a65d92fcb6da5,false,false,,,,TOO_SHORT
1982316,0xc1e8dd25d224e93b444d1fa12da12fca8b9f1015,false,false,,,,TOO_SHORT
1982391,0x894ee02934d17bb3731e93586b2350af64d034a7,false,false,,,,TOO_SHORT
1982651,0xaf56a988ca19bcdb1f851e9a03865467be2ed77c,false,false,,,,TOO_SHORT
1982945,0x57bba5dacab4388b794eb631fcb219e2e222d2b7,false,false,,,,TOO_SHORT
1983010,0x71851bdf215386d37684312632ed9ae121d8cb74,false,false,,,,TOO_SHORT
1983030,0x9d2fede9def4070b21448356597d8d27456d839f,false,false,,,,TOO_SHORT
1983524,0x915d4b6d5ea3b06e78edba783a619db39869373b,false,false,,,,TOO_SHORT
1983550,0x353f44d5ad5da1ee076c1c013fb86d6719838fbe,false,false,,,,TOO_SHORT
1983552,0xc2c58b4ce824de92ae81b8e9da2128101f2046a5,false,false,,,,TOO_SHORT
1983560,0xb6c92a1f9d1971fd3c422265336d32659e2dc763,false,false,,,,TOO_SHORT
1983885,0x05fb610e36eaac1064c726074d7bc0dab019ff72,false,false,,,,TOO_SHORT
1984573,0x66c97148b91d9dd041dd12d136fa8375c66a9378,false,false,"// King of the Ether Throne Contracts.\n// Copyright (c) 2016 Kieran Elby. Released under the MIT License.\n// Version 1.0.0, 31 July 2016.\n//\n// See also http://www.kingoftheether.com and\n// https://github.com/kieranelby/KingOfTheEtherThrone .\n// \n// This file contains a number of contracts, of which only\n// these three are normally created:\n//\n// - Kingdom        = maintains the throne for a kingdom\n// - World          = runs the world, which is a collection of kingdoms\n// - KingdomFactory = used internally by the World contract\n//\n// The ""Mixin"" contracts (ThroneRulesMixin, ReentryProtectorMixin,\n// CarefulSenderMixin, FundsHolderMixin, MoneyRounderMixin,\n// NameableMixin) contain functions / data / structures used\n// by the three main contracts.\n// The ExposedInternalsForTesting contract is used by automated tests.\n\n\n/// @title Mixin to help avoid recursive-call attacks.\ncontract ReentryProtectorMixin {\n\n    // true if we are inside an external function\n    bool reentryProtector;\n\n    // Mark contract as having entered an external function.\n    // Throws an exception if called twice with no externalLeave().\n    // For this to work, Contracts MUST:\n    //  - call externalEnter() at the start of each external function\n    //  - call externalLeave() at the end of each external function\n    //  - never use return statements in between enter and leave\n    //  - never call an external function from another function\n    // WARN: serious risk of contract getting stuck if used wrongly.\n    function externalEnter() internal {\n        if (reentryProtector) {\n            throw;\n        }\n        reentryProtector = true;\n    }\n\n    // Mark contract as having left an external function.\n    // Do this after each call to externalEnter().\n    function externalLeave() internal {\n        reentryProtector = false;\n    }\n\n}\n\n\n/// @title Mixin to help send ether to untrusted addresses.\ncontract CarefulSenderMixin {\n\n    // Seems a reasonable amount for a well-written fallback function.\n    uint constant suggestedExtraGasToIncludeWithSends = 23000;\n\n    // Send `_valueWei` of our ether to `_toAddress`, including\n    // `_extraGasIncluded` gas above the usual 2300 gas stipend\n    // with the send call.\n    //\n    // This needs care because there is no way to tell if _toAddress\n    // is externally owned or is another contract - and sending ether\n    // to a contract address will invoke its fallback function; this\n    // has three implications:\n    //\n    // 1) Danger of recursive attack.\n    //  The destination contract's fallback function (or another\n    //  contract it calls) may call back into this contract (including\n    //  our fallback function and external functions inherited, or into\n    //  other contracts in our stack), leading to unexpected behaviour.\n    //  Mitigations:\n    //   - protect all external functions against re-entry into\n    //     any of them (see ReentryProtectorMixin);\n    //   - program very defensively (e.g. debit balance before send).\n    //\n    // 2) Destination fallback function can fail.\n    //  If the destination contract's fallback function fails, ether\n    //  will not be sent and may be locked into the sending contract.\n    //  Unlike most errors, it will NOT cause this contract to throw.\n    //  Mitigations:\n    //   - check the return value from this function (see below).\n    //\n    // 3) Gas usage.\n    //  The destination fallback function will consume the gas supplied\n    //  in this transaction (which is fixed and set by the transaction\n    //  starter, though some clients do a good job of estimating it.\n    //  This is a problem for lottery-type contracts where one very\n    //  expensive-to-call receiving contract could 'poison' the lottery\n    //  contract by preventing it being invoked by another person who\n    //  cannot supply enough gas.\n    //  Mitigations:\n    //    - choose sensible value for _extraGasIncluded (by default\n    //      only 2300 gas is supplied to the destination function);\n    //    - if call fails consider whether to throw or to ring-fence\n    //      funds for later withdrawal.\n    //\n    // Returns:\n    //\n    //  True if-and-only-if the send call was made and did not throw\n    //  an error. In this case, we will no longer own the _valueWei\n    //  ether. Note that we cannot get the return value of the fallback\n    //  function called (if any).\n    //\n    //  False if the send was made but the destination fallback function\n    //  threw an error (or ran out of gas). If this hapens, we still own\n    //  _valueWei ether and the destination's actions were undone.\n    //\n    //  This function should not normally throw an error unless:\n    //    - not enough gas to make the send/call\n    //    - max call stack depth reached\n    //    - insufficient ether\n    //\n    function carefulSendWithFixedGas(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGasIncluded\n    ) internal returns (bool success) {\n        return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();\n    }\n\n}\n\n\n/// @title Mixin to help track who owns our ether and allow withdrawals.\ncontract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {\n\n    // Record here how much wei is owned by an address.\n    // Obviously, the entries here MUST be backed by actual ether\n    // owned by the contract - we cannot enforce that in this mixin.\n    mapping (address => uint) funds;\n\n    event FundsWithdrawnEvent(\n        address fromAddress,\n        address toAddress,\n        uint valueWei\n    );\n\n    /// @notice Amount of ether held for `_address`.\n    function fundsOf(address _address) constant returns (uint valueWei) {\n        return funds[_address];\n    }\n\n    /// @notice Send the caller (`msg.sender`) all ether they own.\n    function withdrawFunds() {\n        externalEnter();\n        withdrawFundsRP();\n        externalLeave();\n    }\n\n    /// @notice Send `_valueWei` of the ether owned by the caller\n    /// (`msg.sender`) to `_toAddress`, including `_extraGas` gas\n    /// beyond the normal stipend.\n    function withdrawFundsAdvanced(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGas\n    ) {\n        externalEnter();\n        withdrawFundsAdvancedRP(_toAddress, _valueWei, _extraGas);\n        externalLeave();\n    }\n\n    /// @dev internal version of withdrawFunds()\n    function withdrawFundsRP() internal {\n        address fromAddress = msg.sender;\n        address toAddress = fromAddress;\n        uint allAvailableWei = funds[fromAddress];\n        withdrawFundsAdvancedRP(\n            toAddress,\n            allAvailableWei,\n            suggestedExtraGasToIncludeWithSends\n        );\n    }\n\n    /// @dev internal version of withdrawFundsAdvanced(), also used\n    /// by withdrawFundsRP().\n    function withdrawFundsAdvancedRP(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGasIncluded\n    ) internal {\n        if (msg.value != 0) {\n            throw;\n        }\n        address fromAddress = msg.sender;\n        if (_valueWei > funds[fromAddress]) {\n            throw;\n        }\n        funds[fromAddress] -= _valueWei;\n        bool sentOk = carefulSendWithFixedGas(\n            _toAddress,\n            _valueWei,\n            _extraGasIncluded\n        );\n        if (!sentOk) {\n            throw;\n        }\n        FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);\n    }\n\n}\n\n\n/// @title Mixin to help make nicer looking ether amounts.\ncontract MoneyRounderMixin {\n\n    /// @notice Make `_rawValueWei` into a nicer, rounder number.\n    /// @return A value that:\n    ///   - is no larger than `_rawValueWei`\n    ///   - is no smaller than `_rawValueWei` * 0.999\n    ///   - has no more than three significant figures UNLESS the\n    ///     number is very small or very large in monetary terms\n    ///     (which we define as < 1 finney or > 10000 ether), in\n    ///     which case no precision will be lost.\n    function roundMoneyDownNicely(uint _rawValueWei) constant internal\n    returns (uint nicerValueWei) {\n        if (_rawValueWei < 1 finney) {\n            return _rawValueWei;\n        } else if (_rawValueWei < 10 finney) {\n            return 10 szabo * (_rawValueWei / 10 szabo);\n        } else if (_rawValueWei < 100 finney) {\n            return 100 szabo * (_rawValueWei / 100 szabo);\n        } else if (_rawValueWei < 1 ether) {\n            return 1 finney * (_rawValueWei / 1 finney);\n        } else if (_rawValueWei < 10 ether) {\n            return 10 finney * (_rawValueWei / 10 finney);\n        } else if (_rawValueWei < 100 ether) {\n            return 100 finney * (_rawValueWei / 100 finney);\n        } else if (_rawValueWei < 1000 ether) {\n            return 1 ether * (_rawValueWei / 1 ether);\n        } else if (_rawValueWei < 10000 ether) {\n            return 10 ether * (_rawValueWei / 10 ether);\n        } else {\n            return _rawValueWei;\n        }\n    }\n    \n    /// @notice Convert `_valueWei` into a whole number of finney.\n    /// @return The smallest whole number of finney which is equal\n    /// to or greater than `_valueWei` when converted to wei.\n    /// WARN: May be incorrect if `_valueWei` is above 2**254.\n    function roundMoneyUpToWholeFinney(uint _valueWei) constant internal\n    returns (uint valueFinney) {\n        return (1 finney + _valueWei - 1 wei) / 1 finney;\n    }\n\n}\n\n\n/// @title Mixin to help allow users to name things.\ncontract NameableMixin {\n\n    // String manipulation is expensive in the EVM; keep things short.\n\n    uint constant minimumNameLength = 1;\n    uint constant maximumNameLength = 25;\n    string constant nameDataPrefix = ""NAME:"";\n\n    /// @notice Check if `_name` is a reasonable choice of name.\n    /// @return True if-and-only-if `_name_` meets the criteria\n    /// below, or false otherwise:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    ///   - at least one non-punctuation character\n    /// Note that we deliberately exclude characters which may cause\n    /// security problems for websites and databases if escaping is\n    /// not performed correctly, such as < > "" and '.\n    /// Apologies for the lack of non-English language support.\n    function validateNameInternal(string _name) constant internal\n    returns (bool allowed) {\n        bytes memory nameBytes = bytes(_name);\n        uint lengthBytes = nameBytes.length;\n        if (lengthBytes < minimumNameLength ||\n            lengthBytes > maximumNameLength) {\n            return false;\n        }\n        bool foundNonPunctuation = false;\n        for (uint i = 0; i < lengthBytes; i++) {\n            byte b = nameBytes[i];\n            if (\n                (b >= 48 && b <= 57) || // 0 - 9\n                (b >= 65 && b <= 90) || // A - Z\n                (b >= 97 && b <= 122)   // a - z\n            ) {\n                foundNonPunctuation = true;\n                continue;\n            }\n            if (\n                b == 32 || // space\n                b == 33 || // !\n                b == 40 || // (\n                b == 41 || // )\n                b == 45 || // -\n                b == 46 || // .\n                b == 95    // _\n            ) {\n                continue;\n            }\n            return false;\n        }\n        return foundNonPunctuation;\n    }\n\n    // Extract a name from bytes `_data` (presumably from `msg.data`),\n    // or throw an exception if the data is not in the expected format.\n    // \n    // We want to make it easy for people to name things, even if\n    // they're not comfortable calling functions on contracts.\n    //\n    // So we allow names to be sent to the fallback function encoded\n    // as message data.\n    //\n    // Unfortunately, the way the Ethereum Function ABI works means we\n    // must be careful to avoid clashes between message data that\n    // represents our names and message data that represents a call\n    // to an external function - otherwise:\n    //   a) some names won't be usable;\n    //   b) small possibility of a phishing attack where users are\n    //     tricked into using certain names which cause an external\n    //     function call - e.g. if the data sent to the contract is\n    //     keccak256(""withdrawFunds()"") then a withdrawal will occur.\n    //\n    // So we require a prefix ""NAME:"" at the start of the name (encoded\n    // in ASCII) when sent via the fallback function - this prefix\n    // doesn't clash with any external function signature hashes.\n    //\n    // e.g. web3.fromAscii('NAME:' + 'Joe Bloggs')\n    //\n    // WARN: this does not check the name for ""reasonableness"";\n    // use validateNameInternal() for that.\n    //\n    function extractNameFromData(bytes _data) constant internal\n    returns (string extractedName) {\n        // check prefix present\n        uint expectedPrefixLength = (bytes(nameDataPrefix)).length;\n        if (_data.length < expectedPrefixLength) {\n            throw;\n        }\n        uint i;\n        for (i = 0; i < expectedPrefixLength; i++) {\n            if ((bytes(nameDataPrefix))[i] != _data[i]) {\n                throw;\n            }\n        }\n        // copy data after prefix\n        uint payloadLength = _data.length - expectedPrefixLength;\n        if (payloadLength < minimumNameLength ||\n            payloadLength > maximumNameLength) {\n            throw;\n        }\n        string memory name = new string(payloadLength);\n        for (i = 0; i < payloadLength; i++) {\n            (bytes(name))[i] = _data[expectedPrefixLength + i];\n        }\n        return name;\n    }\n\n    // Turn a short name into a ""fuzzy hash"" with the property\n    // that extremely similar names will have the same fuzzy hash.\n    //\n    // This is useful to:\n    //  - stop people choosing names which differ only in case or\n    //    punctuation and would lead to confusion.\n    //  - faciliate searching by name without needing exact match\n    //\n    // For example, these names all have the same fuzzy hash:\n    //\n    //  ""Banana""\n    //  ""BANANA""\n    //  ""Ba-na-na""\n    //  ""  banana  ""\n    //  ""Banana                        .. so long the end is ignored""\n    //\n    // On the other hand, ""Banana1"" and ""A Banana"" are different to\n    // the above.\n    //\n    // WARN: this is likely to work poorly on names that do not meet\n    // the validateNameInternal() test.\n    //\n    function computeNameFuzzyHash(string _name) constant internal\n    returns (uint fuzzyHash) {\n        bytes memory nameBytes = bytes(_name);\n        uint h = 0;\n        uint len = nameBytes.length;\n        if (len > maximumNameLength) {\n            len = maximumNameLength;\n        }\n        for (uint i = 0; i < len; i++) {\n            uint mul = 128;\n            byte b = nameBytes[i];\n            uint ub = uint(b);\n            if (b >= 48 && b <= 57) {\n                // 0-9\n                h = h * mul + ub;\n            } else if (b >= 65 && b <= 90) {\n                // A-Z\n                h = h * mul + ub;\n            } else if (b >= 97 && b <= 122) {\n                // fold a-z to A-Z\n                uint upper = ub - 32;\n                h = h * mul + upper;\n            } else {\n                // ignore others\n            }\n        }\n        return h;\n    }\n\n}\n\n\n/// @title Mixin to help define the rules of a throne.\ncontract ThroneRulesMixin {\n\n    // See World.createKingdom(..) for documentation.\n    struct ThroneRules {\n        uint startingClaimPriceWei;\n        uint maximumClaimPriceWei;\n        uint claimPriceAdjustPercent;\n        uint curseIncubationDurationSeconds;\n        uint commissionPerThousand;\n    }\n\n}\n\n\n/// @title Maintains the throne of a kingdom.\ncontract Kingdom is\n  ReentryProtectorMixin,\n  CarefulSenderMixin,\n  FundsHolderMixin,\n  MoneyRounderMixin,\n  NameableMixin,\n  ThroneRulesMixin {\n\n    // e.g. ""King of the Ether""\n    string public kingdomName;\n\n    // The World contract used to create this kingdom, or 0x0 if none.\n    address public world;\n\n    // The rules that govern this kingdom - see ThroneRulesMixin.\n    ThroneRules public rules;\n\n    // Someone who has ruled (or is ruling) our kingdom.\n    struct Monarch {\n        // where to send their compensation\n        address compensationAddress;\n        // their name\n        string name;\n        // when they became our ruler\n        uint coronationTimestamp;\n        // the claim price paid (excluding any over-payment)\n        uint claimPriceWei;\n        // the compensation sent to or held for them so far\n        uint compensationWei;\n    }\n\n    // The first ruler is number 1; the zero-th entry is a dummy entry.\n    Monarch[] public monarchsByNumber;\n\n    // The topWizard earns half the commission.\n    // They are normally the owner of the World contract.\n    address public topWizard;\n\n    // The subWizard earns half the commission.\n    // They are normally the creator of this Kingdom.\n    // The topWizard and subWizard can be the same address.\n    address public subWizard;\n\n    // NB: we also have a `funds` mapping from FundsHolderMixin,\n    // and a rentryProtector from ReentryProtectorMixin.\n\n    event ThroneClaimedEvent(uint monarchNumber);\n    event CompensationSentEvent(address toAddress, uint valueWei);\n    event CompensationFailEvent(address toAddress, uint valueWei);\n    event CommissionEarnedEvent(address byAddress, uint valueWei);\n    event WizardReplacedEvent(address oldWizard, address newWizard);\n    // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin\n\n    // WARN - does NOT validate arguments; you MUST either call\n    // KingdomFactory.validateProposedThroneRules() or create\n    // the Kingdom via KingdomFactory/World's createKingdom().\n    // See World.createKingdom(..) for parameter documentation.\n    function Kingdom(\n        string _kingdomName,\n        address _world,\n        address _topWizard,\n        address _subWizard,\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) {\n        kingdomName = _kingdomName;\n        world = _world;\n        topWizard = _topWizard;\n        subWizard = _subWizard;\n        rules = ThroneRules(\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n        // We number the monarchs starting from 1; it's sometimes useful\n        // to use zero = invalid, so put in a dummy entry for number 0.\n        monarchsByNumber.push(\n            Monarch(\n                0,\n                """",\n                0,\n                0,\n                0\n            )\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint totalCount) {\n        // zero-th entry is invalid\n        return monarchsByNumber.length - 1;\n    }\n\n    // False if either there are no monarchs, or if the latest monarch\n    // has reigned too long and been struck down by the curse.\n    function isLivingMonarch() constant returns (bool alive) {\n        if (numberOfMonarchs() == 0) {\n            return false;\n        }\n        uint reignStartedTimestamp = latestMonarchInternal().coronationTimestamp;\n        if (now < reignStartedTimestamp) {\n            // Should not be possible, think miners reject blocks with\n            // timestamps that go backwards? But some drift possible and\n            // it needs handling for unsigned overflow audit checks ...\n            return true;\n        }\n        uint elapsedReignDurationSeconds = now - reignStartedTimestamp;\n        if (elapsedReignDurationSeconds > rules.curseIncubationDurationSeconds) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice How much you must pay to claim the throne now, in wei.\n    function currentClaimPriceWei() constant returns (uint priceInWei) {\n        if (!isLivingMonarch()) {\n            return rules.startingClaimPriceWei;\n        } else {\n            uint lastClaimPriceWei = latestMonarchInternal().claimPriceWei;\n            // no danger of overflow because claim price never gets that high\n            uint newClaimPrice =\n              (lastClaimPriceWei * (100 + rules.claimPriceAdjustPercent)) / 100;\n            newClaimPrice = roundMoneyDownNicely(newClaimPrice);\n            if (newClaimPrice < rules.startingClaimPriceWei) {\n                newClaimPrice = rules.startingClaimPriceWei;\n            }\n            if (newClaimPrice > rules.maximumClaimPriceWei) {\n                newClaimPrice = rules.maximumClaimPriceWei;\n            }\n            return newClaimPrice;\n        }\n    }\n\n    /// @notice How much you must pay to claim the throne now, in finney.\n    function currentClaimPriceInFinney() constant\n    returns (uint priceInFinney) {\n        uint valueWei = currentClaimPriceWei();\n        return roundMoneyUpToWholeFinney(valueWei);\n    }\n\n    /// @notice Check if a name can be used as a monarch name.\n    /// @return True if the name satisfies the criteria of:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    function validateProposedMonarchName(string _monarchName) constant\n    returns (bool allowed) {\n        return validateNameInternal(_monarchName);\n    }\n\n    // Get details of the latest monarch (even if they are dead).\n    //\n    // We don't expose externally because returning structs is not well\n    // supported in the ABI (strange that monarchsByNumber array works\n    // fine though). Note that the reference returned is writable - it\n    // can be used to update details of the latest monarch.\n    // WARN: you should check numberOfMonarchs() > 0 first.\n    function latestMonarchInternal() constant internal\n    returns (Monarch storage monarch) {\n        return monarchsByNumber[monarchsByNumber.length - 1];\n    }\n\n    /// @notice Claim throne by sending funds to the contract.\n    /// Any future compensation earned will be sent to the sender's\n    /// address (`msg.sender`).\n    /// Sending from a contract is not recommended unless you know\n    /// what you're doing (and you've tested it).\n    /// If no message data is supplied, the throne will be claimed in\n    /// the name of ""Anonymous"". To supply a name, send data encoded\n    /// using web3.fromAscii('NAME:' + 'your_chosen_valid_name').\n    /// Sender must include payment equal to currentClaimPriceWei().\n    /// Will consume up to ~300,000 gas.\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedMonarchName(string)`)\n    ///   - payment is too low or too high\n    /// Produces events:\n    ///   - `ThroneClaimedEvent`\n    ///   - `CompensationSentEvent` / `CompensationFailEvent`\n    ///   - `CommissionEarnedEvent`\n    function () {\n        externalEnter();\n        fallbackRP();\n        externalLeave();\n    }\n\n    /// @notice Claim throne in the given `_monarchName`.\n    /// Any future compensation earned will be sent to the caller's\n    /// address (`msg.sender`).\n    /// Caller must include payment equal to currentClaimPriceWei().\n    /// Calling from a contract is not recommended unless you know\n    /// what you're doing (and you've tested it).\n    /// Will consume up to ~300,000 gas.\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedMonarchName(string)`)\n    ///   - payment is too low or too high\n    /// Produces events:\n    ///   - `ThroneClaimedEvent\n    ///   - `CompensationSentEvent` / `CompensationFailEvent`\n    ///   - `CommissionEarnedEvent`\n    function claimThrone(string _monarchName) {\n        externalEnter();\n        claimThroneRP(_monarchName);\n        externalLeave();\n    }\n\n    /// @notice Used by either the topWizard or subWizard to transfer\n    /// all rights to future commissions to the `_replacement` wizard.\n    /// WARN: The original wizard retains ownership of any past\n    /// commission held for them in the `funds` mapping, which they\n    /// can still withdraw.\n    /// Produces event WizardReplacedEvent.\n    function replaceWizard(address _replacement) {\n        externalEnter();\n        replaceWizardRP(_replacement);\n        externalLeave();\n    }\n\n    function fallbackRP() internal {\n        if (msg.data.length == 0) {\n            claimThroneRP(""Anonymous"");\n        } else {\n            string memory _monarchName = extractNameFromData(msg.data);\n            claimThroneRP(_monarchName);\n        }\n    }\n    \n    function claimThroneRP(\n        string _monarchName\n    ) internal {\n\n        address _compensationAddress = msg.sender;\n\n        if (!validateNameInternal(_monarchName)) {\n            throw;\n        }\n\n        if (_compensationAddress == 0 ||\n            _compensationAddress == address(this)) {\n            throw;\n        }\n\n        uint paidWei = msg.value;\n        uint priceWei = currentClaimPriceWei();\n        if (paidWei < priceWei) {\n            throw;\n        }\n        // Make it easy for people to pay using a whole number of finney,\n        // which could be a teeny bit higher than the raw wei value.\n        uint excessWei = paidWei - priceWei;\n        if (excessWei > 1 finney) {\n            throw;\n        }\n        \n        uint compensationWei;\n        uint commissionWei;\n        if (!isLivingMonarch()) {\n            // dead men get no compensation\n            commissionWei = paidWei;\n            compensationWei = 0;\n        } else {\n            commissionWei = (paidWei * rules.commissionPerThousand) / 1000;\n            compensationWei = paidWei - commissionWei;\n        }\n\n        if (commissionWei != 0) {\n            recordCommissionEarned(commissionWei);\n        }\n\n        if (compensationWei != 0) {\n            compensateLatestMonarch(compensationWei);\n        }\n\n        // In case of any teeny excess, we use the official price here\n        // since that should determine the new claim price, not paidWei.\n        monarchsByNumber.push(Monarch(\n            _compensationAddress,\n            _monarchName,\n            now,\n            priceWei,\n            0\n        ));\n\n        ThroneClaimedEvent(monarchsByNumber.length - 1);\n    }\n\n    function replaceWizardRP(address replacement) internal {\n        if (msg.value != 0) {\n            throw;\n        }\n        bool replacedOk = false;\n        address oldWizard;\n        if (msg.sender == topWizard) {\n            oldWizard = topWizard;\n            topWizard = replacement;\n            WizardReplacedEvent(oldWizard, replacement);\n            replacedOk = true;\n        }\n        // Careful - topWizard and subWizard can be the same address,\n        // in which case we must replace both.\n        if (msg.sender == subWizard) {\n            oldWizard = subWizard;\n            subWizard = replacement;\n            WizardReplacedEvent(oldWizard, replacement);\n            replacedOk = true;\n        }\n        if (!replacedOk) {\n            throw;\n        }\n    }\n\n    // Allow commission funds to build up in contract for the wizards\n    // to withdraw (carefully ring-fenced).\n    function recordCommissionEarned(uint _commissionWei) internal {\n        // give the subWizard any ""odd"" single wei\n        uint topWizardWei = _commissionWei / 2;\n        uint subWizardWei = _commissionWei - topWizardWei;\n        funds[topWizard] += topWizardWei;\n        CommissionEarnedEvent(topWizard, topWizardWei);\n        funds[subWizard] += subWizardWei;\n        CommissionEarnedEvent(subWizard, subWizardWei);\n    }\n\n    // Send compensation to latest monarch (or hold funds for them\n    // if cannot through no fault of current caller).\n    function compensateLatestMonarch(uint _compensationWei) internal {\n        address compensationAddress =\n          latestMonarchInternal().compensationAddress;\n        // record that we compensated them\n        latestMonarchInternal().compensationWei = _compensationWei;\n        // WARN: if the latest monarch is a contract whose fallback\n        // function needs more 25300 gas than then they will NOT\n        // receive compensation automatically.\n        bool sentOk = carefulSendWithFixedGas(\n            compensationAddress,\n            _compensationWei,\n            suggestedExtraGasToIncludeWithSends\n        );\n        if (sentOk) {\n            CompensationSentEvent(compensationAddress, _compensationWei);\n        } else {\n            // This should only happen if the latest monarch is a contract\n            // whose fallback-function failed or ran out of gas (despite\n            // us including a fair amount of gas).\n            // We do not throw since we do not want the throne to get\n            // 'stuck' (it's not the new usurpers fault) - instead save\n            // the funds we could not send so can be claimed later.\n            // Their monarch contract would need to have been designed\n            // to call our withdrawFundsAdvanced(..) function mind you.\n            funds[compensationAddress] += _compensationWei;\n            CompensationFailEvent(compensationAddress, _compensationWei);\n        }\n    }\n\n}\n\n\n/// @title Used by the World contract to create Kingdom instances.\n/// @dev Mostly exists so topWizard can potentially replace this\n/// contract to modify the Kingdom contract and/or rule validation\n/// logic to be used for *future* Kingdoms created by the World.\n/// We do not implement rentry protection because we don't send/call.\n/// We do not charge a fee here - but if you bypass the World then\n/// you won't be listed on the official World page of course.\ncontract KingdomFactory {\n\n    function KingdomFactory() {\n    }\n\n    function () {\n        // this contract should never have a balance\n        throw;\n    }\n\n    // See World.createKingdom(..) for parameter documentation.\n    function validateProposedThroneRules(\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) constant returns (bool allowed) {\n        // I suppose there is a danger that massive deflation/inflation could\n        // change the real-world sanity of these checks, but in that case we\n        // can deploy a new factory and update the world.\n        if (_startingClaimPriceWei < 10 finney ||\n            _startingClaimPriceWei > 100 ether) {\n            return false;\n        }\n        if (_maximumClaimPriceWei < 1 ether ||\n            _maximumClaimPriceWei > 100000 ether) {\n            return false;\n        }\n        if (_startingClaimPriceWei * 20 > _maximumClaimPriceWei) {\n            return false;\n        }\n        if (_claimPriceAdjustPercent < 10 ||\n            _claimPriceAdjustPercent > 900) {\n            return false;\n        }\n        if (_curseIncubationDurationSeconds < 2 hours ||\n            _curseIncubationDurationSeconds > 10000 days) {\n            return false;\n        }\n        if (_commissionPerThousand < 10 ||\n            _commissionPerThousand > 100) {\n            return false;\n        }\n        return true;\n    }\n\n    /// @notice Create a new Kingdom. Normally called by World contract.\n    /// WARN: Does NOT validate the _kingdomName or _world arguments.\n    /// Will consume up to 1,800,000 gas (!)\n    /// Will throw an error if:\n    ///   - rules invalid (see validateProposedThroneRules)\n    ///   - wizard addresses ""obviously"" wrong\n    ///   - out of gas quite likely (perhaps in future should consider\n    ///     using solidity libraries to reduce Kingdom size?)\n    // See World.createKingdom(..) for parameter documentation.\n    function createKingdom(\n        string _kingdomName,\n        address _world,\n        address _topWizard,\n        address _subWizard,\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) returns (Kingdom newKingdom) {\n        if (msg.value > 0) {\n            // this contract should never have a balance\n            throw;\n        }\n        // NB: topWizard and subWizard CAN be the same as each other.\n        if (_topWizard == 0 || _subWizard == 0) {\n            throw;\n        }\n        if (_topWizard == _world || _subWizard == _world) {\n            throw;\n        }\n        if (!validateProposedThroneRules(\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        )) {\n            throw;\n        }\n        return new Kingdom(\n            _kingdomName,\n            _world,\n            _topWizard,\n            _subWizard,\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n    }\n\n}\n\n\n/// @title Runs the world, which is a collection of Kingdoms.\ncontract World is\n  ReentryProtectorMixin,\n  NameableMixin,\n  MoneyRounderMixin,\n  FundsHolderMixin,\n  ThroneRulesMixin {\n\n    // The topWizard runs the world. They charge for the creation of\n    // kingdoms and become the topWizard in each kingdom created.\n    address public topWizard;\n\n    // How much one must pay to create a new kingdom (in wei).\n    // Can be changed by the topWizard.\n    uint public kingdomCreationFeeWei;\n\n    struct KingdomListing {\n        uint kingdomNumber;\n        string kingdomName;\n        address kingdomContract;\n        address kingdomCreator;\n        uint creationTimestamp;\n        address kingdomFactoryUsed;\n    }\n    \n    // The first kingdom is number 1; the zero-th entry is a dummy.\n    KingdomListing[] public kingdomsByNumber;\n\n    // For safety, we cap just how high the price can get.\n    // Can be changed by the topWizard, though it will only affect\n    // kingdoms created after that.\n    uint public maximumClaimPriceWei;\n\n    // Helper contract for creating Kingdom instances. Can be\n    // upgraded by the topWizard (won't affect existing ones).\n    KingdomFactory public kingdomFactory;\n\n    // Avoids duplicate kingdom names and allows searching by name.\n    mapping (uint => uint) kingdomNumbersByfuzzyHash;\n\n    // NB: we also have a `funds` mapping from FundsHolderMixin,\n    // and a rentryProtector from ReentryProtectorMixin.\n\n    event KingdomCreatedEvent(uint kingdomNumber);\n    event CreationFeeChangedEvent(uint newFeeWei);\n    event FactoryChangedEvent(address newFactory);\n    event WizardReplacedEvent(address oldWizard, address newWizard);\n    // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin\n\n    // Create the world with no kingdoms yet.\n    // Costs about 1.9M gas to deploy.\n    function World(\n        address _topWizard,\n        uint _kingdomCreationFeeWei,\n        KingdomFactory _kingdomFactory,\n        uint _maximumClaimPriceWei\n    ) {\n        if (_topWizard == 0) {\n            throw;\n        }\n        if (_maximumClaimPriceWei < 1 ether) {\n            throw;\n        }\n        topWizard = _topWizard;\n        kingdomCreationFeeWei = _kingdomCreationFeeWei;\n        kingdomFactory = _kingdomFactory;\n        maximumClaimPriceWei = _maximumClaimPriceWei;\n        // We number the kingdoms starting from 1 since it's sometimes\n        // useful to use zero = invalid. Create dummy zero-th entry.\n        kingdomsByNumber.push(KingdomListing(0, """", 0, 0, 0, 0));\n    }\n\n    function numberOfKingdoms() constant returns (uint totalCount) {\n        return kingdomsByNumber.length - 1;\n    }\n\n    /// @return index into kingdomsByNumber if found, or zero if not. \n    function findKingdomCalled(string _kingdomName) constant\n    returns (uint kingdomNumber) {\n        uint fuzzyHash = computeNameFuzzyHash(_kingdomName);\n        return kingdomNumbersByfuzzyHash[fuzzyHash];\n    }\n\n    /// @notice Check if a name can be used as a kingdom name.\n    /// @return True if the name satisfies the criteria of:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    ///\n    /// WARN: does not check if the name is already in use;\n    /// use `findKingdomCalled(string)` for that afterwards.\n    function validateProposedKingdomName(string _kingdomName) constant\n    returns (bool allowed) {\n        return validateNameInternal(_kingdomName);\n    }\n\n    // Check if rules would be allowed for a new custom Kingdom.\n    // Typically used before calling `createKingdom(...)`.\n    function validateProposedThroneRules(\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) constant returns (bool allowed) {\n        return kingdomFactory.validateProposedThroneRules(\n            _startingClaimPriceWei,\n            maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n    }\n\n    // How much one must pay to create a new kingdom (in finney).\n    // Can be changed by the topWizard.\n    function kingdomCreationFeeInFinney() constant\n    returns (uint feeInFinney) {\n        return roundMoneyUpToWholeFinney(kingdomCreationFeeWei);\n    }\n\n    // Reject funds sent to the contract - wizards who cannot interact\n    // with it via the API won't be able to withdraw their commission.\n    function () {\n        throw;\n    }\n\n    /// @notice Create a new kingdom using custom rules.\n    /// @param _kingdomName \\n    ///   e.g. ""King of the Ether Throne""\n    /// @param _startingClaimPriceWei \\n    ///   How much it will cost the first monarch to claim the throne\n    ///   (and also the price after the death of a monarch).\n    /// @param _claimPriceAdjustPercent \\n    ///   Percentage increase after each claim - e.g. if claim price\n    ///   was 200 ETH, and `_claimPriceAdjustPercent` is 50, the next\n    ///   claim price will be 200 ETH + (50% of 200 ETH) => 300 ETH.\n    /// @param _curseIncubationDurationSeconds \\n    ///   The maximum length of a time a monarch can rule before the\n    ///   curse strikes and they are removed without compensation.\n    /// @param _commissionPerThousand \\n    ///   How much of each payment is given to the wizards to share,\n    ///   expressed in parts per thousand - e.g. 25 means 25/1000,\n    ///   or 2.5%.\n    /// \n    /// Caller must include payment equal to kingdomCreationFeeWei.\n    /// The caller will become the 'sub-wizard' and will earn half\n    /// any commission charged by the Kingdom.  Note however they\n    /// will need to call withdrawFunds() on the Kingdom contract\n    /// to get their commission - it's not send automatically.\n    ///\n    /// Will consume up to 1,900,000 gas (!)\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedKingdomName(string)`)\n    ///   - name is already in use (see `findKingdomCalled(string)`)\n    ///   - rules are invalid (see `validateProposedKingdomRules(...)`)\n    ///   - payment is too low or too high\n    ///   - insufficient gas (quite likely!)\n    /// Produces event KingdomCreatedEvent.\n    function createKingdom(\n        string _kingdomName,\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) {\n        externalEnter();\n        createKingdomRP(\n            _kingdomName,\n            _startingClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to transfer all rights to future\n    /// fees and future kingdom wizardships to `_replacement` wizard.\n    /// WARN: The original wizard retains ownership of any past fees\n    /// held for them in the `funds` mapping, which they can still\n    /// withdraw. They also remain topWizard in any existing Kingdoms.\n    /// Produces event WizardReplacedEvent.\n    function replaceWizard(address _replacement) {\n        externalEnter();\n        replaceWizardRP(_replacement);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the fee for creating kingdoms.\n    function setKingdomCreationFeeWei(uint _kingdomCreationFeeWei) {\n        externalEnter();\n        setKingdomCreationFeeWeiRP(_kingdomCreationFeeWei);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the cap on claim price.\n    function setMaximumClaimPriceWei(uint _maximumClaimPriceWei) {\n        externalEnter();\n        setMaximumClaimPriceWeiRP(_maximumClaimPriceWei);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the factory contract which\n    /// will be used to create future Kingdoms.\n    function setKingdomFactory(KingdomFactory _kingdomFactory) {\n        externalEnter();\n        setKingdomFactoryRP(_kingdomFactory);\n        externalLeave();\n    }\n\n    function createKingdomRP(\n        string _kingdomName,\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) internal {\n\n        address subWizard = msg.sender;\n\n        if (!validateNameInternal(_kingdomName)) {\n            throw;\n        }\n\n        uint newKingdomNumber = kingdomsByNumber.length;\n        checkUniqueAndRegisterNewKingdomName(\n            _kingdomName,\n            newKingdomNumber\n        );\n\n        uint paidWei = msg.value;\n        if (paidWei < kingdomCreationFeeWei) {\n            throw;\n        }\n        // Make it easy for people to pay using a whole number of finney,\n        // which could be a teeny bit higher than the raw wei value.\n        uint excessWei = paidWei - kingdomCreationFeeWei;\n        if (excessWei > 1 finney) {\n            throw;\n        }\n        funds[topWizard] += paidWei;\n        \n        // This will perform rule validation.\n        Kingdom kingdomContract = kingdomFactory.createKingdom(\n            _kingdomName,\n            address(this),\n            topWizard,\n            subWizard,\n            _startingClaimPriceWei,\n            maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n\n        kingdomsByNumber.push(KingdomListing(\n            newKingdomNumber,\n            _kingdomName,\n            kingdomContract,\n            msg.sender,\n            now,\n            kingdomFactory\n        ));\n    }\n\n    function replaceWizardRP(address replacement) internal { \n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        address oldWizard = topWizard;\n        topWizard = replacement;\n        WizardReplacedEvent(oldWizard, replacement);\n    }\n\n    function setKingdomCreationFeeWeiRP(uint _kingdomCreationFeeWei) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        kingdomCreationFeeWei = _kingdomCreationFeeWei;\n        CreationFeeChangedEvent(kingdomCreationFeeWei);\n    }\n\n    function setMaximumClaimPriceWeiRP(uint _maximumClaimPriceWei) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        if (_maximumClaimPriceWei < 1 ether) {\n            throw;\n        }\n        maximumClaimPriceWei = _maximumClaimPriceWei;\n    }\n\n    function setKingdomFactoryRP(KingdomFactory _kingdomFactory) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        kingdomFactory = _kingdomFactory;\n        FactoryChangedEvent(kingdomFactory);\n    }\n\n    // If there is no existing kingdom called `_kingdomName`, create\n    // a record mapping that name to kingdom no. `_newKingdomNumber`.\n    // Throws an error if an existing kingdom with the same (or\n    // fuzzily similar - see computeNameFuzzyHash) name exists.\n    function checkUniqueAndRegisterNewKingdomName(\n        string _kingdomName,\n        uint _newKingdomNumber\n    ) internal {\n        uint fuzzyHash = computeNameFuzzyHash(_kingdomName);\n        if (kingdomNumbersByfuzzyHash[fuzzyHash] != 0) {\n            throw;\n        }\n        kingdomNumbersByfuzzyHash[fuzzyHash] = _newKingdomNumber;\n    }\n\n}\n\n\n/// @title Used on the testnet to allow automated testing of internals.\ncontract ExposedInternalsForTesting is\n  MoneyRounderMixin, NameableMixin {\n\n    function roundMoneyDownNicelyET(uint _rawValueWei) constant\n    returns (uint nicerValueWei) {\n        return roundMoneyDownNicely(_rawValueWei);\n    }\n\n    function roundMoneyUpToWholeFinneyET(uint _valueWei) constant\n    returns (uint valueFinney) {\n        return roundMoneyUpToWholeFinney(_valueWei);\n    }\n\n    function validateNameInternalET(string _name) constant\n    returns (bool allowed) {\n        return validateNameInternal(_name);\n    }\n\n    function extractNameFromDataET(bytes _data) constant\n    returns (string extractedName) {\n        return extractNameFromData(_data);\n    }\n    \n    function computeNameFuzzyHashET(string _name) constant\n    returns (uint fuzzyHash) {\n        return computeNameFuzzyHash(_name);\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。多くの機能を持つが、芸術的要素は少ない。,
1985012,0xb83f9dd15b131446994f40f17be44b735c17604a,false,false,,,,TOO_SHORT
1985237,0xe6590897727e0235a13fe1330f7ad43a4586008d,false,false,,,,TOO_SHORT
1985319,0x726f6a9efb0d41725810b5ab9c7afb0d941bb8f3,false,false,,,,TOO_SHORT
1985510,0x999a271e2a2005f323bec9310d11e5bffb3d6945,false,false,,,,TOO_SHORT
1985542,0x5bb6a187a7bcf7e876bfd94239ed9ee932565aaa,false,false,,,,TOO_SHORT
1985850,0x7eaa2beb24d2937cef5558afdf297cee87ad0e8e,false,false,,,,TOO_SHORT
1986032,0xb21264856936b5039005d45df141ea012b19e638,false,false,,,,TOO_SHORT
1986727,0xa889c8da6fb2f3e55a36d23a2c6bf9bf569c97e6,false,false,,,,TOO_SHORT
1986872,0x00e8296303e73958841434508312d95a9b199e63,false,false,,,,TOO_SHORT
1986887,0xd54e0d378f194ae58e076f4e11250ddc670ddef3,false,false,,,,TOO_SHORT
1986901,0x5b59ae2a1c72b50d5030a84e1dbe173cf30c808b,false,false,,,,TOO_SHORT
1987074,0x94a9251580f1bd08e641f735feebf066addee64c,false,false,,,,TOO_SHORT
1987088,0x3da0ab582d13ebb031babb3ba190ae866007fd5a,false,false,,,,TOO_SHORT
1987095,0x0c31ea410b322ce061e69e3ede690e064b6caeba,false,false,,,,TOO_SHORT
1987102,0xe0700b6c574dcf54cfe868c08acb9b9010c06b7a,false,false,,,,TOO_SHORT
1987447,0x23e323a81e93b6a6adf7a1ffe2a6cd8bc9dbda4e,false,false,,,,TOO_SHORT
1987496,0x7658de28dacaf4126936c561e5ef5fef6bd8b114,false,false,,,,TOO_SHORT
1987727,0x7b1768fee873191a83300fcfe5d8cf040149ee83,false,false,,,,TOO_SHORT
1987784,0xa118314c0d767ea35b18b4c97ca438f0e7169d92,false,false,,,,TOO_SHORT
1987822,0x4de97b373ecc0e5389825bcd3ffd02896293aa7f,false,false,,,,TOO_SHORT
1987918,0xbe206ca5b9cc73553b7b43d4165fe877ce11ae1e,false,false,,,,TOO_SHORT
1987959,0x819eecb44c65d47bbcce9b0b073b843220458c17,false,false,,,,TOO_SHORT
1988278,0x44fe6c8794d0027fa0dd195d604246e25c560a38,false,false,,,,TOO_SHORT
1988483,0xc7f8774aa2d7ffcf905d61b2203bfbd68ccd898d,false,false,,,,TOO_SHORT
1988541,0xec98e3ef4ad935c500c0caf3cde08343f92c984e,false,false,,,,TOO_SHORT
1988552,0x49d6f6cb4db69e76ccc107650b742970042784e6,false,false,,,,TOO_SHORT
1988570,0x22e08b65d129544e63f48bfa927d6ef2fe1e261c,false,false,,,,TOO_SHORT
1988571,0x8e218d53f832c655e70646feef9eaa1946eba7f3,false,false,,,,TOO_SHORT
1988720,0x0131c603b0da00a560bde23306815e0577c366ef,false,false,,,,0xb671c3883307cf05bb3dff77a9754e87b4347195
1989261,0x21704538efb32e2668021d77af0d3054028e7259,false,false,,,,TOO_SHORT
1989292,0xbc2af6ea762bdf2aede2df1d801f15dd1e761e93,false,false,,,,TOO_SHORT
1989318,0xa694095f74a1513a2febda5f82a00719e3fe5b93,false,false,,,,TOO_SHORT
1989373,0xc2ec2ce7b57250a34897d78faa02c42b595b7069,false,false,,,,TOO_SHORT
1989401,0x3443e426822c92fa20d75a835067280b3c85c415,false,false,,,,TOO_SHORT
1989589,0xaf0f6a53269fc9dbbd9da9f11c368d36b7a60006,false,false,"//last compiled with soljson-v0.3.5-2016-07-21-6610add\n\ncontract Etheropt {\n\n  struct Position {\n    mapping(uint => int) positions;\n    int cash;\n    bool expired;\n    bool hasPosition;\n  }\n  uint public expiration;\n  string public underlying;\n  uint public margin;\n  uint public realityID;\n  bytes32 public factHash;\n  address public ethAddr;\n  mapping(uint => int) options;\n  uint public numOptions;\n  bool public expired;\n  mapping(address => Position) positions;\n  uint public numPositions;\n  uint public numPositionsExpired;\n  struct Account {\n    address user;\n    int capital;\n  }\n  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills\n  struct MarketMaker {\n    address user;\n    string server;\n  }\n  mapping(uint => MarketMaker) marketMakers; //starts at 1\n  uint public numMarketMakers = 0;\n  mapping(address => uint) marketMakerIDs;\n  mapping(uint => Account) accounts;\n  uint public numAccounts;\n  mapping(address => uint) accountIDs; //starts at 1\n\n  //events\n  event Deposit(address indexed user, uint amount, int balance); //balance is balance after deposit\n  event Withdraw(address indexed user, uint amount, int balance); //balance is balance after withdraw\n  event NewMarketMaker(address indexed user, string server);\n  event Expire(address indexed caller, address indexed user); //user is the account that was expired\n  event OrderMatchFailure(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price);\n  event OrderMatch(address indexed matchUser, int matchSize, address indexed orderUser, int orderSize, uint optionID, uint price);\n\n  function Etheropt(uint expiration_, string underlying_, uint margin_, uint realityID_, bytes32 factHash_, address ethAddr_, int[] strikes_) {\n    expiration = expiration_;\n    underlying = underlying_;\n    margin = margin_;\n    realityID = realityID_;\n    factHash = factHash_;\n    ethAddr = ethAddr_;\n    for (uint i=0; i < strikes_.length; i++) {\n      if (numOptions<20) {\n        uint optionID = numOptions++;\n        options[optionID] = strikes_[i];\n      }\n    }\n  }\n\n  function getAccountID(address user) constant returns(uint) {\n    return accountIDs[user];\n  }\n\n  function getAccount(uint accountID) constant returns(address) {\n    return accounts[accountID].user;\n  }\n\n  function addFunds() {\n    if (accountIDs[msg.sender]>0) {\n      accounts[accountIDs[msg.sender]].capital += int(msg.value);\n    } else {\n      uint accountID = ++numAccounts;\n      accounts[accountID].user = msg.sender;\n      accounts[accountID].capital += int(msg.value);\n      accountIDs[msg.sender] = accountID;\n    }\n    Deposit(msg.sender, msg.value, accounts[accountIDs[msg.sender]].capital);\n  }\n\n  function withdrawFunds(uint amount) {\n    if (accountIDs[msg.sender]>0) {\n      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {\n        accounts[accountIDs[msg.sender]].capital -= int(amount);\n        msg.sender.call.value(amount)();\n        Withdraw(msg.sender, amount, accounts[accountIDs[msg.sender]].capital);\n      }\n    }\n  }\n\n  function getFunds(address user, bool onlyAvailable) constant returns(int) {\n    if (accountIDs[user]>0) {\n      if (onlyAvailable == false) {\n        return accounts[accountIDs[user]].capital;\n      } else {\n        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0);\n      }\n    } else {\n      return 0;\n    }\n  }\n\n  function getFundsAndAvailable(address user) constant returns(int, int) {\n    return (getFunds(user, false), getFunds(user, true));\n  }\n\n  function marketMaker(string server) {\n    if (msg.value>0) throw;\n    if (marketMakerIDs[msg.sender]>0) {\n      marketMakers[marketMakerIDs[msg.sender]].server = server;\n    } else {\n      int funds = getFunds(marketMakers[i].user, false);\n      uint marketMakerID = 0;\n      if (numMarketMakers<6) {\n        marketMakerID = ++numMarketMakers;\n      } else {\n        for (uint i=2; i<=numMarketMakers; i++) {\n          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {\n            marketMakerID = i;\n          }\n        }\n      }\n      if (marketMakerID>0) {\n        marketMakerIDs[marketMakers[marketMakerID].user] = 0;\n        marketMakers[marketMakerID].user = msg.sender;\n        marketMakers[marketMakerID].server = server;\n        marketMakerIDs[msg.sender] = marketMakerID;\n        NewMarketMaker(msg.sender, server);\n      } else {\n        throw;\n      }\n    }\n  }\n\n  function getMarketMakers() constant returns(string, string, string, string, string, string) {\n    string[] memory servers = new string[](6);\n    for (uint i=1; i<=numMarketMakers; i++) {\n      servers[i-1] = marketMakers[i].server;\n    }\n    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);\n  }\n\n  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {\n    int[] memory funds = new int[](6);\n    for (uint i=1; i<=numMarketMakers; i++) {\n      funds[i-1] = getFunds(marketMakers[i].user, false);\n    }\n    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);\n  }\n\n  function getOptionChain() constant returns (uint, string, uint, uint, bytes32, address) {\n    return (expiration, underlying, margin, realityID, factHash, ethAddr);\n  }\n\n  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {\n    uint[] memory optionIDs = new uint[](20);\n    int[] memory strikes_ = new int[](20);\n    int[] memory positions_ = new int[](20);\n    int[] memory cashes = new int[](20);\n    uint z = 0;\n    if (expired == false) {\n      for (uint optionID=0; optionID<numOptions; optionID++) {\n        optionIDs[z] = optionID;\n        strikes_[z] = options[optionID];\n        positions_[z] = positions[user].positions[optionID];\n        cashes[z] = positions[user].cash;\n        z++;\n      }\n    }\n    return (optionIDs, strikes_, positions_, cashes);\n  }\n\n  function expire(uint accountID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {\n    if (expired == false) {\n      if (ecrecover(sha3(factHash, value), v, r, s) == ethAddr) {\n        uint lastAccount = numAccounts;\n        if (accountID==0) {\n          accountID = 1;\n        } else {\n          lastAccount = accountID;\n        }\n        for (accountID=accountID; accountID<=lastAccount; accountID++) {\n          if (positions[accounts[accountID].user].expired == false) {\n            int result = positions[accounts[accountID].user].cash / 1000000000000000000;\n            for (uint optionID=0; optionID<numOptions; optionID++) {\n              int moneyness = getMoneyness(options[optionID], uint(value), margin);\n              result += moneyness * positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;\n            }\n            positions[accounts[accountID].user].expired = true;\n            uint amountToSend = uint(accounts[accountID].capital + result);\n            accounts[accountID].capital = 0;\n            if (positions[accounts[accountID].user].hasPosition==true) {\n              numPositionsExpired++;\n            }\n            accounts[accountID].user.call.value(amountToSend)();\n            Expire(msg.sender, accounts[accountID].user);\n          }\n        }\n        if (numPositionsExpired == numPositions) {\n          expired = true;\n        }\n      }\n    }\n  }\n\n  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {\n    if (strike>=0) { //call\n      if (settlement>uint(strike)) {\n        if (settlement-uint(strike)<margin) {\n          return int(settlement-uint(strike));\n        } else {\n          return int(margin);\n        }\n      } else {\n        return 0;\n      }\n    } else { //put\n      if (settlement<uint(-strike)) {\n        if (uint(-strike)-settlement<margin) {\n          return int(uint(-strike)-settlement);\n        } else {\n          return int(margin);\n        }\n      } else {\n        return 0;\n      }\n    }\n  }\n\n  function orderMatchTest(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, uint value, int matchSize) constant returns(bool) {\n    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+int(value)+getMaxLossAfterTrade(sender, optionID, matchSize, -matchSize * int(price))>0) {\n      return true;\n    }\n    return false;\n  }\n\n  function orderMatch(uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {\n    addFunds();\n    bytes32 hash = sha256(optionID, price, size, orderID, blockExpires);\n    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionID, matchSize, -matchSize * int(price))>0) {\n      if (positions[msg.sender].hasPosition == false) {\n        positions[msg.sender].hasPosition = true;\n        numPositions++;\n      }\n      if (positions[addr].hasPosition == false) {\n        positions[addr].hasPosition = true;\n        numPositions++;\n      }\n      positions[msg.sender].positions[optionID] += matchSize;\n      positions[msg.sender].cash -= matchSize * int(price);\n      positions[addr].positions[optionID] -= matchSize;\n      positions[addr].cash += matchSize * int(price);\n      orderFills[hash] -= matchSize;\n      OrderMatch(msg.sender, matchSize, addr, size, optionID, price);\n    } else {\n      OrderMatchFailure(msg.sender, matchSize, addr, size, optionID, price);\n    }\n  }\n\n  function getMaxLossAfterTrade(address user, uint optionID, int positionChange, int cashChange) constant returns(int) {\n    bool maxLossInitialized = false;\n    int maxLoss = 0;\n    if (positions[user].expired == false && numOptions>0) {\n      for (uint s=0; s<numOptions; s++) {\n        int pnl = positions[user].cash / 1000000000000000000;\n        pnl += cashChange / 1000000000000000000;\n        uint settlement = 0;\n        if (options[s]<0) {\n          settlement = uint(-options[s]);\n        } else {\n          settlement = uint(options[s]);\n        }\n        pnl += moneySumAtSettlement(user, optionID, positionChange, settlement);\n        if (pnl<maxLoss || maxLossInitialized==false) {\n          maxLossInitialized = true;\n          maxLoss = pnl;\n        }\n        pnl = positions[user].cash / 1000000000000000000;\n        pnl += cashChange / 1000000000000000000;\n        settlement = 0;\n        if (options[s]<0) {\n          if (uint(-options[s])>margin) {\n            settlement = uint(-options[s])-margin;\n          } else {\n            settlement = 0;\n          }\n        } else {\n          settlement = uint(options[s])+margin;\n        }\n        pnl += moneySumAtSettlement(user, optionID, positionChange, settlement);\n        if (pnl<maxLoss) {\n          maxLoss = pnl;\n        }\n      }\n    }\n    return maxLoss;\n  }\n\n  function moneySumAtSettlement(address user, uint optionID, int positionChange, uint settlement) internal returns(int) {\n    int pnl = 0;\n    for (uint j=0; j<numOptions; j++) {\n      pnl += positions[user].positions[j] * getMoneyness(options[j], settlement, margin) / 1000000000000000000;\n      if (j==optionID) {\n        pnl += positionChange * getMoneyness(options[j], settlement, margin) / 1000000000000000000;\n      }\n    }\n    return pnl;\n  }\n\n  function min(uint a, uint b) constant returns(uint) {\n    if (a<b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1989771,0xe429a95f842e28ee7b98ca82b61017cc70c171ba,false,false,,,,TOO_SHORT
1989948,0xc3753f81f361a2e5c61ee50eeb917134af54b2ee,false,false,,,,TOO_SHORT
1990038,0xe95f8b7be581361f2b871eeabe2f63798a244938,false,false,,,,TOO_SHORT
1990787,0x1e4816b3021cb7cf8b49d7e85f72eaf98e5eb346,false,false,,,,TOO_SHORT
1991478,0xca0d7326019b47fb3f4e4e8a3ae1b5414a1f15c2,false,false,,,,TOO_SHORT
1991584,0x5f31a6170003305ba249e7ab4e865fc76c7d1de1,false,false,,,,TOO_SHORT
1992260,0xbb6ef99c644cf518746467b0e8e7178f16a6414f,false,false,,,,TOO_SHORT
1992685,0x1426b66d9a6f86b8d60e68200cba2c37a429ff4e,false,false,,,,TOO_SHORT
1992735,0x81cb73a44e41a2884ae7db27486ba27f4f5e5c35,false,false,,,,TOO_SHORT
1992893,0x3955f809a6a7e2c42a7130b603388f28b04e749f,false,false,,,,TOO_SHORT
1993079,0x9f2001282d67ee2efa8af4bb9f79a0dfecf9bade,false,false,,,,TOO_SHORT
1993438,0xa2f9e58ea8e86e6fe96e87010c867542f597209c,false,false,,,,TOO_SHORT
1993485,0x59b8f851e1a433a7ece7c8102aadb8ed2c19727f,false,false,"/*\n	WeeklyLotteryB\n	Coded by: iFA\n	http://wlb.ethereumlottery.net\n	ver: 1.1\n*/\n\ncontract WLBdrawsDBInterface {\n	function newDraw(uint date, uint8[3] numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value);\n	function getDraw(uint id) constant returns (uint date, uint8[3] numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value);\n}\n\ncontract WeeklyLotteryB {\n	/* structures */\n	struct games_s {\n		uint ticketsCount;\n		mapping(bytes32 => uint) hit3Hash;\n		mapping(bytes32 => uint) hit2Hash;\n		uint startTimestamp;\n		uint endTimestamp;\n		bytes3 winningNumbersBytes;\n		uint prepareBlock;\n		bool drawDone;\n		uint prizePot;\n		uint hit3Count;\n		uint hit3Value;\n		uint hit2Count;\n		uint hit2Value;\n	}\n	struct playerGames_s {\n		bytes3[] numbersBytes;\n		mapping(bytes32 => uint) hit3Hash;\n		mapping(bytes32 => uint) hit2Hash;\n		bool checked;\n	}\n	struct players_s {\n		mapping(uint => playerGames_s) games;\n	}\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint begins;\n	}\n	struct draws_s {\n		uint date;\n		uint gameID;\n		bytes3 numbersBytes;\n		uint hit3Count;\n		uint hit3Value;\n		uint hit2Count;\n		uint hit2Value;\n	}\n	/* config */\n	uint public constant ticketPrice = 100 finney; // 0.1 ether\n	uint private constant drawMaxNumber = 50;\n	uint private constant drawBlockDelay = 5;\n	uint private constant prizeDismissDelay = 5;\n	uint private constant contractDismissDelay = 5 weeks;\n	uint private constant investUnit = 1 ether;\n	uint private constant investMinimum = 10 ether;\n	uint private constant investUserLimit = 200;\n	uint private constant investMinDuration = 5; // 5 draw!\n	uint private constant investIdleTime = 1 days;\n	uint private constant forOwner = 2; //%\n	uint private constant forInvestors = 40; //%\n	uint private constant forHit2 = 30; //%\n	/* variables */\n	address private WLBdrawsDB;\n	address private owner;\n	uint private currentJackpot;\n	uint private investmentsValue;\n	uint private extraJackpot;\n	uint private ticketCounter;\n	uint private currentGame;\n	uint private ownerBalance;\n	bool public contractEnabled = true;\n	uint private contractDisabledTimeStamp;\n	mapping(address => players_s) private players;\n	games_s[] private games;\n	investors_s[] private investors;\n	/* events */\n	event NewTicketEvent(address Player, uint8 Number1, uint8 Number2, uint8 Number3);\n	event ContractDisabledEvent(uint DeadlineTime);\n	event DrawPrepareEvent(uint BlockNumber);\n	event DrawEvent(uint GameID, uint8 Number1, uint8 Number2, uint8 Number3, uint Hit3Count, uint Hit3Value, uint Hit2Count, uint Hit2Value);\n	event InvestAddEvent(address Investor, uint Value);\n	event InvestCancelEvent(address Investor, uint Value);\n	/* constructor */\n	function WeeklyLotteryB(address _WLBdrawsDB) {\n		WLBdrawsDB = _WLBdrawsDB;\n		owner = msg.sender;\n		currentGame = 1;\n		games.length = 2;\n		games[1].startTimestamp = now;\n		games[1].endTimestamp = calcNextDrawTime();\n	}\n	/* constant functions */\n	function Visit() constant returns (string) { return ""http://wlb.ethereumlottery.net""; }\n	function Draws(uint id) constant returns (uint date, uint8[3] Numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value) {\n		return WLBdrawsDBInterface( WLBdrawsDB ).getDraw(id);\n	}\n	function CurrentGame() constant returns (uint GameID, uint Jackpot, uint Start, uint End, uint Tickets) {\n		return (currentGame, currentJackpot, games[currentGame].startTimestamp, games[currentGame].endTimestamp, games[currentGame].ticketsCount);\n	}\n	function PlayerTickets(address Player, uint GameID, uint TicketID) constant returns (uint8[3] numbers, bool Checked) {\n		return ( getNumbersFromBytes( players[Player].games[GameID].numbersBytes[TicketID] ), players[Player].games[GameID].checked);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		var (found, InvestorID) = getInvestorByAddress(Address);\n		if (found == false || ! investors[InvestorID].valid) {\n			return (0, 0, false);\n		}\n		return (investors[InvestorID].value, investors[InvestorID].balance, investors[InvestorID].live);\n	}\n	function CheckPrize(address Address) constant returns(uint value) {\n		uint gameID;\n		uint gameLowID;\n		uint8[3] memory numbers;\n		uint hit3Count;\n		uint hit2Count;\n		if (currentGame < prizeDismissDelay) {\n			gameLowID = 1;\n		} else {\n			gameLowID = currentGame-prizeDismissDelay;\n		}\n		for ( gameID=currentGame ; gameID>=gameLowID ; gameID-- ) {\n			if ( ! players[Address].games[gameID].checked) {\n				if (games[gameID].drawDone) {\n					numbers = getNumbersFromBytes(games[gameID].winningNumbersBytes);\n					hit3Count = players[Address].games[gameID].hit3Hash[sha3( numbers[0], numbers[1], numbers[2] )];\n					value += hit3Count * games[gameID].hit3Value;\n					hit2Count = players[Address].games[gameID].hit2Hash[sha3( numbers[0], numbers[1] )];\n					hit2Count += players[Address].games[gameID].hit2Hash[sha3( numbers[0], numbers[2] )];\n					hit2Count += players[Address].games[gameID].hit2Hash[sha3( numbers[1], numbers[2] )];\n					hit2Count -= hit3Count*3;\n					value += hit2Count * games[gameID].hit2Value;\n				} else if ( ! contractEnabled && gameID == currentGame) {\n					value += players[Address].games[gameID].numbersBytes.length * ticketPrice;\n				}\n			}\n		}\n	}\n	/* callback function */\n	function () {\n		var Numbers = getNumbersFromHash(sha3(block.coinbase, now, ticketCounter));\n		BuyTicket(Numbers[0],Numbers[1],Numbers[2]);\n	}\n	/* external functions for players */\n	function BuyTicket(uint8 Number1, uint8 Number2, uint8 Number3) noContract OnlyEnabled {\n		var Numbers = [Number1 , Number2 , Number3];\n		if ( ! checkNumbers( Numbers )) { throw; }\n		Numbers = sortNumbers(Numbers);\n		if (msg.value < ticketPrice) { throw; }\n		if (msg.value-ticketPrice > 0) { if ( ! msg.sender.send( msg.value-ticketPrice )) { throw; } }\n		if (currentJackpot == 0) { throw; }\n		if (games[currentGame].endTimestamp < now) { throw; }\n		ticketCounter++;\n		games[currentGame].ticketsCount++;\n		bytes32 hash0 = sha3( Numbers[0], Numbers[1], Numbers[2] );\n		bytes32 hash1 = sha3( Numbers[0], Numbers[1]);\n		bytes32 hash2 = sha3( Numbers[0], Numbers[2]);\n		bytes32 hash3 = sha3( Numbers[1], Numbers[2]);\n		games[currentGame].hit3Hash[hash0]++;\n		games[currentGame].hit2Hash[hash1]++;\n		games[currentGame].hit2Hash[hash2]++;\n		games[currentGame].hit2Hash[hash3]++;\n		players[msg.sender].games[currentGame].numbersBytes.push ( getBytesFromNumbers(Numbers) );\n		players[msg.sender].games[currentGame].hit3Hash[hash0]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash1]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash2]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash3]++;\n		NewTicketEvent( msg.sender, Numbers[0], Numbers[1], Numbers[2] );\n	}\n	function CheckTickets() external noEther noContract {\n		uint _value;\n		uint _subValue;\n		uint gameID;\n		uint gameLowID;\n		uint8[3] memory numbers;\n		bool changed;\n		uint hit3Count;\n		uint hit2Count;\n		if (currentGame < prizeDismissDelay) {\n			gameLowID = 1;\n		} else {\n			gameLowID = currentGame-prizeDismissDelay;\n		}\n		for ( gameID=currentGame ; gameID>=gameLowID ; gameID-- ) {\n			if ( ! players[msg.sender].games[gameID].checked) {\n				if (games[gameID].drawDone) {\n					numbers = getNumbersFromBytes(games[gameID].winningNumbersBytes);\n					hit3Count = players[msg.sender].games[gameID].hit3Hash[sha3( numbers[0], numbers[1], numbers[2] )];\n					_subValue += hit3Count * games[gameID].hit3Value;\n					hit2Count = players[msg.sender].games[gameID].hit2Hash[sha3( numbers[0], numbers[1] )];\n					hit2Count += players[msg.sender].games[gameID].hit2Hash[sha3( numbers[0], numbers[2] )];\n					hit2Count += players[msg.sender].games[gameID].hit2Hash[sha3( numbers[1], numbers[2] )];\n					hit2Count -= hit3Count*3;\n					_subValue += hit2Count * games[gameID].hit2Value;\n					games[gameID].prizePot -= _subValue;\n					_value += _subValue;\n					players[msg.sender].games[gameID].checked = true;\n					changed = true;\n				} else if ( ! contractEnabled && gameID == currentGame) {\n					_value += players[msg.sender].games[gameID].numbersBytes.length * ticketPrice;\n					players[msg.sender].games[gameID].checked = true;\n					changed = true;\n				}\n			}\n		}\n		if ( ! changed) { throw; }\n		if (_value > 0) { if ( ! msg.sender.send(_value)) { throw; } }\n	}\n	/* external functions for investors */\n	function InvestAdd() external OnlyEnabled noContract {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send( value_ % investUnit )) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		if (value_ < investMinimum) { throw; }\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) {\n			if (investors.length == investUserLimit) { throw; }\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].begins = currentGame;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		investmentsValue += value_;\n		setJackpot();\n		InvestAddEvent(msg.sender, value_);\n	}\n	function InvestWithdraw() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		uint _balance = investors[InvestorID].balance;\n		if (_balance == 0) { throw; }\n		investors[InvestorID].balance = 0;\n		if ( ! msg.sender.send( _balance )) { throw; }\n	}\n	function InvestCancel() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (contractEnabled) {\n			if (investors[InvestorID].begins+investMinDuration > now) { throw; }\n			if (games[currentGame].startTimestamp+investIdleTime > now) { throw; }\n		}\n		uint balance_;\n		if (investors[InvestorID].live) {\n			investmentsValue -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n			InvestCancelEvent(msg.sender, investors[InvestorID].value);\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		delete investors[InvestorID];\n		if ( ! msg.sender.send( balance_ )) { throw; }\n	}\n	/* draw functions for everyone*/\n	function DrawPrepare() noContract OnlyEnabled noEther {\n		if (games[currentGame].endTimestamp > now || games[currentGame].prepareBlock != 0) { throw; }\n		games[currentGame].prepareBlock = block.number+drawBlockDelay;\n		DrawPrepareEvent(games[currentGame].prepareBlock);\n	}\n	function Draw() noContract OnlyEnabled noEther {\n		if (games[currentGame].prepareBlock == 0 || games[currentGame].prepareBlock > block.number) { throw; }\n		bytes32 _hash;\n		uint hit3Value;\n		uint hit3Count;\n		uint hit2Value;\n		uint hit2Count;\n		uint a;\n		for ( a = 1 ; a <= drawBlockDelay ; a++ ) {\n			_hash = sha3(_hash, block.blockhash(games[currentGame].prepareBlock - drawBlockDelay+a));\n		}\n		var numbers = getNumbersFromHash(_hash);\n		games[currentGame].winningNumbersBytes = getBytesFromNumbers( numbers );\n		hit3Count += games[currentGame].hit3Hash[ sha3( numbers[0], numbers[1],numbers[2] ) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[0], numbers[1]) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[0], numbers[2]) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[1], numbers[2]) ];\n		hit2Count -= hit3Count*3;\n		uint totalPot = games[currentGame].ticketsCount*ticketPrice;\n		hit2Value = ( totalPot * forHit2 / 100 );\n		games[currentGame].prizePot = hit2Value;\n		hit2Value = hit2Value / hit2Count;\n		totalPot -= hit2Value;\n		uint _ownerBalance = totalPot * forHit2 / 100;\n		totalPot -= _ownerBalance;\n		ownerBalance += _ownerBalance;\n		uint _addInvestorsValue = totalPot * forInvestors / 100;\n		addInvestorsValue(_addInvestorsValue);\n		totalPot -= _addInvestorsValue;\n		if (hit3Count > 0) {\n			games[currentGame].prizePot += currentJackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				delete investors[a].live;\n			}\n			hit3Value = currentJackpot / hit3Count;\n			extraJackpot = 0;\n			investmentsValue = 0;\n		}\n		extraJackpot += totalPot;\n		setJackpot();\n		DrawEvent(currentGame, numbers[0], numbers[1], numbers[2], hit3Count, hit3Value, hit2Count, hit2Value);\n		WLBdrawsDBInterface( WLBdrawsDB ).newDraw( now, numbers, hit3Count, hit3Value, hit2Count, hit2Value);\n		games[currentGame].hit3Count = hit3Count;\n		games[currentGame].hit3Value = hit3Value;\n		games[currentGame].hit2Count = hit2Count;\n		games[currentGame].hit2Value = hit2Value;\n		games[currentGame].drawDone = true;\n		newGame();\n	}\n	/* owner functions */\n	function OwnerGetFee() external OnlyOwner {\n		if (ownerBalance == 0) { throw; }\n		if (owner.send(ownerBalance) == false) { throw; }\n		ownerBalance = 0;\n	}\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! contractEnabled) {\n			if (contractDisabledTimeStamp+contractDismissDelay < now) {\n				suicide(owner);\n			}\n		} else {\n			contractEnabled = false;\n			contractDisabledTimeStamp = now;\n			ContractDisabledEvent(contractDisabledTimeStamp+contractDismissDelay);\n			ownerBalance += extraJackpot;\n			extraJackpot = 0;\n			games[currentGame].prizePot = games[currentGame].ticketsCount*ticketPrice;\n		}\n	}\n	/* private functions */\n	function addInvestorsValue(uint value) private {\n		bool done;\n		uint a;\n		for ( a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / investmentsValue;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			ownerBalance += value;\n		}\n	}\n	function newGame() private {\n		currentGame++;\n		uint gamesID = games.length;\n		games.length++;\n		games[gamesID].startTimestamp = now;\n		games[gamesID].endTimestamp = calcNextDrawTime();\n		if (games.length > prizeDismissDelay) {\n			ownerBalance += games[currentGame-prizeDismissDelay].prizePot;\n			delete games[currentGame-prizeDismissDelay];\n		}\n	}\n	function getNumbersFromHash(bytes32 hash) private returns (uint8[3] numbers) {\n		bool ok = true;\n		uint8 num = 0;\n		uint hashpos = 0;\n		uint8 a;\n		uint8 b;\n		for (a = 0 ; a < numbers.length ; a++) {\n			while (true) {\n				ok = true;\n				if (hashpos == 32) {\n					hashpos = 0;\n					hash = sha3(hash);\n				}\n				num = getPart( hash, hashpos );\n				num = num % uint8(drawMaxNumber) + 1;\n				hashpos += 1;\n				for (b = 0 ; b < numbers.length ; b++) {\n					if (numbers[b] == num) {\n						ok = false;\n						break; \n					}\n				}\n				if (ok == true) {\n					numbers[a] = num;\n					break;\n				}\n			}\n		}\n		numbers = sortNumbers( numbers );\n	}\n	function getPart(bytes32 a, uint i) private returns (uint8) { return uint8(byte(bytes32(uint(a) * 2 ** (8 * i)))); }\n	function setJackpot() private {\n		currentJackpot = investmentsValue + extraJackpot;\n	}\n	function getInvestorByAddress(address Address) private returns (bool found, uint id) {\n		for ( id=0 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return (true, id);\n			}\n		}\n		return (false, 0);\n	}\n	function checkNumbers(uint8[3] Numbers) private returns (bool) {\n		for ( uint a = 0 ; a < Numbers.length ; a++ ) {\n			if (Numbers[a] > drawMaxNumber || Numbers[a] == 0) { return; }\n			for ( uint b = 0 ; a < Numbers.length ; a++ ) {\n				if (a != b && Numbers[a] == Numbers[b]) { return; }\n			}\n		}\n		return true;\n	}\n	function calcNextDrawTime() private returns (uint ret) {\n		ret = 1468152000;\n		while (ret < now) {\n			ret += 1 weeks;\n		}\n	}\n	function sortNumbers(uint8[3] numbers) private returns(uint8[3] sNumbers) {\n		sNumbers = numbers;\n		for (uint8 i=0; i<numbers.length; i++) {\n			for (uint8 j=i+1; j<numbers.length; j++) {\n				if (sNumbers[i] > sNumbers[j]) {\n					uint8 t = sNumbers[i];\n					sNumbers[i] = sNumbers[j];\n					sNumbers[j] = t;\n				}\n			}\n		}\n	}\n	function getNumbersFromBytes(bytes3 Bytes) private returns (uint8[3] Numbers){\n		Numbers[0] = uint8(Bytes);\n		Numbers[1] = uint8(uint24(Bytes) /256);\n		Numbers[2] = uint8(uint24(Bytes) /256/256);\n	}\n	function getBytesFromNumbers(uint8[3] Numbers) private returns (bytes3 Bytes) {\n		return bytes3(uint(Numbers[0])+uint(Numbers[1])*256+uint(Numbers[2])*256*256);\n	}\n	/* modifiers */\n	modifier noContract() {if (tx.origin != msg.sender) { throw; } _ }\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! contractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1993514,0x2de700d9fdb8b80af8cef9aa7c46f98304ff8bcd,true,false,,,,0xf868a1d3de6edf1f33065da994580b4e82a40044
1993617,0x60ede878ba65557a70d3f1be735e847160449d6b,false,false,,,,TOO_SHORT
1993773,0x6ac85d0408044afb786a6d631d4d3426ce0e031a,false,false,"contract DAO {\n    function balanceOf(address addr) returns (uint);\n    function transferFrom(address from, address to, uint balance) returns (bool);\n    function getNewDAOAddress(uint _proposalID) constant returns(address _newDAO);\n    uint public totalSupply;\n}\n\n/**\n * @title untrustedChildWithdraw\n * @author Paul Szczesny, Alexey Akhunov\n * A withdraw contract for untrusted childDAOs affected by the hard fork.\n * Based on the official WithdrawDAO contract found here: https://etherscan.io/address/0xbf4ed7b27f1d666546e30d74d50d173d20bca754#code\n */\ncontract untrustedChildWithdraw {\n\n  struct childDAO {\n	  DAO dao;\n    uint numerator;\n	}\n\n  DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);\n  uint[] public untrustedProposals = [35, 36, 53, 62, 67, 68, 70, 71, 73, 76, 87];\n  uint public ratioDenominator = 1000000000;\n  uint[] public untrustedTokenNumerator = [1458321331, 1458321331, 1399760834, 1457994374, 1457994374, 1146978827, 1457994374, 1458321336, 1458307000, 1458328768, 1458376290];\n  mapping (uint => childDAO) public whiteList;\n\n  /**\n  * Populates the whiteList based on the list of trusted proposal Ids.\n  */\n  function untrustedChildWithdraw() {\n      for(uint i=0; i<untrustedProposals.length; i++) {\n          uint proposalId = untrustedProposals[i];\n          whiteList[proposalId] = childDAO(DAO(mainDAO.getNewDAOAddress(proposalId)), untrustedTokenNumerator[i]);\n      }\n  }\n\n  /**\n  * Convienience function for the Curator to calculate the required amount of Wei\n  * that needs to be transferred to this contract.\n  */\n  function requiredEndowment() constant returns (uint endowment) {\n      uint sum = 0;\n      for(uint i=0; i<untrustedProposals.length; i++) {\n          uint proposalId = untrustedProposals[i];\n          DAO child = whiteList[proposalId].dao;\n          sum += (child.totalSupply() * (untrustedTokenNumerator[i] / ratioDenominator) );\n      }\n      return sum;\n  }\n\n  /**\n   * Function call to withdraw ETH by burning childDao tokens.\n   * @param proposalId The split proposal ID which created the childDao\n   * @dev This requires that the token-holder authorizes this contract's address using the approve() function.\n   */\n  function withdraw(uint proposalId) {\n    //Check the token balance\n    uint balance = whiteList[proposalId].dao.balanceOf(msg.sender);\n    uint adjustedBalance = balance * (whiteList[proposalId].numerator / ratioDenominator);\n\n    // Transfer childDao tokens first, then send Ether back in return\n    if (!whiteList[proposalId].dao.transferFrom(msg.sender, this, balance) || !msg.sender.send(adjustedBalance))\n      throw;\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。,
1993896,0x81f6e699c66406abb3a1aef46a29b06ce88d675c,false,false,,,,TOO_SHORT
1994338,0xb09c0254b26333f02428dc03435313b9a3f4f039,false,false,,,,TOO_SHORT
1994358,0xa3b0b51f389bf2cd5db40f7369adbe2462d05805,false,false,,,,TOO_SHORT
1994361,0x2fc562127f2e10bf9896330a7209ebbd62f6301a,false,false,,,,TOO_SHORT
1994626,0x7860531410219fcbf19672f2deb13c80b5956430,false,false,,,,TOO_SHORT
1995025,0x47b6504a5235c7890a62cc98091ce80c700b4af0,false,false,,,,TOO_SHORT
1995455,0x5be91f1a477e99422788914c16af4e8bad9dcfa5,false,false,,,,TOO_SHORT
1995515,0x6d44772c11f763e1f9640ed85f8b9cb95bbba350,false,false,,,,TOO_SHORT
1995593,0x05bef9c8ed7d3ea2c9960c0be12cde8187bcc0ca,false,false,,,,TOO_SHORT
1995971,0x953ef2c1c1154aa37a01c2d101974af608cefdf1,false,false,,,,TOO_SHORT
1996000,0x8d99ab91d168f839c381895e4ed1f3f5574ceb8a,false,false,,,,TOO_SHORT
1996266,0xf723b50c93db0c0b067f4970594c9d92cc859a47,false,false,,,,TOO_SHORT
1996430,0x694d925369a50e22ca038d4c38a8271619e8f693,false,false,,,,TOO_SHORT
1996586,0xe18200fd9b56ee8eef743a6489e9c2155d749a91,false,false,,,,TOO_SHORT
1996602,0xf849ddce0c109dec027ea21e7641cdda7cd606b7,false,false,,,,TOO_SHORT
1997041,0x2b16fca625836da25facf2b4cf67d581e64abaa6,false,false,,,,TOO_SHORT
1997403,0xc4cdc0c86f64f6d77520a7e995a2e22e38dfa9f0,false,false,,,,TOO_SHORT
1998096,0xc097567142c7c2f6768e8e5673b59d3d26c057e5,false,false,,,,TOO_SHORT
1998310,0xad164595fd431257d487b84c1894e9434c070844,false,false,,,,TOO_SHORT
1998587,0xba5da99c15ffda57e84b6931b55239851085d386,false,false,,,,TOO_SHORT
1998847,0x08dc8f18e0f32cf8d817ddd6d0bb85090f0ac5b5,false,false,,,,TOO_SHORT
1998864,0xf85107483c8d495fabb5565a4f0b04a9aab92e6a,false,false,,,,TOO_SHORT
1999262,0x2e070ed38688ff20ab4d8d70c15c84e9116f1cda,false,false,,,,TOO_SHORT
1999535,0x2ae0f168cf0a23b69e4c65a11837a28a6337d24b,false,false,,,,TOO_SHORT
1999565,0x0a72894c789b880e4bdeac91807c43cdfebc0c57,false,false,,,,TOO_SHORT
1999813,0xcaf10b47fe54962fd952524e6837b9ef3c798761,false,false,,,,TOO_SHORT
1999833,0x9bfc845231e48a0ef0d53a7b80843ac5cd054ece,false,false,,,,TOO_SHORT
1999861,0x38327f7f2c6163fc253e1fcdd4d21a833aabe328,false,false,,,,TOO_SHORT
1999908,0x345a6e3b030da16bcf121b315f0a9e7f52f89619,false,false,,,,TOO_SHORT
1999925,0xdd216a355569dcf48bcbf010a72853f5982e8787,false,false,,,,TOO_SHORT
