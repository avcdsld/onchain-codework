block_number,address,is_erc20,is_erc721,code,artistic_score,artistic_reason
49428,0xa3483b08c8a0f33eb07aff3a66fbcaf5c9018cdc,FALSE,FALSE,"contract testContract {    \n   function go() constant returns (string) {        \n      return ""Hello Ethereum!"";    \n   }\n}",1,
49853,0x8374f5cc22eda52e960d9558fb48dd4b7946609a,FALSE,FALSE,"contract FirstCoin {\n    mapping (address => uint) public coinBalanceOf;\n\n    event CoinTransfer(address sender, address receiver, uint amount);\n\n    function FirstCoin(uint supply) {\n        coinBalanceOf[msg.sender] = 1000000;\n    }\n\n    function sendCoin(address receiver, uint amount) returns(bool sufficient) {\n        if (coinBalanceOf[msg.sender] < amount) {\n            return false;\n        }\n        coinBalanceOf[msg.sender] -= amount;\n        coinBalanceOf[receiver] += amount;\n        CoinTransfer(msg.sender, receiver, amount);\n        return true;\n    } \n}",1,
49880,0x6e38a457c722c6011b2dfa06d49240e797844d66,FALSE,FALSE,"contract TerraNullius {\n  struct Claim { address claimant; string message; uint block_number; }\n  Claim[] public claims;\n\n  function claim(string message) {\n    uint index = claims.length;\n    claims.length++;\n    claims[index] = Claim(msg.sender, message, block.number);\n  }\n\n  function number_of_claims() returns(uint result) {\n    return claims.length;\n  }\n}",1,
49924,0x109c4f2ccc82c4d77bde15f306707320294aea3f,FALSE,FALSE,contract MyScheme {\n \n    uint treeBalance;\n    uint numInvestorsMinusOne;\n    uint treeDepth;\n    address[] myTree;\n \n    function MyScheme() {\n        treeBalance = 0;\n        myTree.length = 6;\n        myTree[0] = msg.sender;\n        numInvestorsMinusOne = 0;\n    }\n   \n        function getNumInvestors() constant returns (uint a){\n                a = numInvestorsMinusOne+1;\n        }\n   \n        function() {\n        uint amount = msg.value;\n        if (amount>=1000000000000000000){\n            numInvestorsMinusOne+=1;\n            myTree[numInvestorsMinusOne]=msg.sender;\n            amount-=1000000000000000000;\n            treeBalance+=1000000000000000000;\n            if (numInvestorsMinusOne<=2){\n                myTree[0].send(treeBalance);\n                treeBalance=0;\n                treeDepth=1;\n            }\n            else if (numInvestorsMinusOne+1==myTree.length){\n                    for(uint i=myTree.length-3*(treeDepth+1);i<myTree.length-treeDepth-2;i++){\n                        myTree[i].send(500000000000000000);\n                        treeBalance-=500000000000000000;\n                    }\n                    uint eachLevelGets = treeBalance/(treeDepth+1)-1;\n                    uint numInLevel = 1;\n                    for(i=0;i<myTree.length-treeDepth-2;i++){\n                        myTree[i].send(eachLevelGets/numInLevel-1);\n                        treeBalance -= eachLevelGets/numInLevel-1;\n                        if (numInLevel*(numInLevel+1)/2 -1== i){\n                            numInLevel+=1;\n                        }\n                    }\n                    myTree.length+=treeDepth+3;\n                    treeDepth+=1;\n            }\n        }\n                treeBalance+=amount;\n    }\n},1,
51807,0x5564886ca2c518d1964e5fcea4f423b41db9f561,FALSE,FALSE,"contract NameRegister {\n  function addr(bytes32 _name) constant returns (address o_owner) {}\n  function name(address _owner) constant returns (bytes32 o_name) {}\n}\ncontract Registrar is NameRegister {\n  event Changed(bytes32 indexed name);\n  event PrimaryChanged(bytes32 indexed name, address indexed addr);\n  function owner(bytes32 _name) constant returns (address o_owner) {}\n  function addr(bytes32 _name) constant returns (address o_address) {}\n  function subRegistrar(bytes32 _name) constant returns (address o_subRegistrar) {}\n  function content(bytes32 _name) constant returns (bytes32 o_content) {}\n  function name(address _owner) constant returns (bytes32 o_name) {}\n}\n\ncontract GlobalRegistrar is Registrar {\n  struct Record {\n    address owner;\n    address primary;\n    address subRegistrar;\n    bytes32 content;\n    uint value;\n    uint renewalDate;\n  }\n  function Registrar() {\n    // TODO: Populate with hall-of-fame.\n  }\n  function reserve(bytes32 _name) {\n    // Don't allow the same name to be overwritten.\n    // TODO: bidding mechanism\n    if (m_toRecord[_name].owner == 0) {\n      m_toRecord[_name].owner = msg.sender;\n      Changed(_name);\n    }\n  }\n  /*\n  TODO\n  > 12 chars: free\n  <= 12 chars: auction:\n  1. new names are auctioned\n  - 7 day period to collect all bid bytes32es + deposits\n  - 1 day period to collect all bids to be considered (validity requires associated deposit to be >10% of bid)\n  - all valid bids are burnt except highest - difference between that and second highest is returned to winner\n  2. remember when last auctioned/renewed\n  3. anyone can force renewal process:\n  - 7 day period to collect all bid bytes32es + deposits\n  - 1 day period to collect all bids & full amounts - bids only uncovered if sufficiently high.\n  - 1% of winner burnt; original owner paid rest.\n  */\n  modifier onlyrecordowner(bytes32 _name) { if (m_toRecord[_name].owner == msg.sender) _ }\n  function transfer(bytes32 _name, address _newOwner) onlyrecordowner(_name) {\n    m_toRecord[_name].owner = _newOwner;\n    Changed(_name);\n  }\n  function disown(bytes32 _name) onlyrecordowner(_name) {\n    if (m_toName[m_toRecord[_name].primary] == _name)\n    {\n      PrimaryChanged(_name, m_toRecord[_name].primary);\n      m_toName[m_toRecord[_name].primary] = """";\n    }\n    delete m_toRecord[_name];\n    Changed(_name);\n  }\n  function setAddress(bytes32 _name, address _a, bool _primary) onlyrecordowner(_name) {\n    m_toRecord[_name].primary = _a;\n    if (_primary)\n    {\n      PrimaryChanged(_name, _a);\n      m_toName[_a] = _name;\n    }\n    Changed(_name);\n  }\n  function setSubRegistrar(bytes32 _name, address _registrar) onlyrecordowner(_name) {\n    m_toRecord[_name].subRegistrar = _registrar;\n    Changed(_name);\n  }\n  function setContent(bytes32 _name, bytes32 _content) onlyrecordowner(_name) {\n    m_toRecord[_name].content = _content;\n    Changed(_name);\n  }\n  function owner(bytes32 _name) constant returns (address) { return m_toRecord[_name].owner; }\n  function addr(bytes32 _name) constant returns (address) { return m_toRecord[_name].primary; }\n//  function subRegistrar(bytes32 _name) constant returns (address) { return m_toRecord[_name].subRegistrar; } // TODO: bring in on next iteration.\n  function register(bytes32 _name) constant returns (address) { return m_toRecord[_name].subRegistrar; }  // only possible for now\n  function content(bytes32 _name) constant returns (bytes32) { return m_toRecord[_name].content; }\n  function name(address _owner) constant returns (bytes32 o_name) { return m_toName[_owner]; }\n  mapping (address => bytes32) m_toName;\n  mapping (bytes32 => Record) m_toRecord;\n}",1,
63809,0x793ae8c1b1a160bfc07bfb0d04f85eab1a71f4f2,FALSE,FALSE,contract Faucet {\n    uint256 sendAmount;\n    mapping (address => uint) lastSent;\n    uint blockLimit;\n    function Faucet(){\n        \n	sendAmount = 10000000000000000;\n        blockLimit = 5760;\n    }\n	\n	function getWei() returns (bool){\n	    if(lastSent[msg.sender]<(block.number-blockLimit)&&address(this).balance>sendAmount){\n	        msg.sender.send(sendAmount);\n	        lastSent[msg.sender] = block.number;\n	        return true;\n	    } else {\n	        return false;\n	    }\n	}\n	\n},1,
66126,0x5fe5b7546d1628f7348b023a0393de1fc825a4fd,FALSE,FALSE,"contract Roulette {\n    \n    // Global variables\n    string sWelcome;\n    /* Remark: \n     *  Private Seed for generateRand(), \n     *  since this is nowhere visibile, \n     *  it's very hard to guess.\n     */\n    uint privSeed; \n    struct Casino {\n        address addr;\n        uint balance;\n        uint bettingLimitMin;\n        uint bettingLimitMax;\n    }\n    Casino casino;\n\n    // Init Constructor\n    function Roulette() {\n        sWelcome = ""\n-----------------------------\n     Welcome to Roulette \n Got coins? Then come on in! \n-----------------------------\n"";\n        privSeed = 1;\n        casino.addr = msg.sender;\n        casino.balance = 0;\n        casino.bettingLimitMin = 1*10**18;\n        casino.bettingLimitMax = 10*10**18;\n    }\n    \n    function welcome() constant returns (string) {\n        return sWelcome;\n    }\n    function casinoBalance() constant returns (uint) {\n        return casino.balance;\n    }\n    function casinoDeposit() {\n        if (msg.sender == casino.addr)\n            casino.balance += msg.value;\n        else \n            msg.sender.send(msg.value);\n    }\n    function casinoWithdraw(uint amount) {\n        if (msg.sender == casino.addr && amount <= casino.balance) {\n            casino.balance -= amount;\n            casino.addr.send(amount);\n        }\n    }\n    \n    // Bet on Number\n    function betOnNumber(uint number) public returns (string) {\n        // Input Handling\n        address addr = msg.sender;\n        uint betSize = msg.value;\n        if (betSize < casino.bettingLimitMin || betSize > casino.bettingLimitMax) {\n            // Return Funds\n            if (betSize >= 1*10**18)\n                addr.send(betSize);\n            return ""Please choose an amount within between 1 and 10 ETH"";\n        }\n        if (betSize * 36 > casino.balance) {\n            // Return Funds\n            addr.send(betSize);\n            return ""Casino has insufficient funds for this bet amount"";\n        }\n        if (number < 0 || number > 36) {\n            // Return Funds\n            addr.send(betSize);\n            return ""Please choose a number between 0 and 36"";\n        }\n        // Roll the wheel\n        privSeed += 1;\n        uint rand = generateRand();\n        if (number == rand) {\n            // Winner winner chicken dinner!\n            uint winAmount = betSize * 36;\n            casino.balance -= (winAmount - betSize);\n            addr.send(winAmount);\n            return ""Winner winner chicken dinner!"";\n        }\n        else {\n            casino.balance += betSize;\n            return ""Wrong number."";\n        }\n    }\n    \n    // Bet on Color\n    function betOnColor(uint color) public returns (string) {\n        // Input Handling\n        address addr = msg.sender;\n        uint betSize = msg.value;\n        if (betSize < casino.bettingLimitMin || betSize > casino.bettingLimitMax) {\n            // Return Funds\n            if (betSize >= 1*10**18)\n                addr.send(betSize);\n            return ""Please choose an amount within between 1 and 10 ETH"";\n        }\n        if (betSize * 2 > casino.balance) {\n            // Return Funds\n            addr.send(betSize);\n            return ""Casino has insufficient funds for this bet amount"";\n        }\n        if (color != 0 && color != 1) {\n            // Return Funds\n            addr.send(betSize);\n            return ""Please choose either '0' = red or '1' = black as a color"";\n        }\n        // Roll the wheel\n        privSeed += 1;\n        uint rand = generateRand();\n        uint randC = (rand + 1) % 2;\n        // Win\n        if (rand != 0 && (randC == color)) {\n            uint winAmount = betSize * 2;\n            casino.balance -= (winAmount - betSize);\n            addr.send(winAmount);\n            return ""Win! Good job."";\n        }\n        else {\n            casino.balance += betSize;\n            return ""Wrong color."";           \n        }\n    }\n    \n    // Returns a pseudo Random number.\n    function generateRand() private returns (uint) { \n        // Seeds\n        privSeed = (privSeed*3 + 1) / 2;\n        privSeed = privSeed % 10**9;\n        uint number = block.number; // ~ 10**5 ; 60000\n        uint diff = block.difficulty; // ~ 2 Tera = 2*10**12; 1731430114620\n        uint time = block.timestamp; // ~ 2 Giga = 2*10**9; 1439147273\n        uint gas = block.gaslimit; // ~ 3 Mega = 3*10**6\n        // Rand Number in Percent\n        uint total = privSeed + number + diff + time + gas;\n        uint rand = total % 37;\n        return rand;\n    }\n\n    // Function to recover the funds on the contract\n    function kill() {\n        if (msg.sender == casino.addr) \n            suicide(casino.addr);\n    }\n}",1,
74739,0x417705f7e5dba87c3db5ce00295027ae27bcae0f,FALSE,FALSE,contract echo {\n  /* Constructor */\n  function () {\n    msg.sender.send(msg.value);\n  }\n},1,
75008,0xd79b4c6791784184e2755b2fc1659eaab0f80456,FALSE,FALSE,"contract HonestDice {\n	\n	event Bet(address indexed user, uint blocknum, uint256 amount, uint chance);\n	event Won(address indexed user, uint256 amount, uint chance);\n	\n	struct Roll {\n		uint256 value;\n		uint chance;\n		uint blocknum;\n		bytes32 secretHash;\n		bytes32 serverSeed;\n	}\n	\n	uint betsLocked;\n	address owner;\n	address feed;				   \n	uint256 minimumBet = 1 * 1000000000000000000; // 1 Ether\n	uint256 constant maxPayout = 5; // 5% of bankroll\n	uint constant seedCost = 100000000000000000; // This is the cost of supplyin the server seed, deduct it;\n	mapping (address => Roll) rolls;\n	uint constant timeout = 20; // 5 Minutes\n	\n	function HonestDice() {\n		owner = msg.sender;\n		feed = msg.sender;\n	}\n	\n	function roll(uint chance, bytes32 secretHash) {\n		if (chance < 1 || chance > 255 || msg.value < minimumBet || calcWinnings(msg.value, chance) > getMaxPayout() || betsLocked != 0) { \n			msg.sender.send(msg.value); // Refund\n			return;\n		}\n		rolls[msg.sender] = Roll(msg.value, chance, block.number, secretHash, 0);\n		Bet(msg.sender, block.number, msg.value, chance);\n	}\n	\n	function serverSeed(address user, bytes32 seed) {\n		// The server calls this with a random seed\n		if (msg.sender != feed) return;\n		if (rolls[user].serverSeed != 0) return;\n		rolls[user].serverSeed = seed;\n	}\n	\n	function hashTo256(bytes32 hash) constant returns (uint _r) {\n		// Returns a number between 0 - 255 from a hash\n		return uint(hash) & 0xff;\n	}\n	\n	function hash(bytes32 input) constant returns (uint _r) {\n		// Simple sha3 hash. Not to be called via the blockchain\n		return uint(sha3(input));\n	}\n	\n	function isReady() constant returns (bool _r) {\n		return isReadyFor(msg.sender);\n	}\n	\n	function isReadyFor(address _user) constant returns (bool _r) {\n		Roll r = rolls[_user];\n		if (r.serverSeed == 0) return false;\n		return true;\n	}\n	\n	function getResult(bytes32 secret) constant returns (uint _r) {\n		// Get the result number of the roll\n		Roll r = rolls[msg.sender];\n		if (r.serverSeed == 0) return;\n		if (sha3(secret) != r.secretHash) return;\n		return hashTo256(sha3(secret, r.serverSeed));\n	}\n	\n	function didWin(bytes32 secret) constant returns (bool _r) {\n		// Returns if the player won or not\n		Roll r = rolls[msg.sender];\n		if (r.serverSeed == 0) return;\n		if (sha3(secret) != r.secretHash) return;\n		if (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\n			return true;\n		}\n		return false;\n	}\n	\n	function calcWinnings(uint256 value, uint chance) constant returns (uint256 _r) {\n		// 1% house edge\n		return (value * 99 / 100) * 256 / chance;\n	}\n	\n	function getMaxPayout() constant returns (uint256 _r) {\n		return this.balance * maxPayout / 100;\n	}\n	\n	function claim(bytes32 secret) {\n		Roll r = rolls[msg.sender];\n		if (r.serverSeed == 0) return;\n		if (sha3(secret) != r.secretHash) return;\n		if (hashTo256(sha3(secret, r.serverSeed)) < r.chance) { // Winner\n			msg.sender.send(calcWinnings(r.value, r.chance) - seedCost);\n			Won(msg.sender, r.value, r.chance);\n		}\n		\n		delete rolls[msg.sender];\n	}\n	\n	function canClaimTimeout() constant returns (bool _r) {\n		Roll r = rolls[msg.sender];\n		if (r.serverSeed != 0) return false;\n		if (r.value <= 0) return false;\n		if (block.number < r.blocknum + timeout) return false;\n		return true;\n	}\n	\n	function claimTimeout() {\n		// Get your monies back if the server isn't responding with a seed\n		if (!canClaimTimeout()) return;\n		Roll r = rolls[msg.sender];\n		msg.sender.send(r.value);\n		delete rolls[msg.sender];\n	}\n	\n	function getMinimumBet() constant returns (uint _r) {\n		return minimumBet;\n	}\n	\n	function getBankroll() constant returns (uint256 _r) {\n		return this.balance;\n	}\n	\n	function getBetsLocked() constant returns (uint _r) {\n		return betsLocked;\n	}\n	\n	function setFeed(address newFeed) {\n		if (msg.sender != owner) return;\n		feed = newFeed;\n	}\n	\n	function lockBetsForWithdraw() {\n		if (msg.sender != owner) return;\n		uint betsLocked = block.number;\n	}\n	\n	function unlockBets() {\n		if (msg.sender != owner) return;\n		uint betsLocked = 0;\n	}\n	\n	function withdraw(uint amount) {\n		if (msg.sender != owner) return;\n		if (betsLocked == 0 || block.number < betsLocked + 5760) return;\n		owner.send(amount);\n	}\n}",1,
114402,0x3eddc7ebc7db94f54b72d8ed1f42ce6a527305bb,FALSE,FALSE,"/* linagee was here */\ncontract ayeAyeCoin {\n  string info;\n  mapping (address => uint) public coins;\n  address owner;\n  event CoinTransfer(address sender, address receiver, uint amount);\n  uint initialCoins = 6000000; /* There will only ever be 6 million ayeAyeCoins */\n\n  /* Initializes contract with initial supply to creator */\n  function ayeAyeCoin() {\n        owner = msg.sender;\n        coins[owner] = initialCoins;\n  }\n\n  /* Info about coin */\n  function ayeAyeInfo() constant returns (string) {\n     return info;\n  }\n\n  /* send currency */\n  function sendCoin(address receiver, uint amount) returns(bool sufficient) {\n        if (coins[msg.sender] < amount) return false;\n        coins[msg.sender] -= amount;\n        coins[receiver] += amount;\n        CoinTransfer(msg.sender, receiver, amount);\n        return true;\n  }\n\n  /* get your balance */\n  function coinBalance() constant returns (uint amount) {\n     return coins[msg.sender];\n  }\n\n  /* get the balance of another account */\n  function coinBalanceOf(address _addr) constant returns (uint amount) {\n     return coins[_addr];\n  }\n\n  /* A primitive faucet. Love your citizens! */\n  function coinBeg() returns (string) {\n     if (coins[owner] >= 1) {\n        coins[owner]--;\n        coins[msg.sender]++;\n        return ""ayeAyeCoin love! One coin for you!"";\n     }\n     return ""Sorry, the faucet has entirely run dry."";\n  }\n\n  function setInfo(string _info) {\n     if (msg.sender != owner) return;\n     info = _info;\n  }\n}",2,実用的な機能に加え、詩的なコメントやユニークな命名が芸術的要素を加えている。
116526,0x273930d21e01ee25e4c219b63259d214872220a2,FALSE,FALSE,"//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\ncontract multiowned {\n\n    // TYPES\n\n    // struct for the status of a pending operation.\n    struct PendingState {\n        uint yetNeeded;\n        uint ownersDone;\n        uint index;\n    }\n\n    // EVENTS\n\n    // this contract only has five types of events: it can accept a confirmation, in which case\n    // we record owner and operation (hash) alongside it.\n    event Confirmation(address owner, bytes32 operation);\n    event Revoke(address owner, bytes32 operation);\n    // some others are in the case of an owner changing.\n    event OwnerChanged(address oldOwner, address newOwner);\n    event OwnerAdded(address newOwner);\n    event OwnerRemoved(address oldOwner);\n    // the last one is emitted if the required signatures change\n    event RequirementChanged(uint newRequirement);\n\n    // MODIFIERS\n\n    // simple single-sig function modifier.\n    modifier onlyowner {\n        if (isOwner(tx.origin))\n            _\n    }\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\n    // that later attempts can be realised as the same underlying operation and\n    // thus count as confirmations.\n    modifier onlymanyowners(bytes32 _operation) {\n        if (confirmAndCheck(_operation))\n            _\n    }\n\n    // METHODS\n\n    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions\n    // as well as the selection of addresses capable of confirming them.\n    function multiowned(address[] _owners, uint _required) {\n        m_numOwners = _owners.length + 1;\n        m_owners[1] = uint(tx.origin);\n        m_ownerIndex[uint(tx.origin)] = 1;\n        for (uint i = 0; i < _owners.length; ++i)\n        {\n            m_owners[2 + i] = uint(_owners[i]);\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\n        }\n        m_required = _required;\n    }\n    \n    // Revokes a prior confirmation of the given operation\n    function revoke(bytes32 _operation) external {\n        uint ownerIndex = m_ownerIndex[uint(tx.origin)];\n        // make sure they're an owner\n        if (ownerIndex == 0) return;\n        uint ownerIndexBit = 2**ownerIndex;\n        var pending = m_pending[_operation];\n        if (pending.ownersDone & ownerIndexBit > 0) {\n            pending.yetNeeded++;\n            pending.ownersDone -= ownerIndexBit;\n            Revoke(tx.origin, _operation);\n        }\n    }\n    \n    // Replaces an owner `_from` with another `_to`.\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data, block.number)) external {\n        if (isOwner(_to)) return;\n        uint ownerIndex = m_ownerIndex[uint(_from)];\n        if (ownerIndex == 0) return;\n\n        clearPending();\n        m_owners[ownerIndex] = uint(_to);\n        m_ownerIndex[uint(_from)] = 0;\n        m_ownerIndex[uint(_to)] = ownerIndex;\n        OwnerChanged(_from, _to);\n    }\n    \n    function addOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\n        if (isOwner(_owner)) return;\n\n        clearPending();\n        if (m_numOwners >= c_maxOwners)\n            reorganizeOwners();\n        if (m_numOwners >= c_maxOwners)\n            return;\n        m_numOwners++;\n        m_owners[m_numOwners] = uint(_owner);\n        m_ownerIndex[uint(_owner)] = m_numOwners;\n        OwnerAdded(_owner);\n    }\n    \n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data, block.number)) external {\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\n        if (ownerIndex == 0) return;\n        if (m_required > m_numOwners - 1) return;\n\n        m_owners[ownerIndex] = 0;\n        m_ownerIndex[uint(_owner)] = 0;\n        clearPending();\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n        OwnerRemoved(_owner);\n    }\n    \n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data, block.number)) external {\n        if (_newRequired > m_numOwners) return;\n        m_required = _newRequired;\n        clearPending();\n        RequirementChanged(_newRequired);\n    }\n    \n    function isOwner(address _addr) returns (bool) {\n        return m_ownerIndex[uint(_addr)] > 0;\n    }\n    \n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\n        var pending = m_pending[_operation];\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n        // make sure they're an owner\n        if (ownerIndex == 0) return false;\n\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n    \n    // INTERNAL METHODS\n\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n        // determine what index the present sender is:\n        uint ownerIndex = m_ownerIndex[uint(tx.origin)];\n        // make sure they're an owner\n        if (ownerIndex == 0) return;\n\n        var pending = m_pending[_operation];\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\n        if (pending.yetNeeded == 0) {\n            // reset count of confirmations needed.\n            pending.yetNeeded = m_required;\n            // reset which owners have confirmed (none) - set our bitmap to 0.\n            pending.ownersDone = 0;\n            pending.index = m_pendingIndex.length++;\n            m_pendingIndex[pending.index] = _operation;\n        }\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        // make sure we (the message sender) haven't confirmed this operation previously.\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            Confirmation(tx.origin, _operation);\n            // ok - check if count is enough to go ahead.\n            if (pending.yetNeeded <= 1) {\n                // enough confirmations: reset and run interior.\n                delete m_pendingIndex[m_pending[_operation].index];\n                delete m_pending[_operation];\n                return true;\n            }\n            else\n            {\n                // not enough: record that this owner in particular confirmed.\n                pending.yetNeeded--;\n                pending.ownersDone |= ownerIndexBit;\n            }\n        }\n    }\n\n    function reorganizeOwners() private returns (bool) {\n        uint free = 1;\n        while (free < m_numOwners)\n        {\n            while (free < m_numOwners && m_owners[free] != 0) free++;\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n            {\n                m_owners[free] = m_owners[m_numOwners];\n                m_ownerIndex[m_owners[free]] = free;\n                m_owners[m_numOwners] = 0;\n            }\n        }\n    }\n    \n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            if (m_pendingIndex[i] != 0)\n                delete m_pending[m_pendingIndex[i]];\n        delete m_pendingIndex;\n    }\n        \n    // FIELDS\n\n    // the number of owners that must confirm the same operation before it is run.\n    uint public m_required;\n    // pointer used to find a free slot in m_owners\n    uint public m_numOwners;\n    \n    // list of owners\n    uint[256] m_owners;\n    uint constant c_maxOwners = 250;\n    // index on the list of owners to allow reverse lookup\n    mapping(uint => uint) m_ownerIndex;\n    // the ongoing operations.\n    mapping(bytes32 => PendingState) m_pending;\n    bytes32[] m_pendingIndex;\n}\n\n// inheritable ""property"" contract that enables methods to be protected by placing a linear limit (specifiable)\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\n// uses is specified in the modifier.\ncontract daylimit is multiowned {\n\n    // MODIFIERS\n\n    // simple modifier for daily limit.\n    modifier limitedDaily(uint _value) {\n        if (underLimit(_value))\n            _\n    }\n\n    // METHODS\n\n    // constructor - stores initial daily limit and records the present day's index.\n    function daylimit(uint _limit) {\n        m_dailyLimit = _limit;\n        m_lastDay = today();\n    }\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data, block.number)) external {\n        m_dailyLimit = _newLimit;\n    }\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n    function resetSpentToday() onlymanyowners(sha3(msg.data, block.number)) external {\n        m_spentToday = 0;\n    }\n    \n    // INTERNAL METHODS\n    \n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n    // returns true. otherwise just returns false.\n    function underLimit(uint _value) internal onlyowner returns (bool) {\n        // reset the spend limit if we're on a different day to last time.\n        if (today() > m_lastDay) {\n            m_spentToday = 0;\n            m_lastDay = today();\n        }\n        // check to see if there's enough left - if so, subtract and return true.\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n            m_spentToday += _value;\n            return true;\n        }\n        return false;\n    }\n    // determines today's index.\n    function today() private constant returns (uint) { return now / 1 days; }\n\n    // FIELDS\n\n    uint public m_dailyLimit;\n    uint public m_spentToday;\n    uint public m_lastDay;\n}\n\n// interface contract for multisig proxy contracts; see below for docs.\ncontract multisig {\n\n    // EVENTS\n\n    // logged events:\n    // Funds has arrived into the wallet (record how much).\n    event Deposit(address from, uint value);\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n    event SingleTransact(address owner, uint value, address to, bytes data);\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\n    // Confirmation still needed for a transaction.\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n    \n    // FUNCTIONS\n    \n    // TODO: document\n    function changeOwner(address _from, address _to) external;\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\n    function confirm(bytes32 _h) returns (bool);\n}\n\n// usage:\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\n// Wallet(w).from(anotherOwner).confirm(h);\ncontract Wallet is multisig, multiowned, daylimit {\n\n    uint public version = 2;\n\n    // TYPES\n\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n    }\n\n    // METHODS\n\n    // constructor - just pass on the owner array to the multiowned and\n    // the limit to daylimit\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\n            multiowned(_owners, _required) daylimit(_daylimit) {\n    }\n    \n    // kills the contract sending everything to `_to`.\n    function kill(address _to) onlymanyowners(sha3(msg.data, block.number)) external {\n        suicide(_to);\n    }\n    \n    // gets called when no other function matches\n    function() {\n        // just being sent some cash?\n        if (msg.value > 0)\n            Deposit(tx.origin, msg.value);\n    }\n    \n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n    // and _data arguments). They still get the option of using them if they want, anyways.\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\n        // first, take the opportunity to check that we're under the daily limit.\n        if (underLimit(_value)) {\n            SingleTransact(tx.origin, _value, _to, _data);\n            // yes - just execute the call.\n            _to.call.value(_value)(_data);\n            return 0;\n        }\n        // determine our operation hash.\n        _r = sha3(msg.data, block.number);\n        if (!confirm(_r) && m_txs[_r].to == 0) {\n            m_txs[_r].to = _to;\n            m_txs[_r].value = _value;\n            m_txs[_r].data = _data;\n            ConfirmationNeeded(_r, tx.origin, _value, _to, _data);\n        }\n    }\n    \n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n    // to determine the body of the transaction from the hash provided.\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\n        if (m_txs[_h].to != 0) {\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\n            MultiTransact(tx.origin, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\n            delete m_txs[_h];\n            return true;\n        }\n    }\n    \n    // INTERNAL METHODS\n    \n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            delete m_txs[m_pendingIndex[i]];\n        super.clearPending();\n    }\n\n    // FIELDS\n\n    // pending transactions we have at present.\n    mapping (bytes32 => Transaction) m_txs;\n}",1,
162137,0xffeebcadc81e764be170b4852430106e11f66ec7,FALSE,FALSE,contract SimpleStorage {\n    uint storedData;\n    function set(uint x) {\n        storedData = x;\n    }\n    function get() constant returns (uint retVal) {\n        return storedData;\n    }\n},1,
187503,0xc2f63d90a30c451514863c58b92f923070cea723,FALSE,FALSE,contract mortal {\n    /* Define variable owner of the type address*/\n    address owner;\n\n    /* this function is executed at initialization and sets the owner of the contract */\n    function mortal() { owner = msg.sender; }\n\n    /* Function to recover the funds on the contract */\n    function kill() { if (msg.sender == owner) suicide(owner); }\n},1,
343225,0x0a351d0fa69c64628cf803c26e3822a47f290e9f,FALSE,FALSE,"contract DateTime {\n        /*\n         *  Date and Time utilities for ethereum contracts\n         *\n         *  address: 0x1a6184cd4c5bea62b0116de7962ee7315b7bcbce\n         */\n        struct DateTime {\n                uint16 year;\n                uint8 month;\n                uint8 day;\n                uint8 hour;\n                uint8 minute;\n                uint8 second;\n                uint8 weekday;\n        }\n\n        uint constant DAY_IN_SECONDS = 86400;\n        uint constant YEAR_IN_SECONDS = 31536000;\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\n\n        uint constant HOUR_IN_SECONDS = 3600;\n        uint constant MINUTE_IN_SECONDS = 60;\n\n        uint16 constant ORIGIN_YEAR = 1970;\n\n        function isLeapYear(uint16 year) constant returns (bool) {\n                if (year % 4 != 0) {\n                        return false;\n                }\n                if (year % 100 != 0) {\n                        return true;\n                }\n                if (year % 400 != 0) {\n                        return false;\n                }\n                return true;\n        }\n\n        function parseTimestamp(uint timestamp) internal returns (DateTime dt) {\n                uint secondsAccountedFor = 0;\n                uint buf;\n                uint8 i;\n\n                dt.year = ORIGIN_YEAR;\n\n                // Year\n                while (true) {\n                        if (isLeapYear(dt.year)) {\n                                buf = LEAP_YEAR_IN_SECONDS;\n                        }\n                        else {\n                                buf = YEAR_IN_SECONDS;\n                        }\n\n                        if (secondsAccountedFor + buf > timestamp) {\n                                break;\n                        }\n                        dt.year += 1;\n                        secondsAccountedFor += buf;\n                }\n\n                // Month\n                uint8[12] monthDayCounts;\n                monthDayCounts[0] = 31;\n                if (isLeapYear(dt.year)) {\n                        monthDayCounts[1] = 29;\n                }\n                else {\n                        monthDayCounts[1] = 28;\n                }\n                monthDayCounts[2] = 31;\n                monthDayCounts[3] = 30;\n                monthDayCounts[4] = 31;\n                monthDayCounts[5] = 30;\n                monthDayCounts[6] = 31;\n                monthDayCounts[7] = 31;\n                monthDayCounts[8] = 30;\n                monthDayCounts[9] = 31;\n                monthDayCounts[10] = 30;\n                monthDayCounts[11] = 31;\n\n                uint secondsInMonth;\n                for (i = 0; i < monthDayCounts.length; i++) {\n                        secondsInMonth = DAY_IN_SECONDS * monthDayCounts[i];\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\n                                dt.month = i + 1;\n                                break;\n                        }\n                        secondsAccountedFor += secondsInMonth;\n                }\n\n                // Day\n                for (i = 0; i < monthDayCounts[dt.month - 1]; i++) {\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\n                                dt.day = i + 1;\n                                break;\n                        }\n                        secondsAccountedFor += DAY_IN_SECONDS;\n                }\n\n                // Hour\n                for (i = 0; i < 24; i++) {\n                        if (HOUR_IN_SECONDS + secondsAccountedFor > timestamp) {\n                                dt.hour = i;\n                                break;\n                        }\n                        secondsAccountedFor += HOUR_IN_SECONDS;\n                }\n\n                // Minute\n                for (i = 0; i < 60; i++) {\n                        if (MINUTE_IN_SECONDS + secondsAccountedFor > timestamp) {\n                                dt.minute = i;\n                                break;\n                        }\n                        secondsAccountedFor += MINUTE_IN_SECONDS;\n                }\n\n                if (timestamp - secondsAccountedFor > 60) {\n                        __throw();\n                }\n\n                // Second\n                dt.second = uint8(timestamp - secondsAccountedFor);\n\n                // Day of week.\n                buf = timestamp / DAY_IN_SECONDS;\n                dt.weekday = uint8((buf + 3) % 7);\n        }\n\n        function getYear(uint timestamp) constant returns (uint16) {\n                return parseTimestamp(timestamp).year;\n        }\n\n        function getMonth(uint timestamp) constant returns (uint16) {\n                return parseTimestamp(timestamp).month;\n        }\n\n        function getDay(uint timestamp) constant returns (uint16) {\n                return parseTimestamp(timestamp).day;\n        }\n\n        function getHour(uint timestamp) constant returns (uint16) {\n                return parseTimestamp(timestamp).hour;\n        }\n\n        function getMinute(uint timestamp) constant returns (uint16) {\n                return parseTimestamp(timestamp).minute;\n        }\n\n        function getSecond(uint timestamp) constant returns (uint16) {\n                return parseTimestamp(timestamp).second;\n        }\n\n        function getWeekday(uint timestamp) constant returns (uint8) {\n                return parseTimestamp(timestamp).weekday;\n        }\n\n        function toTimestamp(uint16 year, uint8 month, uint8 day) constant returns (uint timestamp) {\n                return toTimestamp(year, month, day, 0, 0, 0);\n        }\n\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) constant returns (uint timestamp) {\n                return toTimestamp(year, month, day, hour, 0, 0);\n        }\n\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) constant returns (uint timestamp) {\n                return toTimestamp(year, month, day, hour, minute, 0);\n        }\n\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) constant returns (uint timestamp) {\n                uint16 i;\n\n                // Year\n                for (i = ORIGIN_YEAR; i < year; i++) {\n                        if (isLeapYear(i)) {\n                                timestamp += LEAP_YEAR_IN_SECONDS;\n                        }\n                        else {\n                                timestamp += YEAR_IN_SECONDS;\n                        }\n                }\n\n                // Month\n                uint8[12] monthDayCounts;\n                monthDayCounts[0] = 31;\n                if (isLeapYear(year)) {\n                        monthDayCounts[1] = 29;\n                }\n                else {\n                        monthDayCounts[1] = 28;\n                }\n                monthDayCounts[2] = 31;\n                monthDayCounts[3] = 30;\n                monthDayCounts[4] = 31;\n                monthDayCounts[5] = 30;\n                monthDayCounts[6] = 31;\n                monthDayCounts[7] = 31;\n                monthDayCounts[8] = 30;\n                monthDayCounts[9] = 31;\n                monthDayCounts[10] = 30;\n                monthDayCounts[11] = 31;\n\n                for (i = 1; i < month; i++) {\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\n                }\n\n                // Day\n                timestamp += DAY_IN_SECONDS * (day - 1);\n\n                // Hour\n                timestamp += HOUR_IN_SECONDS * (hour);\n\n                // Minute\n                timestamp += MINUTE_IN_SECONDS * (minute);\n\n                // Second\n                timestamp += second;\n\n                return timestamp;\n        }\n\n        function __throw() {\n                uint[] arst;\n                arst[1];\n        }\n}",1,
359563,0xd07ce4329b27eb8896c51458468d98a0e4c0394c,FALSE,FALSE,"// Grove v0.2\n\n\n/// @title GroveLib - Library for queriable indexed ordered data.\n/// @author PiperMerriam - <pipermerriam@gmail.com>\nlibrary GroveLib {\n        /*\n         *  Indexes for ordered data\n         *\n         *  Address: 0xd07ce4329b27eb8896c51458468d98a0e4c0394c\n         */\n        struct Index {\n                bytes32 id;\n                bytes32 name;\n                bytes32 root;\n                mapping (bytes32 => Node) nodes;\n        }\n\n        struct Node {\n                bytes32 nodeId;\n                bytes32 indexId;\n                bytes32 id;\n                int value;\n                bytes32 parent;\n                bytes32 left;\n                bytes32 right;\n                uint height;\n        }\n\n        /// @dev This is merely a shortcut for `sha3(owner, indexName)`\n        /// @param owner The address of the owner of this index.\n        /// @param indexName The human readable name for this index.\n        function computeIndexId(address owner, bytes32 indexName) constant returns (bytes32) {\n                return sha3(owner, indexName);\n        }\n\n        /// @dev This is merely a shortcut for `sha3(indexId, id)`\n        /// @param indexId The id for the index the node belongs to.\n        /// @param id The unique identifier for the data this node represents.\n        function computeNodeId(bytes32 indexId, bytes32 id) constant returns (bytes32) {\n                return sha3(indexId, id);\n        }\n\n        function max(uint a, uint b) internal returns (uint) {\n            if (a >= b) {\n                return a;\n            }\n            return b;\n        }\n\n        /*\n         *  Node getters\n         */\n        /// @dev Retrieve the unique identifier for the node.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getNodeId(Index storage index, bytes32 nodeId) constant returns (bytes32) {\n            return index.nodes[nodeId].id;\n        }\n\n        /// @dev Retrieve the index id for the node.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getNodeIndexId(Index storage index, bytes32 nodeId) constant returns (bytes32) {\n            return index.nodes[nodeId].indexId;\n        }\n\n        /// @dev Retrieve the value for the node.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getNodeValue(Index storage index, bytes32 nodeId) constant returns (int) {\n            return index.nodes[nodeId].value;\n        }\n\n        /// @dev Retrieve the height of the node.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getNodeHeight(Index storage index, bytes32 nodeId) constant returns (uint) {\n            return index.nodes[nodeId].height;\n        }\n\n        /// @dev Retrieve the parent id of the node.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getNodeParent(Index storage index, bytes32 nodeId) constant returns (bytes32) {\n            return index.nodes[nodeId].parent;\n        }\n\n        /// @dev Retrieve the left child id of the node.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getNodeLeftChild(Index storage index, bytes32 nodeId) constant returns (bytes32) {\n            return index.nodes[nodeId].left;\n        }\n\n        /// @dev Retrieve the right child id of the node.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getNodeRightChild(Index storage index, bytes32 nodeId) constant returns (bytes32) {\n            return index.nodes[nodeId].right;\n        }\n\n        /// @dev Retrieve the node id of the next node in the tree.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getPreviousNode(Index storage index, bytes32 nodeId) constant returns (bytes32) {\n            Node storage currentNode = index.nodes[nodeId];\n\n            if (currentNode.nodeId == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node memory child;\n\n            if (currentNode.left != 0x0) {\n                // Trace left to latest child in left tree.\n                child = index.nodes[currentNode.left];\n\n                while (child.right != 0) {\n                    child = index.nodes[child.right];\n                }\n                return child.nodeId;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // Now we trace back up through parent relationships, looking\n                // for a link where the child is the right child of it's\n                // parent.\n                Node storage parent = index.nodes[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.right == child.nodeId) {\n                        return parent.nodeId;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = index.nodes[parent.parent];\n                }\n            }\n\n            // This is the first node, and has no previous node.\n            return 0x0;\n        }\n\n        /// @dev Retrieve the node id of the previous node in the tree.\n        /// @param index The index that the node is part of.\n        /// @param nodeId The id for the node to be looked up.\n        function getNextNode(Index storage index, bytes32 nodeId) constant returns (bytes32) {\n            Node storage currentNode = index.nodes[nodeId];\n\n            if (currentNode.nodeId == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node memory child;\n\n            if (currentNode.right != 0x0) {\n                // Trace right to earliest child in right tree.\n                child = index.nodes[currentNode.right];\n\n                while (child.left != 0) {\n                    child = index.nodes[child.left];\n                }\n                return child.nodeId;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // if the node is the left child of it's parent, then the\n                // parent is the next one.\n                Node storage parent = index.nodes[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.left == child.nodeId) {\n                        return parent.nodeId;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = index.nodes[parent.parent];\n                }\n\n                // Now we need to trace all the way up checking to see if any parent is the \n            }\n\n            // This is the final node.\n            return 0x0;\n        }\n\n\n        /// @dev Updates or Inserts the id into the index at its appropriate location based on the value provided.\n        /// @param index The index that the node is part of.\n        /// @param id The unique identifier of the data element the index node will represent.\n        /// @param value The value of the data element that represents it's total ordering with respect to other elementes.\n        function insert(Index storage index, bytes32 id, int value) public {\n                bytes32 nodeId = computeNodeId(index.id, id);\n\n                if (index.nodes[nodeId].nodeId == nodeId) {\n                    // A node with this id already exists.  If the value is\n                    // the same, then just return early, otherwise, remove it\n                    // and reinsert it.\n                    if (index.nodes[nodeId].value == value) {\n                        return;\n                    }\n                    remove(index, id);\n                }\n\n                uint leftHeight;\n                uint rightHeight;\n\n                bytes32 previousNodeId = 0x0;\n\n                bytes32 rootNodeId = index.root;\n\n                if (rootNodeId == 0x0) {\n                    rootNodeId = nodeId;\n                    index.root = nodeId;\n                }\n                Node storage currentNode = index.nodes[rootNodeId];\n\n                // Do insertion\n                while (true) {\n                    if (currentNode.indexId == 0x0) {\n                        // This is a new unpopulated node.\n                        currentNode.nodeId = nodeId;\n                        currentNode.parent = previousNodeId;\n                        currentNode.indexId = index.id;\n                        currentNode.id = id;\n                        currentNode.value = value;\n                        break;\n                    }\n\n                    // Set the previous node id.\n                    previousNodeId = currentNode.nodeId;\n\n                    // The new node belongs in the right subtree\n                    if (value >= currentNode.value) {\n                        if (currentNode.right == 0x0) {\n                            currentNode.right = nodeId;\n                        }\n                        currentNode = index.nodes[currentNode.right];\n                        continue;\n                    }\n\n                    // The new node belongs in the left subtree.\n                    if (currentNode.left == 0x0) {\n                        currentNode.left = nodeId;\n                    }\n                    currentNode = index.nodes[currentNode.left];\n                }\n\n                // Rebalance the tree\n                _rebalanceTree(index, currentNode.nodeId);\n        }\n\n        /// @dev Checks whether a node for the given unique identifier exists within the given index.\n        /// @param index The index that should be searched\n        /// @param id The unique identifier of the data element to check for.\n        function exists(Index storage index, bytes32 id) constant returns (bool) {\n            bytes32 nodeId = computeNodeId(index.id, id);\n            return (index.nodes[nodeId].nodeId == nodeId);\n        }\n\n        /// @dev Remove the node for the given unique identifier from the index.\n        /// @param index The index that should be removed\n        /// @param id The unique identifier of the data element to remove.\n        function remove(Index storage index, bytes32 id) public {\n            bytes32 nodeId = computeNodeId(index.id, id);\n            \n            Node storage replacementNode;\n            Node storage parent;\n            Node storage child;\n            bytes32 rebalanceOrigin;\n\n            Node storage nodeToDelete = index.nodes[nodeId];\n\n            if (nodeToDelete.id != id) {\n                // The id does not exist in the tree.\n                return;\n            }\n\n            if (nodeToDelete.left != 0x0 || nodeToDelete.right != 0x0) {\n                // This node is not a leaf node and thus must replace itself in\n                // it's tree by either the previous or next node.\n                if (nodeToDelete.left != 0x0) {\n                    // This node is guaranteed to not have a right child.\n                    replacementNode = index.nodes[getPreviousNode(index, nodeToDelete.nodeId)];\n                }\n                else {\n                    // This node is guaranteed to not have a left child.\n                    replacementNode = index.nodes[getNextNode(index, nodeToDelete.nodeId)];\n                }\n                // The replacementNode is guaranteed to have a parent.\n                parent = index.nodes[replacementNode.parent];\n\n                // Keep note of the location that our tree rebalancing should\n                // start at.\n                rebalanceOrigin = replacementNode.nodeId;\n\n                // Join the parent of the replacement node with any subtree of\n                // the replacement node.  We can guarantee that the replacement\n                // node has at most one subtree because of how getNextNode and\n                // getPreviousNode are used.\n                if (parent.left == replacementNode.nodeId) {\n                    parent.left = replacementNode.right;\n                    if (replacementNode.right != 0x0) {\n                        child = index.nodes[replacementNode.right];\n                        child.parent = parent.nodeId;\n                    }\n                }\n                if (parent.right == replacementNode.nodeId) {\n                    parent.right = replacementNode.left;\n                    if (replacementNode.left != 0x0) {\n                        child = index.nodes[replacementNode.left];\n                        child.parent = parent.nodeId;\n                    }\n                }\n\n                // Now we replace the nodeToDelete with the replacementNode.\n                // This includes parent/child relationships for all of the\n                // parent, the left child, and the right child.\n                replacementNode.parent = nodeToDelete.parent;\n                if (nodeToDelete.parent != 0x0) {\n                    parent = index.nodes[nodeToDelete.parent];\n                    if (parent.left == nodeToDelete.nodeId) {\n                        parent.left = replacementNode.nodeId;\n                    }\n                    if (parent.right == nodeToDelete.nodeId) {\n                        parent.right = replacementNode.nodeId;\n                    }\n                }\n                else {\n                    // If the node we are deleting is the root node so update\n                    // the indexId to root node mapping.\n                    index.root = replacementNode.nodeId;\n                }\n\n                replacementNode.left = nodeToDelete.left;\n                if (nodeToDelete.left != 0x0) {\n                    child = index.nodes[nodeToDelete.left];\n                    child.parent = replacementNode.nodeId;\n                }\n\n                replacementNode.right = nodeToDelete.right;\n                if (nodeToDelete.right != 0x0) {\n                    child = index.nodes[nodeToDelete.right];\n                    child.parent = replacementNode.nodeId;\n                }\n            }\n            else if (nodeToDelete.parent != 0x0) {\n                // The node being deleted is a leaf node so we only erase it's\n                // parent linkage.\n                parent = index.nodes[nodeToDelete.parent];\n\n                if (parent.left == nodeToDelete.nodeId) {\n                    parent.left = 0x0;\n                }\n                if (parent.right == nodeToDelete.nodeId) {\n                    parent.right = 0x0;\n                }\n\n                // keep note of where the rebalancing should begin.\n                rebalanceOrigin = parent.nodeId;\n            }\n            else {\n                // This is both a leaf node and the root node, so we need to\n                // unset the root node pointer.\n                index.root = 0x0;\n            }\n\n            // Now we zero out all of the fields on the nodeToDelete.\n            nodeToDelete.id = 0x0;\n            nodeToDelete.nodeId = 0x0;\n            nodeToDelete.indexId = 0x0;\n            nodeToDelete.value = 0;\n            nodeToDelete.parent = 0x0;\n            nodeToDelete.left = 0x0;\n            nodeToDelete.right = 0x0;\n\n            // Walk back up the tree rebalancing\n            if (rebalanceOrigin != 0x0) {\n                _rebalanceTree(index, rebalanceOrigin);\n            }\n        }\n\n        bytes2 constant GT = "">"";\n        bytes2 constant LT = ""<"";\n        bytes2 constant GTE = "">="";\n        bytes2 constant LTE = ""<="";\n        bytes2 constant EQ = ""=="";\n\n        function _compare(int left, bytes2 operator, int right) internal returns (bool) {\n            if (operator == GT) {\n                return (left > right);\n            }\n            if (operator == LT) {\n                return (left < right);\n            }\n            if (operator == GTE) {\n                return (left >= right);\n            }\n            if (operator == LTE) {\n                return (left <= right);\n            }\n            if (operator == EQ) {\n                return (left == right);\n            }\n\n            // Invalid operator.\n            throw;\n        }\n\n        function _getMaximum(Index storage index, bytes32 nodeId) internal returns (int) {\n                Node storage currentNode = index.nodes[nodeId];\n\n                while (true) {\n                    if (currentNode.right == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = index.nodes[currentNode.right];\n                }\n        }\n\n        function _getMinimum(Index storage index, bytes32 nodeId) internal returns (int) {\n                Node storage currentNode = index.nodes[nodeId];\n\n                while (true) {\n                    if (currentNode.left == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = index.nodes[currentNode.left];\n                }\n        }\n\n\n        /** @dev Query the index for the edge-most node that satisfies the\n         *  given query.  For >, >=, and ==, this will be the left-most node\n         *  that satisfies the comparison.  For < and <= this will be the\n         *  right-most node that satisfies the comparison.\n         */\n        /// @param index The index that should be queried\n        /** @param operator One of '>', '>=', '<', '<=', '==' to specify what\n         *  type of comparison operator should be used.\n         */\n        function query(Index storage index, bytes2 operator, int value) public returns (bytes32) {\n                bytes32 rootNodeId = index.root;\n                \n                if (rootNodeId == 0x0) {\n                    // Empty tree.\n                    return 0x0;\n                }\n\n                Node storage currentNode = index.nodes[rootNodeId];\n\n                while (true) {\n                    if (_compare(currentNode.value, operator, value)) {\n                        // We have found a match but it might not be the\n                        // *correct* match.\n                        if ((operator == LT) || (operator == LTE)) {\n                            // Need to keep traversing right until this is no\n                            // longer true.\n                            if (currentNode.right == 0x0) {\n                                return currentNode.nodeId;\n                            }\n                            if (_compare(_getMinimum(index, currentNode.right), operator, value)) {\n                                // There are still nodes to the right that\n                                // match.\n                                currentNode = index.nodes[currentNode.right];\n                                continue;\n                            }\n                            return currentNode.nodeId;\n                        }\n\n                        if ((operator == GT) || (operator == GTE) || (operator == EQ)) {\n                            // Need to keep traversing left until this is no\n                            // longer true.\n                            if (currentNode.left == 0x0) {\n                                return currentNode.nodeId;\n                            }\n                            if (_compare(_getMaximum(index, currentNode.left), operator, value)) {\n                                currentNode = index.nodes[currentNode.left];\n                                continue;\n                            }\n                            return currentNode.nodeId;\n                        }\n                    }\n\n                    if ((operator == LT) || (operator == LTE)) {\n                        if (currentNode.left == 0x0) {\n                            // There are no nodes that are less than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = index.nodes[currentNode.left];\n                        continue;\n                    }\n\n                    if ((operator == GT) || (operator == GTE)) {\n                        if (currentNode.right == 0x0) {\n                            // There are no nodes that are greater than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = index.nodes[currentNode.right];\n                        continue;\n                    }\n\n                    if (operator == EQ) {\n                        if (currentNode.value < value) {\n                            if (currentNode.right == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = index.nodes[currentNode.right];\n                            continue;\n                        }\n\n                        if (currentNode.value > value) {\n                            if (currentNode.left == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = index.nodes[currentNode.left];\n                            continue;\n                        }\n                    }\n                }\n        }\n\n        function _rebalanceTree(Index storage index, bytes32 nodeId) internal {\n            // Trace back up rebalancing the tree and updating heights as\n            // needed..\n            Node storage currentNode = index.nodes[nodeId];\n\n            while (true) {\n                int balanceFactor = _getBalanceFactor(index, currentNode.nodeId);\n\n                if (balanceFactor == 2) {\n                    // Right rotation (tree is heavy on the left)\n                    if (_getBalanceFactor(index, currentNode.left) == -1) {\n                        // The subtree is leaning right so it need to be\n                        // rotated left before the current node is rotated\n                        // right.\n                        _rotateLeft(index, currentNode.left);\n                    }\n                    _rotateRight(index, currentNode.nodeId);\n                }\n\n                if (balanceFactor == -2) {\n                    // Left rotation (tree is heavy on the right)\n                    if (_getBalanceFactor(index, currentNode.right) == 1) {\n                        // The subtree is leaning left so it need to be\n                        // rotated right before the current node is rotated\n                        // left.\n                        _rotateRight(index, currentNode.right);\n                    }\n                    _rotateLeft(index, currentNode.nodeId);\n                }\n\n                if ((-1 <= balanceFactor) && (balanceFactor <= 1)) {\n                    _updateNodeHeight(index, currentNode.nodeId);\n                }\n\n                if (currentNode.parent == 0x0) {\n                    // Reached the root which may be new due to tree\n                    // rotation, so set it as the root and then break.\n                    break;\n                }\n\n                currentNode = index.nodes[currentNode.parent];\n            }\n        }\n\n        function _getBalanceFactor(Index storage index, bytes32 nodeId) internal returns (int) {\n                Node storage node = index.nodes[nodeId];\n\n                return int(index.nodes[node.left].height) - int(index.nodes[node.right].height);\n        }\n\n        function _updateNodeHeight(Index storage index, bytes32 nodeId) internal {\n                Node storage node = index.nodes[nodeId];\n\n                node.height = max(index.nodes[node.left].height, index.nodes[node.right].height) + 1;\n        }\n\n        function _rotateLeft(Index storage index, bytes32 nodeId) internal {\n            Node storage originalRoot = index.nodes[nodeId];\n\n            if (originalRoot.right == 0x0) {\n                // Cannot rotate left if there is no right originalRoot to rotate into\n                // place.\n                throw;\n            }\n\n            // The right child is the new root, so it gets the original\n            // `originalRoot.parent` as it's parent.\n            Node storage newRoot = index.nodes[originalRoot.right];\n            newRoot.parent = originalRoot.parent;\n\n            // The original root needs to have it's right child nulled out.\n            originalRoot.right = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If there is a parent node, it needs to now point downward at\n                // the newRoot which is rotating into the place where `node` was.\n                Node storage parent = index.nodes[originalRoot.parent];\n\n                // figure out if we're a left or right child and have the\n                // parent point to the new node.\n                if (parent.left == originalRoot.nodeId) {\n                    parent.left = newRoot.nodeId;\n                }\n                if (parent.right == originalRoot.nodeId) {\n                    parent.right = newRoot.nodeId;\n                }\n            }\n\n\n            if (newRoot.left != 0) {\n                // If the new root had a left child, that moves to be the\n                // new right child of the original root node\n                Node storage leftChild = index.nodes[newRoot.left];\n                originalRoot.right = leftChild.nodeId;\n                leftChild.parent = originalRoot.nodeId;\n            }\n\n            // Update the newRoot's left node to point at the original node.\n            originalRoot.parent = newRoot.nodeId;\n            newRoot.left = originalRoot.nodeId;\n\n            if (newRoot.parent == 0x0) {\n                index.root = newRoot.nodeId;\n            }\n\n            // TODO: are both of these updates necessary?\n            _updateNodeHeight(index, originalRoot.nodeId);\n            _updateNodeHeight(index, newRoot.nodeId);\n        }\n\n        function _rotateRight(Index storage index, bytes32 nodeId) internal {\n            Node storage originalRoot = index.nodes[nodeId];\n\n            if (originalRoot.left == 0x0) {\n                // Cannot rotate right if there is no left node to rotate into\n                // place.\n                throw;\n            }\n\n            // The left child is taking the place of node, so we update it's\n            // parent to be the original parent of the node.\n            Node storage newRoot = index.nodes[originalRoot.left];\n            newRoot.parent = originalRoot.parent;\n\n            // Null out the originalRoot.left\n            originalRoot.left = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If the node has a parent, update the correct child to point\n                // at the newRoot now.\n                Node storage parent = index.nodes[originalRoot.parent];\n\n                if (parent.left == originalRoot.nodeId) {\n                    parent.left = newRoot.nodeId;\n                }\n                if (parent.right == originalRoot.nodeId) {\n                    parent.right = newRoot.nodeId;\n                }\n            }\n\n            if (newRoot.right != 0x0) {\n                Node storage rightChild = index.nodes[newRoot.right];\n                originalRoot.left = newRoot.right;\n                rightChild.parent = originalRoot.nodeId;\n            }\n\n            // Update the new root's right node to point to the original node.\n            originalRoot.parent = newRoot.nodeId;\n            newRoot.right = originalRoot.nodeId;\n\n            if (newRoot.parent == 0x0) {\n                index.root = newRoot.nodeId;\n            }\n\n            // Recompute heights.\n            _updateNodeHeight(index, originalRoot.nodeId);\n            _updateNodeHeight(index, newRoot.nodeId);\n        }\n}\n\n\n/// @title Grove - queryable indexes for ordered data.\n/// @author Piper Merriam <pipermerriam@gmail.com>\ncontract Grove {\n        /*\n         *  Indexes for ordered data\n         *\n         *  Address: 0x8017f24a47c889b1ee80501ff84beb3c017edf0b\n         */\n        // Map index_id to index\n        mapping (bytes32 => GroveLib.Index) index_lookup;\n\n        // Map node_id to index_id.\n        mapping (bytes32 => bytes32) node_to_index;\n\n        /// @notice Computes the id for a Grove index which is sha3(owner, indexName)\n        /// @param owner The address of the index owner.\n        /// @param indexName The name of the index.\n        function computeIndexId(address owner, bytes32 indexName) constant returns (bytes32) {\n                return GroveLib.computeIndexId(owner, indexName);\n        }\n\n        /// @notice Computes the id for a node in a given Grove index which is sha3(indexId, id)\n        /// @param indexId The id for the index the node belongs to.\n        /// @param id The unique identifier for the data this node represents.\n        function computeNodeId(bytes32 indexId, bytes32 id) constant returns (bytes32) {\n                return GroveLib.computeNodeId(indexId, id);\n        }\n\n        /*\n         *  Node getters\n         */\n        /// @notice Retrieves the name of an index.\n        /// @param indexId The id of the index.\n        function getIndexName(bytes32 indexId) constant returns (bytes32) {\n            return index_lookup[indexId].name;\n        }\n\n        /// @notice Retrieves the id of the root node for this index.\n        /// @param indexId The id of the index.\n        function getIndexRoot(bytes32 indexId) constant returns (bytes32) {\n            return index_lookup[indexId].root;\n        }\n\n\n        /// @dev Retrieve the unique identifier this node represents.\n        /// @param nodeId The id for the node\n        function getNodeId(bytes32 nodeId) constant returns (bytes32) {\n            return GroveLib.getNodeId(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /// @dev Retrieve the index id for the node.\n        /// @param nodeId The id for the node\n        function getNodeIndexId(bytes32 nodeId) constant returns (bytes32) {\n            return GroveLib.getNodeIndexId(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /// @dev Retrieve the value of the node.\n        /// @param nodeId The id for the node\n        function getNodeValue(bytes32 nodeId) constant returns (int) {\n            return GroveLib.getNodeValue(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /// @dev Retrieve the height of the node.\n        /// @param nodeId The id for the node\n        function getNodeHeight(bytes32 nodeId) constant returns (uint) {\n            return GroveLib.getNodeHeight(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /// @dev Retrieve the parent id of the node.\n        /// @param nodeId The id for the node\n        function getNodeParent(bytes32 nodeId) constant returns (bytes32) {\n            return GroveLib.getNodeParent(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /// @dev Retrieve the left child id of the node.\n        /// @param nodeId The id for the node\n        function getNodeLeftChild(bytes32 nodeId) constant returns (bytes32) {\n            return GroveLib.getNodeLeftChild(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /// @dev Retrieve the right child id of the node.\n        /// @param nodeId The id for the node\n        function getNodeRightChild(bytes32 nodeId) constant returns (bytes32) {\n            return GroveLib.getNodeRightChild(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /** @dev Retrieve the id of the node that comes immediately before this\n         *  one.  Returns 0x0 if there is no previous node.\n         */\n        /// @param nodeId The id for the node\n        function getPreviousNode(bytes32 nodeId) constant returns (bytes32) {\n            return GroveLib.getPreviousNode(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /** @dev Retrieve the id of the node that comes immediately after this\n         *  one.  Returns 0x0 if there is no previous node.\n         */\n        /// @param nodeId The id for the node\n        function getNextNode(bytes32 nodeId) constant returns (bytes32) {\n            return GroveLib.getNextNode(index_lookup[node_to_index[nodeId]], nodeId);\n        }\n\n        /** @dev Update or Insert a data element represented by the unique\n         *  identifier `id` into the index.\n         */\n        /// @param indexName The human readable name for the index that the node should be upserted into.\n        /// @param id The unique identifier that the index node represents.\n        /// @param value The number which represents this data elements total ordering.\n        function insert(bytes32 indexName, bytes32 id, int value) public {\n                bytes32 indexId = computeIndexId(msg.sender, indexName);\n                var index = index_lookup[indexId];\n\n                if (index.name != indexName) {\n                        // If this is a new index, store it's name and id\n                        index.name = indexName;\n                        index.id = indexId;\n                }\n\n                // Store the mapping from nodeId to the indexId\n                node_to_index[computeNodeId(indexId, id)] = indexId;\n\n                GroveLib.insert(index, id, value);\n        }\n\n        /// @dev Query whether a node exists within the specified index for the unique identifier.\n        /// @param indexId The id for the index.\n        /// @param id The unique identifier of the data element.\n        function exists(bytes32 indexId, bytes32 id) constant returns (bool) {\n            return GroveLib.exists(index_lookup[indexId], id);\n        }\n\n        /// @dev Remove the index node for the given unique identifier.\n        /// @param indexName The name of the index.\n        /// @param id The unique identifier of the data element.\n        function remove(bytes32 indexName, bytes32 id) public {\n            GroveLib.remove(index_lookup[computeIndexId(msg.sender, indexName)], id);\n        }\n\n        /** @dev Query the index for the edge-most node that satisfies the\n         * given query.  For >, >=, and ==, this will be the left-most node\n         * that satisfies the comparison.  For < and <= this will be the\n         * right-most node that satisfies the comparison.\n         */\n        /// @param indexId The id of the index that should be queried\n        /** @param operator One of '>', '>=', '<', '<=', '==' to specify what\n         *  type of comparison operator should be used.\n         */\n        function query(bytes32 indexId, bytes2 operator, int value) public returns (bytes32) {\n                return GroveLib.query(index_lookup[indexId], operator, value);\n        }\n}",1,
398516,0x782bdf7015b71b64f6750796dd087fde32fd6fdc,FALSE,FALSE,"/*\n\nBlockDefinitionStorage deployed and used for Etherias v0.9 and v1.0\n\nSolidity version: 0.1.6-d41f8b7c/.-Emscripten/clang/int linked to libethereum-\ncompile once with default optimization\n\nvar bdsAddress = 0x782bdf7015b71b64f6750796dd087fde32fd6fdc\nvar bdsAbi = [\n	{""constant"":true,""inputs"":[{""name"":""which"",""type"":""uint8""}],""name"":""getAttachesto"",""outputs"":[{""name"":"""",""type"":""int8[48]""}],""type"":""function""},\n	{""constant"":false,""inputs"":[],""name"":""setLocked"",""outputs"":[],""type"":""function""},\n	{""constant"":false,""inputs"":[{""name"":""which"",""type"":""uint8""},{""name"":""occupies"",""type"":""int8[3][8]""}],""name"":""initOccupies"",""outputs"":[],""type"":""function""},\n	{""constant"":true,""inputs"":[{""name"":""which"",""type"":""uint8""}],""name"":""getOccupies"",""outputs"":[{""name"":"""",""type"":""int8[24]""}],""type"":""function""},\n	{""constant"":true,""inputs"":[],""name"":""getLocked"",""outputs"":[{""name"":"""",""type"":""bool""}],""type"":""function""},\n	{""constant"":false,""inputs"":[{""name"":""which"",""type"":""uint8""},{""name"":""attachesto"",""type"":""int8[3][16]""}],""name"":""initAttachesto"",""outputs"":[],""type"":""function""}\n];\nvar bds = new web3.eth.Contract(bdsAbi, bdsAddress);\n\n{\n    ""0878bc51"": ""getAttachesto(uint8)"",\n    ""2d49ffcd"": ""getLocked()"",\n    ""1bcf5758"": ""getOccupies(uint8)"",\n    ""d7f3b73b"": ""initAttachesto(uint8,int8[3][16])"",\n    ""1256c698"": ""initOccupies(uint8,int8[3][8])"",\n    ""10c1952f"": ""setLocked()"" // locking tx: 0x460e71431b0ecb00982fa224bcceb60245422008733ef059c509d3b457932a60\n}\n\n*/\n\ncontract BlockDefStorage\n{\n	bool locked;\n	\n    Block[32] blocks;\n    struct Block\n    {\n    	int8[24] occupies; // [x0,y0,z0,x1,y1,z1...,x7,y7,z7] \n    	int8[48] attachesto; // [x0,y0,z0,x1,y1,z1...,x15,y15,z15] // first one that is 0,0,0 is the end\n    }\n    \n    function getOccupies(uint8 which) public constant returns (int8[24])\n    {\n    	return blocks[which].occupies;\n    }\n    \n    function getAttachesto(uint8 which) public constant returns (int8[48])\n    {\n    	return blocks[which].attachesto;\n    }\n    \n    function getLocked() public constant returns (bool)\n    {\n    	return locked;\n    }\n    \n    function setLocked() \n    {\n    	locked = true; // once set, there is no way to undo this, which prevents reinitialization of Occupies and Attachesto\n    }\n    \n    function initOccupies(uint8 which, int8[3][8] occupies) public \n    {\n    	if(locked) // lockout\n    		return;\n    	uint counter = 0;\n    	for(uint8 index = 0; index < 8; index++)\n    	{\n    		for(uint8 subindex = 0; subindex < 3; subindex++)\n        	{\n    			blocks[which].occupies[counter] = occupies[index][subindex];\n    			counter++;\n        	}\n    	}	\n    }\n    \n    function initAttachesto(uint8 which, int8[3][16] attachesto) public\n    {\n    	if(locked) // lockout\n    		return;\n    	uint counter = 0;\n    	for(uint8 index = 0; index <  16; index++)\n    	{\n    		for(uint8 subindex = 0; subindex < 3; subindex++)\n        	{\n    			blocks[which].attachesto[counter] = attachesto[index][subindex];\n    			counter++;\n        	}\n    	}	\n    }\n}",1,
403758,0x68549d7dbb7a956f955ec1263f55494f05972a6b,FALSE,FALSE,"/*\n\nMapElevationStorage deployed and used for Etherias v0.9 through v1.2\n\nSolidity version: 0.1.6-d41f8b7c/.-Emscripten/clang/int linked to libethereum-\ncompile once with default optimization\n\nvar mesAddress = ""0x68549D7Dbb7A956f955Ec1263F55494f05972A6b"";\nvar mesAbi = [\n	{ ""constant"": true, ""inputs"": [], ""name"": ""getElevations"", ""outputs"": [{ ""name"": """", ""type"": ""uint8[1089]"" }], ""type"": ""function"", ""payable"": false, ""stateMutability"": ""view"" },\n	{ ""constant"": false,  ""inputs"": [], ""name"": ""setLocked"", ""outputs"": [], ""type"": ""function"", ""payable"": true, ""stateMutability"": ""payable"" },\n	{ ""constant"": true, ""inputs"": [], ""name"": ""getLocked"", ""outputs"": [{ ""name"": """", ""type"": ""bool"" }], ""type"": ""function"", ""payable"": false, ""stateMutability"": ""view"" },\n	{ ""constant"": true, ""inputs"": [{ ""name"": ""col"", ""type"": ""uint8"" }, { ""name"": ""row"", ""type"": ""uint8"" }], ""name"": ""getElevation"", ""outputs"": [{ ""name"": """", ""type"": ""uint8"" }], ""type"": ""function"", ""payable"": false, ""stateMutability"": ""view"" },\n	{ ""constant"": false, ""inputs"": [{ ""name"": ""col"", ""type"": ""uint8"" }, { ""name"":  ""_elevations"", ""type"": ""uint8[33]"" }], ""name"": ""initElevations"", ""outputs"": [], ""type"": ""function"", ""payable"": true, ""stateMutability"": ""payable"" }, { ""type"": ""fallback"", ""payable"": true, ""stateMutability"": ""payable"" }\n];\nvar mes = new web3.eth.Contract(mesAbi, mesAddress);\n\n{\n	""4166c1fd"": ""getElevation(uint8,uint8)"",\n	""049b7852"": ""getElevations()"",\n	""2d49ffcd"": ""getLocked()"",\n	""57f10d71"": ""initElevations(uint8,uint8[33])"",\n	""10c1952f"": ""setLocked()"" // locking tx: 0xffbac6118d58a286b6e1a5b7d40497e24ca42b95383a1d7783c239ad25aed84e\n}\n\nNOTE: JS helper functions at bottom.\n\n*/\n\n\ncontract MapElevationStorage\n{\n    uint8[1089] elevations; // while this is a [a,b,c,d,a1,b1,c1,d1...] array, it should be thought of as\n    // [[a,b,c,d], [a1,b1,c1,d1]...] where each subarray is a column.\n    // since you'd access the subarray-style 2D array like this: col, row\n    // that means that in the 1D array, the first grouping is the first col. The second grouping is the second col, etc\n    // As such, element 1 is equivalent to 0,1 -- element 2 = 0,2 -- element 33 = 1,0 -- element 34 = 1,1\n    // this is a bit counter intuitive. You might think it would be arranged first row, second row, etc... but you'd be wrong.\n    address creator;\n    function MapElevationStorage()\n    {\n    	creator = msg.sender;\n    }\n    \n    function getElevations() constant returns (uint8[1089])\n    {\n    	return elevations;\n    }\n    \n    function getElevation(uint8 col, uint8 row) constant returns (uint8)\n    {\n    	//uint index = col * 33 + row;\n    	return elevations[uint(col) * 33 + uint(row)];\n    }\n    \n    function initElevations(uint8 col, uint8[33] _elevations) public \n    {\n    	if(locked) // lockout\n    		return;\n    	uint skip = (uint(col) * 33); // e.g. if row 2, start with element 66\n    	uint counter = 0;\n    	while(counter < 33)\n    	{\n    		elevations[counter+skip] = _elevations[counter];\n    		counter++;\n    	}	\n    }\n    \n    /**********\n    Standard lock-kill methods \n    **********/\n    bool locked;\n    function setLocked()\n    {\n 	   locked = true;\n    }\n    function getLocked() public constant returns (bool)\n    {\n 	   return locked;\n    }\n    function kill()\n    { \n        if (!locked && msg.sender == creator)\n            suicide(creator);  // kills this contract and sends remaining funds back to creator\n    }\n}\n\n\n\n\n/*\n\ndoGetElevations prints a console map of elevations. Row 0 is at the bottom. Col 0 is on the left.\n\nfunction elevationOrPeriod(elevation) {\n	if (elevation >= 125)\n		return elevation;\n	else\n		return ""."";\n}\n\nfunction getElevation(mycol, myrow) {\n	return new Promise((resolve, reject) => {\n		mes.methods.getElevation(mycol, myrow).call(function(err, res) {\n			resolve([mycol, myrow, res]);\n		});\n	});\n}\n\nvar elevations = new Array(33);\nfunction doGetElevations() {\n	var c = 0;\n	var r = 0;\n	var limit = 1089;\n	var numReturned = 0;\n	var c2 = 0;\n	var r2 = 32;\n	var rowString = """";\n	while (c < 33) {\n		r = 0;\n		elevations[c] = new Array(33);\n		while (r < 33) {\n			getElevation(c, r).then(function(resultArray) {\n				elevations[resultArray[0]][resultArray[1]] = resultArray[2];\n				numReturned++;\n				if (numReturned === limit) {\n					while (r2 >= 0) {\n						c2 = 0\n						rowString = """";\n						while (c2 < 33) {\n							rowString = rowString + elevationOrPeriod(elevations[c2][r2]) + ""\t"";\n							c2++;\n						}\n						console.log(rowString.substring(0, rowString.length - 1));\n						r2--;\n					}\n				}\n			});\n			r++;\n		}\n		c++;\n	}\n}\ndoGetElevations();\n\n*/",1,
407810,0xe468d26721b703d224d05563cb64746a7a40e1f4,FALSE,FALSE,"/*\n\nEtheria v0.9\nBlock 407810 \nOct-19-2015 02:54:36 PM +UTC\n0xe468d26721b703d224d05563cb64746a7a40e1f4\n\n\nFunction hashes:\n{\n    ""54385526"": ""setStatus(uint8,uint8,string)"",			// unused (costs 0.1 ETH)\n    ""a5ffca0e"": ""acceptOffer(uint8,uint8,uint8)"",			// used for wrapping/unwrapping only\n    ""8cae1374"": ""editBlock(uint8,uint8,uint256,int8[5])"",	// unused under modern build mechanics\n    ""959eac47"": ""farmTile(uint8,uint8)"",					// unused under modern build mechanics\n    ""fa93019c"": ""getBlocks(uint8,uint8)"",					// unused under modern build mechanics\n    ""a55cab95"": ""getName(uint8,uint8)"",\n    ""6a864559"": ""getOfferers(uint8,uint8)"",					// used for wrapping/unwrapping only\n    ""c7dafc78"": ""getOffers(uint8,uint8)"",					// used for wrapping/unwrapping only\n    ""e039e4a1"": ""getOwner(uint8,uint8)"",\n    ""d39eb301"": ""getStatus(uint8,uint8)"",					// unused (setStatus costs 0.1 ETH)\n    ""4b42d208"": ""getUint8FromByte32(bytes32,uint8)"",		// unused under modern build mechanics\n    ""182db370"": ""getWhatHappened()"",\n    ""6266b514"": ""makeOffer(uint8,uint8)"",					// used for wrapping/unwrapping only\n    ""a713081c"": ""rejectOffer(uint8,uint8,uint8)"",			// used for wrapping/unwrapping only\n    ""edffcd57"": ""retractOffer(uint8,uint8)"",				// used for wrapping/unwrapping only\n    ""93eec1fb"": ""setName(uint8,uint8,string)""\n}\n\nNote: No kill or locking mechanisms\n\nvar etheriaAddress = ""0xe468d26721b703d224d05563cb64746a7a40e1f4"";\nvar abi =  [\n	{""constant"":true,""inputs"":[],""name"":""getWhatHappened"",""outputs"":[{""name"":"""",""type"":""uint8""}],""type"":""function"",""payable"":false,""stateMutability"":""view""},\n	{""constant"":true,""inputs"":[{""name"":""_b32"",""type"":""bytes32""},{""name"":""byteindex"",""type"":""uint8""}],""name"":""getUint8FromByte32"",""outputs"":[{""name"":"""",""type"":""uint8""}],""type"":""function"",""payable"":false,""stateMutability"":""view""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""_s"",""type"":""string""}],""name"":""setStatus"",""outputs"":[],""type"":""function"",""payable"":true,""stateMutability"":""payable""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""makeOffer"",""outputs"":[],""type"":""function"",""payable"":true,""stateMutability"":""payable""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getOfferers"",""outputs"":[{""name"":"""",""type"":""address[]""}],""type"":""function"",""payable"":false,""stateMutability"":""view""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""index"",""type"":""uint256""},{""name"":""_block"",""type"":""int8[5]""}],""name"":""editBlock"",""outputs"":[],""type"":""function"",""payable"":true,""stateMutability"":""payable""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""_n"",""type"":""string""}],""name"":""setName"",""outputs"":[],""type"":""function"",""payable"":true,""stateMutability"":""payable""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""farmTile"",""outputs"":[],""type"":""function"",""payable"":true,""stateMutability"":""payable""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getName"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function"",""payable"":false,""stateMutability"":""view""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""i"",""type"":""uint8""}],""name"":""acceptOffer"",""outputs"":[],""type"":""function"",""payable"":true,""stateMutability"":""payable""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""i"",""type"":""uint8""}],""name"":""rejectOffer"",""outputs"":[],""type"":""function"",""payable"":true,""stateMutability"":""payable""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getOffers"",""outputs"":[{""name"":"""",""type"":""uint256[]""}],""type"":""function"",""payable"":false,""stateMutability"":""view""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getStatus"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function"",""payable"":false,""stateMutability"":""view""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getOwner"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function"",""payable"":false,""stateMutability"":""view""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""retractOffer"",""outputs"":[],""type"":""function"",""payable"":true,""stateMutability"":""payable""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getBlocks"",""outputs"":[{""name"":"""",""type"":""int8[5][]""}],""type"":""function"",""payable"":false,""stateMutability"":""view""},\n	{""inputs"":[],""type"":""constructor"",""payable"":true,""stateMutability"":""payable""},\n	{""type"":""fallback"",""payable"":true,""stateMutability"":""payable""}\n];\nvar etheria = new web3.eth.Contract(abi, etheriaAddress);\n\nExact bytecode match with source below and Solidity: 0.1.6 w/ default optimization (200) (compile 4 times due to solc determinism bug)\nchain: 0x606060405236156100c45760e060020a6000350463182db37081146100c65780634b42d208146100ec578063543855261461012f5780636266b514146101b35780636a864559146101e55780638cae13741461028a57806393eec1fb14610321578063959eac47146103ca578063a55cab95146103e3578063a5ffca0e14610480578063a713081c1461049e578063c7dafc78146104b6578063d39eb3011461054e578063e039e4a1146105eb578063edffcd571461062f578063fa93019c14610646575b005b61220b5460a060020a900460ff165b6040805160ff929092168252519081900360200190f35b6100d56004356024355b60006040836002840260ff908116808403601090810a92603e92909203900a9085908190819081908a168114156123045786935061230a565b604080516020604435600481810135601f81018490048402850184019095528484526100c4948135946024803595939460649492939101918190840183828082843750949650505050505050600034600014156109e85761220b805460a060020a60ff021916742800000000000000000000000000000000000000001790556108a1565b6100c4600435602435600060003460001415611c305761220b805460a060020a60ff02191660a060020a1790556108a1565b610715600435602435604080516020810190915260008152600183602181101561000257506101088402018260218110156100025790906008020160005060010160005080548060200260200160405190810160405280929190818152602001828054801561027e57602002820191906000526020600020905b8154600160a060020a031681526001919091019060200180831161025f575b50505050509050610629565b6040805160a08181019092526100c49160048035926024359260443592916101049160649060059083908390808284375090955050505050506000610300604051908101604052806018905b60008152602001906001900390816102d65750506040805161030081019091526018815b60008152602001906001900390816102fa579050506000600060006000610efa8b8b610375565b604080516020604435600481810135601f81018490048402850184019095528484526100c494813594602480359593946064949293910191819084018382808284375094965050505050505060006108a784845b600060008360ff1610806103965750805460001960ff918216018116908416115b806103a4575060008260ff16105b806103bd575060005460ff908116600019018116908316115b1561062957506001610629565b6100c4600435602435600060006000610c2b8585610375565b61075f60043560243560408051602081019091526000815260018360218110156100025750610108840201826021811015610002579090600802016000506040805160069092018054602060026001831615610100026000190190921691909104601f810182900482028501820190935282845290919083018282801561027e5780601f106108445761010080835404028352916020019161027e565b6100c460043560243560443560006000600060006120b88787610375565b6100c4600435602435604435600061186f8484610375565b61071560043560243560408051602081019091526000815260018360218110156100025750610108840201826021811015610002579090600802016000506040805160029092018054602081810285018101909352808452909183018282801561027e57602002820191906000526020600020905b81600050548152602001906001019080831161052b575b50505050509050610629565b61075f60043560243560408051602081019091526000815260018360218110156100025750610108840201826021811015610002579090600802016000506040805160079092018054602060026001831615610100026000190190921691909104601f810182900482028501820190935282845290919083018282801561027e5780601f106108445761010080835404028352916020019161027e565b6107cd6004356024356000600183602181101561000257506101088402018260218110156100025790906008020160005054600160a060020a031690505b92915050565b6100c460043560243560006000611b1a8484610375565b6107e960043560243560408051602081019091526000815260018360218110156100025761010802016000508260218110156100025760080201600050600301600050805480602002602001604051908101604052809291908181526020016000905b82821015610edf576000848152602081206040805160a08101918290529291850191600591908390855b825461010083900a900460000b8152602060019283018181049485019490930390920291018084116106d35790505050505050815260200190600101906106a9565b60405180806020018281038252838181518152602001915080519060200190602002808383829060006004602084601f0104600302600f01f1509050019250505060405180910390f35b60405180806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156107bf5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60408051600160a060020a039092168252519081900360200190f35b60405180806020018281038252838181518152602001915080516000925b818410156108335760208481028401015160a08083818460006004601ef1509050019260010192610807565b925050509250505060405180910390f35b820191906000526020600020905b81548152906001019060200180831161085257509394506106299350505050565b505061220b80547434000000000000000000000000000000000000000060a060020a60ff0219919091161790555b50505050565b156108dc5761220b80547432000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b60018460218110156100025750610108850201836021811015610002579090600802016000508054909150600160a060020a03908116339091161461094b5761220b80547433000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b81816006016000509080519060200190828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106109b457805160ff19168380011785555b506108739291505b808211156109e457600081556001016109a0565b82800160010185558215610998579182015b828111156109985782518260005055916020019190600101906109c6565b5090565b67016345785d8a00003414610a485760405133600160a060020a031690600090349082818181858883f1505061220b80547429000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b610a528484610375565b15610aa85760405133600160a060020a031690600090349082818181858883f1505061220b8054742a000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b60018460218110156100025750610108850201836021811015610002579090600802016000508054909150600160a060020a039081163390911614610b385760405133600160a060020a031690600090349082818181858883f1505061220b8054742b000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b81816007016000509080519060200190828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610b9157805160ff19168380011785555b50610bc19291506109a0565b82800160010185558215610b85579182015b82811115610b85578251826000505591602001919060010190610ba3565b505061220b8054742c000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b43600484015561220b80547421000000000000000000000000000000000000000060a060020a60ff02199091161790555b5050505050565b15610c605761220b8054741e000000000000000000000000000000000000000060a060020a60ff021991909116179055610c24565b60018560218110156100025750610108860201846021811015610002579090600802016000508054909350600160a060020a039081163390911614610ccf5761220b8054741f000000000000000000000000000000000000000060a060020a60ff021991909116179055610c24565b6110e0836004016000505443031015610d125761220b80547420000000000000000000000000000000000000000060a060020a60ff021991909116179055610c24565b505043600019014060005b600a8160ff161015610bf35760038301805460018101808355919082908015829011610d5a57600083815260209020610d5a9181019083016109a0565b505050506020610d6a83836100f6565b60038501805460ff929092169290920691906000198101908110156100025750805460008281526020812091909101600019908101805460ff191660f860020a95860295909504949094179093558154909281019081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a9081020402179055506000836003016000506001856003016000508054905003815481101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a908102040217905550600019836003016000506001856003016000508054905003815481101561000257906000526020600020900160005060036101000a81548160ff021916908360f860020a9081020402179055506000836003016000506001856003016000508054905003815481101561000257906000526020600020900160005060046101000a81548160ff021916908360f860020a908102040217905550600101610d1d565b505050509050610629565b50505b5050505050505050505050565b15610f2f5761220b80547414000000000000000000000000000000000000000060a060020a60ff021991909116179055610eed565b60018b602181101561000257506101088c02018a6021811015610002579090600802016000508054909750600160a060020a039081163390911614610f9e5761220b80547415000000000000000000000000000000000000000060a060020a60ff021991909116179055610eed565b6060880151600090810b1215610fde5761220b80547416000000000000000000000000000000000000000060a060020a60ff021991909116179055610eed565b6003870180548a9081101561000257506000908152602081208a0154810b810b808a526040805161220a5460e360020a630379eaeb02825260ff9390931660048201529051600160a060020a039290921692631bcf5758926024838101936103009390839003909101908290876161da5a03f11561000257506040805161030080820180845261220a548e5160e360020a630379eaeb0290925260ff919091166103048401529251919a50600160a060020a03929092169350610324808b01929190818c0301816000876161da5a03f1156100025750505060405180610300016040529450600093505b60188460ff16101561135b57602088015185856018811015610002579090602002015101858560188110156100025760009290920b602092909202015287600290906020020151858560010160188110156100025790906020020151018585600101601881101561000257600092830b602091820290920191909152860151600290820b07810b1480159061117a5750600285856001016018811015610002579090602002015160000b0760000b6000145b156111ac5784846018811015610002576020020151600101858560188110156100025760009290920b60209290920201525b606088015185600286016018811015610002579090602002015101858560020160188110156100025760009290920b60209290920201526003870180548a9081101561000257506000908152602081208a01546101009004900b86856018811015610002579090602002015101868560188110156100025760009290920b60209290920201526003870180548a9081101561000257906000526020600020900160005060029054906101000a900460000b868560010160188110156100025790906020020151018685600101601881101561000257600092830b602091820290920191909152870151600290820b07810b148015906112c85750600286856001016018811015610002579090602002015160000b0760000b6000145b156112fa5785846018811015610002576020020151600101868560188110156100025760009290920b60209290920201525b6003870180548a9081101561000257506000908152602081208a015463010000009004900b8660028601601881101561000257602081028201519092019160188110156100025760009290920b6020929092020152600393909301926110c8565b6114518b8b8a8860006000600060006000610600604051908101604052806030905b600081526020019060019003908161137d57506000905060018b602181101561000257506101088c02018a6021811015610002579090600802016000509450600093505b60188460ff16101561238f576124a288856018811015610002576020020151896001870160188110156100025760200201516000600060008360000b60201913158015611412575060218460000b13155b156128935760028460000b0760000b60001415156128ab578460000b60311913158015611443575060318560000b13155b15612886576001925061288b565b151561145c57610eed565b6000876003016000508a815481101561000257508152602081208a015463010000009004810b810b1261165757600092505b60188360ff16101561169857600091505b6005870154821015611708576005870180548390811015610002576000918252602082200154810b900b86846018811015610002579090602002015160000b14801561152457506005870180548390811015610002576020600090812091909101546101009004810b900b90508660018501601881101561000257602002015160000b145b801561156757506005870180548390811015610002576000918252602082200154620100009004810b900b8660028501601881101561000257602002015160000b145b1561164b57848360188110156100025760200201516005880180548490811015610002576000918252602090912001805460ff191660f860020a9283029290920491909117905584600184016018811015610002576020020151600588018054849081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a90810204021790555084836002016018811015610002576020020151600588018054849081101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a9081020402179055505b6001919091019061149f565b5060005b60188160ff1610156116985760058701805460018101808355909190828015829011611714576000838152602090206117149181019083016109a0565b87876003016000508a815481101561000257506000908152602081208b01916001830191839060a08301905b8382111561182157835183826101000a81548160ff021916908360f860020a90810204021790555092602001926001016020816000010492830192600103026116c4565b6003929092019161148e565b505050508481601881101561000257602002015160058801805460001981019081101561000257906000526020600020900160005060006101000a81548160ff021916908360f860020a908102040217905550848160010160188110156100025760058901805460209290920290920151919060001981019081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a908102040217905550848160020160188110156100025760058901805460209290920290920151919060001981019081101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a90810204021790555060030161165b565b801561184e5782816101000a81549060ff0219169055600101602081600001049283019260010302611821565b5050610eea9291505b808211156109e457805460ff19168155600101611857565b156118a45761220b80547446000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b60018460218110156100025750610108850201836021811015610002579090600802016000508054909150600160a060020a0390811633909116146119135761220b80547447000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b60008260ff16108061192f575060028101546000190160ff8316115b156119645761220b80547448000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b611aea8484845b6000806001856021811015610002576101080201846021811015610002576008020160018101805491935090849081101561000257908252602082200154600283018054600160a060020a0392909216918391908690811015610002579060005260206000209001600050546040516000818181858888f19350505050508160010160005083815481101561000257906000526020600020900160006101000a815490600160a060020a030219169055816002016000508381548110156100025790600052602060002090016000506000905550600182015b600182015460ff8216101561231d57600182018054829081101561000257508054600082815260209020830154600160a060020a0316919060001984019081101561000257505060206000208201600019018054600160a060020a03191690911790556002820180548290811015610002575080546000828152602090208301549190600019840190811015610002575050602060002082016000190155600101611a44565b61220b80547449000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b15611b4c5761220b805460a060020a60ff021916743c00000000000000000000000000000000000000001790556108a1565b60018460218110156100025750610108850201836021811015610002579090600802016000509150600090505b600182015460ff82161015611bf35733600160a060020a03168260010160005082815481101561000257600091825260209091200154600160a060020a03161415611c235761220b8054743d000000000000000000000000000000000000000060a060020a60ff0219909116179055611c2b84848361196b565b61220b8054743e000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b600101611b79565b6108a1565b611c3a8484610375565b15611c905761220b80547402000000000000000000000000000000000000000060a060020a60ff02199190911617905560405133600160a060020a031690600090349082818181858883f19350505050506108a1565b60018460218110156100025750610108850201836021811015610002579090600802016000508054909250600160a060020a031660001415611db35734670de0b6b3a7640000141580611d5d575061220b54604080517f4166c1fd00000000000000000000000000000000000000000000000000000000815260ff8781166004830152861660248201529051607d92600160a060020a031691634166c1fd91604482810192602092919082900301816000876161da5a03f1156100025750506040515160ff169190911090505b15611e515760405133600160a060020a031690600090349082818181858883f1505061220b80547403000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b8154600160a060020a03908116339091161480611dd65750662386f26fc1000034105b80611dea575069d3c21bcecceda100000034115b80611dfb57506001820154600a9010155b15611eb35760405133600160a060020a031690600090349082818181858883f1505061220b80547405000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b60405161220954600160a060020a031690600090349082818181858883f150508454600160a060020a03191633178555505061220b80547404000000000000000000000000000000000000000060a060020a60ff0219909116179055506108a1565b5060005b600182015460ff82161015611f845733600160a060020a03168260010160005082815481101561000257600091825260209091200154600160a060020a03161415611fb45733600160a060020a03166000836002016000508381548110156100025790825260208220018150546040516000818181858888f15050505060028301805434925083908110156100025790600052602060002090016000505561220b80547406000000000000000000000000000000000000000060a060020a60ff02199091161790556108a1565b60018281018054918201808255828015829011611fbc57818360005260206000209182019101611fbc91906109a0565b600101611eb7565b50505060028301805460018101808355909250828015829011611ff257818360005260206000209182019101611ff291906109a0565b505050506001820180543391906000198101908110156100025750805460009182526020909120016000199081018054600160a060020a03191690921790915560028301805434928101908110156100025790600052602060002090016000505561220b80547407000000000000000000000000000000000000000060a060020a60ff02199091161790556108a1565b5061220b80547453000000000000000000000000000000000000000060a060020a60ff0219919091161790555b50505050505050565b156120ed5761220b80547450000000000000000000000000000000000000000060a060020a60ff0219919091161790556120af565b60018760218110156100025750610108880201866021811015610002579090600802016000508054909450600160a060020a03908116339091161461215c5761220b80547451000000000000000000000000000000000000000060a060020a60ff0219919091161790556120af565b60008560ff161080612178575060028401546000190160ff8616115b156121ad5761220b80547452000000000000000000000000000000000000000060a060020a60ff0219919091161790556120af565b6002840180548690811015610002575060009081526020812086015460405161220954919550600a86049450600160a060020a03919091169190849082818181858883f1508754600160a060020a031693509086039082818181858883f19350505050508360010160005085815481101561000257506000908152602081208601548554600160a060020a031916600160a060020a039190911617855590505b600184015460ff821610156122c55760ff818116908616146122bd576001840180548290811015610002576000918252602082200154600286018054600160a060020a0392909216929184908110156100025790825260208220018150546040516000818181858888f150505050505b60010161224d565b600184018054600080835591825260209091206122e4918101906109a0565b5060028401805460008083559182526020909120612082918101906109a0565b85870693505b5050508181069003049695505050505050565b600182018054600019810180835590919082801582901161234f5760008381526020902061234f9181019083016109a0565b50505060028301805460001981018083559092508280158290116123865781836000526020600020918201910161238691906109a0565b50505050610c24565b85600014156126275761220a54600160a060020a0316630878bc518a6000909060200201516040518260e060020a028152600401808260ff168152602001915050610600604051808303816000876161da5a03f1156100025750505060405180610600016040529150600090505b60308160ff1610801561240e575085155b156124715781816030811015610002576020020151600090810b14801561244a575081816001016030811015610002576020020151600090810b145b801561246b575081816002016030811015610002576020020151600090810b145b15612665575b61220b805460a060020a60ff021916740d000000000000000000000000000000000000000017905560009650612657565b15156124dc5761220b8054740a000000000000000000000000000000000000000060a060020a60ff02199190911617905560009650612657565b600092505b60058501548310156125e0576005850180548490811015610002576000918252602082200154810b900b8885601881101561000257602002015160000b14801561256457506005850180548490811015610002576020600090812091909101546101009004810b900b90508860018601601881101561000257602002015160000b145b80156125a757506005850180548490811015610002576000918252602082200154620100009004810b900b8860028601601881101561000257602002015160000b145b1561261b5761220b8054740b000000000000000000000000000000000000000060a060020a60ff02199190911617905560009650612657565b856000148015612605575087846002016018811015610002576020020151600090810b145b1561260f57600195505b600393909301926113c1565b600192909201916124e1565b61220b8054740e000000000000000000000000000000000000000060a060020a60ff021991909116179055600196505b505050505050949350505050565b60208901518282603081101561000257602002015101828260308110156100025760009290920b6020929092020152604089015182600183016030811015610002576020020151018260018301603081101561000257600092830b602091820290920191909152830151600290820b07810b148015906127025750600282826001016030811015610002579090602002015160000b0760000b6000145b156127345781816030811015610002576020020151600101828260308110156100025760009290920b60209290920201525b606089015182600283016030811015610002576020020151018260028301603081101561000257600092830b6020919091029091015292505b60058501548310801561277e575085155b15612872576005850180548490811015610002576000918252602082200154810b900b8282603081101561000257602002015160000b1480156127f95750600585018054849081101561000257602060009081209281529101546101009004810b900b8260018301603081101561000257602002015160000b145b801561283c57506005850180548490811015610002576000918252602082200154620100009004810b900b8260028301603081101561000257602002015160000b145b1561287a5761220b805460a060020a60ff021916740c000000000000000000000000000000000000000017905560019650612657565b6003016123fd565b6001929092019161276d565b600092505b505092915050565b60008560000b12156128d057600019850291506128d4565b8460000b6030191315801561144357506031600086900b13612886576001925061288b565b8491505b60008460000b12156128eb575060001983026128ee565b50825b60008460000b12158015612906575060008560000b12155b80612922575060008460000b128015612922575060008560000b135b156129565760028460000b0760000b60001415156129845760c660028302600383020160ff1611612886576001925061288b565b60028460000b0760000b600014156129845760c660028302600383020160ff1611612886576001925061288b565b60c66002600184010260001983016003020160ff1611612886576001925061288b56\ncompiled:606060405236156100c45760e060020a6000350463182db37081146100c65780634b42d208146100ec578063543855261461012f5780636266b514146101b35780636a864559146101e55780638cae13741461028a57806393eec1fb14610321578063959eac47146103ca578063a55cab95146103e3578063a5ffca0e14610480578063a713081c1461049e578063c7dafc78146104b6578063d39eb3011461054e578063e039e4a1146105eb578063edffcd571461062f578063fa93019c14610646575b005b61220b5460a060020a900460ff165b6040805160ff929092168252519081900360200190f35b6100d56004356024355b60006040836002840260ff908116808403601090810a92603e92909203900a9085908190819081908a168114156123045786935061230a565b604080516020604435600481810135601f81018490048402850184019095528484526100c4948135946024803595939460649492939101918190840183828082843750949650505050505050600034600014156109e85761220b805460a060020a60ff021916742800000000000000000000000000000000000000001790556108a1565b6100c4600435602435600060003460001415611c305761220b805460a060020a60ff02191660a060020a1790556108a1565b610715600435602435604080516020810190915260008152600183602181101561000257506101088402018260218110156100025790906008020160005060010160005080548060200260200160405190810160405280929190818152602001828054801561027e57602002820191906000526020600020905b8154600160a060020a031681526001919091019060200180831161025f575b50505050509050610629565b6040805160a08181019092526100c49160048035926024359260443592916101049160649060059083908390808284375090955050505050506000610300604051908101604052806018905b60008152602001906001900390816102d65750506040805161030081019091526018815b60008152602001906001900390816102fa579050506000600060006000610efa8b8b610375565b604080516020604435600481810135601f81018490048402850184019095528484526100c494813594602480359593946064949293910191819084018382808284375094965050505050505060006108a784845b600060008360ff1610806103965750805460001960ff918216018116908416115b806103a4575060008260ff16105b806103bd575060005460ff908116600019018116908316115b1561062957506001610629565b6100c4600435602435600060006000610c2b8585610375565b61075f60043560243560408051602081019091526000815260018360218110156100025750610108840201826021811015610002579090600802016000506040805160069092018054602060026001831615610100026000190190921691909104601f810182900482028501820190935282845290919083018282801561027e5780601f106108445761010080835404028352916020019161027e565b6100c460043560243560443560006000600060006120b88787610375565b6100c4600435602435604435600061186f8484610375565b61071560043560243560408051602081019091526000815260018360218110156100025750610108840201826021811015610002579090600802016000506040805160029092018054602081810285018101909352808452909183018282801561027e57602002820191906000526020600020905b81600050548152602001906001019080831161052b575b50505050509050610629565b61075f60043560243560408051602081019091526000815260018360218110156100025750610108840201826021811015610002579090600802016000506040805160079092018054602060026001831615610100026000190190921691909104601f810182900482028501820190935282845290919083018282801561027e5780601f106108445761010080835404028352916020019161027e565b6107cd6004356024356000600183602181101561000257506101088402018260218110156100025790906008020160005054600160a060020a031690505b92915050565b6100c460043560243560006000611b1a8484610375565b6107e960043560243560408051602081019091526000815260018360218110156100025761010802016000508260218110156100025760080201600050600301600050805480602002602001604051908101604052809291908181526020016000905b82821015610edf576000848152602081206040805160a08101918290529291850191600591908390855b825461010083900a900460000b8152602060019283018181049485019490930390920291018084116106d35790505050505050815260200190600101906106a9565b60405180806020018281038252838181518152602001915080519060200190602002808383829060006004602084601f0104600302600f01f1509050019250505060405180910390f35b60405180806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f1680156107bf5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60408051600160a060020a039092168252519081900360200190f35b60405180806020018281038252838181518152602001915080516000925b818410156108335760208481028401015160a08083818460006004601ef1509050019260010192610807565b925050509250505060405180910390f35b820191906000526020600020905b81548152906001019060200180831161085257509394506106299350505050565b505061220b80547434000000000000000000000000000000000000000060a060020a60ff0219919091161790555b50505050565b156108dc5761220b80547432000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b60018460218110156100025750610108850201836021811015610002579090600802016000508054909150600160a060020a03908116339091161461094b5761220b80547433000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b81816006016000509080519060200190828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f106109b457805160ff19168380011785555b506108739291505b808211156109e457600081556001016109a0565b82800160010185558215610998579182015b828111156109985782518260005055916020019190600101906109c6565b5090565b67016345785d8a00003414610a485760405133600160a060020a031690600090349082818181858883f1505061220b80547429000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b610a528484610375565b15610aa85760405133600160a060020a031690600090349082818181858883f1505061220b8054742a000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b60018460218110156100025750610108850201836021811015610002579090600802016000508054909150600160a060020a039081163390911614610b385760405133600160a060020a031690600090349082818181858883f1505061220b8054742b000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b81816007016000509080519060200190828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610b9157805160ff19168380011785555b50610bc19291506109a0565b82800160010185558215610b85579182015b82811115610b85578251826000505591602001919060010190610ba3565b505061220b8054742c000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b43600484015561220b80547421000000000000000000000000000000000000000060a060020a60ff02199091161790555b5050505050565b15610c605761220b8054741e000000000000000000000000000000000000000060a060020a60ff021991909116179055610c24565b60018560218110156100025750610108860201846021811015610002579090600802016000508054909350600160a060020a039081163390911614610ccf5761220b8054741f000000000000000000000000000000000000000060a060020a60ff021991909116179055610c24565b6110e0836004016000505443031015610d125761220b80547420000000000000000000000000000000000000000060a060020a60ff021991909116179055610c24565b505043600019014060005b600a8160ff161015610bf35760038301805460018101808355919082908015829011610d5a57600083815260209020610d5a9181019083016109a0565b505050506020610d6a83836100f6565b60038501805460ff929092169290920691906000198101908110156100025750805460008281526020812091909101600019908101805460ff191660f860020a95860295909504949094179093558154909281019081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a9081020402179055506000836003016000506001856003016000508054905003815481101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a908102040217905550600019836003016000506001856003016000508054905003815481101561000257906000526020600020900160005060036101000a81548160ff021916908360f860020a9081020402179055506000836003016000506001856003016000508054905003815481101561000257906000526020600020900160005060046101000a81548160ff021916908360f860020a908102040217905550600101610d1d565b505050509050610629565b50505b5050505050505050505050565b15610f2f5761220b80547414000000000000000000000000000000000000000060a060020a60ff021991909116179055610eed565b60018b602181101561000257506101088c02018a6021811015610002579090600802016000508054909750600160a060020a039081163390911614610f9e5761220b80547415000000000000000000000000000000000000000060a060020a60ff021991909116179055610eed565b6060880151600090810b1215610fde5761220b80547416000000000000000000000000000000000000000060a060020a60ff021991909116179055610eed565b6003870180548a9081101561000257506000908152602081208a0154810b810b808a526040805161220a5460e360020a630379eaeb02825260ff9390931660048201529051600160a060020a039290921692631bcf5758926024838101936103009390839003909101908290876161da5a03f11561000257506040805161030080820180845261220a548e5160e360020a630379eaeb0290925260ff919091166103048401529251919a50600160a060020a03929092169350610324808b01929190818c0301816000876161da5a03f1156100025750505060405180610300016040529450600093505b60188460ff16101561135b57602088015185856018811015610002579090602002015101858560188110156100025760009290920b602092909202015287600290906020020151858560010160188110156100025790906020020151018585600101601881101561000257600092830b602091820290920191909152860151600290820b07810b1480159061117a5750600285856001016018811015610002579090602002015160000b0760000b6000145b156111ac5784846018811015610002576020020151600101858560188110156100025760009290920b60209290920201525b606088015185600286016018811015610002579090602002015101858560020160188110156100025760009290920b60209290920201526003870180548a9081101561000257506000908152602081208a01546101009004900b86856018811015610002579090602002015101868560188110156100025760009290920b60209290920201526003870180548a9081101561000257906000526020600020900160005060029054906101000a900460000b868560010160188110156100025790906020020151018685600101601881101561000257600092830b602091820290920191909152870151600290820b07810b148015906112c85750600286856001016018811015610002579090602002015160000b0760000b6000145b156112fa5785846018811015610002576020020151600101868560188110156100025760009290920b60209290920201525b6003870180548a9081101561000257506000908152602081208a015463010000009004900b8660028601601881101561000257602081028201519092019160188110156100025760009290920b6020929092020152600393909301926110c8565b6114518b8b8a8860006000600060006000610600604051908101604052806030905b600081526020019060019003908161137d57506000905060018b602181101561000257506101088c02018a6021811015610002579090600802016000509450600093505b60188460ff16101561238f576124a288856018811015610002576020020151896001870160188110156100025760200201516000600060008360000b60201913158015611412575060218460000b13155b156128935760028460000b0760000b60001415156128ab578460000b60311913158015611443575060318560000b13155b15612886576001925061288b565b151561145c57610eed565b6000876003016000508a815481101561000257508152602081208a015463010000009004810b810b1261165757600092505b60188360ff16101561169857600091505b6005870154821015611708576005870180548390811015610002576000918252602082200154810b900b86846018811015610002579090602002015160000b14801561152457506005870180548390811015610002576020600090812091909101546101009004810b900b90508660018501601881101561000257602002015160000b145b801561156757506005870180548390811015610002576000918252602082200154620100009004810b900b8660028501601881101561000257602002015160000b145b1561164b57848360188110156100025760200201516005880180548490811015610002576000918252602090912001805460ff191660f860020a9283029290920491909117905584600184016018811015610002576020020151600588018054849081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a90810204021790555084836002016018811015610002576020020151600588018054849081101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a9081020402179055505b6001919091019061149f565b5060005b60188160ff1610156116985760058701805460018101808355909190828015829011611714576000838152602090206117149181019083016109a0565b87876003016000508a815481101561000257506000908152602081208b01916001830191839060a08301905b8382111561182157835183826101000a81548160ff021916908360f860020a90810204021790555092602001926001016020816000010492830192600103026116c4565b6003929092019161148e565b505050508481601881101561000257602002015160058801805460001981019081101561000257906000526020600020900160005060006101000a81548160ff021916908360f860020a908102040217905550848160010160188110156100025760058901805460209290920290920151919060001981019081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a908102040217905550848160020160188110156100025760058901805460209290920290920151919060001981019081101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a90810204021790555060030161165b565b801561184e5782816101000a81549060ff0219169055600101602081600001049283019260010302611821565b5050610eea9291505b808211156109e457805460ff19168155600101611857565b156118a45761220b80547446000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b60018460218110156100025750610108850201836021811015610002579090600802016000508054909150600160a060020a0390811633909116146119135761220b80547447000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b60008260ff16108061192f575060028101546000190160ff8316115b156119645761220b80547448000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b611aea8484845b6000806001856021811015610002576101080201846021811015610002576008020160018101805491935090849081101561000257908252602082200154600283018054600160a060020a0392909216918391908690811015610002579060005260206000209001600050546040516000818181858888f19350505050508160010160005083815481101561000257906000526020600020900160006101000a815490600160a060020a030219169055816002016000508381548110156100025790600052602060002090016000506000905550600182015b600182015460ff8216101561231d57600182018054829081101561000257508054600082815260209020830154600160a060020a0316919060001984019081101561000257505060206000208201600019018054600160a060020a03191690911790556002820180548290811015610002575080546000828152602090208301549190600019840190811015610002575050602060002082016000190155600101611a44565b61220b80547449000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b15611b4c5761220b805460a060020a60ff021916743c00000000000000000000000000000000000000001790556108a1565b60018460218110156100025750610108850201836021811015610002579090600802016000509150600090505b600182015460ff82161015611bf35733600160a060020a03168260010160005082815481101561000257600091825260209091200154600160a060020a03161415611c235761220b8054743d000000000000000000000000000000000000000060a060020a60ff0219909116179055611c2b84848361196b565b61220b8054743e000000000000000000000000000000000000000060a060020a60ff0219919091161790556108a1565b600101611b79565b6108a1565b611c3a8484610375565b15611c905761220b80547402000000000000000000000000000000000000000060a060020a60ff02199190911617905560405133600160a060020a031690600090349082818181858883f19350505050506108a1565b60018460218110156100025750610108850201836021811015610002579090600802016000508054909250600160a060020a031660001415611db35734670de0b6b3a7640000141580611d5d575061220b54604080517f4166c1fd00000000000000000000000000000000000000000000000000000000815260ff8781166004830152861660248201529051607d92600160a060020a031691634166c1fd91604482810192602092919082900301816000876161da5a03f1156100025750506040515160ff169190911090505b15611e515760405133600160a060020a031690600090349082818181858883f1505061220b80547403000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b8154600160a060020a03908116339091161480611dd65750662386f26fc1000034105b80611dea575069d3c21bcecceda100000034115b80611dfb57506001820154600a9010155b15611eb35760405133600160a060020a031690600090349082818181858883f1505061220b80547405000000000000000000000000000000000000000060a060020a60ff021991909116179055506108a1915050565b60405161220954600160a060020a031690600090349082818181858883f150508454600160a060020a03191633178555505061220b80547404000000000000000000000000000000000000000060a060020a60ff0219909116179055506108a1565b5060005b600182015460ff82161015611f845733600160a060020a03168260010160005082815481101561000257600091825260209091200154600160a060020a03161415611fb45733600160a060020a03166000836002016000508381548110156100025790825260208220018150546040516000818181858888f15050505060028301805434925083908110156100025790600052602060002090016000505561220b80547406000000000000000000000000000000000000000060a060020a60ff02199091161790556108a1565b60018281018054918201808255828015829011611fbc57818360005260206000209182019101611fbc91906109a0565b600101611eb7565b50505060028301805460018101808355909250828015829011611ff257818360005260206000209182019101611ff291906109a0565b505050506001820180543391906000198101908110156100025750805460009182526020909120016000199081018054600160a060020a03191690921790915560028301805434928101908110156100025790600052602060002090016000505561220b80547407000000000000000000000000000000000000000060a060020a60ff02199091161790556108a1565b5061220b80547453000000000000000000000000000000000000000060a060020a60ff0219919091161790555b50505050505050565b156120ed5761220b80547450000000000000000000000000000000000000000060a060020a60ff0219919091161790556120af565b60018760218110156100025750610108880201866021811015610002579090600802016000508054909450600160a060020a03908116339091161461215c5761220b80547451000000000000000000000000000000000000000060a060020a60ff0219919091161790556120af565b60008560ff161080612178575060028401546000190160ff8616115b156121ad5761220b80547452000000000000000000000000000000000000000060a060020a60ff0219919091161790556120af565b6002840180548690811015610002575060009081526020812086015460405161220954919550600a86049450600160a060020a03919091169190849082818181858883f1508754600160a060020a031693509086039082818181858883f19350505050508360010160005085815481101561000257506000908152602081208601548554600160a060020a031916600160a060020a039190911617855590505b600184015460ff821610156122c55760ff818116908616146122bd576001840180548290811015610002576000918252602082200154600286018054600160a060020a0392909216929184908110156100025790825260208220018150546040516000818181858888f150505050505b60010161224d565b600184018054600080835591825260209091206122e4918101906109a0565b5060028401805460008083559182526020909120612082918101906109a0565b85870693505b5050508181069003049695505050505050565b600182018054600019810180835590919082801582901161234f5760008381526020902061234f9181019083016109a0565b50505060028301805460001981018083559092508280158290116123865781836000526020600020918201910161238691906109a0565b50505050610c24565b85600014156126275761220a54600160a060020a0316630878bc518a6000909060200201516040518260e060020a028152600401808260ff168152602001915050610600604051808303816000876161da5a03f1156100025750505060405180610600016040529150600090505b60308160ff1610801561240e575085155b156124715781816030811015610002576020020151600090810b14801561244a575081816001016030811015610002576020020151600090810b145b801561246b575081816002016030811015610002576020020151600090810b145b15612665575b61220b805460a060020a60ff021916740d000000000000000000000000000000000000000017905560009650612657565b15156124dc5761220b8054740a000000000000000000000000000000000000000060a060020a60ff02199190911617905560009650612657565b600092505b60058501548310156125e0576005850180548490811015610002576000918252602082200154810b900b8885601881101561000257602002015160000b14801561256457506005850180548490811015610002576020600090812091909101546101009004810b900b90508860018601601881101561000257602002015160000b145b80156125a757506005850180548490811015610002576000918252602082200154620100009004810b900b8860028601601881101561000257602002015160000b145b1561261b5761220b8054740b000000000000000000000000000000000000000060a060020a60ff02199190911617905560009650612657565b856000148015612605575087846002016018811015610002576020020151600090810b145b1561260f57600195505b600393909301926113c1565b600192909201916124e1565b61220b8054740e000000000000000000000000000000000000000060a060020a60ff021991909116179055600196505b505050505050949350505050565b60208901518282603081101561000257602002015101828260308110156100025760009290920b6020929092020152604089015182600183016030811015610002576020020151018260018301603081101561000257600092830b602091820290920191909152830151600290820b07810b148015906127025750600282826001016030811015610002579090602002015160000b0760000b6000145b156127345781816030811015610002576020020151600101828260308110156100025760009290920b60209290920201525b606089015182600283016030811015610002576020020151018260028301603081101561000257600092830b6020919091029091015292505b60058501548310801561277e575085155b15612872576005850180548490811015610002576000918252602082200154810b900b8282603081101561000257602002015160000b1480156127f95750600585018054849081101561000257602060009081209281529101546101009004810b900b8260018301603081101561000257602002015160000b145b801561283c57506005850180548490811015610002576000918252602082200154620100009004810b900b8260028301603081101561000257602002015160000b145b1561287a5761220b805460a060020a60ff021916740c000000000000000000000000000000000000000017905560019650612657565b6003016123fd565b6001929092019161276d565b600092505b505092915050565b60008560000b12156128d057600019850291506128d4565b8460000b6030191315801561144357506031600086900b13612886576001925061288b565b8491505b60008460000b12156128eb575060001983026128ee565b50825b60008460000b12158015612906575060008560000b12155b80612922575060008460000b128015612922575060008560000b135b156129565760028460000b0760000b60001415156129845760c660028302600383020160ff1611612886576001925061288b565b60028460000b0760000b600014156129845760c660028302600383020160ff1611612886576001925061288b565b60c66002600184010260001983016003020160ff1611612886576001925061288b56\n\n*/\n\ncontract BlockDefStorage \n{\n	function getOccupies(uint8 which) public returns (int8[24])\n	{}\n	function getAttachesto(uint8 which) public returns (int8[48])\n    {}\n}\n\ncontract MapElevationRetriever \n{\n	function getElevation(uint8 col, uint8 row) public constant returns (uint8)\n	{}\n}\n\ncontract Etheria //is mortal\n{\n    uint8 mapsize = 33;\n    Tile[33][33] tiles;\n    address creator;\n    \n    struct Tile \n    {\n    	address owner;\n    	address[] offerers;\n    	uint[] offers;\n    	int8[5][] blocks; //0 = which,1 = blockx,2 = blocky,3 = blockz, 4 = color\n    	uint lastfarm;\n    	int8[3][] occupado;\n    	string name;\n    	string status;\n    }\n    \n    BlockDefStorage bds;\n    MapElevationRetriever mer;\n    \n    function Etheria() {\n    	creator = msg.sender;\n    	bds = BlockDefStorage(0x782bdf7015b71b64f6750796dd087fde32fd6fdc); \n    	mer = MapElevationRetriever(0x68549d7dbb7a956f955ec1263f55494f05972a6b);\n    }\n    \n    function getOwner(uint8 col, uint8 row) public constant returns(address)\n    {\n    	return tiles[col][row].owner; // no harm if col,row are invalid\n    }\n    \n    /***\n     *     _   _   ___  ___  ___ _____            _____ _____ ___ _____ _   _ _____ \n     *    | \ | | / _ \ |  \/  ||  ___|   ___    /  ___|_   _/ _ \_   _| | | /  ___|\n     *    |  \| |/ /_\ \| .  . || |__    ( _ )   \ `--.  | |/ /_\ \| | | | | \ `--. \n     *    | . ` ||  _  || |\/| ||  __|   / _ \/\  `--. \ | ||  _  || | | | | |`--. \\n     *    | |\  || | | || |  | || |___  | (_>  < /\__/ / | || | | || | | |_| /\__/ /\n     *    \_| \_/\_| |_/\_|  |_/\____/   \___/\/ \____/  \_/\_| |_/\_/  \___/\____/ \n     *                                                                              \n     *                                                                              \n     */\n    \n    function getName(uint8 col, uint8 row) public constant returns(string)\n    {\n    	return tiles[col][row].name; // no harm if col,row are invalid\n    }\n    function setName(uint8 col, uint8 row, string _n) public\n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 50;  \n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != msg.sender)\n    	{\n    		whathappened = 51;\n    		return;\n    	}\n    	tile.name = _n;\n    	whathappened = 52;\n    	return;\n    }\n    \n    function getStatus(uint8 col, uint8 row) public constant returns(string)\n    {\n    	return tiles[col][row].status; // no harm if col,row are invalid\n    }\n    function setStatus(uint8 col, uint8 row, string _s) public // setting status costs .1 eth. (currently 5 cents. Cry me a river.)\n    {\n    	if(msg.value == 0)	// the only situation where we don't refund money.\n    	{\n    		whathappened = 40;\n    		return;\n    	}\n    	if(msg.value != 100000000000000000) // the only situation\n    	{\n    		msg.sender.send(msg.value); 		// return their money\n    		whathappened = 41;\n    		return;\n    	}\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		msg.sender.send(msg.value); 		// return their money\n    		whathappened = 42;\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != msg.sender)\n    	{\n    		msg.sender.send(msg.value); 		// return their money\n    		whathappened = 43;\n    		return;\n    	}\n    	tile.status = _s;\n    	whathappened = 44;\n    	return;\n    }\n    \n    /***\n     *    ______ ___  _________  ________ _   _ _____            ___________ _____ _____ _____ _   _ _____ \n     *    |  ___/ _ \ | ___ \  \/  |_   _| \ | |  __ \   ___    |  ___|  _  \_   _|_   _|_   _| \ | |  __ \\n     *    | |_ / /_\ \| |_/ / .  . | | | |  \| | |  \/  ( _ )   | |__ | | | | | |   | |   | | |  \| | |  \/\n     *    |  _||  _  ||    /| |\/| | | | | . ` | | __   / _ \/\ |  __|| | | | | |   | |   | | | . ` | | __ \n     *    | |  | | | || |\ \| |  | |_| |_| |\  | |_\ \ | (_>  < | |___| |/ / _| |_  | |  _| |_| |\  | |_\ \\n     *    \_|  \_| |_/\_| \_\_|  |_/\___/\_| \_/\____/  \___/\/ \____/|___/  \___/  \_/  \___/\_| \_/\____/\n     *                                                                                                     \n     */\n    \n    function farmTile(uint8 col, uint8 row) public \n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 30;\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n        if(tile.owner != msg.sender)\n        {\n        	whathappened = 31;\n        	return;\n        }\n        if((block.number - tile.lastfarm) < 4320) // a day's worth of blocks hasn't passed yet. can only farm once a day. (Assumes block times of 20 seconds.)\n        {\n        	whathappened = 32;\n        	return;\n        }\n        bytes32 lastblockhash = block.blockhash(block.number - 1);\n    	for(uint8 i = 0; i < 10; i++)\n    	{\n            tile.blocks.length+=1;\n    	    tile.blocks[tile.blocks.length - 1][0] = int8(getUint8FromByte32(lastblockhash,i) % 32); // which, guaranteed 0-31\n    	    tile.blocks[tile.blocks.length - 1][1] = 0; // x\n    	    tile.blocks[tile.blocks.length - 1][2] = 0; // y\n    	    tile.blocks[tile.blocks.length - 1][3] = -1; // z\n    	    tile.blocks[tile.blocks.length - 1][4] = 0; // color\n    	}\n    	tile.lastfarm = block.number;\n    	whathappened = 33;\n    	return;\n    }\n    \n    function editBlock(uint8 col, uint8 row, uint index, int8[5] _block)  \n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 20;\n    		return;\n    	}\n    	\n    	Tile tile = tiles[col][row];\n        if(tile.owner != msg.sender) // 1. DID THE OWNER SEND THIS MESSAGE?\n        {\n        	whathappened = 21;\n        	return;\n        }\n        if(_block[3] < 0) // 2. IS THE Z LOCATION OF THE BLOCK BELOW ZERO? BLOCKS CANNOT BE HIDDEN\n        {\n        	whathappened = 22;\n        	return;\n        }\n        \n        _block[0] = tile.blocks[index][0]; // can't change the which, so set it to whatever it already was\n\n        int8[24] memory didoccupy = bds.getOccupies(uint8(_block[0]));\n        int8[24] memory wouldoccupy = bds.getOccupies(uint8(_block[0]));\n        \n        for(uint8 b = 0; b < 24; b+=3) // always 8 hexes, calculate the didoccupy\n 		{\n 			 wouldoccupy[b] = wouldoccupy[b]+_block[1];\n 			 wouldoccupy[b+1] = wouldoccupy[b+1]+_block[2];\n 			 if(wouldoccupy[1] % 2 != 0 && wouldoccupy[b+1] % 2 == 0) // if anchor y is odd and this hex y is even, (SW NE beam goes 11,`2`2,23,`3`4,35,`4`6,47,`5`8  ` = x value incremented by 1. Same applies to SW NE beam from 01,12,13,24,25,36,37,48)\n 				 wouldoccupy[b] = wouldoccupy[b]+1;  			   // then offset x by +1\n 			 wouldoccupy[b+2] = wouldoccupy[b+2]+_block[3];\n 			 \n 			 didoccupy[b] = didoccupy[b]+tile.blocks[index][1];\n 			 didoccupy[b+1] = didoccupy[b+1]+tile.blocks[index][2];\n 			 if(didoccupy[1] % 2 != 0 && didoccupy[b+1] % 2 == 0) // if anchor y and this hex y are both odd,\n 				 didoccupy[b] = didoccupy[b]+1; 					 // then offset x by +1\n       		didoccupy[b+2] = didoccupy[b+2]+tile.blocks[index][3];\n 		}\n        \n        if(!isValidLocation(col,row,_block, wouldoccupy))\n        {\n        	return; // whathappened is already set\n        }\n        \n        // EVERYTHING CHECKED OUT, WRITE OR OVERWRITE THE HEXES IN OCCUPADO\n        \n      	if(tile.blocks[index][3] >= 0) // If the previous z was greater than 0 (i.e. not hidden) ...\n     	{\n         	for(uint8 l = 0; l < 24; l+=3) // loop 8 times,find the previous occupado entries and overwrite them\n         	{\n         		for(uint o = 0; o < tile.occupado.length; o++)\n         		{\n         			if(didoccupy[l] == tile.occupado[o][0] && didoccupy[l+1] == tile.occupado[o][1] && didoccupy[l+2] == tile.occupado[o][2]) // x,y,z equal?\n         			{\n         				tile.occupado[o][0] = wouldoccupy[l]; // found it. Overwrite it\n         				tile.occupado[o][1] = wouldoccupy[l+1];\n         				tile.occupado[o][2] = wouldoccupy[l+2];\n         			}\n         		}\n         	}\n     	}\n     	else // previous block was hidden\n     	{\n     		for(uint8 ll = 0; ll < 24; ll+=3) // add the 8 new hexes to occupado\n         	{\n     			tile.occupado.length++;\n     			tile.occupado[tile.occupado.length-1][0] = wouldoccupy[ll];\n     			tile.occupado[tile.occupado.length-1][1] = wouldoccupy[ll+1];\n     			tile.occupado[tile.occupado.length-1][2] = wouldoccupy[ll+2];\n         	}\n     	}\n     	tile.blocks[index] = _block;\n    	return;\n    }\n       \n    function getBlocks(uint8 col, uint8 row) public constant returns (int8[5][])\n    {\n    	return tiles[col][row].blocks; // no harm if col,row are invalid\n    }\n   \n    /***\n     *     _________________ ___________  _____ \n     *    |  _  |  ___|  ___|  ___| ___ \/  ___|\n     *    | | | | |_  | |_  | |__ | |_/ /\ `--. \n     *    | | | |  _| |  _| |  __||    /  `--. \\n     *    \ \_/ / |   | |   | |___| |\ \ /\__/ /\n     *     \___/\_|   \_|   \____/\_| \_|\____/ \n     *                                          \n     */\n    \n    function makeOffer(uint8 col, uint8 row)\n    {\n    	if(msg.value == 0) // checking this first means that we will ALWAYS need to return money on any other failure\n    	{\n    		whathappened = 1;\n    		return;\n    	}	// do nothing, just return\n    	\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 2;\n    		msg.sender.send(msg.value); 		// return their money\n    		return;\n    	}\n    	\n    	Tile tile = tiles[col][row];\n    	if(tile.owner == address(0x0000000000000000000000000000000000000000))			// if UNOWNED\n    	{	  \n    		if(msg.value != 1000000000000000000 || mer.getElevation(col,row) < 125)	// 1 ETH is the starting value. If not return; // Also, if below sea level, return. \n    		{\n    			msg.sender.send(msg.value); 	 									// return their money\n    			whathappened = 3;\n    			return;\n    		}\n    		else\n    		{	\n    			creator.send(msg.value);     		 								// this was a valid offer, send money to contract creator\n    			tile.owner = msg.sender;  								// set tile owner to the buyer\n    			whathappened = 4;\n    			return;\n    		}\n    	}	\n    	else 																		// if already OWNED\n    	{\n    		if(tile.owner == msg.sender || msg.value < 10000000000000000 || msg.value > 1000000000000000000000000 || tile.offerers.length >= 10 ) // trying to make an offer on their own tile. or the offer list is full (10 max) or the value is out of range (.01 ETH - 1 mil ETH is range)\n    		{\n    			msg.sender.send(msg.value); 	 									// return the money\n    			whathappened = 5;\n    			return;\n    		}\n    		else\n    		{	\n    			for(uint8 i = 0; i < tile.offerers.length; i++)\n    			{\n    				if(tile.offerers[i] == msg.sender) 						// user has already made an offer. Update it and return;\n    				{\n    					msg.sender.send(tile.offers[i]); 					// return their previous money\n    					tile.offers[i] = msg.value; 							// set the new offer\n    					whathappened = 6;\n    					return;\n    				}\n    			}	\n    			// the user has not yet made an offer\n    			tile.offerers.length++; // make room for 1 more\n    			tile.offers.length++; // make room for 1 more\n    			tile.offerers[tile.offerers.length - 1] = msg.sender; // record who is making the offer\n    			tile.offers[tile.offers.length - 1] = msg.value; // record the offer\n    			whathappened = 7;\n    			return;\n    		}\n    	}\n    }\n    \n    function retractOffer(uint8 col, uint8 row) // retracts the first offer in the array by this user.\n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 60;\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n        for(uint8 i = 0; i < tile.offerers.length; i++)\n    	{\n    		if(tile.offerers[i] == msg.sender) // this user has an offer on file. Remove it.\n    		{\n    			whathappened = 61;\n    			removeOffer(col,row,i);\n    			return;\n    		}\n    	}	\n        whathappened = 62; // no offer found for msg.sender\n        return;\n    }\n    \n    function rejectOffer(uint8 col, uint8 row, uint8 i) // index 0-10\n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 70;\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != msg.sender) // only the owner can reject offers\n    	{\n    		whathappened = 71;\n    		return;\n    	}\n    	if(i < 0 || i > (tile.offers.length - 1)) // index oob\n    	{\n    		whathappened = 72;\n    		return;\n    	}	\n    	removeOffer(col,row,i);\n    	whathappened = 73;\n		return;\n    }\n    \n    function removeOffer(uint8 col, uint8 row, uint8 i) private // index 0-10, can't be odd\n    {\n    	Tile tile = tiles[col][row]; // private method. No need to check col,row validity\n        tile.offerers[i].send(tile.offers[i]); // return the money\n    			\n    	// delete user and offer and reshape the array\n    	delete tile.offerers[i];   // zero out user\n    	delete tile.offers[i];   // zero out offer\n    	for(uint8 j = i+1; j < tile.offerers.length; j++) // close the arrays after the gap\n    	{\n    	    tile.offerers[j-1] = tile.offerers[j];\n    	    tile.offers[j-1] = tile.offers[j];\n    	}\n    	tile.offerers.length--;\n    	tile.offers.length--;\n    	return;\n    }\n    \n    function acceptOffer(uint8 col, uint8 row, uint8 i) // accepts the offer at index (1-10)\n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 80;\n    		return;\n    	}\n    	\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != msg.sender) // only the owner can reject offers\n    	{\n    		whathappened = 81;\n    		return;\n    	}\n    	if(i < 0 || i > (tile.offers.length - 1)) // index oob\n    	{\n    		whathappened = 82;\n    		return;\n    	}	\n    	uint offeramount = tile.offers[i];\n    	uint housecut = offeramount / 10;\n    	creator.send(housecut);\n    	tile.owner.send(offeramount-housecut); // send offer money to oldowner\n    	tile.owner = tile.offerers[i]; // new owner is the offerer\n    	for(uint8 j = 0; j < tile.offerers.length; j++) // return all the other offerers' offer money\n    	{\n    		if(j != i) // don't return money for the purchaser\n    			tile.offerers[j].send(tile.offers[j]);\n    	}\n    	delete tile.offerers; // delete all offerers\n    	delete tile.offers; // delete all offers\n    	whathappened = 83;\n    	return;\n    }\n    \n    function getOfferers(uint8 col, uint8 row) constant returns (address[])\n    {\n    	return tiles[col][row].offerers; // no harm if col,row are invalid\n    }\n    \n    function getOffers(uint8 col, uint8 row) constant returns (uint[])\n    {\n    	return tiles[col][row].offers; // no harm if col,row are invalid\n    }\n    \n    function isOOB(uint8 col, uint8 row) private constant returns (bool)\n    {\n    	if(col < 0 || col > (mapsize-1) || row < 0 || row > (mapsize-1))\n    		return true; // is out of bounds\n    }\n    \n    /***\n     *     _   _ _____ _____ _     _____ _______   __\n     *    | | | |_   _|_   _| |   |_   _|_   _\ \ / /\n     *    | | | | | |   | | | |     | |   | |  \ V / \n     *    | | | | | |   | | | |     | |   | |   \ /  \n     *    | |_| | | |  _| |_| |_____| |_  | |   | |  \n     *     \___/  \_/  \___/\_____/\___/  \_/   \_/  \n     *                                               \n     */\n    \n    // this logic COULD be reduced a little, but the gain is minimal and readability suffers\n    function blockHexCoordsValid(int8 x, int8 y) private constant returns (bool)\n    {\n    	if(-33 <= y && y <= 33)\n    	{\n    		if(y % 2 != 0 ) // odd\n    		{\n    			if(-50 <= x && x <= 49)\n    				return true;\n    		}\n    		else // even\n    		{\n    			if(-49 <= x && x <= 49)\n    				return true;\n    		}	\n    	}	\n    	else\n    	{	\n    		uint8 absx;\n			uint8 absy;\n			if(x < 0)\n				absx = uint8(x*-1);\n			else\n				absx = uint8(x);\n			if(y < 0)\n				absy = uint8(y*-1);\n			else\n				absy = uint8(y);\n    		if((y >= 0 && x >= 0) || (y < 0 && x > 0)) // first or 4th quadrants\n    		{\n    			if(y % 2 != 0 ) // odd\n    			{\n    				if (((absx*2) + (absy*3)) <= 198)\n    					return true;\n    			}	\n    			else	// even\n    			{\n    				if ((((absx+1)*2) + ((absy-1)*3)) <= 198)\n    					return true;\n    			}\n    		}\n    		else\n    		{	\n    			if(y % 2 == 0 ) // even\n    			{\n    				if (((absx*2) + (absy*3)) <= 198)\n    					return true;\n    			}	\n    			else	// odd\n    			{\n    				if ((((absx+1)*2) + ((absy-1)*3)) <= 198)\n    					return true;\n    			}\n    		}\n    	}\n    	return false;\n    }\n    \n    // SEVERAL CHECKS TO BE PERFORMED\n    // 1. DID THE OWNER SEND THIS MESSAGE?		(SEE editBlock)\n    // 2. IS THE Z LOCATION OF THE BLOCK BELOW ZERO? BLOCKS CANNOT BE HIDDEN AFTER SHOWING	   (SEE editBlock)\n    // 3. DO ANY OF THE PROPOSED HEXES FALL OUTSIDE OF THE TILE? \n    // 4. DO ANY OF THE PROPOSED HEXES CONFLICT WITH ENTRIES IN OCCUPADO? \n    // 5. DO ANY OF THE BLOCKS TOUCH ANOTHER?\n    // 6. NONE OF THE OCCUPY BLOCKS TOUCHED THE GROUND. BUT MAYBE THEY TOUCH ANOTHER BLOCK?\n    \n    function isValidLocation(uint8 col, uint8 row, int8[5] _block, int8[24] wouldoccupy) private constant returns (bool)\n    {\n    	bool touches;\n    	Tile tile = tiles[col][row]; // since this is a private method, we don't need to check col,row validity\n    	\n        for(uint8 b = 0; b < 24; b+=3) // always 8 hexes, calculate the wouldoccupy and the didoccupy\n       	{\n       		if(!blockHexCoordsValid(wouldoccupy[b], wouldoccupy[b+1])) // 3. DO ANY OF THE PROPOSED HEXES FALL OUTSIDE OF THE TILE? \n      		{\n       			whathappened = 10;\n      			return false;\n      		}\n       		for(uint o = 0; o < tile.occupado.length; o++)  // 4. DO ANY OF THE PROPOSED HEXES CONFLICT WITH ENTRIES IN OCCUPADO? \n          	{\n      			if(wouldoccupy[b] == tile.occupado[o][0] && wouldoccupy[b+1] == tile.occupado[o][1] && wouldoccupy[b+2] == tile.occupado[o][2]) // do the x,y,z entries of each match?\n      			{\n      				whathappened = 11;\n      				return false; // this hex conflicts. The proposed block does not avoid overlap. Return false immediately.\n      			}\n          	}\n      		if(touches == false && wouldoccupy[b+2] == 0)  // 5. DO ANY OF THE BLOCKS TOUCH ANOTHER? (GROUND ONLY FOR NOW)\n      		{\n      			touches = true; // once true, always true til the end of this method. We must keep looping to check all the hexes for conflicts and tile boundaries, though, so we can't return true here.\n      		}	\n       	}\n        \n        // now if we're out of the loop and here, there were no conflicts and the block was found to be in the tile boundary.\n        // touches may be true or false, so we need to check \n          \n        if(touches == false)  // 6. NONE OF THE OCCUPY BLOCKS TOUCHED THE GROUND. BUT MAYBE THEY TOUCH ANOTHER BLOCK?\n  		{\n          	int8[48] memory attachesto = bds.getAttachesto(uint8(_block[0]));\n          	for(uint8 a = 0; a < 48 && !touches; a+=3) // always 8 hexes, calculate the wouldoccupy and the didoccupy\n          	{\n          		if(attachesto[a] == 0 && attachesto[a+1] == 0 && attachesto[a+2] == 0) // there are no more attachestos available, break (0,0,0 signifies end)\n          			break;\n          		attachesto[a] = attachesto[a]+_block[1];\n          		attachesto[a+1] = attachesto[a+1]+_block[2];\n           		if(attachesto[1] % 2 != 0 && attachesto[a+1] % 2 == 0) // if anchor y and this hex y are both odd,  (for attachesto, anchory is the same as for occupies, but the z is different. Nothing to worry about)\n           			attachesto[a] = attachesto[a]+1;  			       // then offset x by +1\n           		attachesto[a+2] = attachesto[a+2]+_block[3];\n           		for(o = 0; o < tile.occupado.length && !touches; o++)\n           		{\n           			if(attachesto[a] == tile.occupado[o][0] && attachesto[a+1] == tile.occupado[o][1] && attachesto[a+2] == tile.occupado[o][2]) // a valid attachesto found in occupado?\n           			{\n           				whathappened = 12;\n           				return true; // in bounds, didn't conflict and now touches is true. All good. Return.\n           			}\n           		}\n          	}\n          	whathappened = 13;\n          	return false; \n  		}\n        else // touches was true by virtue of a z = 0 above (touching the ground). Return true;\n        {\n        	whathappened = 14;\n        	return true;\n        }	\n    }  \n\n    // This function is handy for getting random numbers from 0-255 without getting a new hash every time. \n    // With one bytes32, there are 32 of these available, depending on the index\n    function getUint8FromByte32(bytes32 _b32, uint8 byteindex) public constant returns(uint8) {\n    	uint numdigits = 64;\n    	uint buint = uint(_b32);\n    	uint upperpowervar = 16 ** (numdigits - (byteindex*2)); 		// @i=0 upperpowervar=16**64 (SEE EXCEPTION BELOW), @i=1 upperpowervar=16**62, @i upperpowervar=16**60\n    	uint lowerpowervar = 16 ** (numdigits - 2 - (byteindex*2));		// @i=0 upperpowervar=16**62, @i=1 upperpowervar=16**60, @i upperpowervar=16**58\n    	uint postheadchop;\n    	if(byteindex == 0)\n    		postheadchop = buint; 								//for byteindex 0, buint is just the input number. 16^64 is out of uint range, so this exception has to be made.\n    	else\n    		postheadchop = buint % upperpowervar; 				// @i=0 _b32=a1b2c3d4... postheadchop=a1b2c3d4, @i=1 postheadchop=b2c3d4, @i=2 postheadchop=c3d4\n    	uint remainder = postheadchop % lowerpowervar; 			// @i=0 remainder=b2c3d4, @i=1 remainder=c3d4, @i=2 remainder=d4\n    	uint evenedout = postheadchop - remainder; 				// @i=0 evenedout=a1000000, @i=1 remainder=b20000, @i=2 remainder=c300\n    	uint b = evenedout / lowerpowervar; 					// @i=0 b=a1 (to uint), @i=1 b=b2, @i=2 b=c3\n    	return uint8(b);\n    }\n    \n  uint8 whathappened;\n  function getWhatHappened() public constant returns (uint8)\n  {\n  	return whathappened;\n  }\n}",1,
420373,0xe414716f017b5c1457bf98e985bccb135dff81f2,FALSE,FALSE,"//                                                                                                                                                                                                         \ncontract BlockDefStorage \n{\n	function getOccupies(uint8 which) public returns (int8[24])\n	{}\n	function getAttachesto(uint8 which) public returns (int8[48])\n    {}\n}\n\ncontract MapElevationRetriever \n{\n	function getElevation(uint8 col, uint8 row) public constant returns (uint8)\n	{}\n}\n\ncontract Etheria \n{\n	// change from v0.9 - event added\n	event TileChanged(uint8 col, uint8 row);//, address owner, string name, string status, uint lastfarm, address[] offerers, uint[] offers, int8[5][] blocks);\n	\n    uint8 mapsize = 33;\n    Tile[33][33] tiles;\n    address creator;\n    \n    struct Tile \n    {\n    	address owner;\n    	string name;\n    	string status;\n    	address[] offerers;\n    	uint[] offers;\n    	int8[5][] blocks; //0 = which,1 = blockx,2 = blocky,3 = blockz, 4 = color\n    	uint lastfarm;\n    	\n    	int8[3][] occupado; // the only one not reported in the //TileChanged event\n    }\n    \n    BlockDefStorage bds;\n    MapElevationRetriever mer;\n    \n    function Etheria() {\n    	creator = msg.sender;\n    	bds = BlockDefStorage(0x782bdf7015b71b64f6750796dd087fde32fd6fdc); \n    	mer = MapElevationRetriever(0x68549d7dbb7a956f955ec1263f55494f05972a6b);\n    }\n    \n    function getOwner(uint8 col, uint8 row) public constant returns(address)\n    {\n    	return tiles[col][row].owner; // no harm if col,row are invalid\n    }\n    \n    /***\n     *     _   _   ___  ___  ___ _____            _____ _____ ___ _____ _   _ _____ \n     *    | \ | | / _ \ |  \/  ||  ___|   ___    /  ___|_   _/ _ \_   _| | | /  ___|\n     *    |  \| |/ /_\ \| .  . || |__    ( _ )   \ `--.  | |/ /_\ \| | | | | \ `--. \n     *    | . ` ||  _  || |\/| ||  __|   / _ \/\  `--. \ | ||  _  || | | | | |`--. \\n     *    | |\  || | | || |  | || |___  | (_>  < /\__/ / | || | | || | | |_| /\__/ /\n     *    \_| \_/\_| |_/\_|  |_/\____/   \___/\/ \____/  \_/\_| |_/\_/  \___/\____/ \n     *                                                                              \n     *                                                                              \n     */\n    \n    function getName(uint8 col, uint8 row) public constant returns(string)\n    {\n    	return tiles[col][row].name; // no harm if col,row are invalid\n    }\n    \n    // change from v0.9 - event emission added\n    function setName(uint8 col, uint8 row, string _n) public\n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 50;  \n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != msg.sender)\n    	{\n    		whathappened = 51;\n    		return;\n    	}\n    	tile.name = _n;\n    	TileChanged(col,row);\n    	whathappened = 52;\n    	return;\n    }\n    \n    function getStatus(uint8 col, uint8 row) public constant returns(string)\n    {\n    	return tiles[col][row].status; // no harm if col,row are invalid\n    }\n    \n    // change from v0.9 - incoming money sent to creator, event emissions added\n    function setStatus(uint8 col, uint8 row, string _s) public // setting status costs 1 eth to prevent spam\n    {\n    	if(msg.value == 0)	// the only situation where we don't refund money.\n    	{\n    		whathappened = 40;\n    		return;\n    	}\n    	if(msg.value != 1000000000000000000) \n    	{\n    		msg.sender.send(msg.value); 		// return their money\n    		whathappened = 41;\n    		return;\n    	}\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		msg.sender.send(msg.value); 		// return their money\n    		whathappened = 42;\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != msg.sender)\n    	{\n    		msg.sender.send(msg.value); 		// return their money\n    		whathappened = 43;\n    		return;\n    	}\n    	tile.status = _s;\n    	creator.send(msg.value);\n    	TileChanged(col,row);\n    	whathappened = 44;\n    	return;\n    }\n    \n    /***\n     *    ______ ___  _________  ________ _   _ _____            ___________ _____ _____ _____ _   _ _____ \n     *    |  ___/ _ \ | ___ \  \/  |_   _| \ | |  __ \   ___    |  ___|  _  \_   _|_   _|_   _| \ | |  __ \\n     *    | |_ / /_\ \| |_/ / .  . | | | |  \| | |  \/  ( _ )   | |__ | | | | | |   | |   | | |  \| | |  \/\n     *    |  _||  _  ||    /| |\/| | | | | . ` | | __   / _ \/\ |  __|| | | | | |   | |   | | | . ` | | __ \n     *    | |  | | | || |\ \| |  | |_| |_| |\  | |_\ \ | (_>  < | |___| |/ / _| |_  | |  _| |_| |\  | |_\ \\n     *    \_|  \_| |_/\_| \_\_|  |_/\___/\_| \_/\____/  \___/\/ \____/|___/  \___/  \_/  \___/\_| \_/\____/\n     *                                                                                                     \n     */\n    \n    // change from v0.9 - getLastFarm added\n    function getLastFarm(uint8 col, uint8 row) public constant returns (uint)\n    {\n    	return tiles[col][row].lastfarm;\n    }\n    \n    // changes from v0.9\n    // added ability to pay to farm more often\n    // added event emission\n    // first block farmed will always be a column, rest are randomized\n    function farmTile(uint8 col, uint8 row) public \n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 30;\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n        if(tile.owner != msg.sender)\n        {\n        	whathappened = 31;\n        	return;\n        }\n        if((block.number - tile.lastfarm) < 2500) // ~12 hours of blocks\n        {\n        	if(msg.value == 0)\n        	{\n        		whathappened = 32;\n        		return;\n        	}	\n        	else if(msg.value != 1000000000000000000)\n        	{	\n        		msg.sender.send(msg.value); // return their money\n        		whathappened = 34;\n        		return;\n        	}\n        	else // they paid 1 ETH\n        	{\n        		creator.send(msg.value);\n        	}	\n        	// If they haven't waited long enough, but they've paid 1 eth, let them farm again.\n        }\n        else\n        {\n        	if(msg.value > 0) // they've waited long enough but also sent money. Return it and continue normally.\n        	{\n        		msg.sender.send(msg.value); // return their money\n        	}\n        }\n        \n        // by this point, they've either waited 2500 blocks or paid 1 ETH\n        bytes32 lastblockhash = block.blockhash(block.number - 1);\n    	for(uint8 i = 0; i < 20; i++)\n    	{\n            tile.blocks.length+=1;\n            if(tile.blocks.length == 1) // The VERY FIRST block, ever for this tile\n            	tile.blocks[tile.blocks.length - 1][0] = 0; // make it a column for easy testing and tutorial\n            else\n            	tile.blocks[tile.blocks.length - 1][0] = int8(getUint8FromByte32(lastblockhash,i) % 32); // which, guaranteed 0-31\n    	    tile.blocks[tile.blocks.length - 1][1] = 0; // x\n    	    tile.blocks[tile.blocks.length - 1][2] = 0; // y\n    	    tile.blocks[tile.blocks.length - 1][3] = -1; // z\n    	    tile.blocks[tile.blocks.length - 1][4] = 0; // color\n    	}\n    	tile.lastfarm = block.number;\n    	TileChanged(col,row);\n    	whathappened = 33;\n    	return;\n    }\n    \n    // change from v0.9 - event emission added\n    function editBlock(uint8 col, uint8 row, uint index, int8[5] _block)  \n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 20;\n    		return;\n    	}\n    	\n    	Tile tile = tiles[col][row];\n        if(tile.owner != msg.sender) // 1. DID THE OWNER SEND THIS MESSAGE?\n        {\n        	whathappened = 21;\n        	return;\n        }\n        if(_block[3] < 0) // 2. IS THE Z LOCATION OF THE BLOCK BELOW ZERO? BLOCKS CANNOT BE HIDDEN\n        {\n        	whathappened = 22;\n        	return;\n        }\n        \n        _block[0] = tile.blocks[index][0]; // can't change the which, so set it to whatever it already was\n\n        int8[24] memory didoccupy = bds.getOccupies(uint8(_block[0]));\n        int8[24] memory wouldoccupy = bds.getOccupies(uint8(_block[0]));\n        \n        for(uint8 b = 0; b < 24; b+=3) // always 8 hexes, calculate the didoccupy\n 		{\n 			 wouldoccupy[b] = wouldoccupy[b]+_block[1];\n 			 wouldoccupy[b+1] = wouldoccupy[b+1]+_block[2];\n 			 if(wouldoccupy[1] % 2 != 0 && wouldoccupy[b+1] % 2 == 0) // if anchor y is odd and this hex y is even, (SW NE beam goes 11,`2`2,23,`3`4,35,`4`6,47,`5`8  ` = x value incremented by 1. Same applies to SW NE beam from 01,12,13,24,25,36,37,48)\n 				 wouldoccupy[b] = wouldoccupy[b]+1;  			   // then offset x by +1\n 			 wouldoccupy[b+2] = wouldoccupy[b+2]+_block[3];\n 			 \n 			 didoccupy[b] = didoccupy[b]+tile.blocks[index][1];\n 			 didoccupy[b+1] = didoccupy[b+1]+tile.blocks[index][2];\n 			 if(didoccupy[1] % 2 != 0 && didoccupy[b+1] % 2 == 0) // if anchor y and this hex y are both odd,\n 				 didoccupy[b] = didoccupy[b]+1; 					 // then offset x by +1\n       		didoccupy[b+2] = didoccupy[b+2]+tile.blocks[index][3];\n 		}\n        \n        if(!isValidLocation(col,row,_block, wouldoccupy))\n        {\n        	return; // whathappened is already set\n        }\n        \n        // EVERYTHING CHECKED OUT, WRITE OR OVERWRITE THE HEXES IN OCCUPADO\n        \n      	if(tile.blocks[index][3] >= 0) // If the previous z was greater than 0 (i.e. not hidden) ...\n     	{\n         	for(uint8 l = 0; l < 24; l+=3) // loop 8 times,find the previous occupado entries and overwrite them\n         	{\n         		for(uint o = 0; o < tile.occupado.length; o++)\n         		{\n         			if(didoccupy[l] == tile.occupado[o][0] && didoccupy[l+1] == tile.occupado[o][1] && didoccupy[l+2] == tile.occupado[o][2]) // x,y,z equal?\n         			{\n         				tile.occupado[o][0] = wouldoccupy[l]; // found it. Overwrite it\n         				tile.occupado[o][1] = wouldoccupy[l+1];\n         				tile.occupado[o][2] = wouldoccupy[l+2];\n         			}\n         		}\n         	}\n     	}\n     	else // previous block was hidden\n     	{\n     		for(uint8 ll = 0; ll < 24; ll+=3) // add the 8 new hexes to occupado\n         	{\n     			tile.occupado.length++;\n     			tile.occupado[tile.occupado.length-1][0] = wouldoccupy[ll];\n     			tile.occupado[tile.occupado.length-1][1] = wouldoccupy[ll+1];\n     			tile.occupado[tile.occupado.length-1][2] = wouldoccupy[ll+2];\n         	}\n     	}\n     	tile.blocks[index] = _block;\n     	TileChanged(col,row);\n    	return;\n    }\n       \n    function getBlocks(uint8 col, uint8 row) public constant returns (int8[5][])\n    {\n    	return tiles[col][row].blocks; // no harm if col,row are invalid\n    }\n   \n    /***\n     *     _________________ ___________  _____ \n     *    |  _  |  ___|  ___|  ___| ___ \/  ___|\n     *    | | | | |_  | |_  | |__ | |_/ /\ `--. \n     *    | | | |  _| |  _| |  __||    /  `--. \\n     *    \ \_/ / |   | |   | |___| |\ \ /\__/ /\n     *     \___/\_|   \_|   \____/\_| \_|\____/ \n     *                                          \n     */\n    // change from v0.9 - event emission added and .push() used instead of array.length++ notation\n    function makeOffer(uint8 col, uint8 row)\n    {\n    	if(msg.value == 0) // checking this first means that we will ALWAYS need to return money on any other failure\n    	{\n    		whathappened = 1;\n    		return;\n    	}	// do nothing, just return\n    	\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 2;\n    		msg.sender.send(msg.value); 		// return their money\n    		return;\n    	}\n    	\n    	Tile tile = tiles[col][row];\n    	if(tile.owner == address(0x0000000000000000000000000000000000000000))			// if UNOWNED\n    	{	  \n    		if(msg.value != 1000000000000000000 || mer.getElevation(col,row) < 125)	// 1 ETH is the starting value. If not return; // Also, if below sea level, return. \n    		{\n    			msg.sender.send(msg.value); 	 									// return their money\n    			whathappened = 3;\n    			return;\n    		}\n    		else\n    		{	\n    			creator.send(msg.value);     		 								// this was a valid offer, send money to contract creator\n    			tile.owner = msg.sender;  								// set tile owner to the buyer\n    			TileChanged(col,row);\n    			whathappened = 4;\n    			return;\n    		}\n    	}	\n    	else 																		// if already OWNED\n    	{\n    		if(tile.owner == msg.sender || msg.value < 10000000000000000 || msg.value > 1000000000000000000000000 || tile.offerers.length >= 10 ) // trying to make an offer on their own tile. or the offer list is full (10 max) or the value is out of range (.01 ETH - 1 mil ETH is range)\n    		{\n    			msg.sender.send(msg.value); 	 									// return the money\n    			whathappened = 5;\n    			return;\n    		}\n    		else\n    		{	\n    			for(uint8 i = 0; i < tile.offerers.length; i++)\n    			{\n    				if(tile.offerers[i] == msg.sender) 						// user has already made an offer. Update it and return;\n    				{\n    					msg.sender.send(tile.offers[i]); 					// return their previous money\n    					tile.offers[i] = msg.value; 							// set the new offer\n    					TileChanged(col,row);\n    					whathappened = 6;\n    					return;\n    				}\n    			}	\n    			// the user has not yet made an offer\n    			tile.offerers.push(msg.sender); // make room for 1 more\n    			tile.offers.push(msg.value); // make room for 1 more\n    			TileChanged(col,row);\n    			whathappened = 7;\n    			return;\n    		}\n    	}\n    }\n    \n    // change from v0.9 - deleteOffer created to combine retractOffer, rejectOffer, and removeOffer\n    function deleteOffer(uint8 col, uint8 row, uint8 i, uint amt) // index 0-10\n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 70;\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n    	if(i < 0 || i > (tile.offers.length - 1)) // index oob\n    	{\n    		whathappened = 72;\n    		return;\n    	}	\n    	if(tile.owner == msg.sender || tile.offerers[i] == msg.sender) // If this is the tile owner OR the offerer of the offer at index i, they can delete the request.\n    	{	\n    		if(amt != tile.offers[i]) // to prevent conflicts of offers and deletions by multiple parties, amt must be specified and match\n    		{\n    			whathappened = 74;\n    			return;\n    		}\n    		\n    		//removeOffer(col,row,i);\n    		tile.offerers[i].send(tile.offers[i]); 				// return the money\n    		delete tile.offerers[i];   							// zero out user\n    		delete tile.offers[i];   							// zero out offer\n    		for(uint8 j = i+1; j < tile.offerers.length; j++) 	// reshape arrays after deletion\n    		{\n    			tile.offerers[j-1] = tile.offerers[j];\n    			tile.offers[j-1] = tile.offers[j];\n    		}\n    		tile.offerers.length--;\n    		tile.offers.length--;\n    		// end removeOffer\n    		\n    		TileChanged(col,row);\n        	whathappened = 73;\n    		return;\n    	}\n    	else // permission to delete denied\n    	{\n    		whathappened = 71;\n    		return;\n    	}\n    	\n    }\n    \n    // change from v0.9 - added amt check and event emission\n    function acceptOffer(uint8 col, uint8 row, uint8 i, uint amt) // accepts the offer at index (1-10)\n    {\n    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n    	{\n    		whathappened = 80;\n    		return;\n    	}\n    	\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != msg.sender) // only the owner can reject offers\n    	{\n    		whathappened = 81;\n    		return;\n    	}\n    	if(i < 0 || i > (tile.offers.length - 1)) // index oob\n    	{\n    		whathappened = 82;\n    		return;\n    	}	\n    	uint offeramount = tile.offers[i];\n    	if(amt != offeramount) // to prevent conflicts of offers and deletions by multiple parties, amt must be specified and match\n		{\n			whathappened = 84;\n			return;\n		}\n    	uint housecut = offeramount / 10;\n    	creator.send(housecut);\n    	tile.owner.send(offeramount-housecut); // send offer money to oldowner\n    	tile.owner = tile.offerers[i]; // new owner is the offerer\n    	for(uint8 j = 0; j < tile.offerers.length; j++) // return all the other offerers' offer money\n    	{\n    		if(j != i) // don't return money for the purchaser\n    			tile.offerers[j].send(tile.offers[j]);\n    	}\n    	delete tile.offerers; // delete all offerers\n    	delete tile.offers; // delete all offers\n    	TileChanged(col,row);\n    	whathappened = 83;\n    	return;\n    }\n    \n    function getOfferers(uint8 col, uint8 row) constant returns (address[])\n    {\n    	return tiles[col][row].offerers; // no harm if col,row are invalid\n    }\n    \n    function getOffers(uint8 col, uint8 row) constant returns (uint[])\n    {\n    	return tiles[col][row].offers; // no harm if col,row are invalid\n    }\n    \n    function isOOB(uint8 col, uint8 row) private constant returns (bool)\n    {\n    	if(col < 0 || col > (mapsize-1) || row < 0 || row > (mapsize-1))\n    		return true; // is out of bounds\n    }\n    \n    /***\n     *     _   _ _____ _____ _     _____ _______   __\n     *    | | | |_   _|_   _| |   |_   _|_   _\ \ / /\n     *    | | | | | |   | | | |     | |   | |  \ V / \n     *    | | | | | |   | | | |     | |   | |   \ /  \n     *    | |_| | | |  _| |_| |_____| |_  | |   | |  \n     *     \___/  \_/  \___/\_____/\___/  \_/   \_/  \n     *                                               \n     */\n    \n    // changed from v0.9, but unused, irrelevant\n    function blockHexCoordsValid(int8 x, int8 y) private constant returns (bool)\n    {\n    	uint8 absx;\n		uint8 absy;\n		if(x < 0)\n			absx = uint8(x*-1);\n		else\n			absx = uint8(x);\n		if(y < 0)\n			absy = uint8(y*-1);\n		else\n			absy = uint8(y);\n    	\n    	if(absy <= 33) // middle rectangle\n    	{\n    		if(y % 2 != 0 ) // odd\n    		{\n    			if(-50 <= x && x <= 49)\n    				return true;\n    		}\n    		else // even\n    		{\n    			if(absx <= 49)\n    				return true;\n    		}	\n    	}	\n    	else\n    	{	\n    		if((y >= 0 && x >= 0) || (y < 0 && x > 0)) // first or 4th quadrants\n    		{\n    			if(y % 2 != 0 ) // odd\n    			{\n    				if (((absx*2) + (absy*3)) <= 198)\n    					return true;\n    			}	\n    			else	// even\n    			{\n    				if ((((absx+1)*2) + ((absy-1)*3)) <= 198)\n    					return true;\n    			}\n    		}\n    		else\n    		{	\n    			if(y % 2 == 0 ) // even\n    			{\n    				if (((absx*2) + (absy*3)) <= 198)\n    					return true;\n    			}	\n    			else	// odd\n    			{\n    				if ((((absx+1)*2) + ((absy-1)*3)) <= 198)\n    					return true;\n    			}\n    		}\n    	}\n    	return false;\n    }\n    \n    // changed from v0.9, but unused, irrelevant\n    function isValidLocation(uint8 col, uint8 row, int8[5] _block, int8[24] wouldoccupy) private constant returns (bool)\n    {\n    	bool touches;\n    	Tile tile = tiles[col][row]; // since this is a private method, we don't need to check col,row validity\n    	\n        for(uint8 b = 0; b < 24; b+=3) // always 8 hexes, calculate the wouldoccupy and the didoccupy\n       	{\n       		if(!blockHexCoordsValid(wouldoccupy[b], wouldoccupy[b+1])) // 3. DO ANY OF THE PROPOSED HEXES FALL OUTSIDE OF THE TILE? \n      		{\n       			whathappened = 10;\n      			return false;\n      		}\n       		for(uint o = 0; o < tile.occupado.length; o++)  // 4. DO ANY OF THE PROPOSED HEXES CONFLICT WITH ENTRIES IN OCCUPADO? \n          	{\n      			if(wouldoccupy[b] == tile.occupado[o][0] && wouldoccupy[b+1] == tile.occupado[o][1] && wouldoccupy[b+2] == tile.occupado[o][2]) // do the x,y,z entries of each match?\n      			{\n      				whathappened = 11;\n      				return false; // this hex conflicts. The proposed block does not avoid overlap. Return false immediately.\n      			}\n          	}\n      		if(touches == false && wouldoccupy[b+2] == 0)  // 5. DO ANY OF THE BLOCKS TOUCH ANOTHER? (GROUND ONLY FOR NOW)\n      		{\n      			touches = true; // once true, always true til the end of this method. We must keep looping to check all the hexes for conflicts and tile boundaries, though, so we can't return true here.\n      		}	\n       	}\n        \n        // now if we're out of the loop and here, there were no conflicts and the block was found to be in the tile boundary.\n        // touches may be true or false, so we need to check \n          \n        if(touches == false)  // 6. NONE OF THE OCCUPY BLOCKS TOUCHED THE GROUND. BUT MAYBE THEY TOUCH ANOTHER BLOCK?\n  		{\n          	int8[48] memory attachesto = bds.getAttachesto(uint8(_block[0]));\n          	for(uint8 a = 0; a < 48 && !touches; a+=3) // always 8 hexes, calculate the wouldoccupy and the didoccupy\n          	{\n          		if(attachesto[a] == 0 && attachesto[a+1] == 0 && attachesto[a+2] == 0) // there are no more attachestos available, break (0,0,0 signifies end)\n          			break;\n          		//attachesto[a] = attachesto[a]+_block[1];\n          		attachesto[a+1] = attachesto[a+1]+_block[2];\n           		if(attachesto[1] % 2 != 0 && attachesto[a+1] % 2 == 0) // (for attachesto, anchory is the same as for occupies, but the z is different. Nothing to worry about)\n           			attachesto[a] = attachesto[a]+1;  			       // then offset x by +1\n           		//attachesto[a+2] = attachesto[a+2]+_block[3];\n           		for(o = 0; o < tile.occupado.length && !touches; o++)\n           		{\n           			if((attachesto[a]+_block[1]) == tile.occupado[o][0] && attachesto[a+1] == tile.occupado[o][1] && (attachesto[a+2]+_block[3]) == tile.occupado[o][2]) // a valid attachesto found in occupado?\n           			{\n           				whathappened = 12;\n           				return true; // in bounds, didn't conflict and now touches is true. All good. Return.\n           			}\n           		}\n          	}\n          	whathappened = 13;\n          	return false; \n  		}\n        else // touches was true by virtue of a z = 0 above (touching the ground). Return true;\n        {\n        	whathappened = 14;\n        	return true;\n        }	\n    }  \n\n    // changed from v0.9, but unused, irrelevant\n    function getUint8FromByte32(bytes32 _b32, uint8 byteindex) public constant returns(uint8) {\n    	uint numdigits = 64;\n    	uint base = 16;\n    	uint digitsperbyte = 2;\n    	uint buint = uint(_b32);\n    	//uint upperpowervar = 16 ** (numdigits - (byteindex*2)); 		// @i=0 upperpowervar=16**64 (SEE EXCEPTION BELOW), @i=1 upperpowervar=16**62, @i upperpowervar=16**60\n    	uint lowerpowervar = base ** (numdigits - digitsperbyte - (byteindex*digitsperbyte));		// @i=0 upperpowervar=16**62, @i=1 upperpowervar=16**60, @i upperpowervar=16**58\n    	uint postheadchop;\n    	if(byteindex == 0)\n    		postheadchop = buint; 										//for byteindex 0, buint is just the input number. 16^64 is out of uint range, so this exception has to be made.\n    	else\n    		postheadchop = buint % (base ** (numdigits - (byteindex*digitsperbyte))); // @i=0 _b32=a1b2c3d4... postheadchop=a1b2c3d4, @i=1 postheadchop=b2c3d4, @i=2 postheadchop=c3d4\n    	return uint8((postheadchop - (postheadchop % lowerpowervar)) / lowerpowervar);\n    }\n    \n    uint8 whathappened;\n    function getWhatHappened() public constant returns (uint8)\n    {\n    	return whathappened;\n    }\n    \n   /**********\n   Standard lock-kill methods // added from v0.9\n   **********/\n   bool locked;\n   function setLocked()\n   {\n	   locked = true;\n   }\n   function getLocked() public constant returns (bool)\n   {\n	   return locked;\n   }\n   function kill()\n   { \n       if (!locked && msg.sender == creator)\n           suicide(creator);  // kills this contract and sends remaining funds back to creator\n   }\n}\n//                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    \n",1,
429088,0x07307d0b136a79bac718f43388aed706389c4588,FALSE,FALSE,"// String Utils v0.1\n\n/// @title String Utils - String utility functions\n/// @author Piper Merriam - \nlibrary StringLib {\n    /*\n     *  Address: 0x443b53559d337277373171280ec57029718203fb\n     */\n\n    /// @dev Converts an unsigned integert to its string representation.\n    /// @param v The number to be converted.\n    function uintToBytes(uint v) constant returns (bytes32 ret) {\n        if (v == 0) {\n            ret = '0';\n        }\n        else {\n            while (v > 0) {\n                ret = bytes32(uint(ret) / (2 ** 8));\n                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\n                v /= 10;\n            }\n        }\n        return ret;\n    }\n\n    /// @dev Converts a numeric string to it's unsigned integer representation.\n    /// @param v The string to be converted.\n    function bytesToUInt(bytes32 v) constant returns (uint ret) {\n        if (v == 0x0) {\n            throw;\n        }\n\n        uint digit;\n\n        for (uint i = 0; i < 32; i++) {\n            digit = uint((uint(v) / (2 ** (8 * (31 - i)))) & 0xff);\n            if (digit == 0) {\n                break;\n            }\n            else if (digit < 48 || digit > 57) {\n                throw;\n            }\n            ret *= 10;\n            ret += (digit - 48);\n        }\n        return ret;\n    }\n}\n\n\n// Accounting v0.1 (not the same as the 0.1 release of this library)\n\n/// @title Accounting Lib - Accounting utilities\n/// @author Piper Merriam - \nlibrary AccountingLib {\n        /*\n         *  Address: 0x7de615d8a51746a9f10f72a593fb5b3718dc3d52\n         */\n        struct Bank {\n            mapping (address => uint) accountBalances;\n        }\n\n        /// @dev Low level method for adding funds to an account.  Protects against overflow.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be added to.\n        /// @param value The amount that should be added to the account.\n        function addFunds(Bank storage self, address accountAddress, uint value) public {\n                if (self.accountBalances[accountAddress] + value < self.accountBalances[accountAddress]) {\n                        // Prevent Overflow.\n                        throw;\n                }\n                self.accountBalances[accountAddress] += value;\n        }\n\n        event _Deposit(address indexed _from, address indexed accountAddress, uint value);\n        /// @dev Function wrapper around the _Deposit event so that it can be used by contracts.  Can be used to log a deposit to an account.\n        /// @param _from The address that deposited the funds.\n        /// @param accountAddress The address of the account the funds were added to.\n        /// @param value The amount that was added to the account.\n        function Deposit(address _from, address accountAddress, uint value) public {\n            _Deposit(_from, accountAddress, value);\n        }\n\n\n        /// @dev Safe function for depositing funds.  Returns boolean for whether the deposit was successful\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be added to.\n        /// @param value The amount that should be added to the account.\n        function deposit(Bank storage self, address accountAddress, uint value) public returns (bool) {\n                addFunds(self, accountAddress, value);\n                return true;\n        }\n\n        event _Withdrawal(address indexed accountAddress, uint value);\n\n        /// @dev Function wrapper around the _Withdrawal event so that it can be used by contracts.  Can be used to log a withdrawl from an account.\n        /// @param accountAddress The address of the account the funds were withdrawn from.\n        /// @param value The amount that was withdrawn to the account.\n        function Withdrawal(address accountAddress, uint value) public {\n            _Withdrawal(accountAddress, value);\n        }\n\n        event _InsufficientFunds(address indexed accountAddress, uint value, uint balance);\n\n        /// @dev Function wrapper around the _InsufficientFunds event so that it can be used by contracts.  Can be used to log a failed withdrawl from an account.\n        /// @param accountAddress The address of the account the funds were to be withdrawn from.\n        /// @param value The amount that was attempted to be withdrawn from the account.\n        /// @param balance The current balance of the account.\n        function InsufficientFunds(address accountAddress, uint value, uint balance) public {\n            _InsufficientFunds(accountAddress, value, balance);\n        }\n\n        /// @dev Low level method for removing funds from an account.  Protects against underflow.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be deducted from.\n        /// @param value The amount that should be deducted from the account.\n        function deductFunds(Bank storage self, address accountAddress, uint value) public {\n                /*\n                 *  Helper function that should be used for any reduction of\n                 *  account funds.  It has error checking to prevent\n                 *  underflowing the account balance which would be REALLY bad.\n                 */\n                if (value > self.accountBalances[accountAddress]) {\n                        // Prevent Underflow.\n                        throw;\n                }\n                self.accountBalances[accountAddress] -= value;\n        }\n\n        /// @dev Safe function for withdrawing funds.  Returns boolean for whether the deposit was successful as well as sending the amount in ether to the account address.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be withdrawn from.\n        /// @param value The amount that should be withdrawn from the account.\n        function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (self.accountBalances[accountAddress] >= value) {\n                        deductFunds(self, accountAddress, value);\n                        if (!accountAddress.send(value)) {\n                                // Potentially sending money to a contract that\n                                // has a fallback function.  So instead, try\n                                // tranferring the funds with the call api.\n                                if (!accountAddress.call.value(value)()) {\n                                        // Revert the entire transaction.  No\n                                        // need to destroy the funds.\n                                        throw;\n                                }\n                        }\n                        return true;\n                }\n                return false;\n        }\n}\n\n// Grove v0.3 (not the same as the 0.3 release of this library)\n\n\n/// @title GroveLib - Library for queriable indexed ordered data.\n/// @author PiperMerriam - \nlibrary GroveLib {\n        /*\n         *  Indexes for ordered data\n         *\n         *  Address: 0x920c890a90db8fba7604864b0cf38ee667331323\n         */\n        struct Index {\n                bytes32 root;\n                mapping (bytes32 => Node) nodes;\n        }\n\n        struct Node {\n                bytes32 id;\n                int value;\n                bytes32 parent;\n                bytes32 left;\n                bytes32 right;\n                uint height;\n        }\n\n        function max(uint a, uint b) internal returns (uint) {\n            if (a >= b) {\n                return a;\n            }\n            return b;\n        }\n\n        /*\n         *  Node getters\n         */\n        /// @dev Retrieve the unique identifier for the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeId(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].id;\n        }\n\n        /// @dev Retrieve the value for the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeValue(Index storage index, bytes32 id) constant returns (int) {\n            return index.nodes[id].value;\n        }\n\n        /// @dev Retrieve the height of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeHeight(Index storage index, bytes32 id) constant returns (uint) {\n            return index.nodes[id].height;\n        }\n\n        /// @dev Retrieve the parent id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeParent(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].parent;\n        }\n\n        /// @dev Retrieve the left child id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeLeftChild(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].left;\n        }\n\n        /// @dev Retrieve the right child id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeRightChild(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].right;\n        }\n\n        /// @dev Retrieve the node id of the next node in the tree.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getPreviousNode(Index storage index, bytes32 id) constant returns (bytes32) {\n            Node storage currentNode = index.nodes[id];\n\n            if (currentNode.id == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node memory child;\n\n            if (currentNode.left != 0x0) {\n                // Trace left to latest child in left tree.\n                child = index.nodes[currentNode.left];\n\n                while (child.right != 0) {\n                    child = index.nodes[child.right];\n                }\n                return child.id;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // Now we trace back up through parent relationships, looking\n                // for a link where the child is the right child of it's\n                // parent.\n                Node storage parent = index.nodes[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.right == child.id) {\n                        return parent.id;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = index.nodes[parent.parent];\n                }\n            }\n\n            // This is the first node, and has no previous node.\n            return 0x0;\n        }\n\n        /// @dev Retrieve the node id of the previous node in the tree.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNextNode(Index storage index, bytes32 id) constant returns (bytes32) {\n            Node storage currentNode = index.nodes[id];\n\n            if (currentNode.id == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node memory child;\n\n            if (currentNode.right != 0x0) {\n                // Trace right to earliest child in right tree.\n                child = index.nodes[currentNode.right];\n\n                while (child.left != 0) {\n                    child = index.nodes[child.left];\n                }\n                return child.id;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // if the node is the left child of it's parent, then the\n                // parent is the next one.\n                Node storage parent = index.nodes[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.left == child.id) {\n                        return parent.id;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = index.nodes[parent.parent];\n                }\n\n                // Now we need to trace all the way up checking to see if any parent is the \n            }\n\n            // This is the final node.\n            return 0x0;\n        }\n\n\n        /// @dev Updates or Inserts the id into the index at its appropriate location based on the value provided.\n        /// @param index The index that the node is part of.\n        /// @param id The unique identifier of the data element the index node will represent.\n        /// @param value The value of the data element that represents it's total ordering with respect to other elementes.\n        function insert(Index storage index, bytes32 id, int value) public {\n                if (index.nodes[id].id == id) {\n                    // A node with this id already exists.  If the value is\n                    // the same, then just return early, otherwise, remove it\n                    // and reinsert it.\n                    if (index.nodes[id].value == value) {\n                        return;\n                    }\n                    remove(index, id);\n                }\n\n                uint leftHeight;\n                uint rightHeight;\n\n                bytes32 previousNodeId = 0x0;\n\n                if (index.root == 0x0) {\n                    index.root = id;\n                }\n                Node storage currentNode = index.nodes[index.root];\n\n                // Do insertion\n                while (true) {\n                    if (currentNode.id == 0x0) {\n                        // This is a new unpopulated node.\n                        currentNode.id = id;\n                        currentNode.parent = previousNodeId;\n                        currentNode.value = value;\n                        break;\n                    }\n\n                    // Set the previous node id.\n                    previousNodeId = currentNode.id;\n\n                    // The new node belongs in the right subtree\n                    if (value >= currentNode.value) {\n                        if (currentNode.right == 0x0) {\n                            currentNode.right = id;\n                        }\n                        currentNode = index.nodes[currentNode.right];\n                        continue;\n                    }\n\n                    // The new node belongs in the left subtree.\n                    if (currentNode.left == 0x0) {\n                        currentNode.left = id;\n                    }\n                    currentNode = index.nodes[currentNode.left];\n                }\n\n                // Rebalance the tree\n                _rebalanceTree(index, currentNode.id);\n        }\n\n        /// @dev Checks whether a node for the given unique identifier exists within the given index.\n        /// @param index The index that should be searched\n        /// @param id The unique identifier of the data element to check for.\n        function exists(Index storage index, bytes32 id) constant returns (bool) {\n            return (index.nodes[id].id == id);\n        }\n\n        /// @dev Remove the node for the given unique identifier from the index.\n        /// @param index The index that should be removed\n        /// @param id The unique identifier of the data element to remove.\n        function remove(Index storage index, bytes32 id) public {\n            Node storage replacementNode;\n            Node storage parent;\n            Node storage child;\n            bytes32 rebalanceOrigin;\n\n            Node storage nodeToDelete = index.nodes[id];\n\n            if (nodeToDelete.id != id) {\n                // The id does not exist in the tree.\n                return;\n            }\n\n            if (nodeToDelete.left != 0x0 || nodeToDelete.right != 0x0) {\n                // This node is not a leaf node and thus must replace itself in\n                // it's tree by either the previous or next node.\n                if (nodeToDelete.left != 0x0) {\n                    // This node is guaranteed to not have a right child.\n                    replacementNode = index.nodes[getPreviousNode(index, nodeToDelete.id)];\n                }\n                else {\n                    // This node is guaranteed to not have a left child.\n                    replacementNode = index.nodes[getNextNode(index, nodeToDelete.id)];\n                }\n                // The replacementNode is guaranteed to have a parent.\n                parent = index.nodes[replacementNode.parent];\n\n                // Keep note of the location that our tree rebalancing should\n                // start at.\n                rebalanceOrigin = replacementNode.id;\n\n                // Join the parent of the replacement node with any subtree of\n                // the replacement node.  We can guarantee that the replacement\n                // node has at most one subtree because of how getNextNode and\n                // getPreviousNode are used.\n                if (parent.left == replacementNode.id) {\n                    parent.left = replacementNode.right;\n                    if (replacementNode.right != 0x0) {\n                        child = index.nodes[replacementNode.right];\n                        child.parent = parent.id;\n                    }\n                }\n                if (parent.right == replacementNode.id) {\n                    parent.right = replacementNode.left;\n                    if (replacementNode.left != 0x0) {\n                        child = index.nodes[replacementNode.left];\n                        child.parent = parent.id;\n                    }\n                }\n\n                // Now we replace the nodeToDelete with the replacementNode.\n                // This includes parent/child relationships for all of the\n                // parent, the left child, and the right child.\n                replacementNode.parent = nodeToDelete.parent;\n                if (nodeToDelete.parent != 0x0) {\n                    parent = index.nodes[nodeToDelete.parent];\n                    if (parent.left == nodeToDelete.id) {\n                        parent.left = replacementNode.id;\n                    }\n                    if (parent.right == nodeToDelete.id) {\n                        parent.right = replacementNode.id;\n                    }\n                }\n                else {\n                    // If the node we are deleting is the root node update the\n                    // index root node pointer.\n                    index.root = replacementNode.id;\n                }\n\n                replacementNode.left = nodeToDelete.left;\n                if (nodeToDelete.left != 0x0) {\n                    child = index.nodes[nodeToDelete.left];\n                    child.parent = replacementNode.id;\n                }\n\n                replacementNode.right = nodeToDelete.right;\n                if (nodeToDelete.right != 0x0) {\n                    child = index.nodes[nodeToDelete.right];\n                    child.parent = replacementNode.id;\n                }\n            }\n            else if (nodeToDelete.parent != 0x0) {\n                // The node being deleted is a leaf node so we only erase it's\n                // parent linkage.\n                parent = index.nodes[nodeToDelete.parent];\n\n                if (parent.left == nodeToDelete.id) {\n                    parent.left = 0x0;\n                }\n                if (parent.right == nodeToDelete.id) {\n                    parent.right = 0x0;\n                }\n\n                // keep note of where the rebalancing should begin.\n                rebalanceOrigin = parent.id;\n            }\n            else {\n                // This is both a leaf node and the root node, so we need to\n                // unset the root node pointer.\n                index.root = 0x0;\n            }\n\n            // Now we zero out all of the fields on the nodeToDelete.\n            nodeToDelete.id = 0x0;\n            nodeToDelete.value = 0;\n            nodeToDelete.parent = 0x0;\n            nodeToDelete.left = 0x0;\n            nodeToDelete.right = 0x0;\n\n            // Walk back up the tree rebalancing\n            if (rebalanceOrigin != 0x0) {\n                _rebalanceTree(index, rebalanceOrigin);\n            }\n        }\n\n        bytes2 constant GT = "">"";\n        bytes2 constant LT = ""<"";\n        bytes2 constant GTE = "">="";\n        bytes2 constant LTE = ""<="";\n        bytes2 constant EQ = ""=="";\n\n        function _compare(int left, bytes2 operator, int right) internal returns (bool) {\n            if (operator == GT) {\n                return (left > right);\n            }\n            if (operator == LT) {\n                return (left < right);\n            }\n            if (operator == GTE) {\n                return (left >= right);\n            }\n            if (operator == LTE) {\n                return (left <= right);\n            }\n            if (operator == EQ) {\n                return (left == right);\n            }\n\n            // Invalid operator.\n            throw;\n        }\n\n        function _getMaximum(Index storage index, bytes32 id) internal returns (int) {\n                Node storage currentNode = index.nodes[id];\n\n                while (true) {\n                    if (currentNode.right == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = index.nodes[currentNode.right];\n                }\n        }\n\n        function _getMinimum(Index storage index, bytes32 id) internal returns (int) {\n                Node storage currentNode = index.nodes[id];\n\n                while (true) {\n                    if (currentNode.left == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = index.nodes[currentNode.left];\n                }\n        }\n\n\n        /** @dev Query the index for the edge-most node that satisfies the\n         *  given query.  For >, >=, and ==, this will be the left-most node\n         *  that satisfies the comparison.  For < and <= this will be the\n         *  right-most node that satisfies the comparison.\n         */\n        /// @param index The index that should be queried\n        /** @param operator One of '>', '>=', '<', '<=', '==' to specify what\n         *  type of comparison operator should be used.\n         */\n        function query(Index storage index, bytes2 operator, int value) public returns (bytes32) {\n                bytes32 rootNodeId = index.root;\n                \n                if (rootNodeId == 0x0) {\n                    // Empty tree.\n                    return 0x0;\n                }\n\n                Node storage currentNode = index.nodes[rootNodeId];\n\n                while (true) {\n                    if (_compare(currentNode.value, operator, value)) {\n                        // We have found a match but it might not be the\n                        // *correct* match.\n                        if ((operator == LT) || (operator == LTE)) {\n                            // Need to keep traversing right until this is no\n                            // longer true.\n                            if (currentNode.right == 0x0) {\n                                return currentNode.id;\n                            }\n                            if (_compare(_getMinimum(index, currentNode.right), operator, value)) {\n                                // There are still nodes to the right that\n                                // match.\n                                currentNode = index.nodes[currentNode.right];\n                                continue;\n                            }\n                            return currentNode.id;\n                        }\n\n                        if ((operator == GT) || (operator == GTE) || (operator == EQ)) {\n                            // Need to keep traversing left until this is no\n                            // longer true.\n                            if (currentNode.left == 0x0) {\n                                return currentNode.id;\n                            }\n                            if (_compare(_getMaximum(index, currentNode.left), operator, value)) {\n                                currentNode = index.nodes[currentNode.left];\n                                continue;\n                            }\n                            return currentNode.id;\n                        }\n                    }\n\n                    if ((operator == LT) || (operator == LTE)) {\n                        if (currentNode.left == 0x0) {\n                            // There are no nodes that are less than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = index.nodes[currentNode.left];\n                        continue;\n                    }\n\n                    if ((operator == GT) || (operator == GTE)) {\n                        if (currentNode.right == 0x0) {\n                            // There are no nodes that are greater than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = index.nodes[currentNode.right];\n                        continue;\n                    }\n\n                    if (operator == EQ) {\n                        if (currentNode.value < value) {\n                            if (currentNode.right == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = index.nodes[currentNode.right];\n                            continue;\n                        }\n\n                        if (currentNode.value > value) {\n                            if (currentNode.left == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = index.nodes[currentNode.left];\n                            continue;\n                        }\n                    }\n                }\n        }\n\n        function _rebalanceTree(Index storage index, bytes32 id) internal {\n            // Trace back up rebalancing the tree and updating heights as\n            // needed..\n            Node storage currentNode = index.nodes[id];\n\n            while (true) {\n                int balanceFactor = _getBalanceFactor(index, currentNode.id);\n\n                if (balanceFactor == 2) {\n                    // Right rotation (tree is heavy on the left)\n                    if (_getBalanceFactor(index, currentNode.left) == -1) {\n                        // The subtree is leaning right so it need to be\n                        // rotated left before the current node is rotated\n                        // right.\n                        _rotateLeft(index, currentNode.left);\n                    }\n                    _rotateRight(index, currentNode.id);\n                }\n\n                if (balanceFactor == -2) {\n                    // Left rotation (tree is heavy on the right)\n                    if (_getBalanceFactor(index, currentNode.right) == 1) {\n                        // The subtree is leaning left so it need to be\n                        // rotated right before the current node is rotated\n                        // left.\n                        _rotateRight(index, currentNode.right);\n                    }\n                    _rotateLeft(index, currentNode.id);\n                }\n\n                if ((-1 <= balanceFactor) && (balanceFactor <= 1)) {\n                    _updateNodeHeight(index, currentNode.id);\n                }\n\n                if (currentNode.parent == 0x0) {\n                    // Reached the root which may be new due to tree\n                    // rotation, so set it as the root and then break.\n                    break;\n                }\n\n                currentNode = index.nodes[currentNode.parent];\n            }\n        }\n\n        function _getBalanceFactor(Index storage index, bytes32 id) internal returns (int) {\n                Node storage node = index.nodes[id];\n\n                return int(index.nodes[node.left].height) - int(index.nodes[node.right].height);\n        }\n\n        function _updateNodeHeight(Index storage index, bytes32 id) internal {\n                Node storage node = index.nodes[id];\n\n                node.height = max(index.nodes[node.left].height, index.nodes[node.right].height) + 1;\n        }\n\n        function _rotateLeft(Index storage index, bytes32 id) internal {\n            Node storage originalRoot = index.nodes[id];\n\n            if (originalRoot.right == 0x0) {\n                // Cannot rotate left if there is no right originalRoot to rotate into\n                // place.\n                throw;\n            }\n\n            // The right child is the new root, so it gets the original\n            // `originalRoot.parent` as it's parent.\n            Node storage newRoot = index.nodes[originalRoot.right];\n            newRoot.parent = originalRoot.parent;\n\n            // The original root needs to have it's right child nulled out.\n            originalRoot.right = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If there is a parent node, it needs to now point downward at\n                // the newRoot which is rotating into the place where `node` was.\n                Node storage parent = index.nodes[originalRoot.parent];\n\n                // figure out if we're a left or right child and have the\n                // parent point to the new node.\n                if (parent.left == originalRoot.id) {\n                    parent.left = newRoot.id;\n                }\n                if (parent.right == originalRoot.id) {\n                    parent.right = newRoot.id;\n                }\n            }\n\n\n            if (newRoot.left != 0) {\n                // If the new root had a left child, that moves to be the\n                // new right child of the original root node\n                Node storage leftChild = index.nodes[newRoot.left];\n                originalRoot.right = leftChild.id;\n                leftChild.parent = originalRoot.id;\n            }\n\n            // Update the newRoot's left node to point at the original node.\n            originalRoot.parent = newRoot.id;\n            newRoot.left = originalRoot.id;\n\n            if (newRoot.parent == 0x0) {\n                index.root = newRoot.id;\n            }\n\n            // TODO: are both of these updates necessary?\n            _updateNodeHeight(index, originalRoot.id);\n            _updateNodeHeight(index, newRoot.id);\n        }\n\n        function _rotateRight(Index storage index, bytes32 id) internal {\n            Node storage originalRoot = index.nodes[id];\n\n            if (originalRoot.left == 0x0) {\n                // Cannot rotate right if there is no left node to rotate into\n                // place.\n                throw;\n            }\n\n            // The left child is taking the place of node, so we update it's\n            // parent to be the original parent of the node.\n            Node storage newRoot = index.nodes[originalRoot.left];\n            newRoot.parent = originalRoot.parent;\n\n            // Null out the originalRoot.left\n            originalRoot.left = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If the node has a parent, update the correct child to point\n                // at the newRoot now.\n                Node storage parent = index.nodes[originalRoot.parent];\n\n                if (parent.left == originalRoot.id) {\n                    parent.left = newRoot.id;\n                }\n                if (parent.right == originalRoot.id) {\n                    parent.right = newRoot.id;\n                }\n            }\n\n            if (newRoot.right != 0x0) {\n                Node storage rightChild = index.nodes[newRoot.right];\n                originalRoot.left = newRoot.right;\n                rightChild.parent = originalRoot.id;\n            }\n\n            // Update the new root's right node to point to the original node.\n            originalRoot.parent = newRoot.id;\n            newRoot.right = originalRoot.id;\n\n            if (newRoot.parent == 0x0) {\n                index.root = newRoot.id;\n            }\n\n            // Recompute heights.\n            _updateNodeHeight(index, originalRoot.id);\n            _updateNodeHeight(index, newRoot.id);\n        }\n}\n\n\n// Resource Pool v0.1.0 (has been modified from the main released version of this library)\n\n\n// @title ResourcePoolLib - Library for a set of resources that are ready for use.\n// @author Piper Merriam \nlibrary ResourcePoolLib {\n        /*\n         *  Address: 0xd6bbd16eaa6ea3f71a458bffc64c0ca24fc8c58e\n         */\n        struct Pool {\n                uint rotationDelay;\n                uint overlapSize;\n                uint freezePeriod;\n\n                uint _id;\n\n                GroveLib.Index generationStart;\n                GroveLib.Index generationEnd;\n\n                mapping (uint => Generation) generations;\n                mapping (address => uint) bonds;\n        }\n\n        /*\n         * Generations have the following properties.\n         *\n         * 1. Must always overlap by a minimum amount specified by MIN_OVERLAP.\n         *\n         *    1   2   3   4   5   6   7   8   9   10  11  12  13\n         *    [1:-----------------]\n         *                [4:--------------------->\n         */\n        struct Generation {\n                uint id;\n                uint startAt;\n                uint endAt;\n                address[] members;\n        }\n\n        /// @dev Creates the next generation for the given pool.  All members from the current generation are carried over (with their order randomized).  The current generation will have it's endAt block set.\n        /// @param self The pool to operate on.\n        function createNextGeneration(Pool storage self) public returns (uint) {\n                /*\n                 *  Creat a new pool generation with all of the current\n                 *  generation's members copied over in random order.\n                 */\n                Generation storage previousGeneration = self.generations[self._id];\n\n                self._id += 1;\n                Generation storage nextGeneration = self.generations[self._id];\n                nextGeneration.id = self._id;\n                nextGeneration.startAt = block.number + self.freezePeriod + self.rotationDelay;\n                GroveLib.insert(self.generationStart, StringLib.uintToBytes(nextGeneration.id), int(nextGeneration.startAt));\n\n                if (previousGeneration.id == 0) {\n                        // This is the first generation so we just need to set\n                        // it's `id` and `startAt`.\n                        return nextGeneration.id;\n                }\n\n                // Set the end date for the current generation.\n                previousGeneration.endAt = block.number + self.freezePeriod + self.rotationDelay + self.overlapSize;\n                GroveLib.insert(self.generationEnd, StringLib.uintToBytes(previousGeneration.id), int(previousGeneration.endAt));\n\n                // Now we copy the members of the previous generation over to\n                // the next generation as well as randomizing their order.\n                address[] memory members = previousGeneration.members;\n\n                for (uint i = 0; i < members.length; i++) {\n                    // Pick a *random* index and push it onto the next\n                    // generation's members.\n                    uint index = uint(sha3(block.blockhash(block.number))) % (members.length - nextGeneration.members.length);\n                    nextGeneration.members.length += 1;\n                    nextGeneration.members[nextGeneration.members.length - 1] = members[index];\n\n                    // Then move the member at the last index into the picked\n                    // index's location.\n                    members[index] = members[members.length - 1];\n                }\n\n                return nextGeneration.id;\n        }\n\n        /// @dev Returns the first generation id that fully contains the block window provided.\n        /// @param self The pool to operate on.\n        /// @param leftBound The left bound for the block window (inclusive)\n        /// @param rightBound The right bound for the block window (inclusive)\n        function getGenerationForWindow(Pool storage self, uint leftBound, uint rightBound) constant returns (uint) {\n            // TODO: tests\n                var left = GroveLib.query(self.generationStart, ""<="", int(leftBound));\n\n                if (left != 0x0) {\n                    Generation memory leftCandidate = self.generations[StringLib.bytesToUInt(left)];\n                    if (leftCandidate.startAt <= leftBound && (leftCandidate.endAt >= rightBound || leftCandidate.endAt == 0)) {\n                        return leftCandidate.id;\n                    }\n                }\n\n                var right = GroveLib.query(self.generationEnd, "">="", int(rightBound));\n                if (right != 0x0) {\n                    Generation memory rightCandidate = self.generations[StringLib.bytesToUInt(right)];\n                    if (rightCandidate.startAt <= leftBound && (rightCandidate.endAt >= rightBound || rightCandidate.endAt == 0)) {\n                        return rightCandidate.id;\n                    }\n                }\n\n                return 0;\n        }\n\n        /// @dev Returns the first generation in the future that has not yet started.\n        /// @param self The pool to operate on.\n        function getNextGenerationId(Pool storage self) constant returns (uint) {\n            // TODO: tests\n                var next = GroveLib.query(self.generationStart, "">"", int(block.number));\n                if (next == 0x0) {\n                    return 0;\n                }\n                return StringLib.bytesToUInt(next);\n        }\n\n        /// @dev Returns the first generation that is currently active.\n        /// @param self The pool to operate on.\n        function getCurrentGenerationId(Pool storage self) constant returns (uint) {\n            // TODO: tests\n                var next = GroveLib.query(self.generationEnd, "">"", int(block.number));\n                if (next != 0x0) {\n                    return StringLib.bytesToUInt(next);\n                }\n\n                next = GroveLib.query(self.generationStart, ""<="", int(block.number));\n                if (next != 0x0) {\n                    return StringLib.bytesToUInt(next);\n                }\n                return 0;\n        }\n\n        /*\n         *  Pool membership API\n         */\n        /// @dev Returns a boolean for whether the given address is in the given generation.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address to check membership of\n        /// @param generationId The id of the generation to check.\n        function isInGeneration(Pool storage self, address resourceAddress, uint generationId) constant returns (bool) {\n            // TODO: tests\n            if (generationId == 0) {\n                return false;\n            }\n            Generation memory generation = self.generations[generationId];\n            for (uint i = 0; i < generation.members.length; i++) {\n                if (generation.members[i] == resourceAddress) {\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /// @dev Returns a boolean for whether the given address is in the current generation.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address to check membership of\n        function isInCurrentGeneration(Pool storage self, address resourceAddress) constant returns (bool) {\n            // TODO: tests\n            return isInGeneration(self, resourceAddress, getCurrentGenerationId(self));\n        }\n\n        /// @dev Returns a boolean for whether the given address is in the next queued generation.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address to check membership of\n        function isInNextGeneration(Pool storage self, address resourceAddress) constant returns (bool) {\n            // TODO: tests\n            return isInGeneration(self, resourceAddress, getNextGenerationId(self));\n        }\n\n        /// @dev Returns a boolean for whether the given address is in either the current generation or the next queued generation.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address to check membership of\n        function isInPool(Pool storage self, address resourceAddress) constant returns (bool) {\n            // TODO: tests\n            return (isInCurrentGeneration(self, resourceAddress) || isInNextGeneration(self, resourceAddress));\n        }\n\n        event _AddedToGeneration(address indexed resourceAddress, uint indexed generationId);\n        /// @dev Function to expose the _AddedToGeneration event to contracts.\n        /// @param resourceAddress The address that was added\n        /// @param generationId The id of the generation.\n        function AddedToGeneration(address resourceAddress, uint generationId) public {\n                _AddedToGeneration(resourceAddress, generationId);\n        }\n\n        event _RemovedFromGeneration(address indexed resourceAddress, uint indexed generationId);\n        /// @dev Function to expose the _AddedToGeneration event to contracts.\n        /// @param resourceAddress The address that was removed.\n        /// @param generationId The id of the generation.\n        function RemovedFromGeneration(address resourceAddress, uint generationId) public {\n                _RemovedFromGeneration(resourceAddress, generationId);\n        }\n\n        /// @dev Returns a boolean as to whether the provided address is allowed to enter the pool at this time.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address in question\n        /// @param minimumBond The minimum bond amount that should be required for entry.\n        function canEnterPool(Pool storage self, address resourceAddress, uint minimumBond) constant returns (bool) {\n            /*\n             *  - bond\n             *  - pool is open\n             *  - not already in it.\n             *  - not already left it.\n             */\n            // TODO: tests\n            if (self.bonds[resourceAddress] < minimumBond) {\n                // Insufficient bond balance;\n                return false;\n            }\n\n            if (isInPool(self, resourceAddress)) {\n                // Already in the pool either in the next upcoming generation\n                // or the currently active generation.\n                return false;\n            }\n\n            var nextGenerationId = getNextGenerationId(self);\n            if (nextGenerationId != 0) {\n                var nextGeneration = self.generations[nextGenerationId];\n                if (block.number + self.freezePeriod >= nextGeneration.startAt) {\n                    // Next generation starts too soon.\n                    return false;\n                }\n            }\n\n            return true;\n        }\n\n        /// @dev Adds the address to pool by adding them to the next generation (as well as creating it if it doesn't exist).\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address to be added to the pool\n        /// @param minimumBond The minimum bond amount that should be required for entry.\n        function enterPool(Pool storage self, address resourceAddress, uint minimumBond) public returns (uint) {\n            if (!canEnterPool(self, resourceAddress, minimumBond)) {\n                throw;\n            }\n            uint nextGenerationId = getNextGenerationId(self);\n            if (nextGenerationId == 0) {\n                // No next generation has formed yet so create it.\n                nextGenerationId = createNextGeneration(self);\n            }\n            Generation storage nextGeneration = self.generations[nextGenerationId];\n            // now add the new address.\n            nextGeneration.members.length += 1;\n            nextGeneration.members[nextGeneration.members.length - 1] = resourceAddress;\n            return nextGenerationId;\n        }\n\n        /// @dev Returns a boolean as to whether the provided address is allowed to exit the pool at this time.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address in question\n        function canExitPool(Pool storage self, address resourceAddress) constant returns (bool) {\n            if (!isInCurrentGeneration(self, resourceAddress)) {\n                // Not in the pool.\n                return false;\n            }\n\n            uint nextGenerationId = getNextGenerationId(self);\n            if (nextGenerationId == 0) {\n                // Next generation hasn't been generated yet.\n                return true;\n            }\n\n            if (self.generations[nextGenerationId].startAt - self.freezePeriod <= block.number) {\n                // Next generation starts too soon.\n                return false;\n            }\n\n            // They can leave if they are still in the next generation.\n            // otherwise they have already left it.\n            return isInNextGeneration(self, resourceAddress);\n        }\n\n\n        /// @dev Removes the address from the pool by removing them from the next generation (as well as creating it if it doesn't exist)\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address in question\n        function exitPool(Pool storage self, address resourceAddress) public returns (uint) {\n            if (!canExitPool(self, resourceAddress)) {\n                throw;\n            }\n            uint nextGenerationId = getNextGenerationId(self);\n            if (nextGenerationId == 0) {\n                // No next generation has formed yet so create it.\n                nextGenerationId = createNextGeneration(self);\n            }\n            // Remove them from the generation\n            removeFromGeneration(self, nextGenerationId, resourceAddress);\n            return nextGenerationId;\n        }\n\n        /// @dev Removes the address from a generation's members array. Returns boolean as to whether removal was successful.\n        /// @param self The pool to operate on.\n        /// @param generationId The id of the generation to operate on.\n        /// @param resourceAddress The address to be removed.\n        function removeFromGeneration(Pool storage self, uint generationId, address resourceAddress) public returns (bool){\n            Generation storage generation = self.generations[generationId];\n            // now remove the address\n            for (uint i = 0; i < generation.members.length; i++) {\n                if (generation.members[i] == resourceAddress) {\n                    generation.members[i] = generation.members[generation.members.length - 1];\n                    generation.members.length -= 1;\n                    return true;\n                }\n            }\n            return false;\n        }\n\n        /*\n         *  Bonding\n         */\n\n        /// @dev Subtracts the amount from an account's bond balance.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address of the account\n        /// @param value The value to subtract.\n        function deductFromBond(Pool storage self, address resourceAddress, uint value) public {\n                /*\n                 *  deduct funds from a bond value without risk of an\n                 *  underflow.\n                 */\n                if (value > self.bonds[resourceAddress]) {\n                        // Prevent Underflow.\n                        throw;\n                }\n                self.bonds[resourceAddress] -= value;\n        }\n\n        /// @dev Adds the amount to an account's bond balance.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address of the account\n        /// @param value The value to add.\n        function addToBond(Pool storage self, address resourceAddress, uint value) public {\n                /*\n                 *  Add funds to a bond value without risk of an\n                 *  overflow.\n                 */\n                if (self.bonds[resourceAddress] + value < self.bonds[resourceAddress]) {\n                        // Prevent Overflow\n                        throw;\n                }\n                self.bonds[resourceAddress] += value;\n        }\n\n        /// @dev Withdraws a bond amount from an address's bond account, sending them the corresponding amount in ether.\n        /// @param self The pool to operate on.\n        /// @param resourceAddress The address of the account\n        /// @param value The value to withdraw.\n        function withdrawBond(Pool storage self, address resourceAddress, uint value, uint minimumBond) public {\n                /*\n                 *  Only if you are not in either of the current call pools.\n                 */\n                // Prevent underflow\n                if (value > self.bonds[resourceAddress]) {\n                        throw;\n                }\n\n                // Do a permissions check to be sure they can withdraw the\n                // funds.\n                if (isInPool(self, resourceAddress)) {\n                        if (self.bonds[resourceAddress] - value < minimumBond) {\n                            return;\n                        }\n                }\n\n                deductFromBond(self, resourceAddress, value);\n                if (!resourceAddress.send(value)) {\n                        // Potentially sending money to a contract that\n                        // has a fallback function.  So instead, try\n                        // tranferring the funds with the call api.\n                        if (!resourceAddress.call.gas(msg.gas).value(value)()) {\n                                // Revert the entire transaction.  No\n                                // need to destroy the funds.\n                                throw;\n                        }\n                }\n        }\n}\n\n\ncontract Relay {\n        address operator;\n\n        function Relay() {\n                operator = msg.sender;\n        }\n\n        function relayCall(address contractAddress, bytes4 abiSignature, bytes data) public returns (bool) {\n                if (msg.sender != operator) {\n                        throw;\n                }\n                return contractAddress.call(abiSignature, data);\n        }\n}\n\n\n\n\nlibrary ScheduledCallLib {\n    /*\n     *  Address: 0x5c3623dcef2d5168dbe3e8cc538788cd8912d898\n     */\n    struct CallDatabase {\n        Relay unauthorizedRelay;\n        Relay authorizedRelay;\n\n        bytes32 lastCallKey;\n        bytes lastData;\n        uint lastDataLength;\n        bytes32 lastDataHash;\n\n        ResourcePoolLib.Pool callerPool;\n        GroveLib.Index callIndex;\n\n        AccountingLib.Bank gasBank;\n\n        mapping (bytes32 => Call) calls;\n        mapping (bytes32 => bytes) data_registry;\n\n        mapping (bytes32 => bool) accountAuthorizations;\n    }\n\n    struct Call {\n            address contractAddress;\n            address scheduledBy;\n            uint calledAtBlock;\n            uint targetBlock;\n            uint8 gracePeriod;\n            uint nonce;\n            uint baseGasPrice;\n            uint gasPrice;\n            uint gasUsed;\n            uint gasCost;\n            uint payout;\n            uint fee;\n            address executedBy;\n            bytes4 abiSignature;\n            bool isCancelled;\n            bool wasCalled;\n            bool wasSuccessful;\n            bytes32 dataHash;\n    }\n\n    // The author (Piper Merriam) address.\n    address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n    /*\n     *  Getter methods for `Call` information\n     */\n    function getCallContractAddress(CallDatabase storage self, bytes32 callKey) constant returns (address) {\n            return self.calls[callKey].contractAddress;\n    }\n\n    function getCallScheduledBy(CallDatabase storage self, bytes32 callKey) constant returns (address) {\n            return self.calls[callKey].scheduledBy;\n    }\n\n    function getCallCalledAtBlock(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            return self.calls[callKey].calledAtBlock;\n    }\n\n    function getCallGracePeriod(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            return self.calls[callKey].gracePeriod;\n    }\n\n    function getCallTargetBlock(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            return self.calls[callKey].targetBlock;\n    }\n\n    function getCallBaseGasPrice(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            return self.calls[callKey].baseGasPrice;\n    }\n\n    function getCallGasPrice(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            return self.calls[callKey].gasPrice;\n    }\n\n    function getCallGasUsed(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            return self.calls[callKey].gasUsed;\n    }\n\n    function getCallABISignature(CallDatabase storage self, bytes32 callKey) constant returns (bytes4) {\n            return self.calls[callKey].abiSignature;\n    }\n\n    function checkIfCalled(CallDatabase storage self, bytes32 callKey) constant returns (bool) {\n            return self.calls[callKey].wasCalled;\n    }\n\n    function checkIfSuccess(CallDatabase storage self, bytes32 callKey) constant returns (bool) {\n            return self.calls[callKey].wasSuccessful;\n    }\n\n    function checkIfCancelled(CallDatabase storage self, bytes32 callKey) constant returns (bool) {\n            return self.calls[callKey].isCancelled;\n    }\n\n    function getCallDataHash(CallDatabase storage self, bytes32 callKey) constant returns (bytes32) {\n            return self.calls[callKey].dataHash;\n    }\n\n    function getCallPayout(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            return self.calls[callKey].payout;\n    }\n\n    function getCallFee(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            return self.calls[callKey].fee;\n    }\n\n    /*\n     *  Scheduling Authorization API\n     */\n\n    function addAuthorization(CallDatabase storage self, address schedulerAddress, address contractAddress) public {\n            self.accountAuthorizations[sha3(schedulerAddress, contractAddress)] = true;\n    }\n\n    function removeAuthorization(CallDatabase storage self, address schedulerAddress, address contractAddress) public {\n            self.accountAuthorizations[sha3(schedulerAddress, contractAddress)] = false;\n    }\n\n    function checkAuthorization(CallDatabase storage self, address schedulerAddress, address contractAddress) constant returns (bool) {\n            return self.accountAuthorizations[sha3(schedulerAddress, contractAddress)];\n    }\n\n    /*\n     *  Data Registry API\n     */\n    function getCallData(CallDatabase storage self, bytes32 callKey) constant returns (bytes) {\n            return self.data_registry[self.calls[callKey].dataHash];\n    }\n\n    /*\n     *  API used by Alarm service\n     */\n    // The number of blocks that each caller in the pool has to complete their\n    // call.\n    uint constant CALL_WINDOW_SIZE = 16;\n\n    function getGenerationIdForCall(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            Call call = self.calls[callKey];\n            return ResourcePoolLib.getGenerationForWindow(self.callerPool, call.targetBlock, call.targetBlock + call.gracePeriod);\n    }\n\n    function getDesignatedCaller(CallDatabase storage self, bytes32 callKey, uint blockNumber) constant returns (address) {\n            /*\n             *  Returns the caller from the current call pool who is\n             *  designated as the executor of this call.\n             */\n            Call call = self.calls[callKey];\n            if (blockNumber < call.targetBlock || blockNumber > call.targetBlock + call.gracePeriod) {\n                    // blockNumber not within call window.\n                    return 0x0;\n            }\n\n            // Check if we are in free-for-all window.\n            uint numWindows = call.gracePeriod / CALL_WINDOW_SIZE;\n            uint blockWindow = (blockNumber - call.targetBlock) / CALL_WINDOW_SIZE;\n\n            if (blockWindow + 2 > numWindows) {\n                    // We are within the free-for-all period.\n                    return 0x0;\n            }\n\n            // Lookup the pool that full contains the call window for this\n            // call.\n            uint generationId = ResourcePoolLib.getGenerationForWindow(self.callerPool, call.targetBlock, call.targetBlock + call.gracePeriod);\n            if (generationId == 0) {\n                    // No pool currently in operation.\n                    return 0x0;\n            }\n            var generation = self.callerPool.generations[generationId];\n\n            uint offset = uint(callKey) % generation.members.length;\n            return generation.members[(offset + blockWindow) % generation.members.length];\n    }\n\n    event _AwardedMissedBlockBonus(address indexed fromCaller, address indexed toCaller, uint indexed generationId, bytes32 callKey, uint blockNumber, uint bonusAmount);\n    function AwardedMissedBlockBonus(address fromCaller, address toCaller, uint generationId, bytes32 callKey, uint blockNumber, uint bonusAmount) public {\n        _AwardedMissedBlockBonus(fromCaller, toCaller, generationId, callKey, blockNumber, bonusAmount);\n    }\n\n    function getMinimumBond() constant returns (uint) {\n            return tx.gasprice * block.gaslimit;\n    }\n\n    function doBondBonusTransfer(CallDatabase storage self, address fromCaller, address toCaller) internal returns (uint) {\n            uint bonusAmount = getMinimumBond();\n            uint bondBalance = self.callerPool.bonds[fromCaller];\n\n            // If the bond balance is lower than the award\n            // balance, then adjust the reward amount to\n            // match the bond balance.\n            if (bonusAmount > bondBalance) {\n                    bonusAmount = bondBalance;\n            }\n\n            // Transfer the funds fromCaller => toCaller\n            ResourcePoolLib.deductFromBond(self.callerPool, fromCaller, bonusAmount);\n            ResourcePoolLib.addToBond(self.callerPool, toCaller, bonusAmount);\n\n            return bonusAmount;\n    }\n\n    function awardMissedBlockBonus(CallDatabase storage self, address toCaller, bytes32 callKey) public {\n            var call = self.calls[callKey];\n\n            var generation = self.callerPool.generations[ResourcePoolLib.getGenerationForWindow(self.callerPool, call.targetBlock, call.targetBlock + call.gracePeriod)];\n            uint i;\n            uint bonusAmount;\n            address fromCaller;\n\n            uint numWindows = call.gracePeriod / CALL_WINDOW_SIZE;\n            uint blockWindow = (block.number - call.targetBlock) / CALL_WINDOW_SIZE;\n\n            // Check if we are within the free-for-all period.  If so, we\n            // award from all pool members.\n            if (blockWindow + 2 > numWindows) {\n                    address firstCaller = getDesignatedCaller(self, callKey, call.targetBlock);\n                    for (i = call.targetBlock; i <= call.targetBlock + call.gracePeriod; i += CALL_WINDOW_SIZE) {\n                            fromCaller = getDesignatedCaller(self, callKey, i);\n                            if (fromCaller == firstCaller && i != call.targetBlock) {\n                                    // We have already gone through all of\n                                    // the pool callers so we should break\n                                    // out of the loop.\n                                    break;\n                            }\n                            if (fromCaller == toCaller) {\n                                    continue;\n                            }\n                            bonusAmount = doBondBonusTransfer(self, fromCaller, toCaller);\n\n                            // Log the bonus was awarded.\n                            AwardedMissedBlockBonus(fromCaller, toCaller, generation.id, callKey, block.number, bonusAmount);\n                    }\n                    return;\n            }\n\n            // Special case for single member and empty pools\n            if (generation.members.length < 2) {\n                    return;\n            }\n\n            // Otherwise the award comes from the previous caller.\n            for (i = 0; i < generation.members.length; i++) {\n                    // Find where the member is in the pool and\n                    // award from the previous pool members bond.\n                    if (generation.members[i] == toCaller) {\n                            fromCaller = generation.members[(i + generation.members.length - 1) % generation.members.length];\n\n                            bonusAmount = doBondBonusTransfer(self, fromCaller, toCaller);\n\n                            // Log the bonus was awarded.\n                            AwardedMissedBlockBonus(fromCaller, toCaller, generation.id, callKey, block.number, bonusAmount);\n\n                            // Remove the caller from the next pool.\n                            if (ResourcePoolLib.getNextGenerationId(self.callerPool) == 0) {\n                                    // This is the first address to modify the\n                                    // current pool so we need to setup the next\n                                    // pool.\n                                    ResourcePoolLib.createNextGeneration(self.callerPool);\n                            }\n                            ResourcePoolLib.removeFromGeneration(self.callerPool, ResourcePoolLib.getNextGenerationId(self.callerPool), fromCaller);\n                            return;\n                    }\n            }\n    }\n\n    /*\n     *  Data registration API\n     */\n    event _DataRegistered(bytes32 indexed dataHash);\n    function DataRegistered(bytes32 dataHash) constant {\n        _DataRegistered(dataHash);\n    }\n\n    function registerData(CallDatabase storage self, bytes data) public {\n            self.lastData.length = data.length - 4;\n            if (data.length > 4) {\n                    for (uint i = 0; i < self.lastData.length; i++) {\n                            self.lastData[i] = data[i + 4];\n                    }\n            }\n            self.data_registry[sha3(self.lastData)] = self.lastData;\n            self.lastDataHash = sha3(self.lastData);\n            self.lastDataLength = self.lastData.length;\n    }\n\n    /*\n     *  Call execution API\n     */\n    // This number represents the constant gas cost of the addition\n    // operations that occur in `doCall` that cannot be tracked with\n    // msg.gas.\n    uint constant EXTRA_CALL_GAS = 153321;\n\n    // This number represents the overall overhead involved in executing a\n    // scheduled call.\n    uint constant CALL_OVERHEAD = 120104;\n\n    event _CallExecuted(address indexed executedBy, bytes32 indexed callKey);\n    function CallExecuted(address executedBy, bytes32 callKey) public {\n        _CallExecuted(executedBy, callKey);\n    }\n    event _CallAborted(address indexed executedBy, bytes32 indexed callKey, bytes18 reason);\n    function CallAborted(address executedBy, bytes32 callKey, bytes18 reason) public {\n        _CallAborted(executedBy, callKey, reason);\n    }\n\n    function doCall(CallDatabase storage self, bytes32 callKey, address msgSender) public {\n            uint gasBefore = msg.gas;\n\n            Call storage call = self.calls[callKey];\n\n            if (call.wasCalled) {\n                    // The call has already been executed so don't do it again.\n                    _CallAborted(msg.sender, callKey, ""ALREADY CALLED"");\n                    return;\n            }\n\n            if (call.isCancelled) {\n                    // The call was cancelled so don't execute it.\n                    _CallAborted(msg.sender, callKey, ""CANCELLED"");\n                    return;\n            }\n\n            if (call.contractAddress == 0x0) {\n                    // This call key doesnt map to a registered call.\n                    _CallAborted(msg.sender, callKey, ""UNKNOWN"");\n                    return;\n            }\n\n            if (block.number < call.targetBlock) {\n                    // Target block hasnt happened yet.\n                    _CallAborted(msg.sender, callKey, ""TOO EARLY"");\n                    return;\n            }\n\n            if (block.number > call.targetBlock + call.gracePeriod) {\n                    // The blockchain has advanced passed the period where\n                    // it was allowed to be called.\n                    _CallAborted(msg.sender, callKey, ""TOO LATE"");\n                    return;\n            }\n\n            uint heldBalance = getCallMaxCost(self, callKey);\n\n            if (self.gasBank.accountBalances[call.scheduledBy] < heldBalance) {\n                    // The scheduledBy's account balance is less than the\n                    // current gasLimit and thus potentiall can't pay for\n                    // the call.\n\n                    // Mark it as called since it was.\n                    call.wasCalled = true;\n                    \n                    // Log it.\n                    _CallAborted(msg.sender, callKey, ""INSUFFICIENT_FUNDS"");\n                    return;\n            }\n\n            // Check if this caller is allowed to execute the call.\n            if (self.callerPool.generations[ResourcePoolLib.getCurrentGenerationId(self.callerPool)].members.length > 0) {\n                    address designatedCaller = getDesignatedCaller(self, callKey, block.number);\n                    if (designatedCaller != 0x0 && designatedCaller != msgSender) {\n                            // This call was reserved for someone from the\n                            // bonded pool of callers and can only be\n                            // called by them during this block window.\n                            _CallAborted(msg.sender, callKey, ""WRONG_CALLER"");\n                            return;\n                    }\n\n                    uint blockWindow = (block.number - call.targetBlock) / CALL_WINDOW_SIZE;\n                    if (blockWindow > 0) {\n                            // Someone missed their call so this caller\n                            // gets to claim their bond for picking up\n                            // their slack.\n                            awardMissedBlockBonus(self, msgSender, callKey);\n                    }\n            }\n\n            // Log metadata about the call.\n            call.gasPrice = tx.gasprice;\n            call.executedBy = msgSender;\n            call.calledAtBlock = block.number;\n\n            // Fetch the call data\n            var data = self.data_registry[call.dataHash];\n\n            // During the call, we need to put enough funds to pay for the\n            // call on hold to ensure they are available to pay the caller.\n            AccountingLib.withdraw(self.gasBank, call.scheduledBy, heldBalance);\n\n            // Mark whether the function call was successful.\n            if (checkAuthorization(self, call.scheduledBy, call.contractAddress)) {\n                    call.wasSuccessful = self.authorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n            }\n            else {\n                    call.wasSuccessful = self.unauthorizedRelay.relayCall.gas(msg.gas - CALL_OVERHEAD)(call.contractAddress, call.abiSignature, data);\n            }\n\n            // Add the held funds back into the scheduler's account.\n            AccountingLib.deposit(self.gasBank, call.scheduledBy, heldBalance);\n\n            // Mark the call as having been executed.\n            call.wasCalled = true;\n\n            // Compute the scalar (0 - 200) for the fee.\n            uint feeScalar = getCallFeeScalar(call.baseGasPrice, call.gasPrice);\n\n            // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\n            // amount that represents the gas usage of the commands that\n            // happen after this line.\n            call.gasUsed = (gasBefore - msg.gas + EXTRA_CALL_GAS);\n            call.gasCost = call.gasUsed * call.gasPrice;\n\n            // Now we need to pay the caller as well as keep fee.\n            // callerPayout -> call cost + 1%\n            // fee -> 1% of callerPayout\n            call.payout = call.gasCost * feeScalar * 101 / 10000;\n            call.fee = call.gasCost * feeScalar / 10000;\n\n            AccountingLib.deductFunds(self.gasBank, call.scheduledBy, call.payout + call.fee);\n\n            AccountingLib.addFunds(self.gasBank, msgSender, call.payout);\n            AccountingLib.addFunds(self.gasBank, owner, call.fee);\n    }\n\n    function getCallMaxCost(CallDatabase storage self, bytes32 callKey) constant returns (uint) {\n            /*\n             *  tx.gasprice * block.gaslimit\n             *  \n             */\n            // call cost + 2%\n            var call = self.calls[callKey];\n\n            uint gasCost = tx.gasprice * block.gaslimit;\n            uint feeScalar = getCallFeeScalar(call.baseGasPrice, tx.gasprice);\n\n            return gasCost * feeScalar * 102 / 10000;\n    }\n\n    function getCallFeeScalar(uint baseGasPrice, uint gasPrice) constant returns (uint) {\n            /*\n             *  Return a number between 0 - 200 to scale the fee based on\n             *  the gas price set for the calling transaction as compared\n             *  to the gas price of the scheduling transaction.\n             *\n             *  - number approaches zero as the transaction gas price goes\n             *  above the gas price recorded when the call was scheduled.\n             *\n             *  - the number approaches 200 as the transaction gas price\n             *  drops under the price recorded when the call was scheduled.\n             *\n             *  This encourages lower gas costs as the lower the gas price\n             *  for the executing transaction, the higher the payout to the\n             *  caller.\n             */\n            if (gasPrice > baseGasPrice) {\n                    return 100 * baseGasPrice / gasPrice;\n            }\n            else {\n                    return 200 - 100 * baseGasPrice / (2 * baseGasPrice - gasPrice);\n            }\n    }\n\n    /*\n     *  Call Scheduling API\n     */\n\n    // The result of `sha()` so that we can validate that people aren't\n    // looking up call data that failed to register.\n    bytes32 constant emptyDataHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n\n    function computeCallKey(address scheduledBy, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) constant returns (bytes32) {\n            return sha3(scheduledBy, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n    }\n\n    // Ten minutes into the future.\n    uint constant MAX_BLOCKS_IN_FUTURE = 40;\n\n    event _CallScheduled(bytes32 indexed callKey);\n    function CallScheduled(bytes32 callKey) public {\n        _CallScheduled(callKey);\n    }\n    event _CallRejected(bytes32 indexed callKey, bytes15 reason);\n    function CallRejected(bytes32 callKey, bytes15 reason) public {\n        _CallRejected(callKey, reason);\n    }\n\n    function getCallWindowSize() public returns (uint) {\n        return CALL_WINDOW_SIZE;\n    }\n\n    function getMinimumGracePeriod() public returns (uint) {\n        return 4 * CALL_WINDOW_SIZE;\n    }\n\n    function scheduleCall(CallDatabase storage self, address schedulerAddress, address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public returns (bytes15) {\n            /*\n             * Primary API for scheduling a call.  Prior to calling this\n             * the data should already have been registered through the\n             * `registerData` API.\n             */\n            bytes32 callKey = computeCallKey(schedulerAddress, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n\n            if (dataHash != emptyDataHash && self.data_registry[dataHash].length == 0) {\n                    // Don't allow registering calls if the data hash has\n                    // not actually been registered.  The only exception is\n                    // the *emptyDataHash*.\n                    return ""NO_DATA"";\n            }\n\n            if (targetBlock < block.number + MAX_BLOCKS_IN_FUTURE) {\n                    // Don't allow scheduling further than\n                    // MAX_BLOCKS_IN_FUTURE\n                    return ""TOO_SOON"";\n            }\n            Call storage call = self.calls[callKey];\n\n            if (call.contractAddress != 0x0) {\n                    return ""DUPLICATE"";\n            }\n\n            if (gracePeriod < getMinimumGracePeriod()) {\n                    return ""GRACE_TOO_SHORT"";\n            }\n\n            self.lastCallKey = callKey;\n\n            call.contractAddress = contractAddress;\n            call.scheduledBy = schedulerAddress;\n            call.nonce = nonce;\n            call.abiSignature = abiSignature;\n            call.dataHash = dataHash;\n            call.targetBlock = targetBlock;\n            call.gracePeriod = gracePeriod;\n            call.baseGasPrice = tx.gasprice;\n\n            // Put the call into the grove index.\n            GroveLib.insert(self.callIndex, callKey, int(call.targetBlock));\n\n            return 0x0;\n    }\n\n    event _CallCancelled(bytes32 indexed callKey);\n    function CallCancelled(bytes32 callKey) public {\n        _CallCancelled(callKey);\n    }\n\n    // Two minutes\n    uint constant MIN_CANCEL_WINDOW = 8;\n\n    function cancelCall(CallDatabase storage self, bytes32 callKey, address msgSender) public returns (bool) {\n            Call storage call = self.calls[callKey];\n            if (call.scheduledBy != msgSender) {\n                    // Nobody but the scheduler can cancel a call.\n                    return false;\n            }\n            if (call.wasCalled) {\n                    // No need to cancel a call that already was executed.\n                    return false;\n            }\n            if (call.targetBlock - MIN_CANCEL_WINDOW <= block.number) {\n                    // Call cannot be cancelled this close to execution.\n                    return false;\n            }\n            call.isCancelled = true;\n            return true;\n    }\n}\n\n\n/*\n *  Ethereum Alarm Service\n *  Version 0.4.0\n *\n *  address: 0x07307d0b136a79bac718f43388aed706389c4588\n */\ncontract Alarm {\n        /*\n         *  Constructor\n         *\n         *  - sets up relays\n         *  - configures the caller pool.\n         */\n        function Alarm() {\n                callDatabase.unauthorizedRelay = new Relay();\n                callDatabase.authorizedRelay = new Relay();\n\n                callDatabase.callerPool.freezePeriod = 80;\n                callDatabase.callerPool.rotationDelay = 80;\n                callDatabase.callerPool.overlapSize = 256;\n        }\n\n        ScheduledCallLib.CallDatabase callDatabase;\n\n        // The author (Piper Merriam) address.\n        address constant owner = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n        /*\n         *  Account Management API\n         */\n        function getAccountBalance(address accountAddress) constant public returns (uint) {\n                return callDatabase.gasBank.accountBalances[accountAddress];\n        }\n\n        function deposit() public {\n                deposit(msg.sender);\n        }\n\n        function deposit(address accountAddress) public {\n                /*\n                 *  Public API for depositing funds in a specified account.\n                 */\n                AccountingLib.deposit(callDatabase.gasBank, accountAddress, msg.value);\n                AccountingLib.Deposit(msg.sender, accountAddress, msg.value);\n        }\n\n        function withdraw(uint value) public {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (AccountingLib.withdraw(callDatabase.gasBank, msg.sender, value)) {\n                        AccountingLib.Withdrawal(msg.sender, value);\n                }\n                else {\n                        AccountingLib.InsufficientFunds(msg.sender, value, callDatabase.gasBank.accountBalances[msg.sender]);\n                }\n        }\n\n        function() {\n                /*\n                 *  Fallback function that allows depositing funds just by\n                 *  sending a transaction.\n                 */\n                deposit(msg.sender);\n        }\n\n        /*\n         *  Scheduling Authorization API\n         */\n        function unauthorizedAddress() constant returns (address) {\n                return address(callDatabase.unauthorizedRelay);\n        }\n\n        function authorizedAddress() constant returns (address) {\n                return address(callDatabase.authorizedRelay);\n        }\n\n        function addAuthorization(address schedulerAddress) public {\n                ScheduledCallLib.addAuthorization(callDatabase, schedulerAddress, msg.sender);\n        }\n\n        function removeAuthorization(address schedulerAddress) public {\n                callDatabase.accountAuthorizations[sha3(schedulerAddress, msg.sender)] = false;\n        }\n\n        function checkAuthorization(address schedulerAddress, address contractAddress) constant returns (bool) {\n                return callDatabase.accountAuthorizations[sha3(schedulerAddress, contractAddress)];\n        }\n\n        /*\n         *  Caller bonding\n         */\n        function getMinimumBond() constant returns (uint) {\n                return ScheduledCallLib.getMinimumBond();\n        }\n\n        function depositBond() public {\n                ResourcePoolLib.addToBond(callDatabase.callerPool, msg.sender, msg.value);\n        }\n\n        function withdrawBond(uint value) public {\n                ResourcePoolLib.withdrawBond(callDatabase.callerPool, msg.sender, value, getMinimumBond());\n        }\n\n        function getBondBalance() constant returns (uint) {\n                return getBondBalance(msg.sender);\n        }\n\n        function getBondBalance(address callerAddress) constant returns (uint) {\n                return callDatabase.callerPool.bonds[callerAddress];\n        }\n\n\n        /*\n         *  Pool Management\n         */\n        function getGenerationForCall(bytes32 callKey) constant returns (uint) {\n                var call = callDatabase.calls[callKey];\n                return ResourcePoolLib.getGenerationForWindow(callDatabase.callerPool, call.targetBlock, call.targetBlock + call.gracePeriod);\n        }\n\n        function getGenerationSize(uint generationId) constant returns (uint) {\n                return callDatabase.callerPool.generations[generationId].members.length;\n        }\n\n        function getGenerationStartAt(uint generationId) constant returns (uint) {\n                return callDatabase.callerPool.generations[generationId].startAt;\n        }\n\n        function getGenerationEndAt(uint generationId) constant returns (uint) {\n                return callDatabase.callerPool.generations[generationId].endAt;\n        }\n\n        function getCurrentGenerationId() constant returns (uint) {\n                return ResourcePoolLib.getCurrentGenerationId(callDatabase.callerPool);\n        }\n\n        function getNextGenerationId() constant returns (uint) {\n                return ResourcePoolLib.getNextGenerationId(callDatabase.callerPool);\n        }\n\n        function isInPool() constant returns (bool) {\n                return ResourcePoolLib.isInPool(callDatabase.callerPool, msg.sender);\n        }\n\n        function isInPool(address callerAddress) constant returns (bool) {\n                return ResourcePoolLib.isInPool(callDatabase.callerPool, callerAddress);\n        }\n\n        function isInGeneration(uint generationId) constant returns (bool) {\n                return isInGeneration(msg.sender, generationId);\n        }\n\n        function isInGeneration(address callerAddress, uint generationId) constant returns (bool) {\n                return ResourcePoolLib.isInGeneration(callDatabase.callerPool, callerAddress, generationId);\n        }\n\n        /*\n         *  Pool Meta information\n         */\n        function getPoolFreezePeriod() constant returns (uint) {\n                return callDatabase.callerPool.freezePeriod;\n        }\n\n        function getPoolOverlapSize() constant returns (uint) {\n                return callDatabase.callerPool.overlapSize;\n        }\n\n        function getPoolRotationDelay() constant returns (uint) {\n                return callDatabase.callerPool.rotationDelay;\n        }\n\n        /*\n         *  Pool Membership\n         */\n        function canEnterPool() constant returns (bool) {\n                return ResourcePoolLib.canEnterPool(callDatabase.callerPool, msg.sender, getMinimumBond());\n        }\n\n        function canEnterPool(address callerAddress) constant returns (bool) {\n                return ResourcePoolLib.canEnterPool(callDatabase.callerPool, callerAddress, getMinimumBond());\n        }\n\n        function canExitPool() constant returns (bool) {\n                return ResourcePoolLib.canExitPool(callDatabase.callerPool, msg.sender);\n        }\n\n        function canExitPool(address callerAddress) constant returns (bool) {\n                return ResourcePoolLib.canExitPool(callDatabase.callerPool, callerAddress);\n        }\n\n        function enterPool() public {\n                uint generationId = ResourcePoolLib.enterPool(callDatabase.callerPool, msg.sender, getMinimumBond());\n                ResourcePoolLib.AddedToGeneration(msg.sender, generationId);\n        }\n\n        function exitPool() public {\n                uint generationId = ResourcePoolLib.exitPool(callDatabase.callerPool, msg.sender);\n                ResourcePoolLib.RemovedFromGeneration(msg.sender, generationId);\n        }\n\n        /*\n         *  Call Information API\n         */\n\n        function getLastCallKey() constant returns (bytes32) {\n                return callDatabase.lastCallKey;\n        }\n\n        /*\n         *  Getter methods for `Call` information\n         */\n        function getCallContractAddress(bytes32 callKey) constant returns (address) {\n                return ScheduledCallLib.getCallContractAddress(callDatabase, callKey);\n        }\n\n        function getCallScheduledBy(bytes32 callKey) constant returns (address) {\n                return ScheduledCallLib.getCallScheduledBy(callDatabase, callKey);\n        }\n\n        function getCallCalledAtBlock(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallCalledAtBlock(callDatabase, callKey);\n        }\n\n        function getCallGracePeriod(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallGracePeriod(callDatabase, callKey);\n        }\n\n        function getCallTargetBlock(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallTargetBlock(callDatabase, callKey);\n        }\n\n        function getCallBaseGasPrice(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallBaseGasPrice(callDatabase, callKey);\n        }\n\n        function getCallGasPrice(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallGasPrice(callDatabase, callKey);\n        }\n\n        function getCallGasUsed(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallGasUsed(callDatabase, callKey);\n        }\n\n        function getCallABISignature(bytes32 callKey) constant returns (bytes4) {\n                return ScheduledCallLib.getCallABISignature(callDatabase, callKey);\n        }\n\n        function checkIfCalled(bytes32 callKey) constant returns (bool) {\n                return ScheduledCallLib.checkIfCalled(callDatabase, callKey);\n        }\n\n        function checkIfSuccess(bytes32 callKey) constant returns (bool) {\n                return ScheduledCallLib.checkIfSuccess(callDatabase, callKey);\n        }\n\n        function checkIfCancelled(bytes32 callKey) constant returns (bool) {\n                return ScheduledCallLib.checkIfCancelled(callDatabase, callKey);\n        }\n\n        function getCallDataHash(bytes32 callKey) constant returns (bytes32) {\n                return ScheduledCallLib.getCallDataHash(callDatabase, callKey);\n        }\n\n        function getCallPayout(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallPayout(callDatabase, callKey);\n        }\n\n        function getCallFee(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallFee(callDatabase, callKey);\n        }\n\n        function getCallMaxCost(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getCallMaxCost(callDatabase, callKey);\n        }\n\n        function getCallData(bytes32 callKey) constant returns (bytes) {\n                return callDatabase.data_registry[callDatabase.calls[callKey].dataHash];\n        }\n\n        /*\n         *  Data registration API\n         */\n        function registerData() public {\n                ScheduledCallLib.registerData(callDatabase, msg.data);\n                ScheduledCallLib.DataRegistered(callDatabase.lastDataHash);\n        }\n\n        function getLastDataHash() constant returns (bytes32) {\n                return callDatabase.lastDataHash;\n        }\n\n        function getLastDataLength() constant returns (uint) {\n                return callDatabase.lastDataLength;\n        }\n\n        function getLastData() constant returns (bytes) {\n                return callDatabase.lastData;\n        }\n\n        /*\n         *  Call execution API\n         */\n        function doCall(bytes32 callKey) public {\n                ScheduledCallLib.doCall(callDatabase, callKey, msg.sender);\n        }\n\n        /*\n         *  Call Scheduling API\n         */\n        function getMinimumGracePeriod() constant returns (uint) {\n                return ScheduledCallLib.getMinimumGracePeriod();\n        }\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock) public {\n                /*\n                 *  Schedule call with gracePeriod defaulted to 255 and nonce\n                 *  defaulted to 0.\n                 */\n                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, 255, 0);\n        }\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod) public {\n                /*\n                 *  Schedule call with nonce defaulted to 0.\n                 */\n                scheduleCall(contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, 0);\n        }\n\n        function scheduleCall(address contractAddress, bytes4 abiSignature, bytes32 dataHash, uint targetBlock, uint8 gracePeriod, uint nonce) public {\n                /*\n                 * Primary API for scheduling a call.  Prior to calling this\n                 * the data should already have been registered through the\n                 * `registerData` API.\n                 */\n                bytes15 reason = ScheduledCallLib.scheduleCall(callDatabase, msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n                bytes32 callKey = ScheduledCallLib.computeCallKey(msg.sender, contractAddress, abiSignature, dataHash, targetBlock, gracePeriod, nonce);\n\n                if (reason != 0x0) {\n                        ScheduledCallLib.CallRejected(callKey, reason);\n                }\n                else {\n                        ScheduledCallLib.CallScheduled(callKey);\n                }\n        }\n\n        function cancelCall(bytes32 callKey) public {\n                if (ScheduledCallLib.cancelCall(callDatabase, callKey, address(msg.sender))) {\n                        ScheduledCallLib.CallCancelled(callKey);\n                }\n        }\n\n        /*\n         *  Next Call API\n         */\n        function getCallWindowSize() constant returns (uint) {\n                return ScheduledCallLib.getCallWindowSize();\n        }\n\n        function getGenerationIdForCall(bytes32 callKey) constant returns (uint) {\n                return ScheduledCallLib.getGenerationIdForCall(callDatabase, callKey);\n        }\n\n        function getDesignatedCaller(bytes32 callKey, uint blockNumber) constant returns (address) {\n                return ScheduledCallLib.getDesignatedCaller(callDatabase, callKey, blockNumber);\n        }\n\n        function getNextCall(uint blockNumber) constant returns (bytes32) {\n                return GroveLib.query(callDatabase.callIndex, "">="", int(blockNumber));\n        }\n\n        function getNextCallSibling(bytes32 callKey) constant returns (bytes32) {\n                return GroveLib.getNextNode(callDatabase.callIndex, callKey);\n        }\n}",1,
433535,0x1d11e5eae3112dbd44f99266872ff1d07c77dce8,FALSE,FALSE,"/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n*/\n\ncontract OraclizeAddrResolver {\n\n    address public addr;\n    \n    address owner;\n    \n    function OraclizeAddrResolver(){\n        owner = msg.sender;\n    }\n    \n    \n    function getAddress() returns (address oaddr){\n        return addr;\n    }\n    \n    function setAddr(address newaddr){\n        if (msg.sender != owner) throw;\n        addr = newaddr;\n    }\n    \n}",1,
459227,0xd4e686a1fbf1bfe058510f07cd3936d3d5a70589,FALSE,FALSE,"contract BlockDefStorage\n{\n	\n    Block[18] blocks;\n    struct Block\n    {\n    	int8[24] occupies; // [x0,y0,z0,x1,y1,z1...,x7,y7,z7] \n    	int8[48] attachesto; // [x0,y0,z0,x1,y1,z1...,x15,y15,z15] // first one that is 0,0,0 is the end\n    }\n    \n    address creator;\n    function BlockDefStorage()\n    {\n    	creator = msg.sender;\n    }\n    \n    function getOccupies(uint8 which) public constant returns (int8[24])\n    {\n    	return blocks[which].occupies;\n    }\n    \n    function getAttachesto(uint8 which) public constant returns (int8[48])\n    {\n    	return blocks[which].attachesto;\n    }\n\n    function initOccupies(uint8 which, int8[24] occupies) public \n    {\n    	if(locked) // lockout\n    		return;\n    	for(uint8 index = 0; index < 24; index++)\n    	{\n    		blocks[which].occupies[index] = occupies[index];\n    	}	\n    }\n    \n    function initAttachesto(uint8 which, int8[48] attachesto) public\n    {\n    	if(locked) // lockout\n    		return;\n    	for(uint8 index = 0; index <  48; index++)\n    	{\n    		blocks[which].attachesto[index] = attachesto[index];\n    	}	\n    }\n    \n    /**********\n    Standard lock-kill methods \n    **********/\n    bool locked;\n    function setLocked()\n    {\n 	   locked = true;\n    }\n    function getLocked() public constant returns (bool)\n    {\n 	   return locked;\n    }\n    function kill()\n    { \n        if (!locked && msg.sender == creator)\n            suicide(creator);  // kills this contract and sends remaining funds back to creator\n    }\n}",1,
459708,0x169332ae7d143e4b5c6baedb2fef77bfbddb4011,FALSE,FALSE,"/*\n\nEtheria v1.1\nBlock 459708  \nOct-29-2015 09:11:55 PM +UTC\n0x169332ae7d143e4b5c6baedb2fef77bfbddb4011\n\n\n{\n    ""54385526"": ""setStatus(uint8,uint8,string)"",			// unused (costs 1 ETH)\n    ""2ef761d3"": ""buyTile(uint8,uint8)"",						// unused (sold out - attempting to buy already-owned tiles will lose your ETH)\n    ""8cae1374"": ""editBlock(uint8,uint8,uint256,int8[5])"",	// unused under modern build mechanics\n    ""f2a75fe4"": ""empty()"",									\n    ""90fd53ec"": ""farmTile(uint8,uint8,int8)"",				// unused under modern build mechanics\n    ""fa93019c"": ""getBlocks(uint8,uint8)"",					// unused under modern build mechanics\n    ""8435be4b"": ""getLastFarm(uint8,uint8)"",					// unused under modern build mechanics\n    ""2d49ffcd"": ""getLocked()"",\n    ""a55cab95"": ""getName(uint8,uint8)"",\n    ""e039e4a1"": ""getOwner(uint8,uint8)"",					\n    ""d39eb301"": ""getStatus(uint8,uint8)"",					// unused (setStatus costs 1 ETH)\n    ""182db370"": ""getWhatHappened()"",		\n    ""41c0e1b5"": ""kill()"",									// unkillable due to lock\n    ""10c1952f"": ""setLocked()"",								// locking tx: 0x97341f4098ffda41df50ee719ed38ee572098d2a4c0620b70005771da989b451\n    ""93eec1fb"": ""setName(uint8,uint8,string)"",\n    ""7d5fec5a"": ""setOwner(uint8,uint8,address)""				// uses tx.origin - tiles can only be owned by end-user accounts ( DO NOT SEND TO A CONTRACT. YOUR TILE WILL BE LOST)\n}\n\nvar etheriaAddress = ""0x169332ae7d143e4b5c6baedb2fef77bfbddb4011"";\nvar abi = var abi = [\n	{""constant"":false,""inputs"":[],""name"":""setLocked"",""outputs"":[],""type"":""functin""},\n	{""constant"":true,""inputs"":[],""name"":""getWhatHappened"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function""},\n	{""constant"":true,""inputs"":[],""name"":""getLocked"",""outputs"":[{""name"":"""",""type"":""bool""}],""type"":""function""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""buyTile"",""outputs"":[],""type"":""function""},\n	{""constant"":false,""inputs"":[],""name"":""kill"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""_s"",""type"":""string""}],""name"":""setStatus"",""outputs"":[],""type"":""function""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""newowner"",""type"":""address""}],""name"":""setOwner"",""outputs"":[],""type"":""function""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getLastFarm"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""index"",""type"":""uint256""},{""name"":""_block"",""type"":""int8[5]""}],""name"":""editBlock"",""outputs"":[],""type"":""function""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""blocktype"",""type"":""int8""}],""name"":""farmTile"",""outputs"":[],""type"":""function""},\n	{""constant"":false,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""},{""name"":""_n"",""type"":""string""}],""name"":""setName"",""outputs"":[],""type"":""function""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getName"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getStatus"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getOwner"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},\n	{""constant"":false,""inputs"":[],""name"":""empty"",""outputs"":[],""type"":""function""},\n	{""constant"":true,""inputs"":[{""name"":""col"",""type"":""uint8""},{""name"":""row"",""type"":""uint8""}],""name"":""getBlocks"",""outputs"":[{""name"":"""",""type"":""int8[5][]""}],""type"":""function""},\n	{""inputs"":[],""type"":""constructor""},\n	{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""col"",""type"":""uint8""},{""indexed"":false,""name"":""row"",""type"":""uint8""}],""name"":""TileChanged"",""type"":""event""}\n];\nvar etheria = new web3.eth.Contract(abi, etheriaAddress);\n\nExact bytecode match of source below w/ solidity 0.1.6 + 200 optimization, compiled twice.\nchain: 0x606060405236156100c45760e060020a600035046310c1952f81146100ea578063182db370146101155780632d49ffcd1461017f5780632ef761d31461018e57806341c0e1b5146102fb57806354385526146103065780637d5fec5a1461043d5780638435be4b146104ac5780638cae1374146104e757806390fd53ec1461063857806393eec1fb14610720578063a55cab95146107d4578063d39eb3011461086f578063e039e4a11461090a578063f2a75fe41461094b578063fa93019c14610977575b610a45604051600160a060020a03321690600090349082818181858883f150505050505b565b610a456119875433600160a060020a03908116911614156100e85761198b805460ff19166001179055565b610a47604080516020818101835260008252825161198a805460026001821615610100026000190190911604601f810184900484028301840190955284825292939092918301828280156121d95780601f106121ae576101008083540402835291602001916121d9565b610ab55b61198b5460ff165b90565b610a4560043560243560006001836021811015610002575060c6840201826021811015610002579090600602016000508054909150600160a060020a0316600014156110195734670de0b6b3a7640000141580610265575060408051611989547f4166c1fd00000000000000000000000000000000000000000000000000000000825260ff8087166004840152851660248301529151607d92600160a060020a031691634166c1fd91604482810192602092919082900301816000876161da5a03f1156100025750506040515160ff169190911090505b156110e457604051600160a060020a03321690600090349082818181858883f1506040818101905260208082527f333a62757954696c653a4552523a77726f6e672076616c206f7220776174657291810191825261198a805494819052945060026001851615610100026000190190941693909304601f01839004600080516020612a8b833981519152908101939250906110b4565b610a456121e5610183565b604080516020604435600481810135601f8101849004840285018401909552848452610a459481359460248035959394606494929391019181908401838280828437509496505050505050506000670de0b6b3a76400003414610daf57604051600160a060020a033216908290349082818181858883f150606081016040908152602482527f34313a7365745374617475733a4552523a76616c756520776173206e6f74203160208381019182527f20455448000000000000000000000000000000000000000000000000000000009284019290925261198a80549581905260498155955060026001861615610100026000190190951694909404601f0104600080516020612a8b833981519152908101939250906044015b82811115610c4e57825182600050559160200191906001019061041f565b610a45600435602435604435600160a060020a0332166001846021811015610002575060c68502018360218110156100025790906006020160005054600160a060020a03161480610b41575061198754600160a060020a0390811632909116148015610b415750610b3f610183565b610ab560043560243560006001836021811015610002575060c684020182602181101561000257909060060201600050600401549050610945565b6040805160a0818101909252610a459160048035926024359260443592916101049160649060059083908390808284375090955050505050506000610300604051908101604052806018905b60008152602001906001900390816105335750506040805161030081019091526018815b600081526020019060019003908161055757506000905080808060018b6021811015610002575060c68c02018a6021811015610002579090600602016000508054909750600160a060020a039081163291909116146116ab5760408051808201909152601a8082527f32313a65646974426c6f636b3a4552523a6e6f74206f776e6572000000000000602092830190815261198a8054818652825160ff19166034178255909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192915b5061169b929150610c56565b610a456004356024356044356000600060008360000b128061065d575060118360000b135b156112185760408051606081018252602181527f33343a6661726d54696c653a4552523a696e76616c696420626c6f636b74797060208281019182527f65000000000000000000000000000000000000000000000000000000000000009383019390935261198a8054600082905260438255909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101926041015b828111156112d7578251826000505591602001919060010190610702565b604080516020604435600481810135601f8101849004840285018401909552848452610a4594813594602480359593946064949293910191819084018382808284375094965050505050505060006001846021811015610002575060c6850201836021811015610002579090600602016000508054909150600160a060020a03908116329190911614801590610bcb575061198754600160a060020a0390811632909116148015610bc95750610bc7610183565b610a476004356024356040805160208101909152600081526001836021811015610002575060c68402018260218110156100025750506040805160026006850260c68702018101805460206001821615610100026000190190911692909204601f8101839004830284018301909452838352919290830182828015610bbb5780601f10610b9057610100808354040283529160200191610bbb565b610a4760043560243560408051602081019091526000815260018360218110156100025760c602016000508260218110156100025760060201600050604080516002928301805460206001821615610100026000190190911694909404601f81018590048502830185019093528282529092909190830182828015610bbb5780601f10610b9057610100808354040283529160200191610bbb565b610ac7600435602435600060018360218110156100025760c602018150826021811015610002576006020160005054600160a060020a031690505b92915050565b610a4560405161198754600160a060020a03908116916000913016319082818181858883f15050505050565b610ae460043560243560408051602081019091526000815260018360218110156100025760c602016000508260218110156100025760060201600050600301600050805480602002602001604051908101604052809291908181526020016000905b828210156111e3576000848152604080516020832060a08201928390529092908501916005918390855b825461010083900a900460000b815260206001928301818104948501949093039092029101808411610a035790505050505050815260200190600101906109d9565b005b60405180806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f168015610aa75780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b60405180806020018281038252838181518152602001915080516000925b81841015610b2e5760208481028401015160a08083818460006004601ef1509050019260010192610b02565b925050509250505060405180910390f35b155b15610b8b57806001846021811015610002575060c685020183602181101561000257909060060201600050805473ffffffffffffffffffffffffffffffffffffffff191690911790555b505050565b820191906000526020600020905b815481529060010190602001808311610b9e57829003601f168201915b50505050509050610945565b155b155b15610c6a576040805180820190915260188082527f35303a7365744e616d653a4552523a6e6f74206f776e65720000000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff191660301785555b50610cc39291505b80821115610ccb5760008155600101610c56565b81816001016000509080519060200190828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610ccf57805160ff19168380011785555b50610cff929150610c56565b505050505050565b5090565b82800160010185558215610cb7579182015b82811115610cb7578251826000505591602001919060010190610ce1565b50506040805160ff8087168252851660208201528151600080516020612a6b833981519152929181900390910190a16040805180820190915260128082527f35323a7365744e616d653a535543434553530000000000000000000000000000602092830190815261198a80546000829052825160ff191660241782559093600080516020612a8b83398151915260026001841615610100026000190190931692909204601f010481019291610c4e565b6001846021811015610002575060c6850201836021811015610002579090600602016000508054909150600160a060020a03908116329190911614801590610e19575061198754600160a060020a0390811632909116148015610e175750610e15610183565b155b155b15610ec057604051600160a060020a03321690600090349082818181858883f15060408181019052601a8082527f34333a7365745374617475733a4552523a6e6f74206f776e6572000000000000602092830190815261198a8054958190528151603460ff19909116178155955060026001861615610100026000190190951694909404601f0191909104600080516020612a8b8339815191529081019391925090610c4e565b81816002016000509080519060200190828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610f1957805160ff19168380011785555b50610f49929150610c56565b82800160010185558215610f0d579182015b82811115610f0d578251826000505591602001919060010190610f2b565b505060405161198754600160a060020a031690600090349082818181858883f15060ff80891682528716602082015260408051600080516020612a6b8339815191529550918290030192509050a16040805180820190915260148082527f34343a7365745374617475733a53554343455353000000000000000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff19166028178555610c4e565b6040805160608101825260228082527f353a62757954696c653a4552523a4f4f42206f7220616c7265616479206f776e60208381019182527f6564000000000000000000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101925b828001600101855582156111d0579182015b828111156111d05782518260005055916020019190600101906110c6565b60405161198754600160a060020a031690600090349082818181858883f15050835473ffffffffffffffffffffffffffffffffffffffff19163217845550506040805160ff8087168252851660208201528151600080516020612a6b83398151915293509081900390910190a16040805180820190915260118082527f343a62757954696c653a53554343455353000000000000000000000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff19168380011785555b506111dc929150610c56565b5050610b8b565b505050509050610945565b5050604051600160a060020a03321690600090349082818181858883f150505050505b5050505050565b6001856021811015610002575060c6860201846021811015610002579090600602016000508054909250600160a060020a039081163291909116146112e3576040805180820190915260198082527f33313a6661726d54696c653a4552523a6e6f74206f776e657200000000000000602092830190815261198a805460008290528251603260ff19909116178255909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192915b506111ee929150610c56565b6109c48260040160005054430310156113e057670de0b6b3a7640000341461144b57604051600160a060020a03321690600090349082818181858883f150606081016040908152602382527f33313a6661726d54696c653a4552523a76616c756520776173206e6f7420312060208381019182527f45544800000000000000000000000000000000000000000000000000000000009284019290925261198a80549581905260478155955060026001861615610100026000190190951694909404601f0104600080516020612a8b833981519152908101939250906043015b828111156115245782518260005055916020019190600101906113c2565b600034111561140a57604051600160a060020a03321690600090349082818181858883f150505050505b5060005b600a8160ff161015611473576003820180546001810180835591908290801582901161153757600083815260209020611537918101908301610c56565b60405161198754600160a060020a031690600090349082818181858883f1505050505061140a565b4360048301556040805160ff8781168252861660208201528151600080516020612a6b833981519152929181900390910190a16040805180820190915260138082527f33333a6661726d54696c653a5355434345535300000000000000000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff191660261785555b50611530929150610c56565b5050611211565b505050506003820180548491906000198101908110156100025750805460008281526020812091909101600019908101805460ff191660f860020a958602959095049490941790935581549092810190811015610002579082526020822001815060016101000a81548160ff021916908360f860020a90810204021790555060008260030160005060018460030160005080549050038154811015610002579082526020822001815060026101000a81548160ff021916908360f860020a908102040217905550600019826003016000506001846003016000508054905003815481101561000257906000526020600020900160005060036101000a81548160ff021916908360f860020a90810204021790555060008260030160005060018460030160005080549050038154811015610002579082526020822001815060046101000a81548160ff021916908360f860020a90810204021790555060010161140e565b50505b5050505050505050505050565b6060880151600090810b1215611786576040805160608101825260238082527f32323a65646974426c6f636b3a4552523a63616e6e6f74206869646520626c6f60208381019182527f636b730000000000000000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101925b8280016001018555821561062c579182015b8281111561062c578251826000505591602001919060010190611768565b600387015460001901891115611835576040805160608101825260298082527f32333a65646974426c6f636b3a4552523a626c6f636b20696e646578206f757460208381019182527f206f662072616e67650000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192611756565b875160000b600019141561192b5760038701805460808a015191908b908110156100025750600090815260208082208c01805460f860020a948502949094046401000000000264ff0000000019909416939093179092556040805160608101825260288082527f32343a65646974426c6f636b3a535543434553533a626c6f636b20636f6c6f728286019081527f206368616e676564000000000000000000000000000000000000000000000000929093019190915261198a8054938190529360026001851615610100026000190190941693909304601f0192909204600080516020612a8b8339815191529081019291611756565b6003870180548a9081101561000257506000908152602081208a0154810b810b808a52604080516119885460e360020a630379eaeb02825260ff9390931660048201529051600160a060020a039290921692631bcf5758926024838101936103009390839003909101908290876161da5a03f115610002575060408051610300818101808452611988548e5160e360020a630379eaeb0290925260ff919091166103048401529251919a50600160a060020a03929092169350610324808b01929190818c0301816000876161da5a03f1156100025750505060405180610300016040529450600093505b60188460ff161015611ca857602088015185856018811015610002579090602002015101858560188110156100025760009290920b602092909202015287600290906020020151858560010160188110156100025790906020020151018585600101601881101561000257600092830b602091820290920191909152860151600290820b07810b14801590611ac75750600285856001016018811015610002579090602002015160000b0760000b6000145b15611af95784846018811015610002576020020151600101858560188110156100025760009290920b60209290920201525b606088015185600286016018811015610002579090602002015101858560020160188110156100025760009290920b60209290920201526003870180548a9081101561000257506000908152602081208a01546101009004900b86856018811015610002579090602002015101868560188110156100025760009290920b60209290920201526003870180548a9081101561000257906000526020600020900160005060029054906101000a900460000b868560010160188110156100025790906020020151018685600101601881101561000257600092830b602091820290920191909152870151600290820b07810b14801590611c155750600286856001016018811015610002579090602002015160000b0760000b6000145b15611c475785846018811015610002576020020151600101868560188110156100025760009290920b60209290920201525b6003870180548a9081101561000257506000908152602081208a015463010000009004900b8660028601601881101561000257602081028201519092019160188110156100025760009290920b602092909202015260039390930192611a15565b611d5d8b8b8a8860006000600060006000610600604051908101604052806030905b6000815260200190600190039081611cca57506000905060018b6021811015610002575060c68c02018a6021811015610002579090600602016000509450600093505b60188460ff16101561221557612390888560188110156100025760200201518960018701601881101561000257602002015160006000600060008560000b121561293b576000198502915061293f565b1515611d685761169e565b6000876003016000508a815481101561000257508152602081208a015463010000009004810b810b12611f6257600092505b60188360ff161015611fa357600091505b6005870154821015612013576005870180548390811015610002576000918252602082200154810b900b86846018811015610002579090602002015160000b148015611e2f575060058701805483908110156100025760206000908120909101546101009004810b900b90508660018501601881101561000257602002015160000b145b8015611e7257506005870180548390811015610002576000918252602082200154620100009004810b900b8660028501601881101561000257602002015160000b145b15611f5657848360188110156100025760200201516005880180548490811015610002576000918252602090912001805460ff191660f860020a9283029290920491909117905584600184016018811015610002576020020151600588018054849081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a90810204021790555084836002016018811015610002576020020151600588018054849081101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a9081020402179055505b60019190910190611dab565b5060005b60188160ff161015611fa3576005870180546001810180835590919082801582901161201f5760008381526020902061201f918101908301610c56565b87876003016000508a815481101561000257506000908152602081208b01916001830191839060a08301905b8382111561212c57835183826101000a81548160ff021916908360f860020a9081020402179055509260200192600101602081600001049283019260010302611fcf565b60039290920191611d9a565b505050508481601881101561000257602002015160058801805460001981019081101561000257906000526020600020900160005060006101000a81548160ff021916908360f860020a908102040217905550848160010160188110156100025760058901805460209290920290920151919060001981019081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a908102040217905550848160020160188110156100025760058901805460209290920290920151919060001981019081101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a908102040217905550600301611f66565b80156121595782816101000a81549060ff021916905560010160208160000104928301926001030261212c565b505061217a9291505b80821115610ccb57805460ff19168155600101612162565b50506040805160ff8d811682528c1660208201528151600080516020612a6b833981519152929181900390910190a161169e565b820191906000526020600020905b8154815290600101906020018083116121bc57829003601f168201915b5050505050905061018b565b15801561220157506119875433600160a060020a039081169116145b156100e85761198754600160a060020a0316ff5b856000141561260b5761198854600160a060020a0316630878bc518a60006040805192517f0878bc5100000000000000000000000000000000000000000000000000000000845260ff166004840152516024838101936106009390839003909101908290876161da5a03f1156100025750505060405180610600016040529150600090505b60308160ff161080156122ab575085155b1561230e5781816030811015610002576020020151600090810b1480156122e7575081816001016030811015610002576020020151600090810b145b8015612308575081816002016030811015610002576020020151600090810b145b156126d6575b6040805180820190915260198082527f31333a65646974426c6f636b3a4552523a666c6f6174696e6700000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff19166032178555612416565b1515612422576040805180820190915260148082527f31303a65646974426c6f636b3a4552523a4f4f42000000000000000000000000602092830190815261198a805460008290528251602860ff19909116178255909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192915b506125af929150610c56565b600092505b60058501548310156125c4576005850180548490811015610002576000918252602082200154810b900b8885601881101561000257602002015160000b1480156124a9575060058501805484908110156100025760206000908120909101546101009004810b900b90508860018601601881101561000257602002015160000b145b80156124ec57506005850180548490811015610002576000918252602082200154620100009004810b900b8860028601601881101561000257602002015160000b145b156125ff5760408051606081018252602c81527f31313a65646974426c6f636b3a4552523a636f6e666c6963742077697468206160208281019182527f6e6f7468657220626c6f636b00000000000000000000000000000000000000009383019390935261198a8054600082905260598255909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192604c015b82811115612416578251826000505591602001919060010190612591565b5050600096505b505050505050949350505050565b8560001480156125e9575087846002016018811015610002576020020151600090810b145b156125f357600195505b60039390930192611d0d565b60019290920191612427565b6040805160608101825260288082527f31343a65646974426c6f636b3a535543434553533a626c6f636b20707574206f60208381019182527f6e2067726f756e64000000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101925b82800160010185558215612917579182015b828111156129175782518260005055916020019190600101906126b8565b604089015182600183016030811015610002576020020151018260018301603081101561000257600092830b602091820290920191909152830151600290820b07810b148015906127445750600282826001016030811015610002579090602002015160000b0760000b6000145b156127765781816030811015610002576020020151600101828260308110156100025760009290920b60209290920201525b600092505b60058501548310801561278c575085155b1561290357600585018054849081101561000257600091825260208083209190910154908b015190820b90910b90838360308110156100025760200201510160000b1480156128135750600585018054849081101561000257602060009081209281529101546101009004810b900b8260018301603081101561000257602002015160000b145b801561285f5750600585018054849081101561000257600091825260208220015460608b015162010000909104820b90910b90836002840160308110156100025760200201510160000b145b1561290b576040805160608101825260298082527f31323a65646974426c6f636b3a535543434553533a626c6f636b20707574206f60208381019182527f6e20616e6f746865720000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101926126a6565b60030161229a565b6001929092019161277b565b50612923929150610c56565b5050600196506125b6565b600092505b505092915050565b8491505b60008460000b121561295657506000198302612959565b50825b602160ff82161161299e5760028460000b0760000b6000141515612a06578460000b60311913158015612990575060318560000b13155b1561292e5760019250612933565b60008460000b121580156129b6575060008560000b12155b806129d2575060008460000b1280156129d2575060008560000b135b15612a1a5760028460000b0760000b6000141515612a485760c660028302600383020160ff161161292e5760019250612933565b603160ff83161161292e5760019250612933565b60028460000b0760000b60001415612a485760c660028302600383020160ff161161292e5760019250612933565b60c660ff60018401600202600019840160030201161161292e576001925061293356962cd36cf694aa154c5d3a551f19c98f356d906e96828eeb616e16fae64157389122e0c2cf84605d9b01a64c349fe202a66c35f9275f5369bd0bb827330d7391\ncompile2:606060405236156100c45760e060020a600035046310c1952f81146100ea578063182db370146101155780632d49ffcd1461017f5780632ef761d31461018e57806341c0e1b5146102fb57806354385526146103065780637d5fec5a1461043d5780638435be4b146104ac5780638cae1374146104e757806390fd53ec1461063857806393eec1fb14610720578063a55cab95146107d4578063d39eb3011461086f578063e039e4a11461090a578063f2a75fe41461094b578063fa93019c14610977575b610a45604051600160a060020a03321690600090349082818181858883f150505050505b565b610a456119875433600160a060020a03908116911614156100e85761198b805460ff19166001179055565b610a47604080516020818101835260008252825161198a805460026001821615610100026000190190911604601f810184900484028301840190955284825292939092918301828280156121d95780601f106121ae576101008083540402835291602001916121d9565b610ab55b61198b5460ff165b90565b610a4560043560243560006001836021811015610002575060c6840201826021811015610002579090600602016000508054909150600160a060020a0316600014156110195734670de0b6b3a7640000141580610265575060408051611989547f4166c1fd00000000000000000000000000000000000000000000000000000000825260ff8087166004840152851660248301529151607d92600160a060020a031691634166c1fd91604482810192602092919082900301816000876161da5a03f1156100025750506040515160ff169190911090505b156110e457604051600160a060020a03321690600090349082818181858883f1506040818101905260208082527f333a62757954696c653a4552523a77726f6e672076616c206f7220776174657291810191825261198a805494819052945060026001851615610100026000190190941693909304601f01839004600080516020612a8b833981519152908101939250906110b4565b610a456121e5610183565b604080516020604435600481810135601f8101849004840285018401909552848452610a459481359460248035959394606494929391019181908401838280828437509496505050505050506000670de0b6b3a76400003414610daf57604051600160a060020a033216908290349082818181858883f150606081016040908152602482527f34313a7365745374617475733a4552523a76616c756520776173206e6f74203160208381019182527f20455448000000000000000000000000000000000000000000000000000000009284019290925261198a80549581905260498155955060026001861615610100026000190190951694909404601f0104600080516020612a8b833981519152908101939250906044015b82811115610c4e57825182600050559160200191906001019061041f565b610a45600435602435604435600160a060020a0332166001846021811015610002575060c68502018360218110156100025790906006020160005054600160a060020a03161480610b41575061198754600160a060020a0390811632909116148015610b415750610b3f610183565b610ab560043560243560006001836021811015610002575060c684020182602181101561000257909060060201600050600401549050610945565b6040805160a0818101909252610a459160048035926024359260443592916101049160649060059083908390808284375090955050505050506000610300604051908101604052806018905b60008152602001906001900390816105335750506040805161030081019091526018815b600081526020019060019003908161055757506000905080808060018b6021811015610002575060c68c02018a6021811015610002579090600602016000508054909750600160a060020a039081163291909116146116ab5760408051808201909152601a8082527f32313a65646974426c6f636b3a4552523a6e6f74206f776e6572000000000000602092830190815261198a8054818652825160ff19166034178255909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192915b5061169b929150610c56565b610a456004356024356044356000600060008360000b128061065d575060118360000b135b156112185760408051606081018252602181527f33343a6661726d54696c653a4552523a696e76616c696420626c6f636b74797060208281019182527f65000000000000000000000000000000000000000000000000000000000000009383019390935261198a8054600082905260438255909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101926041015b828111156112d7578251826000505591602001919060010190610702565b604080516020604435600481810135601f8101849004840285018401909552848452610a4594813594602480359593946064949293910191819084018382808284375094965050505050505060006001846021811015610002575060c6850201836021811015610002579090600602016000508054909150600160a060020a03908116329190911614801590610bcb575061198754600160a060020a0390811632909116148015610bc95750610bc7610183565b610a476004356024356040805160208101909152600081526001836021811015610002575060c68402018260218110156100025750506040805160026006850260c68702018101805460206001821615610100026000190190911692909204601f8101839004830284018301909452838352919290830182828015610bbb5780601f10610b9057610100808354040283529160200191610bbb565b610a4760043560243560408051602081019091526000815260018360218110156100025760c602016000508260218110156100025760060201600050604080516002928301805460206001821615610100026000190190911694909404601f81018590048502830185019093528282529092909190830182828015610bbb5780601f10610b9057610100808354040283529160200191610bbb565b610ac7600435602435600060018360218110156100025760c602018150826021811015610002576006020160005054600160a060020a031690505b92915050565b610a4560405161198754600160a060020a03908116916000913016319082818181858883f15050505050565b610ae460043560243560408051602081019091526000815260018360218110156100025760c602016000508260218110156100025760060201600050600301600050805480602002602001604051908101604052809291908181526020016000905b828210156111e3576000848152604080516020832060a08201928390529092908501916005918390855b825461010083900a900460000b815260206001928301818104948501949093039092029101808411610a035790505050505050815260200190600101906109d9565b005b60405180806020018281038252838181518152602001915080519060200190808383829060006004602084601f0104600302600f01f150905090810190601f168015610aa75780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b60408051918252519081900360200190f35b60408051600160a060020a03929092168252519081900360200190f35b60405180806020018281038252838181518152602001915080516000925b81841015610b2e5760208481028401015160a08083818460006004601ef1509050019260010192610b02565b925050509250505060405180910390f35b155b15610b8b57806001846021811015610002575060c685020183602181101561000257909060060201600050805473ffffffffffffffffffffffffffffffffffffffff191690911790555b505050565b820191906000526020600020905b815481529060010190602001808311610b9e57829003601f168201915b50505050509050610945565b155b155b15610c6a576040805180820190915260188082527f35303a7365744e616d653a4552523a6e6f74206f776e65720000000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff191660301785555b50610cc39291505b80821115610ccb5760008155600101610c56565b81816001016000509080519060200190828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610ccf57805160ff19168380011785555b50610cff929150610c56565b505050505050565b5090565b82800160010185558215610cb7579182015b82811115610cb7578251826000505591602001919060010190610ce1565b50506040805160ff8087168252851660208201528151600080516020612a6b833981519152929181900390910190a16040805180820190915260128082527f35323a7365744e616d653a535543434553530000000000000000000000000000602092830190815261198a80546000829052825160ff191660241782559093600080516020612a8b83398151915260026001841615610100026000190190931692909204601f010481019291610c4e565b6001846021811015610002575060c6850201836021811015610002579090600602016000508054909150600160a060020a03908116329190911614801590610e19575061198754600160a060020a0390811632909116148015610e175750610e15610183565b155b155b15610ec057604051600160a060020a03321690600090349082818181858883f15060408181019052601a8082527f34333a7365745374617475733a4552523a6e6f74206f776e6572000000000000602092830190815261198a8054958190528151603460ff19909116178155955060026001861615610100026000190190951694909404601f0191909104600080516020612a8b8339815191529081019391925090610c4e565b81816002016000509080519060200190828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10610f1957805160ff19168380011785555b50610f49929150610c56565b82800160010185558215610f0d579182015b82811115610f0d578251826000505591602001919060010190610f2b565b505060405161198754600160a060020a031690600090349082818181858883f15060ff80891682528716602082015260408051600080516020612a6b8339815191529550918290030192509050a16040805180820190915260148082527f34343a7365745374617475733a53554343455353000000000000000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff19166028178555610c4e565b6040805160608101825260228082527f353a62757954696c653a4552523a4f4f42206f7220616c7265616479206f776e60208381019182527f6564000000000000000000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101925b828001600101855582156111d0579182015b828111156111d05782518260005055916020019190600101906110c6565b60405161198754600160a060020a031690600090349082818181858883f15050835473ffffffffffffffffffffffffffffffffffffffff19163217845550506040805160ff8087168252851660208201528151600080516020612a6b83398151915293509081900390910190a16040805180820190915260118082527f343a62757954696c653a53554343455353000000000000000000000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff19168380011785555b506111dc929150610c56565b5050610b8b565b505050509050610945565b5050604051600160a060020a03321690600090349082818181858883f150505050505b5050505050565b6001856021811015610002575060c6860201846021811015610002579090600602016000508054909250600160a060020a039081163291909116146112e3576040805180820190915260198082527f33313a6661726d54696c653a4552523a6e6f74206f776e657200000000000000602092830190815261198a805460008290528251603260ff19909116178255909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192915b506111ee929150610c56565b6109c48260040160005054430310156113e057670de0b6b3a7640000341461144b57604051600160a060020a03321690600090349082818181858883f150606081016040908152602382527f33313a6661726d54696c653a4552523a76616c756520776173206e6f7420312060208381019182527f45544800000000000000000000000000000000000000000000000000000000009284019290925261198a80549581905260478155955060026001861615610100026000190190951694909404601f0104600080516020612a8b833981519152908101939250906043015b828111156115245782518260005055916020019190600101906113c2565b600034111561140a57604051600160a060020a03321690600090349082818181858883f150505050505b5060005b600a8160ff161015611473576003820180546001810180835591908290801582901161153757600083815260209020611537918101908301610c56565b60405161198754600160a060020a031690600090349082818181858883f1505050505061140a565b4360048301556040805160ff8781168252861660208201528151600080516020612a6b833981519152929181900390910190a16040805180820190915260138082527f33333a6661726d54696c653a5355434345535300000000000000000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff191660261785555b50611530929150610c56565b5050611211565b505050506003820180548491906000198101908110156100025750805460008281526020812091909101600019908101805460ff191660f860020a958602959095049490941790935581549092810190811015610002579082526020822001815060016101000a81548160ff021916908360f860020a90810204021790555060008260030160005060018460030160005080549050038154811015610002579082526020822001815060026101000a81548160ff021916908360f860020a908102040217905550600019826003016000506001846003016000508054905003815481101561000257906000526020600020900160005060036101000a81548160ff021916908360f860020a90810204021790555060008260030160005060018460030160005080549050038154811015610002579082526020822001815060046101000a81548160ff021916908360f860020a90810204021790555060010161140e565b50505b5050505050505050505050565b6060880151600090810b1215611786576040805160608101825260238082527f32323a65646974426c6f636b3a4552523a63616e6e6f74206869646520626c6f60208381019182527f636b730000000000000000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101925b8280016001018555821561062c579182015b8281111561062c578251826000505591602001919060010190611768565b600387015460001901891115611835576040805160608101825260298082527f32333a65646974426c6f636b3a4552523a626c6f636b20696e646578206f757460208381019182527f206f662072616e67650000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192611756565b875160000b600019141561192b5760038701805460808a015191908b908110156100025750600090815260208082208c01805460f860020a948502949094046401000000000264ff0000000019909416939093179092556040805160608101825260288082527f32343a65646974426c6f636b3a535543434553533a626c6f636b20636f6c6f728286019081527f206368616e676564000000000000000000000000000000000000000000000000929093019190915261198a8054938190529360026001851615610100026000190190941693909304601f0192909204600080516020612a8b8339815191529081019291611756565b6003870180548a9081101561000257506000908152602081208a0154810b810b808a52604080516119885460e360020a630379eaeb02825260ff9390931660048201529051600160a060020a039290921692631bcf5758926024838101936103009390839003909101908290876161da5a03f115610002575060408051610300818101808452611988548e5160e360020a630379eaeb0290925260ff919091166103048401529251919a50600160a060020a03929092169350610324808b01929190818c0301816000876161da5a03f1156100025750505060405180610300016040529450600093505b60188460ff161015611ca857602088015185856018811015610002579090602002015101858560188110156100025760009290920b602092909202015287600290906020020151858560010160188110156100025790906020020151018585600101601881101561000257600092830b602091820290920191909152860151600290820b07810b14801590611ac75750600285856001016018811015610002579090602002015160000b0760000b6000145b15611af95784846018811015610002576020020151600101858560188110156100025760009290920b60209290920201525b606088015185600286016018811015610002579090602002015101858560020160188110156100025760009290920b60209290920201526003870180548a9081101561000257506000908152602081208a01546101009004900b86856018811015610002579090602002015101868560188110156100025760009290920b60209290920201526003870180548a9081101561000257906000526020600020900160005060029054906101000a900460000b868560010160188110156100025790906020020151018685600101601881101561000257600092830b602091820290920191909152870151600290820b07810b14801590611c155750600286856001016018811015610002579090602002015160000b0760000b6000145b15611c475785846018811015610002576020020151600101868560188110156100025760009290920b60209290920201525b6003870180548a9081101561000257506000908152602081208a015463010000009004900b8660028601601881101561000257602081028201519092019160188110156100025760009290920b602092909202015260039390930192611a15565b611d5d8b8b8a8860006000600060006000610600604051908101604052806030905b6000815260200190600190039081611cca57506000905060018b6021811015610002575060c68c02018a6021811015610002579090600602016000509450600093505b60188460ff16101561221557612390888560188110156100025760200201518960018701601881101561000257602002015160006000600060008560000b121561293b576000198502915061293f565b1515611d685761169e565b6000876003016000508a815481101561000257508152602081208a015463010000009004810b810b12611f6257600092505b60188360ff161015611fa357600091505b6005870154821015612013576005870180548390811015610002576000918252602082200154810b900b86846018811015610002579090602002015160000b148015611e2f575060058701805483908110156100025760206000908120909101546101009004810b900b90508660018501601881101561000257602002015160000b145b8015611e7257506005870180548390811015610002576000918252602082200154620100009004810b900b8660028501601881101561000257602002015160000b145b15611f5657848360188110156100025760200201516005880180548490811015610002576000918252602090912001805460ff191660f860020a9283029290920491909117905584600184016018811015610002576020020151600588018054849081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a90810204021790555084836002016018811015610002576020020151600588018054849081101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a9081020402179055505b60019190910190611dab565b5060005b60188160ff161015611fa3576005870180546001810180835590919082801582901161201f5760008381526020902061201f918101908301610c56565b87876003016000508a815481101561000257506000908152602081208b01916001830191839060a08301905b8382111561212c57835183826101000a81548160ff021916908360f860020a9081020402179055509260200192600101602081600001049283019260010302611fcf565b60039290920191611d9a565b505050508481601881101561000257602002015160058801805460001981019081101561000257906000526020600020900160005060006101000a81548160ff021916908360f860020a908102040217905550848160010160188110156100025760058901805460209290920290920151919060001981019081101561000257906000526020600020900160005060016101000a81548160ff021916908360f860020a908102040217905550848160020160188110156100025760058901805460209290920290920151919060001981019081101561000257906000526020600020900160005060026101000a81548160ff021916908360f860020a908102040217905550600301611f66565b80156121595782816101000a81549060ff021916905560010160208160000104928301926001030261212c565b505061217a9291505b80821115610ccb57805460ff19168155600101612162565b50506040805160ff8d811682528c1660208201528151600080516020612a6b833981519152929181900390910190a161169e565b820191906000526020600020905b8154815290600101906020018083116121bc57829003601f168201915b5050505050905061018b565b15801561220157506119875433600160a060020a039081169116145b156100e85761198754600160a060020a0316ff5b856000141561260b5761198854600160a060020a0316630878bc518a60006040805192517f0878bc5100000000000000000000000000000000000000000000000000000000845260ff166004840152516024838101936106009390839003909101908290876161da5a03f1156100025750505060405180610600016040529150600090505b60308160ff161080156122ab575085155b1561230e5781816030811015610002576020020151600090810b1480156122e7575081816001016030811015610002576020020151600090810b145b8015612308575081816002016030811015610002576020020151600090810b145b156126d6575b6040805180820190915260198082527f31333a65646974426c6f636b3a4552523a666c6f6174696e6700000000000000602092830190815261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b8339815191529081019291805160ff19166032178555612416565b1515612422576040805180820190915260148082527f31303a65646974426c6f636b3a4552523a4f4f42000000000000000000000000602092830190815261198a805460008290528251602860ff19909116178255909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192915b506125af929150610c56565b600092505b60058501548310156125c4576005850180548490811015610002576000918252602082200154810b900b8885601881101561000257602002015160000b1480156124a9575060058501805484908110156100025760206000908120909101546101009004810b900b90508860018601601881101561000257602002015160000b145b80156124ec57506005850180548490811015610002576000918252602082200154620100009004810b900b8860028601601881101561000257602002015160000b145b156125ff5760408051606081018252602c81527f31313a65646974426c6f636b3a4552523a636f6e666c6963742077697468206160208281019182527f6e6f7468657220626c6f636b00000000000000000000000000000000000000009383019390935261198a8054600082905260598255909360026001831615610100026000190190921691909104601f0104600080516020612a8b83398151915290810192604c015b82811115612416578251826000505591602001919060010190612591565b5050600096505b505050505050949350505050565b8560001480156125e9575087846002016018811015610002576020020151600090810b145b156125f357600195505b60039390930192611d0d565b60019290920191612427565b6040805160608101825260288082527f31343a65646974426c6f636b3a535543434553533a626c6f636b20707574206f60208381019182527f6e2067726f756e64000000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101925b82800160010185558215612917579182015b828111156129175782518260005055916020019190600101906126b8565b604089015182600183016030811015610002576020020151018260018301603081101561000257600092830b602091820290920191909152830151600290820b07810b148015906127445750600282826001016030811015610002579090602002015160000b0760000b6000145b156127765781816030811015610002576020020151600101828260308110156100025760009290920b60209290920201525b600092505b60058501548310801561278c575085155b1561290357600585018054849081101561000257600091825260208083209190910154908b015190820b90910b90838360308110156100025760200201510160000b1480156128135750600585018054849081101561000257602060009081209281529101546101009004810b900b8260018301603081101561000257602002015160000b145b801561285f5750600585018054849081101561000257600091825260208220015460608b015162010000909104820b90910b90836002840160308110156100025760200201510160000b145b1561290b576040805160608101825260298082527f31323a65646974426c6f636b3a535543434553533a626c6f636b20707574206f60208381019182527f6e20616e6f746865720000000000000000000000000000000000000000000000939094019290925261198a80546000829052909360026001831615610100026000190190921691909104601f0104600080516020612a8b833981519152908101926126a6565b60030161229a565b6001929092019161277b565b50612923929150610c56565b5050600196506125b6565b600092505b505092915050565b8491505b60008460000b121561295657506000198302612959565b50825b602160ff82161161299e5760028460000b0760000b6000141515612a06578460000b60311913158015612990575060318560000b13155b1561292e5760019250612933565b60008460000b121580156129b6575060008560000b12155b806129d2575060008460000b1280156129d2575060008560000b135b15612a1a5760028460000b0760000b6000141515612a485760c660028302600383020160ff161161292e5760019250612933565b603160ff83161161292e5760019250612933565b60028460000b0760000b60001415612a485760c660028302600383020160ff161161292e5760019250612933565b60c660ff60018401600202600019840160030201161161292e576001925061293356962cd36cf694aa154c5d3a551f19c98f356d906e96828eeb616e16fae64157389122e0c2cf84605d9b01a64c349fe202a66c35f9275f5369bd0bb827330d7391\n\n\n */\n \ncontract BlockDefStorage \n{\n	function getOccupies(uint8 blocktype) public returns (int8[24])\n	{}\n	function getAttachesto(uint8 blocktype) public returns (int8[48])\n    {}\n}\n\ncontract MapElevationRetriever \n{\n	function getElevation(uint8 col, uint8 row) public constant returns (uint8)\n	{}\n}\n\ncontract Etheria \n{\n	event TileChanged(uint8 col, uint8 row);//, address owner, string name, string status, uint lastfarm, address[] offerers, uint[] offers, int8[5][] blocks);\n	\n    uint8 mapsize = 33;\n    Tile[33][33] tiles;\n    address creator;\n    \n    struct Tile \n    {\n    	address owner;\n    	string name;\n    	string status;\n    	int8[5][] blocks; //0 = blocktype,1 = blockx,2 = blocky,3 = blockz, 4 = color\n    	uint lastfarm;\n    	int8[3][] occupado; // the only one not reported in the //TileChanged event\n    }\n    \n    BlockDefStorage bds;\n    MapElevationRetriever mer;\n    \n    function Etheria() {\n    	creator = tx.origin;\n    	bds = BlockDefStorage(0xd4e686a1fbf1bfe058510f07cd3936d3d5a70589); \n    	mer = MapElevationRetriever(0x68549d7dbb7a956f955ec1263f55494f05972a6b);\n    }\n    \n    function getOwner(uint8 col, uint8 row) public constant returns(address)\n    {\n    	return tiles[col][row].owner; // no harm if col,row are invalid\n    }\n    \n    function setOwner(uint8 col, uint8 row, address newowner)\n    {\n    	if(tiles[col][row].owner == tx.origin ||\n    			(tx.origin == creator && !getLocked()))\n    		tiles[col][row].owner = newowner;  // needs whathappened here.\n    }\n    \n    /***\n     *     _   _   ___  ___  ___ _____            _____ _____ ___ _____ _   _ _____ \n     *    | \ | | / _ \ |  \/  ||  ___|   ___    /  ___|_   _/ _ \_   _| | | /  ___|\n     *    |  \| |/ /_\ \| .  . || |__    ( _ )   \ `--.  | |/ /_\ \| | | | | \ `--. \n     *    | . ` ||  _  || |\/| ||  __|   / _ \/\  `--. \ | ||  _  || | | | | |`--. \\n     *    | |\  || | | || |  | || |___  | (_>  < /\__/ / | || | | || | | |_| /\__/ /\n     *    \_| \_/\_| |_/\_|  |_/\____/   \___/\/ \____/  \_/\_| |_/\_/  \___/\____/ \n     *                                                                              \n     *                                                                              \n     */\n    \n    function getName(uint8 col, uint8 row) public constant returns(string)\n    {\n    	return tiles[col][row].name; // no harm if col,row are invalid\n    }\n    function setName(uint8 col, uint8 row, string _n) public\n    {\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != tx.origin && !(tx.origin == creator && !getLocked()))\n    	{\n    		whathappened = ""50:setName:ERR:not owner"";  \n    		return;\n    	}\n    	tile.name = _n;\n    	TileChanged(col,row);\n    	whathappened = ""52:setName:SUCCESS"";\n    	return;\n    }\n    \n    function getStatus(uint8 col, uint8 row) public constant returns(string)\n    {\n    	return tiles[col][row].status; // no harm if col,row are invalid\n    }\n    function setStatus(uint8 col, uint8 row, string _s) public // setting status costs 1 eth to prevent spam\n    {\n    	if(msg.value != 1000000000000000000) \n    	{\n    		tx.origin.send(msg.value); 		// return their money\n    		whathappened = ""41:setStatus:ERR:value was not 1 ETH"";\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != tx.origin && !(tx.origin == creator && !getLocked()))\n    	{\n    		tx.origin.send(msg.value); 		// return their money\n    		whathappened = ""43:setStatus:ERR:not owner"";  \n    		return;\n    	}\n    	tile.status = _s;\n    	creator.send(msg.value);\n    	TileChanged(col,row);\n    	whathappened = ""44:setStatus:SUCCESS"";\n    	return;\n    }\n    \n    /***\n     *    ______ ___  _________  ________ _   _ _____            ___________ _____ _____ _____ _   _ _____ \n     *    |  ___/ _ \ | ___ \  \/  |_   _| \ | |  __ \   ___    |  ___|  _  \_   _|_   _|_   _| \ | |  __ \\n     *    | |_ / /_\ \| |_/ / .  . | | | |  \| | |  \/  ( _ )   | |__ | | | | | |   | |   | | |  \| | |  \/\n     *    |  _||  _  ||    /| |\/| | | | | . ` | | __   / _ \/\ |  __|| | | | | |   | |   | | | . ` | | __ \n     *    | |  | | | || |\ \| |  | |_| |_| |\  | |_\ \ | (_>  < | |___| |/ / _| |_  | |  _| |_| |\  | |_\ \\n     *    \_|  \_| |_/\_| \_\_|  |_/\___/\_| \_/\____/  \___/\/ \____/|___/  \___/  \_/  \___/\_| \_/\____/\n     *                                                                                                     \n     */\n    \n    function getLastFarm(uint8 col, uint8 row) public constant returns (uint)\n    {\n    	return tiles[col][row].lastfarm;\n    }\n    \n    function farmTile(uint8 col, uint8 row, int8 blocktype) public \n    {\n    	if(blocktype < 0 || blocktype > 17) // invalid blocktype\n    	{\n    		whathappened = ""34:farmTile:ERR:invalid blocktype"";\n    		tx.origin.send(msg.value); // in case they sent ether, return it.\n    		return;\n    	}	\n    	\n    	Tile tile = tiles[col][row];\n        if(tile.owner != tx.origin)\n        {\n        	whathappened = ""31:farmTile:ERR:not owner"";\n        	tx.origin.send(msg.value); // in case they sent ether, return it.\n        	return;\n        }\n        if((block.number - tile.lastfarm) < 2500) // ~12 hours of blocks\n        {\n        	if(msg.value != 1000000000000000000)\n        	{	\n        		tx.origin.send(msg.value); // return their money\n        		whathappened = ""31:farmTile:ERR:value was not 1 ETH"";\n        		return;\n        	}\n        	else // they paid 1 ETH\n        	{\n        		creator.send(msg.value);\n        		// If they haven't waited long enough, but they've paid 1 eth, let them farm again.\n        	}	\n        }\n        else\n        {\n        	if(msg.value > 0) // they've waited long enough but also sent money. Return it and continue normally.\n        	{\n        		tx.origin.send(msg.value); // return their money\n        	}\n        }\n        \n        // by this point, they've either waited 2500 blocks or paid 1 ETH\n    	for(uint8 i = 0; i < 10; i++)\n    	{\n            tile.blocks.length+=1;\n            tile.blocks[tile.blocks.length - 1][0] = int8(blocktype); // blocktype 0-17\n    	    tile.blocks[tile.blocks.length - 1][1] = 0; // x\n    	    tile.blocks[tile.blocks.length - 1][2] = 0; // y\n    	    tile.blocks[tile.blocks.length - 1][3] = -1; // z\n    	    tile.blocks[tile.blocks.length - 1][4] = 0; // color\n    	}\n    	tile.lastfarm = block.number;\n    	TileChanged(col,row);\n    	whathappened = ""33:farmTile:SUCCESS"";\n    	return;\n    }\n    \n    function editBlock(uint8 col, uint8 row, uint index, int8[5] _block)  \n    {\n    	Tile tile = tiles[col][row];\n        if(tile.owner != tx.origin) // 1. DID THE OWNER SEND THIS MESSAGE?\n        {\n        	whathappened = ""21:editBlock:ERR:not owner"";\n        	return;\n        }\n        if(_block[3] < 0) // 2. IS THE Z LOCATION OF THE BLOCK BELOW ZERO? BLOCKS CANNOT BE HIDDEN\n        {\n        	whathappened = ""22:editBlock:ERR:cannot hide blocks"";\n        	return;\n        }\n        if(index > (tile.blocks.length-1))\n        {\n        	whathappened = ""23:editBlock:ERR:block index out of range"";\n        	return;\n        }		\n        if(_block[0] == -1) // user has signified they want to only change the color of this block\n        {\n        	tile.blocks[index][4] = _block[4];\n        	whathappened = ""24:editBlock:SUCCESS:block color changed"";\n        	return;\n        }	\n        _block[0] = tile.blocks[index][0]; // can't change the blocktype, so set it to whatever it already was\n\n        int8[24] memory didoccupy = bds.getOccupies(uint8(_block[0]));\n        int8[24] memory wouldoccupy = bds.getOccupies(uint8(_block[0]));\n        \n        for(uint8 b = 0; b < 24; b+=3) // always 8 hexes, calculate the didoccupy\n 		{\n 			 wouldoccupy[b] = wouldoccupy[b]+_block[1];\n 			 wouldoccupy[b+1] = wouldoccupy[b+1]+_block[2];\n 			 if(wouldoccupy[1] % 2 != 0 && wouldoccupy[b+1] % 2 == 0) // if anchor y is odd and this hex y is even, (SW NE beam goes 11,`2`2,23,`3`4,35,`4`6,47,`5`8  ` = x value incremented by 1. Same applies to SW NE beam from 01,12,13,24,25,36,37,48)\n 				 wouldoccupy[b] = wouldoccupy[b]+1;  			   // then offset x by +1\n 			 wouldoccupy[b+2] = wouldoccupy[b+2]+_block[3];\n 			 \n 			 didoccupy[b] = didoccupy[b]+tile.blocks[index][1];\n 			 didoccupy[b+1] = didoccupy[b+1]+tile.blocks[index][2];\n 			 if(didoccupy[1] % 2 != 0 && didoccupy[b+1] % 2 == 0) // if anchor y and this hex y are both odd,\n 				 didoccupy[b] = didoccupy[b]+1; 					 // then offset x by +1\n       		didoccupy[b+2] = didoccupy[b+2]+tile.blocks[index][3];\n 		}\n        \n        if(!isValidLocation(col,row,_block, wouldoccupy))\n        {\n        	return; // whathappened is already set\n        }\n        \n        // EVERYTHING CHECKED OUT, WRITE OR OVERWRITE THE HEXES IN OCCUPADO\n        \n      	if(tile.blocks[index][3] >= 0) // If the previous z was greater than 0 (i.e. not hidden) ...\n     	{\n         	for(uint8 l = 0; l < 24; l+=3) // loop 8 times,find the previous occupado entries and overwrite them\n         	{\n         		for(uint o = 0; o < tile.occupado.length; o++)\n         		{\n         			if(didoccupy[l] == tile.occupado[o][0] && didoccupy[l+1] == tile.occupado[o][1] && didoccupy[l+2] == tile.occupado[o][2]) // x,y,z equal?\n         			{\n         				tile.occupado[o][0] = wouldoccupy[l]; // found it. Overwrite it\n         				tile.occupado[o][1] = wouldoccupy[l+1];\n         				tile.occupado[o][2] = wouldoccupy[l+2];\n         			}\n         		}\n         	}\n     	}\n     	else // previous block was hidden\n     	{\n     		for(uint8 ll = 0; ll < 24; ll+=3) // add the 8 new hexes to occupado\n         	{\n     			tile.occupado.length++;\n     			tile.occupado[tile.occupado.length-1][0] = wouldoccupy[ll];\n     			tile.occupado[tile.occupado.length-1][1] = wouldoccupy[ll+1];\n     			tile.occupado[tile.occupado.length-1][2] = wouldoccupy[ll+2];\n         	}\n     	}\n     	tile.blocks[index] = _block;\n     	TileChanged(col,row);\n    	return;\n    }\n       \n    function getBlocks(uint8 col, uint8 row) public constant returns (int8[5][])\n    {\n    	return tiles[col][row].blocks; // no harm if col,row are invalid\n    }\n   \n    /***\n     *     _________________ ___________  _____ \n     *    |  _  |  ___|  ___|  ___| ___ \/  ___|\n     *    | | | | |_  | |_  | |__ | |_/ /\ `--. \n     *    | | | |  _| |  _| |  __||    /  `--. \\n     *    \ \_/ / |   | |   | |___| |\ \ /\__/ /\n     *     \___/\_|   \_|   \____/\_| \_|\____/ \n     *                                          \n     */\n    // three success conditions:\n    // 1. Valid offer on unowned tile. (whathap = 4)\n    // 2. Valid offer on owned tile where offerer did not previously have an offer on file (whathap = 7)\n    // 3. Valid offer on owned tile where offerer DID have a previous offer on file (whathap = 6)\n    function buyTile(uint8 col, uint8 row)\n    {    	\n    	Tile tile = tiles[col][row];\n    	if(tile.owner == address(0x0000000000000000000000000000000000000000))			// if UNOWNED\n    	{	  \n    		if(msg.value != 1000000000000000000 || mer.getElevation(col,row) < 125)	// 1 ETH is the starting value. If not return; // Also, if below sea level, return. \n    		{\n    			tx.origin.send(msg.value); 	 									// return their money\n    			whathappened = ""3:buyTile:ERR:wrong val or water"";\n    			return;\n    		}\n    		else\n    		{	\n    			creator.send(msg.value);     		 					// this was a valid offer, send money to contract creator\n    			tile.owner = tx.origin;  								// set tile owner to the buyer\n    			TileChanged(col,row);\n    			whathappened = ""4:buyTile:SUCCESS"";\n    			return;\n    		}\n    	}\n    	else\n    	{\n    		whathappened = ""5:buyTile:ERR:OOB or already owned"";\n    		return;\n    	}\n    }\n    \n    /***\n     *     _   _ _____ _____ _     _____ _______   __\n     *    | | | |_   _|_   _| |   |_   _|_   _\ \ / /\n     *    | | | | | |   | | | |     | |   | |  \ V / \n     *    | | | | | |   | | | |     | |   | |   \ /  \n     *    | |_| | | |  _| |_| |_____| |_  | |   | |  \n     *     \___/  \_/  \___/\_____/\___/  \_/   \_/  \n     *                                               \n     */\n    \n    // this logic COULD be reduced a little, but the gain is minimal and readability suffers\n    function blockHexCoordsValid(int8 x, int8 y) private constant returns (bool)\n    {\n    	uint8 absx;\n		uint8 absy;\n		if(x < 0)\n			absx = uint8(x*-1);\n		else\n			absx = uint8(x);\n		if(y < 0)\n			absy = uint8(y*-1);\n		else\n			absy = uint8(y);\n    	\n    	if(absy <= 33) // middle rectangle\n    	{\n    		if(y % 2 != 0 ) // odd\n    		{\n    			if(-50 <= x && x <= 49)\n    				return true;\n    		}\n    		else // even\n    		{\n    			if(absx <= 49)\n    				return true;\n    		}	\n    	}	\n    	else\n    	{	\n    		if((y >= 0 && x >= 0) || (y < 0 && x > 0)) // first or 4th quadrants\n    		{\n    			if(y % 2 != 0 ) // odd\n    			{\n    				if (((absx*2) + (absy*3)) <= 198)\n    					return true;\n    			}	\n    			else	// even\n    			{\n    				if ((((absx+1)*2) + ((absy-1)*3)) <= 198)\n    					return true;\n    			}\n    		}\n    		else\n    		{	\n    			if(y % 2 == 0 ) // even\n    			{\n    				if (((absx*2) + (absy*3)) <= 198)\n    					return true;\n    			}	\n    			else	// odd\n    			{\n    				if ((((absx+1)*2) + ((absy-1)*3)) <= 198)\n    					return true;\n    			}\n    		}\n    	}\n    	return false;\n    }\n    \n    // SEVERAL CHECKS TO BE PERFORMED\n    // 1. DID THE OWNER SEND THIS MESSAGE?		(SEE editBlock)\n    // 2. IS THE Z LOCATION OF THE BLOCK BELOW ZERO? BLOCKS CANNOT BE HIDDEN AFTER SHOWING	   (SEE editBlock)\n    // 3. DO ANY OF THE PROPOSED HEXES FALL OUTSIDE OF THE TILE? \n    // 4. DO ANY OF THE PROPOSED HEXES CONFLICT WITH ENTRIES IN OCCUPADO? \n    // 5. DO ANY OF THE BLOCKS TOUCH ANOTHER?\n    // 6. NONE OF THE OCCUPY BLOCKS TOUCHED THE GROUND. BUT MAYBE THEY TOUCH ANOTHER BLOCK?\n    \n    function isValidLocation(uint8 col, uint8 row, int8[5] _block, int8[24] wouldoccupy) private constant returns (bool)\n    {\n    	bool touches;\n    	Tile tile = tiles[col][row]; // since this is a private method, we don't need to check col,row validity\n    	\n        for(uint8 b = 0; b < 24; b+=3) // always 8 hexes, calculate the wouldoccupy and the didoccupy\n       	{\n       		if(!blockHexCoordsValid(wouldoccupy[b], wouldoccupy[b+1])) // 3. DO ANY OF THE PROPOSED HEXES FALL OUTSIDE OF THE TILE? \n      		{\n       			whathappened = ""10:editBlock:ERR:OOB"";\n      			return false;\n      		}\n       		for(uint o = 0; o < tile.occupado.length; o++)  // 4. DO ANY OF THE PROPOSED HEXES CONFLICT WITH ENTRIES IN OCCUPADO? \n          	{\n      			if(wouldoccupy[b] == tile.occupado[o][0] && wouldoccupy[b+1] == tile.occupado[o][1] && wouldoccupy[b+2] == tile.occupado[o][2]) // do the x,y,z entries of each match?\n      			{\n      				whathappened = ""11:editBlock:ERR:conflict with another block"";\n      				return false; // this hex conflicts. The proposed block does not avoid overlap. Return false immediately.\n      			}\n          	}\n      		if(touches == false && wouldoccupy[b+2] == 0)  // 5. DO ANY OF THE BLOCKS TOUCH ANOTHER? (GROUND ONLY FOR NOW)\n      		{\n      			touches = true; // once true, always true til the end of this method. We must keep looping to check all the hexes for conflicts and tile boundaries, though, so we can't return true here.\n      		}	\n       	}\n        \n        // now if we're out of the loop and here, there were no conflicts and the block was found to be in the tile boundary.\n        // touches may be true or false, so we need to check \n          \n        if(touches == false)  // 6. NONE OF THE OCCUPY BLOCKS TOUCHED THE GROUND. BUT MAYBE THEY TOUCH ANOTHER BLOCK?\n  		{\n          	int8[48] memory attachesto = bds.getAttachesto(uint8(_block[0]));\n          	for(uint8 a = 0; a < 48 && !touches; a+=3) // always 8 hexes, calculate the wouldoccupy and the didoccupy\n          	{\n          		if(attachesto[a] == 0 && attachesto[a+1] == 0 && attachesto[a+2] == 0) // there are no more attachestos available, break (0,0,0 signifies end)\n          			break;\n          		//attachesto[a] = attachesto[a]+_block[1];\n          		attachesto[a+1] = attachesto[a+1]+_block[2];\n           		if(attachesto[1] % 2 != 0 && attachesto[a+1] % 2 == 0) // (for attachesto, anchory is the same as for occupies, but the z is different. Nothing to worry about)\n           			attachesto[a] = attachesto[a]+1;  			       // then offset x by +1\n           		//attachesto[a+2] = attachesto[a+2]+_block[3];\n           		for(o = 0; o < tile.occupado.length && !touches; o++)\n           		{\n           			if((attachesto[a]+_block[1]) == tile.occupado[o][0] && attachesto[a+1] == tile.occupado[o][1] && (attachesto[a+2]+_block[3]) == tile.occupado[o][2]) // a valid attachesto found in occupado?\n           			{\n           				whathappened = ""12:editBlock:SUCCESS:block put on another"";\n           				return true; // in bounds, didn't conflict and now touches is true. All good. Return.\n           			}\n           		}\n          	}\n          	whathappened = ""13:editBlock:ERR:floating"";\n          	return false; \n  		}\n        else // touches was true by virtue of a z = 0 above (touching the ground). Return true;\n        {\n        	whathappened = ""14:editBlock:SUCCESS:block put on ground"";\n        	return true;\n        }	\n    }  \n\n    string whathappened;\n    function getWhatHappened() public constant returns (string)\n    {\n    	return whathappened;\n    }\n\n   /***\n    Return money fallback and empty random funds, if any\n    */\n   function() \n   {\n	   tx.origin.send(msg.value);\n   }\n   \n   function empty() \n   {\n	   creator.send(address(this).balance); // etheria should never hold a balance. But in case it does, at least provide a way to retrieve them.\n   }\n    \n   /**********\n   Standard lock-kill methods \n   **********/\n   bool locked;			// until locked, creator can kill, set names, statuses and tile ownership.\n   function setLocked()\n   {\n	   if (msg.sender == creator)\n		   locked = true;\n   }\n   function getLocked() public constant returns (bool)\n   {\n	   return locked;\n   }\n   function kill()\n   { \n	   if (!getLocked() && msg.sender == creator)\n		   suicide(creator);  // kills this contract and sends remaining funds back to creator\n   }\n}\n",2,
470957,0xb21f8684f23dbb1008508b4de91a0aaedebdb7e4,FALSE,FALSE,"//                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               contract BlockDefStorage \n{\n	function getOccupies(uint8 blocktype) public returns (int8[24])\n	{}\n	function getAttachesto(uint8 blocktype) public returns (int8[48])\n    {}\n}\n\ncontract MapElevationRetriever \n{\n	function getElevation(uint8 col, uint8 row) public constant returns (uint8)\n	{}\n}\n\ncontract Etheria \n{\n	event TileChanged(uint8 col, uint8 row);//, address owner, string name, string status, uint lastfarm, address[] offerers, uint[] offers, int8[5][] blocks);\n	\n    uint8 mapsize = 33;\n    Tile[33][33] tiles;\n    address creator;\n    \n    struct Tile \n    {\n    	address owner;\n    	string name;\n    	string status;\n    	int8[5][] blocks; //0 = blocktype,1 = blockx,2 = blocky,3 = blockz, 4 = color\n    	uint lastfarm;\n    	int8[3][] occupado; // the only one not reported in the //TileChanged event\n    }\n    \n    BlockDefStorage bds;\n    MapElevationRetriever mer;\n    \n    function Etheria() {\n    	creator = tx.origin;\n    	bds = BlockDefStorage(0xd4e686a1fbf1bfe058510f07cd3936d3d5a70589); \n    	mer = MapElevationRetriever(0x68549d7dbb7a956f955ec1263f55494f05972a6b);\n    }\n    \n    function getOwner(uint8 col, uint8 row) public constant returns(address)\n    {\n    	return tiles[col][row].owner; // no harm if col,row are invalid\n    }\n    \n    function setOwner(uint8 col, uint8 row, address newowner)\n    {\n//    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n//    	{\n//    		whathappened = ""setOwner:ERR:c,r OOB"";  \n//    		return;\n//    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != tx.origin && !(tx.origin == creator && !getLocked()))\n    	{\n    		whathappened = ""setOwner:ERR:not owner"";  \n    		return;\n    	}\n    	tile.owner = newowner;\n    	TileChanged(col,row);\n    	whathappened = ""setOwner:OK"";\n    	return;\n    }\n    \n    /***\n     *     _   _   ___  ___  ___ _____            _____ _____ ___ _____ _   _ _____ \n     *    | \ | | / _ \ |  \/  ||  ___|   ___    /  ___|_   _/ _ \_   _| | | /  ___|\n     *    |  \| |/ /_\ \| .  . || |__    ( _ )   \ `--.  | |/ /_\ \| | | | | \ `--. \n     *    | . ` ||  _  || |\/| ||  __|   / _ \/\  `--. \ | ||  _  || | | | | |`--. \\n     *    | |\  || | | || |  | || |___  | (_>  < /\__/ / | || | | || | | |_| /\__/ /\n     *    \_| \_/\_| |_/\_|  |_/\____/   \___/\/ \____/  \_/\_| |_/\_/  \___/\____/ \n     *                                                                              \n     *                                                                              \n     */\n    \n    function getName(uint8 col, uint8 row) public constant returns(string)\n    {\n    	return tiles[col][row].name; // no harm if col,row are invalid\n    }\n    \n    function setName(uint8 col, uint8 row, string _n) public\n    {\n//    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n//    	{\n//    		whathappened = ""setName:ERR:c,r OOB"";  \n//    		return;\n//    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != tx.origin && !(tx.origin == creator && !getLocked()))\n    	{\n    		whathappened = ""setName:ERR:not owner"";  \n    		return;\n    	}\n    	tile.name = _n;\n    	TileChanged(col,row);\n    	whathappened = ""setName:OK"";\n    	return;\n    }\n    \n    function getStatus(uint8 col, uint8 row) public constant returns(string)\n    {\n    	return tiles[col][row].status; // no harm if col,row are invalid\n    }\n    \n    function setStatus(uint8 col, uint8 row, string _s) public // setting status costs 1 eth to prevent spam\n    {\n//    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n//    	{\n//    		tx.origin.send(msg.value); 		// return their money, if any\n//    		whathappened = ""setStatus:ERR:c,r OOB"";  \n//    		return;\n//    	}\n    	if(msg.value != 1000000000000000000) \n    	{\n    		tx.origin.send(msg.value); 		// return their money, if any\n    		whathappened = ""setStatus:ERR:val!=1eth"";\n    		return;\n    	}\n    	Tile tile = tiles[col][row];\n    	if(tile.owner != tx.origin && !(tx.origin == creator && !getLocked()))\n    	{\n    		tx.origin.send(msg.value); 		// return their money, if any\n    		whathappened = ""setStatus:ERR:not owner"";  \n    		return;\n    	}\n    	tile.status = _s;\n    	creator.send(msg.value);\n    	TileChanged(col,row);\n    	whathappened = ""setStatus:OK"";\n    	return;\n    }\n    \n    /***\n     *    ______ ___  _________  ________ _   _ _____            ___________ _____ _____ _____ _   _ _____ \n     *    |  ___/ _ \ | ___ \  \/  |_   _| \ | |  __ \   ___    |  ___|  _  \_   _|_   _|_   _| \ | |  __ \\n     *    | |_ / /_\ \| |_/ / .  . | | | |  \| | |  \/  ( _ )   | |__ | | | | | |   | |   | | |  \| | |  \/\n     *    |  _||  _  ||    /| |\/| | | | | . ` | | __   / _ \/\ |  __|| | | | | |   | |   | | | . ` | | __ \n     *    | |  | | | || |\ \| |  | |_| |_| |\  | |_\ \ | (_>  < | |___| |/ / _| |_  | |  _| |_| |\  | |_\ \\n     *    \_|  \_| |_/\_| \_\_|  |_/\___/\_| \_/\____/  \___/\/ \____/|___/  \___/  \_/  \___/\_| \_/\____/\n     *                                                                                                     \n     */\n    \n    function getLastFarm(uint8 col, uint8 row) public constant returns (uint)\n    {\n    	return tiles[col][row].lastfarm;\n    }\n    \n    function farmTile(uint8 col, uint8 row, int8 blocktype) public \n    {\n//    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n//    	{\n//    		tx.origin.send(msg.value); 		// return their money, if any\n//    		whathappened = ""farmTile:ERR:c,r OOB"";  \n//    		return;\n//    	}\n    	\n    	if(blocktype < 0 || blocktype > 17) // invalid blocktype\n    	{\n    		tx.origin.send(msg.value); 		// return their money, if any\n    		whathappened = ""farmTile:ERR:invalid blocktype"";\n    		return;\n    	}	\n    	\n    	Tile tile = tiles[col][row];\n        if(tile.owner != tx.origin)\n        {\n        	tx.origin.send(msg.value); 		// return their money, if any\n        	whathappened = ""farmTile:ERR:not owner"";\n        	return;\n        }\n        if((block.number - tile.lastfarm) < 2500) // ~12 hours of blocks\n        {\n        	if(msg.value != 1000000000000000000)\n        	{	\n        		tx.origin.send(msg.value); // return their money\n        		whathappened = ""farmTile:ERR:val!=1eth"";\n        		return;\n        	}\n        	else // they paid 1 ETH\n        	{\n        		creator.send(msg.value); // If they haven't waited long enough, but they've paid 1 eth, let them farm again.\n        	}	\n        }\n        else\n        {\n        	if(msg.value > 0) // they've waited long enough but also sent money. Return it and continue normally.\n        	{\n        		tx.origin.send(msg.value); // return their money\n        	}\n        }\n        \n        // by this point, they've either waited 2500 blocks or paid 1 ETH\n    	for(uint8 i = 0; i < 10; i++)\n    	{\n            tile.blocks.length+=1;\n            tile.blocks[tile.blocks.length - 1][0] = int8(blocktype); // blocktype 0-17\n    	    tile.blocks[tile.blocks.length - 1][1] = 0; // x\n    	    tile.blocks[tile.blocks.length - 1][2] = 0; // y\n    	    tile.blocks[tile.blocks.length - 1][3] = -1; // z\n    	    tile.blocks[tile.blocks.length - 1][4] = 0; // color\n    	}\n    	tile.lastfarm = block.number;\n    	TileChanged(col,row);\n    	whathappened = ""farmTile:OK"";\n    	return;\n    }\n    \n    function editBlock(uint8 col, uint8 row, uint index, int8[5] _block)   // NOTE: won't return accidental money.\n    {\n//    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n//    	{\n//    		whathappened = ""editBlock:ERR:c,r OOB"";  \n//    		return;\n//    	}\n    	Tile tile = tiles[col][row];\n        if(tile.owner != tx.origin) // 1. DID THE OWNER SEND THIS MESSAGE?\n        {\n        	whathappened = ""editBlock:ERR:not owner"";\n        	return;\n        }\n        if(_block[3] < 0) // 2. IS THE Z LOCATION OF THE BLOCK BELOW ZERO? BLOCKS CANNOT BE HIDDEN\n        {\n        	whathappened = ""editBlock:ERR:can't hide blocks"";\n        	return;\n        }\n        if(index > (tile.blocks.length-1))\n        {\n        	whathappened = ""editBlock:ERR:index OOR"";\n        	return;\n        }		\n        if(_block[0] == -1) // user has signified they want to only change the color of this block\n        {\n        	tile.blocks[index][4] = _block[4];\n        	whathappened = ""editBlock:OK:color changed"";\n        	return;\n        }	\n        _block[0] = tile.blocks[index][0]; // can't change the blocktype, so set it to whatever it already was\n\n        int8[24] memory didoccupy = bds.getOccupies(uint8(_block[0]));\n        int8[24] memory wouldoccupy = bds.getOccupies(uint8(_block[0]));\n        \n        for(uint8 b = 0; b < 24; b+=3) // always 8 hexes, calculate the didoccupy\n 		{\n 			 wouldoccupy[b] = wouldoccupy[b]+_block[1];\n 			 wouldoccupy[b+1] = wouldoccupy[b+1]+_block[2];\n 			 if(wouldoccupy[1] % 2 != 0 && wouldoccupy[b+1] % 2 == 0) // if anchor y is odd and this hex y is even, (SW NE beam goes 11,`2`2,23,`3`4,35,`4`6,47,`5`8  ` = x value incremented by 1. Same applies to SW NE beam from 01,12,13,24,25,36,37,48)\n 				 wouldoccupy[b] = wouldoccupy[b]+1;  			   // then offset x by +1\n 			 wouldoccupy[b+2] = wouldoccupy[b+2]+_block[3];\n 			 \n 			 didoccupy[b] = didoccupy[b]+tile.blocks[index][1];\n 			 didoccupy[b+1] = didoccupy[b+1]+tile.blocks[index][2];\n 			 if(didoccupy[1] % 2 != 0 && didoccupy[b+1] % 2 == 0) // if anchor y and this hex y are both odd,\n 				 didoccupy[b] = didoccupy[b]+1; 					 // then offset x by +1\n       		didoccupy[b+2] = didoccupy[b+2]+tile.blocks[index][3];\n 		}\n        \n        if(!isValidLocation(col,row,_block, wouldoccupy))\n        {\n        	return; // whathappened is already set\n        }\n        \n        // EVERYTHING CHECKED OUT, WRITE OR OVERWRITE THE HEXES IN OCCUPADO\n        \n      	if(tile.blocks[index][3] >= 0) // If the previous z was greater than 0 (i.e. not hidden) ...\n     	{\n         	for(uint8 l = 0; l < 24; l+=3) // loop 8 times,find the previous occupado entries and overwrite them\n         	{\n         		for(uint o = 0; o < tile.occupado.length; o++)\n         		{\n         			if(didoccupy[l] == tile.occupado[o][0] && didoccupy[l+1] == tile.occupado[o][1] && didoccupy[l+2] == tile.occupado[o][2]) // x,y,z equal?\n         			{\n         				tile.occupado[o][0] = wouldoccupy[l]; // found it. Overwrite it\n         				tile.occupado[o][1] = wouldoccupy[l+1];\n         				tile.occupado[o][2] = wouldoccupy[l+2];\n         			}\n         		}\n         	}\n     	}\n     	else // previous block was hidden\n     	{\n     		for(uint8 ll = 0; ll < 24; ll+=3) // add the 8 new hexes to occupado\n         	{\n     			tile.occupado.length++;\n     			tile.occupado[tile.occupado.length-1][0] = wouldoccupy[ll];\n     			tile.occupado[tile.occupado.length-1][1] = wouldoccupy[ll+1];\n     			tile.occupado[tile.occupado.length-1][2] = wouldoccupy[ll+2];\n         	}\n     	}\n     	tile.blocks[index] = _block;\n     	TileChanged(col,row);\n    	return;\n    }\n       \n    function getBlocks(uint8 col, uint8 row) public constant returns (int8[5][])\n    {\n    	return tiles[col][row].blocks; // no harm if col,row are invalid\n    }\n   \n    // three OK conditions:\n    // 1. Valid offer on unowned tile. (whathap = 4)\n    // 2. Valid offer on owned tile where offerer did not previously have an offer on file (whathap = 7)\n    // 3. Valid offer on owned tile where offerer DID have a previous offer on file (whathap = 6)\n    function buyTile(uint8 col, uint8 row)\n    {    	\n//    	if(isOOB(col,row)) // row and/or col was not between 0-mapsize\n//    	{\n//    		tx.origin.send(msg.value);              // return their money, if any\n//    		whathappened = ""buyTile:ERR:c,r OOB"";  \n//    		return;\n//    	}\n//    	\n    	if(msg.value != 1000000000000000000)	// 1 ETH is the starting value. If not return; // Also, if below sea level, return. \n		{\n    		tx.origin.send(msg.value);              // return their money, if any\n    		whathappened = ""buyTile:ERR:val!=1eth"";  \n    		return;\n		}\n    	\n    	Tile tile = tiles[col][row];\n    	if(tile.owner == address(0x0000000000000000000000000000000000000000))			// if UNOWNED\n    	{	  \n    		if(mer.getElevation(col,row) < 125)	// 1 ETH is the starting value. If not return; // Also, if below sea level, return. \n    		{\n    			tx.origin.send(msg.value); 	 									// return their money\n    			whathappened = ""buyTile:ERR:water"";\n    			return;\n    		}\n    		else\n    		{	\n    			creator.send(msg.value);     		 					// this was a valid offer, send money to contract creator\n    			tile.owner = tx.origin;  								// set tile owner to the buyer\n    			TileChanged(col,row);\n    			whathappened = ""buyTile:OK"";\n    			return;\n    		}\n    	}\n    	else\n    	{\n    		tx.origin.send(msg.value);              // return their money, if any\n    		whathappened = ""buyTile:ERR:alr owned"";\n    		return;\n    	}\n    }\n    \n    /***\n     *     _   _ _____ _____ _     _____ _______   __\n     *    | | | |_   _|_   _| |   |_   _|_   _\ \ / /\n     *    | | | | | |   | | | |     | |   | |  \ V / \n     *    | | | | | |   | | | |     | |   | |   \ /  \n     *    | |_| | | |  _| |_| |_____| |_  | |   | |  \n     *     \___/  \_/  \___/\_____/\___/  \_/   \_/  \n     *                                               \n     */\n    \n    // this logic COULD be reduced a little, but the gain is minimal and readability suffers\n    function blockHexCoordsValid(int8 x, int8 y) private constant returns (bool)\n    {\n    	uint absx;\n		uint absy;\n		if(x < 0)\n			absx = uint(x*-1);\n		else\n			absx = uint(x);\n		if(y < 0)\n			absy = uint(y*-1);\n		else\n			absy = uint(y);\n    	\n    	if(absy <= 33) // middle rectangle\n    	{\n    		if(y % 2 != 0 ) // odd\n    		{\n    			if(-50 <= x && x <= 49)\n    				return true;\n    		}\n    		else // even\n    		{\n    			if(absx <= 49)\n    				return true;\n    		}	\n    	}	\n    	else\n    	{	\n    		if((y >= 0 && x >= 0) || (y < 0 && x > 0)) // first or 4th quadrants\n    		{\n    			if(y % 2 != 0 ) // odd\n    			{\n    				if (((absx*2) + (absy*3)) <= 198)\n    					return true;\n    			}	\n    			else	// even\n    			{\n    				if ((((absx+1)*2) + ((absy-1)*3)) <= 198)\n    					return true;\n    			}\n    		}\n    		else\n    		{	\n    			if(y % 2 == 0 ) // even\n    			{\n    				if (((absx*2) + (absy*3)) <= 198)\n    					return true;\n    			}	\n    			else	// odd\n    			{\n    				if ((((absx+1)*2) + ((absy-1)*3)) <= 198)\n    					return true;\n    			}\n    		}\n    	}\n    	return false;\n    }\n    \n    // SEVERAL CHECKS TO BE PERFORMED\n    // 1. DID THE OWNER SEND THIS MESSAGE?		(SEE editBlock)\n    // 2. IS THE Z LOCATION OF THE BLOCK BELOW ZERO? BLOCKS CANNOT BE HIDDEN AFTER SHOWING	   (SEE editBlock)\n    // 3. DO ANY OF THE PROPOSED HEXES FALL OUTSIDE OF THE TILE? \n    // 4. DO ANY OF THE PROPOSED HEXES CONFLICT WITH ENTRIES IN OCCUPADO? \n    // 5. DO ANY OF THE BLOCKS TOUCH ANOTHER?\n    // 6. NONE OF THE OCCUPY BLOCKS TOUCHED THE GROUND. BUT MAYBE THEY TOUCH ANOTHER BLOCK?\n    \n    function isValidLocation(uint8 col, uint8 row, int8[5] _block, int8[24] wouldoccupy) private constant returns (bool)\n    {\n    	bool touches;\n    	Tile tile = tiles[col][row]; // since this is a private method, we don't need to check col,row validity\n    	\n        for(uint8 b = 0; b < 24; b+=3) // always 8 hexes, calculate the wouldoccupy and the didoccupy\n       	{\n       		if(!blockHexCoordsValid(wouldoccupy[b], wouldoccupy[b+1])) // 3. DO ANY OF THE PROPOSED HEXES FALL OUTSIDE OF THE TILE? \n      		{\n       			whathappened = ""editBlock:ERR:OOB"";\n      			return false;\n      		}\n       		for(uint o = 0; o < tile.occupado.length; o++)  // 4. DO ANY OF THE PROPOSED HEXES CONFLICT WITH ENTRIES IN OCCUPADO? \n          	{\n      			if(wouldoccupy[b] == tile.occupado[o][0] && wouldoccupy[b+1] == tile.occupado[o][1] && wouldoccupy[b+2] == tile.occupado[o][2]) // do the x,y,z entries of each match?\n      			{\n      				whathappened = ""editBlock:ERR:conflict"";\n      				return false; // this hex conflicts. The proposed block does not avoid overlap. Return false immediately.\n      			}\n          	}\n      		if(touches == false && wouldoccupy[b+2] == 0)  // 5. DO ANY OF THE BLOCKS TOUCH ANOTHER? (GROUND ONLY FOR NOW)\n      		{\n      			touches = true; // once true, always true til the end of this method. We must keep looping to check all the hexes for conflicts and tile boundaries, though, so we can't return true here.\n      		}	\n       	}\n        \n        // now if we're out of the loop and here, there were no conflicts and the block was found to be in the tile boundary.\n        // touches may be true or false, so we need to check \n          \n        if(touches == false)  // 6. NONE OF THE OCCUPY BLOCKS TOUCHED THE GROUND. BUT MAYBE THEY TOUCH ANOTHER BLOCK?\n  		{\n          	int8[48] memory attachesto = bds.getAttachesto(uint8(_block[0]));\n          	for(uint8 a = 0; a < 48 && !touches; a+=3) // always 8 hexes, calculate the wouldoccupy and the didoccupy\n          	{\n          		if(attachesto[a] == 0 && attachesto[a+1] == 0 && attachesto[a+2] == 0) // there are no more attachestos available, break (0,0,0 signifies end)\n          			break;\n          		//attachesto[a] = attachesto[a]+_block[1];\n          		attachesto[a+1] = attachesto[a+1]+_block[2];\n           		if(attachesto[1] % 2 != 0 && attachesto[a+1] % 2 == 0) // (for attachesto, anchory is the same as for occupies, but the z is different. Nothing to worry about)\n           			attachesto[a] = attachesto[a]+1;  			       // then offset x by +1\n           		//attachesto[a+2] = attachesto[a+2]+_block[3];\n           		for(o = 0; o < tile.occupado.length && !touches; o++)\n           		{\n           			if((attachesto[a]+_block[1]) == tile.occupado[o][0] && attachesto[a+1] == tile.occupado[o][1] && (attachesto[a+2]+_block[3]) == tile.occupado[o][2]) // a valid attachesto found in occupado?\n           			{\n           				whathappened = ""editBlock:OK:attached"";\n           				return true; // in bounds, didn't conflict and now touches is true. All good. Return.\n           			}\n           		}\n          	}\n          	whathappened = ""editBlock:ERR:floating"";\n          	return false; \n  		}\n        else // touches was true by virtue of a z = 0 above (touching the ground). Return true;\n        {\n        	whathappened = ""editBlock:OK:ground"";\n        	return true;\n        }	\n    }  \n\n//    function isOOB(uint8 col, uint8 row) private constant returns (bool)\n//    {\n//    	if(col < 0 || col > (mapsize-1) || row < 0 || row > (mapsize-1))\n//    		return true; // is out of bounds\n//    }\n    \n    string whathappened;\n    function getWhatHappened() public constant returns (string)\n    {\n    	return whathappened;\n    }\n\n   /***\n    Return money fallback and empty random funds, if any\n    */\n   function() \n   {\n	   tx.origin.send(msg.value);\n   }\n   \n   function empty() \n   {\n	   creator.send(address(this).balance); // etheria should never hold a balance. But in case it does, at least provide a way to retrieve them.\n   }\n    \n   /**********\n   Standard lock-kill methods \n   **********/\n   bool locked;			// until locked, creator can kill, set names, statuses and tile ownership.\n   function setLocked()\n   {\n	   if (msg.sender == creator)\n		   locked = true;\n   }\n   function getLocked() public constant returns (bool)\n   {\n	   return locked;\n   }\n   function kill()\n   { \n	   if (!getLocked() && msg.sender == creator)\n		   suicide(creator);  // kills this contract and sends remaining funds back to creator\n   }\n}\n\n//                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               \n                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           \n",1,
548481,0x3025cb17ff79e731e8786af0bf08ac611f530b2a,FALSE,FALSE,"//sol Wallet\n// Multi-sig, daily-limited account proxy/wallet.\n// @authors:\n// Gav Wood <g@ethdev.com>\n// inheritable ""property"" contract that enables methods to be protected by requiring the acquiescence of either a\n// single, or, crucially, each of a number of, designated owners.\n// usage:\n// use modifiers onlyowner (just own owned) or onlymanyowners(hash), whereby the same hash must be provided by\n// some number (specified in constructor) of the set of owners (specified in the constructor, modifiable) before the\n// interior is executed.\ncontract multiowned {\n\n	// TYPES\n\n    // struct for the status of a pending operation.\n    struct PendingState {\n        uint yetNeeded;\n        uint ownersDone;\n        uint index;\n    }\n\n	// EVENTS\n\n    // this contract only has five types of events: it can accept a confirmation, in which case\n    // we record owner and operation (hash) alongside it.\n    event Confirmation(address owner, bytes32 operation);\n    event Revoke(address owner, bytes32 operation);\n    // some others are in the case of an owner changing.\n    event OwnerChanged(address oldOwner, address newOwner);\n    event OwnerAdded(address newOwner);\n    event OwnerRemoved(address oldOwner);\n    // the last one is emitted if the required signatures change\n    event RequirementChanged(uint newRequirement);\n\n	// MODIFIERS\n\n    // simple single-sig function modifier.\n    modifier onlyowner {\n        if (isOwner(msg.sender))\n            _\n    }\n    // multi-sig function modifier: the operation must have an intrinsic hash in order\n    // that later attempts can be realised as the same underlying operation and\n    // thus count as confirmations.\n    modifier onlymanyowners(bytes32 _operation) {\n        if (confirmAndCheck(_operation))\n            _\n    }\n\n	// METHODS\n\n    // constructor is given number of sigs required to do protected ""onlymanyowners"" transactions\n    // as well as the selection of addresses capable of confirming them.\n    function multiowned(address[] _owners, uint _required) {\n        m_numOwners = _owners.length + 1;\n        m_owners[1] = uint(msg.sender);\n        m_ownerIndex[uint(msg.sender)] = 1;\n        for (uint i = 0; i < _owners.length; ++i)\n        {\n            m_owners[2 + i] = uint(_owners[i]);\n            m_ownerIndex[uint(_owners[i])] = 2 + i;\n        }\n        m_required = _required;\n    }\n    \n    // Revokes a prior confirmation of the given operation\n    function revoke(bytes32 _operation) external {\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n        // make sure they're an owner\n        if (ownerIndex == 0) return;\n        uint ownerIndexBit = 2**ownerIndex;\n        var pending = m_pending[_operation];\n        if (pending.ownersDone & ownerIndexBit > 0) {\n            pending.yetNeeded++;\n            pending.ownersDone -= ownerIndexBit;\n            Revoke(msg.sender, _operation);\n        }\n    }\n    \n    // Replaces an owner `_from` with another `_to`.\n    function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external {\n        if (isOwner(_to)) return;\n        uint ownerIndex = m_ownerIndex[uint(_from)];\n        if (ownerIndex == 0) return;\n\n        clearPending();\n        m_owners[ownerIndex] = uint(_to);\n        m_ownerIndex[uint(_from)] = 0;\n        m_ownerIndex[uint(_to)] = ownerIndex;\n        OwnerChanged(_from, _to);\n    }\n    \n    function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n        if (isOwner(_owner)) return;\n\n        clearPending();\n        if (m_numOwners >= c_maxOwners)\n            reorganizeOwners();\n        if (m_numOwners >= c_maxOwners)\n            return;\n        m_numOwners++;\n        m_owners[m_numOwners] = uint(_owner);\n        m_ownerIndex[uint(_owner)] = m_numOwners;\n        OwnerAdded(_owner);\n    }\n    \n    function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external {\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\n        if (ownerIndex == 0) return;\n        if (m_required > m_numOwners - 1) return;\n\n        m_owners[ownerIndex] = 0;\n        m_ownerIndex[uint(_owner)] = 0;\n        clearPending();\n        reorganizeOwners(); //make sure m_numOwner is equal to the number of owners and always points to the optimal free slot\n        OwnerRemoved(_owner);\n    }\n    \n    function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external {\n        if (_newRequired > m_numOwners) return;\n        m_required = _newRequired;\n        clearPending();\n        RequirementChanged(_newRequired);\n    }\n    \n    function isOwner(address _addr) returns (bool) {\n        return m_ownerIndex[uint(_addr)] > 0;\n    }\n    \n    function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) {\n        var pending = m_pending[_operation];\n        uint ownerIndex = m_ownerIndex[uint(_owner)];\n\n        // make sure they're an owner\n        if (ownerIndex == 0) return false;\n\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        return !(pending.ownersDone & ownerIndexBit == 0);\n    }\n    \n    // INTERNAL METHODS\n\n    function confirmAndCheck(bytes32 _operation) internal returns (bool) {\n        // determine what index the present sender is:\n        uint ownerIndex = m_ownerIndex[uint(msg.sender)];\n        // make sure they're an owner\n        if (ownerIndex == 0) return;\n\n        var pending = m_pending[_operation];\n        // if we're not yet working on this operation, switch over and reset the confirmation status.\n        if (pending.yetNeeded == 0) {\n            // reset count of confirmations needed.\n            pending.yetNeeded = m_required;\n            // reset which owners have confirmed (none) - set our bitmap to 0.\n            pending.ownersDone = 0;\n            pending.index = m_pendingIndex.length++;\n            m_pendingIndex[pending.index] = _operation;\n        }\n        // determine the bit to set for this owner.\n        uint ownerIndexBit = 2**ownerIndex;\n        // make sure we (the message sender) haven't confirmed this operation previously.\n        if (pending.ownersDone & ownerIndexBit == 0) {\n            Confirmation(msg.sender, _operation);\n            // ok - check if count is enough to go ahead.\n            if (pending.yetNeeded <= 1) {\n                // enough confirmations: reset and run interior.\n                delete m_pendingIndex[m_pending[_operation].index];\n                delete m_pending[_operation];\n                return true;\n            }\n            else\n            {\n                // not enough: record that this owner in particular confirmed.\n                pending.yetNeeded--;\n                pending.ownersDone |= ownerIndexBit;\n            }\n        }\n    }\n\n    function reorganizeOwners() private {\n        uint free = 1;\n        while (free < m_numOwners)\n        {\n            while (free < m_numOwners && m_owners[free] != 0) free++;\n            while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--;\n            if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0)\n            {\n                m_owners[free] = m_owners[m_numOwners];\n                m_ownerIndex[m_owners[free]] = free;\n                m_owners[m_numOwners] = 0;\n            }\n        }\n    }\n    \n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            if (m_pendingIndex[i] != 0)\n                delete m_pending[m_pendingIndex[i]];\n        delete m_pendingIndex;\n    }\n        \n   	// FIELDS\n\n    // the number of owners that must confirm the same operation before it is run.\n    uint public m_required;\n    // pointer used to find a free slot in m_owners\n    uint public m_numOwners;\n    \n    // list of owners\n    uint[256] m_owners;\n    uint constant c_maxOwners = 250;\n    // index on the list of owners to allow reverse lookup\n    mapping(uint => uint) m_ownerIndex;\n    // the ongoing operations.\n    mapping(bytes32 => PendingState) m_pending;\n    bytes32[] m_pendingIndex;\n}\n\n// inheritable ""property"" contract that enables methods to be protected by placing a linear limit (specifiable)\n// on a particular resource per calendar day. is multiowned to allow the limit to be altered. resource that method\n// uses is specified in the modifier.\ncontract daylimit is multiowned {\n\n	// MODIFIERS\n\n    // simple modifier for daily limit.\n    modifier limitedDaily(uint _value) {\n        if (underLimit(_value))\n            _\n    }\n\n	// METHODS\n\n    // constructor - stores initial daily limit and records the present day's index.\n    function daylimit(uint _limit) {\n        m_dailyLimit = _limit;\n        m_lastDay = today();\n    }\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n    function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external {\n        m_dailyLimit = _newLimit;\n    }\n    // (re)sets the daily limit. needs many of the owners to confirm. doesn't alter the amount already spent today.\n    function resetSpentToday() onlymanyowners(sha3(msg.data)) external {\n        m_spentToday = 0;\n    }\n    \n    // INTERNAL METHODS\n    \n    // checks to see if there is at least `_value` left from the daily limit today. if there is, subtracts it and\n    // returns true. otherwise just returns false.\n    function underLimit(uint _value) internal onlyowner returns (bool) {\n        // reset the spend limit if we're on a different day to last time.\n        if (today() > m_lastDay) {\n            m_spentToday = 0;\n            m_lastDay = today();\n        }\n        // check to see if there's enough left - if so, subtract and return true.\n        if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) {\n            m_spentToday += _value;\n            return true;\n        }\n        return false;\n    }\n    // determines today's index.\n    function today() private constant returns (uint) { return now / 1 days; }\n\n	// FIELDS\n\n    uint public m_dailyLimit;\n    uint m_spentToday;\n    uint m_lastDay;\n}\n\n// interface contract for multisig proxy contracts; see below for docs.\ncontract multisig {\n\n	// EVENTS\n\n    // logged events:\n    // Funds has arrived into the wallet (record how much).\n    event Deposit(address _from, uint value);\n    // Single transaction going out of the wallet (record who signed for it, how much, and to whom it's going).\n    event SingleTransact(address owner, uint value, address to, bytes data);\n    // Multi-sig transaction going out of the wallet (record who signed for it last, the operation hash, how much, and to whom it's going).\n    event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data);\n    // Confirmation still needed for a transaction.\n    event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data);\n    \n    // FUNCTIONS\n    \n    // TODO: document\n    function changeOwner(address _from, address _to) external;\n    function execute(address _to, uint _value, bytes _data) external returns (bytes32);\n    function confirm(bytes32 _h) returns (bool);\n}\n\n// usage:\n// bytes32 h = Wallet(w).from(oneOwner).transact(to, value, data);\n// Wallet(w).from(anotherOwner).confirm(h);\ncontract Wallet is multisig, multiowned, daylimit {\n\n	// TYPES\n\n    // Transaction structure to remember details of transaction lest it need be saved for a later call.\n    struct Transaction {\n        address to;\n        uint value;\n        bytes data;\n    }\n\n    // METHODS\n\n    // constructor - just pass on the owner array to the multiowned and\n    // the limit to daylimit\n    function Wallet(address[] _owners, uint _required, uint _daylimit)\n            multiowned(_owners, _required) daylimit(_daylimit) {\n    }\n    \n    // kills the contract sending everything to `_to`.\n    function kill(address _to) onlymanyowners(sha3(msg.data)) external {\n        suicide(_to);\n    }\n    \n    // gets called when no other function matches\n    function() {\n        // just being sent some cash?\n        if (msg.value > 0)\n            Deposit(msg.sender, msg.value);\n    }\n    \n    // Outside-visible transact entry point. Executes transacion immediately if below daily spend limit.\n    // If not, goes into multisig process. We provide a hash on return to allow the sender to provide\n    // shortcuts for the other confirmations (allowing them to avoid replicating the _to, _value\n    // and _data arguments). They still get the option of using them if they want, anyways.\n    function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) {\n        // first, take the opportunity to check that we're under the daily limit.\n        if (underLimit(_value)) {\n            SingleTransact(msg.sender, _value, _to, _data);\n            // yes - just execute the call.\n            _to.call.value(_value)(_data);\n            return 0;\n        }\n        // determine our operation hash.\n        _r = sha3(msg.data, block.number);\n        if (!confirm(_r) && m_txs[_r].to == 0) {\n            m_txs[_r].to = _to;\n            m_txs[_r].value = _value;\n            m_txs[_r].data = _data;\n            ConfirmationNeeded(_r, msg.sender, _value, _to, _data);\n        }\n    }\n    \n    // confirm a transaction through just the hash. we use the previous transactions map, m_txs, in order\n    // to determine the body of the transaction from the hash provided.\n    function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) {\n        if (m_txs[_h].to != 0) {\n            m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data);\n            MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data);\n            delete m_txs[_h];\n            return true;\n        }\n    }\n    \n    // INTERNAL METHODS\n    \n    function clearPending() internal {\n        uint length = m_pendingIndex.length;\n        for (uint i = 0; i < length; ++i)\n            delete m_txs[m_pendingIndex[i]];\n        super.clearPending();\n    }\n\n	// FIELDS\n\n    // pending transactions we have at present.\n    mapping (bytes32 => Transaction) m_txs;\n}",1,
611093,0xaa1de55b828067d37e9c163a547c7e0302afae07,FALSE,FALSE,contract owned {\n    function owned() {\n        owner = msg.sender;\n    }\n    modifier onlyowner() { \n        if (msg.sender == owner)\n            _\n    }\n    address owner;\n}\ncontract CoinLock is owned {\n    uint public expiration; // Timestamp in # of seconds.\n    \n    function lock(uint _expiration) onlyowner returns (bool) {\n        if (_expiration > block.timestamp && expiration == 0) {\n            expiration = _expiration;\n            return true;\n        }\n        return false;\n    }\n    function redeem() onlyowner {\n        if (block.timestamp > expiration) {\n            suicide(owner);\n        }\n    }\n},1,
671225,0xda9ebfa1516409e5501c454667acc0db4471b66e,FALSE,FALSE,"contract ElcoinDb {\n    address owner;\n    address caller;\n\n    event Transaction(bytes32 indexed hash, address indexed from, address indexed to, uint time, uint amount);\n\n    modifier checkOwner() { if(msg.sender == owner) { _ } else { return; } }\n    modifier checkCaller() { if(msg.sender == caller) { _ } else { return; } }\n    mapping (address => uint) public balances;\n\n    function ElcoinDb(address pCaller) {\n        owner = msg.sender;\n        caller = pCaller;\n    }\n\n    function getOwner() constant returns (address rv) {\n        return owner;\n    }\n\n    function getCaller() constant returns (address rv) {\n        return caller;\n    }\n\n    function setCaller(address pCaller) checkOwner() returns (bool _success) {\n        caller = pCaller;\n\n        return true;\n    }\n\n    function setOwner(address pOwner) checkOwner() returns (bool _success) {\n        owner = pOwner;\n\n        return true;\n    }\n\n    function getBalance(address addr) constant returns(uint balance) {\n        return balances[addr];\n    }\n\n    function deposit(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\n        balances[addr] += amount;\n        Transaction(hash,0 , addr, time, amount);\n\n        return true;\n    }\n\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\n        uint oldBalance = balances[addr];\n        if(oldBalance >= amount) {\n            msg.sender.send(amount);\n            balances[addr] = oldBalance - amount;\n            Transaction(hash, addr, 0, time, amount);\n            return true;\n        }\n\n        return false;\n    }\n}",1,
930473,0x89efe605e9ecbe22849cd85d5449cc946c26f8f3,FALSE,FALSE,"// Accounting v0.1 (not the same as the 0.1 release of this library)\n\n/// @title Accounting Lib - Accounting utilities\n/// @author Piper Merriam - <pipermerriam@gmail.com>\nlibrary AccountingLib {\n        /*\n         *  Address: 0x89efe605e9ecbe22849cd85d5449cc946c26f8f3\n         */\n        struct Bank {\n            mapping (address => uint) accountBalances;\n        }\n\n        /// @dev Low level method for adding funds to an account.  Protects against overflow.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be added to.\n        /// @param value The amount that should be added to the account.\n        function addFunds(Bank storage self, address accountAddress, uint value) public {\n                if (self.accountBalances[accountAddress] + value < self.accountBalances[accountAddress]) {\n                        // Prevent Overflow.\n                        throw;\n                }\n                self.accountBalances[accountAddress] += value;\n        }\n\n        event _Deposit(address indexed _from, address indexed accountAddress, uint value);\n        /// @dev Function wrapper around the _Deposit event so that it can be used by contracts.  Can be used to log a deposit to an account.\n        /// @param _from The address that deposited the funds.\n        /// @param accountAddress The address of the account the funds were added to.\n        /// @param value The amount that was added to the account.\n        function Deposit(address _from, address accountAddress, uint value) public {\n            _Deposit(_from, accountAddress, value);\n        }\n\n\n        /// @dev Safe function for depositing funds.  Returns boolean for whether the deposit was successful\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be added to.\n        /// @param value The amount that should be added to the account.\n        function deposit(Bank storage self, address accountAddress, uint value) public returns (bool) {\n                addFunds(self, accountAddress, value);\n                return true;\n        }\n\n        event _Withdrawal(address indexed accountAddress, uint value);\n\n        /// @dev Function wrapper around the _Withdrawal event so that it can be used by contracts.  Can be used to log a withdrawl from an account.\n        /// @param accountAddress The address of the account the funds were withdrawn from.\n        /// @param value The amount that was withdrawn to the account.\n        function Withdrawal(address accountAddress, uint value) public {\n            _Withdrawal(accountAddress, value);\n        }\n\n        event _InsufficientFunds(address indexed accountAddress, uint value, uint balance);\n\n        /// @dev Function wrapper around the _InsufficientFunds event so that it can be used by contracts.  Can be used to log a failed withdrawl from an account.\n        /// @param accountAddress The address of the account the funds were to be withdrawn from.\n        /// @param value The amount that was attempted to be withdrawn from the account.\n        /// @param balance The current balance of the account.\n        function InsufficientFunds(address accountAddress, uint value, uint balance) public {\n            _InsufficientFunds(accountAddress, value, balance);\n        }\n\n        /// @dev Low level method for removing funds from an account.  Protects against underflow.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be deducted from.\n        /// @param value The amount that should be deducted from the account.\n        function deductFunds(Bank storage self, address accountAddress, uint value) public {\n                /*\n                 *  Helper function that should be used for any reduction of\n                 *  account funds.  It has error checking to prevent\n                 *  underflowing the account balance which would be REALLY bad.\n                 */\n                if (value > self.accountBalances[accountAddress]) {\n                        // Prevent Underflow.\n                        throw;\n                }\n                self.accountBalances[accountAddress] -= value;\n        }\n\n        /// @dev Safe function for withdrawing funds.  Returns boolean for whether the deposit was successful as well as sending the amount in ether to the account address.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be withdrawn from.\n        /// @param value The amount that should be withdrawn from the account.\n        function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (self.accountBalances[accountAddress] >= value) {\n                        deductFunds(self, accountAddress, value);\n                        if (!accountAddress.send(value)) {\n                                // Potentially sending money to a contract that\n                                // has a fallback function.  So instead, try\n                                // tranferring the funds with the call api.\n                                if (!accountAddress.call.value(value)()) {\n                                        // Revert the entire transaction.  No\n                                        // need to destroy the funds.\n                                        throw;\n                                }\n                        }\n                        return true;\n                }\n                return false;\n        }\n\n        uint constant DEFAULT_SEND_GAS = 100000;\n\n        function sendRobust(address toAddress, uint value) public returns (bool) {\n                if (msg.gas < DEFAULT_SEND_GAS) {\n                    return sendRobust(toAddress, value, msg.gas);\n                }\n                return sendRobust(toAddress, value, DEFAULT_SEND_GAS);\n        }\n\n        function sendRobust(address toAddress, uint value, uint maxGas) public returns (bool) {\n                if (value > 0 && !toAddress.send(value)) {\n                        // Potentially sending money to a contract that\n                        // has a fallback function.  So instead, try\n                        // tranferring the funds with the call api.\n                        if (!toAddress.call.gas(maxGas).value(value)()) {\n                                return false;\n                        }\n                }\n                return true;\n        }\n}",1,
930475,0x7c1eb207c07e7ab13cf245585bd03d0fa478d034,FALSE,FALSE,"// Grove v0.2\n\n\n/// @title GroveLib - Library for queriable indexed ordered data.\n/// @author PiperMerriam - <pipermerriam@gmail.com>\nlibrary GroveLib {\n        /*\n         *  Indexes for ordered data\n         *\n         *  Address: 0x7c1eb207c07e7ab13cf245585bd03d0fa478d034\n         */\n        struct Index {\n                bytes32 root;\n                mapping (bytes32 => Node) nodes;\n        }\n\n        struct Node {\n                bytes32 id;\n                int value;\n                bytes32 parent;\n                bytes32 left;\n                bytes32 right;\n                uint height;\n        }\n\n        function max(uint a, uint b) internal returns (uint) {\n            if (a >= b) {\n                return a;\n            }\n            return b;\n        }\n\n        /*\n         *  Node getters\n         */\n        /// @dev Retrieve the unique identifier for the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeId(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].id;\n        }\n\n        /// @dev Retrieve the value for the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeValue(Index storage index, bytes32 id) constant returns (int) {\n            return index.nodes[id].value;\n        }\n\n        /// @dev Retrieve the height of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeHeight(Index storage index, bytes32 id) constant returns (uint) {\n            return index.nodes[id].height;\n        }\n\n        /// @dev Retrieve the parent id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeParent(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].parent;\n        }\n\n        /// @dev Retrieve the left child id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeLeftChild(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].left;\n        }\n\n        /// @dev Retrieve the right child id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeRightChild(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].right;\n        }\n\n        /// @dev Retrieve the node id of the next node in the tree.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getPreviousNode(Index storage index, bytes32 id) constant returns (bytes32) {\n            Node storage currentNode = index.nodes[id];\n\n            if (currentNode.id == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node memory child;\n\n            if (currentNode.left != 0x0) {\n                // Trace left to latest child in left tree.\n                child = index.nodes[currentNode.left];\n\n                while (child.right != 0) {\n                    child = index.nodes[child.right];\n                }\n                return child.id;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // Now we trace back up through parent relationships, looking\n                // for a link where the child is the right child of it's\n                // parent.\n                Node storage parent = index.nodes[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.right == child.id) {\n                        return parent.id;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = index.nodes[parent.parent];\n                }\n            }\n\n            // This is the first node, and has no previous node.\n            return 0x0;\n        }\n\n        /// @dev Retrieve the node id of the previous node in the tree.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNextNode(Index storage index, bytes32 id) constant returns (bytes32) {\n            Node storage currentNode = index.nodes[id];\n\n            if (currentNode.id == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node memory child;\n\n            if (currentNode.right != 0x0) {\n                // Trace right to earliest child in right tree.\n                child = index.nodes[currentNode.right];\n\n                while (child.left != 0) {\n                    child = index.nodes[child.left];\n                }\n                return child.id;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // if the node is the left child of it's parent, then the\n                // parent is the next one.\n                Node storage parent = index.nodes[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.left == child.id) {\n                        return parent.id;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = index.nodes[parent.parent];\n                }\n\n                // Now we need to trace all the way up checking to see if any parent is the \n            }\n\n            // This is the final node.\n            return 0x0;\n        }\n\n\n        /// @dev Updates or Inserts the id into the index at its appropriate location based on the value provided.\n        /// @param index The index that the node is part of.\n        /// @param id The unique identifier of the data element the index node will represent.\n        /// @param value The value of the data element that represents it's total ordering with respect to other elementes.\n        function insert(Index storage index, bytes32 id, int value) public {\n                if (index.nodes[id].id == id) {\n                    // A node with this id already exists.  If the value is\n                    // the same, then just return early, otherwise, remove it\n                    // and reinsert it.\n                    if (index.nodes[id].value == value) {\n                        return;\n                    }\n                    remove(index, id);\n                }\n\n                uint leftHeight;\n                uint rightHeight;\n\n                bytes32 previousNodeId = 0x0;\n\n                if (index.root == 0x0) {\n                    index.root = id;\n                }\n                Node storage currentNode = index.nodes[index.root];\n\n                // Do insertion\n                while (true) {\n                    if (currentNode.id == 0x0) {\n                        // This is a new unpopulated node.\n                        currentNode.id = id;\n                        currentNode.parent = previousNodeId;\n                        currentNode.value = value;\n                        break;\n                    }\n\n                    // Set the previous node id.\n                    previousNodeId = currentNode.id;\n\n                    // The new node belongs in the right subtree\n                    if (value >= currentNode.value) {\n                        if (currentNode.right == 0x0) {\n                            currentNode.right = id;\n                        }\n                        currentNode = index.nodes[currentNode.right];\n                        continue;\n                    }\n\n                    // The new node belongs in the left subtree.\n                    if (currentNode.left == 0x0) {\n                        currentNode.left = id;\n                    }\n                    currentNode = index.nodes[currentNode.left];\n                }\n\n                // Rebalance the tree\n                _rebalanceTree(index, currentNode.id);\n        }\n\n        /// @dev Checks whether a node for the given unique identifier exists within the given index.\n        /// @param index The index that should be searched\n        /// @param id The unique identifier of the data element to check for.\n        function exists(Index storage index, bytes32 id) constant returns (bool) {\n            return (index.nodes[id].height > 0);\n        }\n\n        /// @dev Remove the node for the given unique identifier from the index.\n        /// @param index The index that should be removed\n        /// @param id The unique identifier of the data element to remove.\n        function remove(Index storage index, bytes32 id) public {\n            Node storage replacementNode;\n            Node storage parent;\n            Node storage child;\n            bytes32 rebalanceOrigin;\n\n            Node storage nodeToDelete = index.nodes[id];\n\n            if (nodeToDelete.id != id) {\n                // The id does not exist in the tree.\n                return;\n            }\n\n            if (nodeToDelete.left != 0x0 || nodeToDelete.right != 0x0) {\n                // This node is not a leaf node and thus must replace itself in\n                // it's tree by either the previous or next node.\n                if (nodeToDelete.left != 0x0) {\n                    // This node is guaranteed to not have a right child.\n                    replacementNode = index.nodes[getPreviousNode(index, nodeToDelete.id)];\n                }\n                else {\n                    // This node is guaranteed to not have a left child.\n                    replacementNode = index.nodes[getNextNode(index, nodeToDelete.id)];\n                }\n                // The replacementNode is guaranteed to have a parent.\n                parent = index.nodes[replacementNode.parent];\n\n                // Keep note of the location that our tree rebalancing should\n                // start at.\n                rebalanceOrigin = replacementNode.id;\n\n                // Join the parent of the replacement node with any subtree of\n                // the replacement node.  We can guarantee that the replacement\n                // node has at most one subtree because of how getNextNode and\n                // getPreviousNode are used.\n                if (parent.left == replacementNode.id) {\n                    parent.left = replacementNode.right;\n                    if (replacementNode.right != 0x0) {\n                        child = index.nodes[replacementNode.right];\n                        child.parent = parent.id;\n                    }\n                }\n                if (parent.right == replacementNode.id) {\n                    parent.right = replacementNode.left;\n                    if (replacementNode.left != 0x0) {\n                        child = index.nodes[replacementNode.left];\n                        child.parent = parent.id;\n                    }\n                }\n\n                // Now we replace the nodeToDelete with the replacementNode.\n                // This includes parent/child relationships for all of the\n                // parent, the left child, and the right child.\n                replacementNode.parent = nodeToDelete.parent;\n                if (nodeToDelete.parent != 0x0) {\n                    parent = index.nodes[nodeToDelete.parent];\n                    if (parent.left == nodeToDelete.id) {\n                        parent.left = replacementNode.id;\n                    }\n                    if (parent.right == nodeToDelete.id) {\n                        parent.right = replacementNode.id;\n                    }\n                }\n                else {\n                    // If the node we are deleting is the root node update the\n                    // index root node pointer.\n                    index.root = replacementNode.id;\n                }\n\n                replacementNode.left = nodeToDelete.left;\n                if (nodeToDelete.left != 0x0) {\n                    child = index.nodes[nodeToDelete.left];\n                    child.parent = replacementNode.id;\n                }\n\n                replacementNode.right = nodeToDelete.right;\n                if (nodeToDelete.right != 0x0) {\n                    child = index.nodes[nodeToDelete.right];\n                    child.parent = replacementNode.id;\n                }\n            }\n            else if (nodeToDelete.parent != 0x0) {\n                // The node being deleted is a leaf node so we only erase it's\n                // parent linkage.\n                parent = index.nodes[nodeToDelete.parent];\n\n                if (parent.left == nodeToDelete.id) {\n                    parent.left = 0x0;\n                }\n                if (parent.right == nodeToDelete.id) {\n                    parent.right = 0x0;\n                }\n\n                // keep note of where the rebalancing should begin.\n                rebalanceOrigin = parent.id;\n            }\n            else {\n                // This is both a leaf node and the root node, so we need to\n                // unset the root node pointer.\n                index.root = 0x0;\n            }\n\n            // Now we zero out all of the fields on the nodeToDelete.\n            nodeToDelete.id = 0x0;\n            nodeToDelete.value = 0;\n            nodeToDelete.parent = 0x0;\n            nodeToDelete.left = 0x0;\n            nodeToDelete.right = 0x0;\n            nodeToDelete.height = 0;\n\n            // Walk back up the tree rebalancing\n            if (rebalanceOrigin != 0x0) {\n                _rebalanceTree(index, rebalanceOrigin);\n            }\n        }\n\n        bytes2 constant GT = "">"";\n        bytes2 constant LT = ""<"";\n        bytes2 constant GTE = "">="";\n        bytes2 constant LTE = ""<="";\n        bytes2 constant EQ = ""=="";\n\n        function _compare(int left, bytes2 operator, int right) internal returns (bool) {\n            if (operator == GT) {\n                return (left > right);\n            }\n            if (operator == LT) {\n                return (left < right);\n            }\n            if (operator == GTE) {\n                return (left >= right);\n            }\n            if (operator == LTE) {\n                return (left <= right);\n            }\n            if (operator == EQ) {\n                return (left == right);\n            }\n\n            // Invalid operator.\n            throw;\n        }\n\n        function _getMaximum(Index storage index, bytes32 id) internal returns (int) {\n                Node storage currentNode = index.nodes[id];\n\n                while (true) {\n                    if (currentNode.right == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = index.nodes[currentNode.right];\n                }\n        }\n\n        function _getMinimum(Index storage index, bytes32 id) internal returns (int) {\n                Node storage currentNode = index.nodes[id];\n\n                while (true) {\n                    if (currentNode.left == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = index.nodes[currentNode.left];\n                }\n        }\n\n\n        /** @dev Query the index for the edge-most node that satisfies the\n         *  given query.  For >, >=, and ==, this will be the left-most node\n         *  that satisfies the comparison.  For < and <= this will be the\n         *  right-most node that satisfies the comparison.\n         */\n        /// @param index The index that should be queried\n        /** @param operator One of '>', '>=', '<', '<=', '==' to specify what\n         *  type of comparison operator should be used.\n         */\n        function query(Index storage index, bytes2 operator, int value) public returns (bytes32) {\n                bytes32 rootNodeId = index.root;\n                \n                if (rootNodeId == 0x0) {\n                    // Empty tree.\n                    return 0x0;\n                }\n\n                Node storage currentNode = index.nodes[rootNodeId];\n\n                while (true) {\n                    if (_compare(currentNode.value, operator, value)) {\n                        // We have found a match but it might not be the\n                        // *correct* match.\n                        if ((operator == LT) || (operator == LTE)) {\n                            // Need to keep traversing right until this is no\n                            // longer true.\n                            if (currentNode.right == 0x0) {\n                                return currentNode.id;\n                            }\n                            if (_compare(_getMinimum(index, currentNode.right), operator, value)) {\n                                // There are still nodes to the right that\n                                // match.\n                                currentNode = index.nodes[currentNode.right];\n                                continue;\n                            }\n                            return currentNode.id;\n                        }\n\n                        if ((operator == GT) || (operator == GTE) || (operator == EQ)) {\n                            // Need to keep traversing left until this is no\n                            // longer true.\n                            if (currentNode.left == 0x0) {\n                                return currentNode.id;\n                            }\n                            if (_compare(_getMaximum(index, currentNode.left), operator, value)) {\n                                currentNode = index.nodes[currentNode.left];\n                                continue;\n                            }\n                            return currentNode.id;\n                        }\n                    }\n\n                    if ((operator == LT) || (operator == LTE)) {\n                        if (currentNode.left == 0x0) {\n                            // There are no nodes that are less than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = index.nodes[currentNode.left];\n                        continue;\n                    }\n\n                    if ((operator == GT) || (operator == GTE)) {\n                        if (currentNode.right == 0x0) {\n                            // There are no nodes that are greater than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = index.nodes[currentNode.right];\n                        continue;\n                    }\n\n                    if (operator == EQ) {\n                        if (currentNode.value < value) {\n                            if (currentNode.right == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = index.nodes[currentNode.right];\n                            continue;\n                        }\n\n                        if (currentNode.value > value) {\n                            if (currentNode.left == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = index.nodes[currentNode.left];\n                            continue;\n                        }\n                    }\n                }\n        }\n\n        function _rebalanceTree(Index storage index, bytes32 id) internal {\n            // Trace back up rebalancing the tree and updating heights as\n            // needed..\n            Node storage currentNode = index.nodes[id];\n\n            while (true) {\n                int balanceFactor = _getBalanceFactor(index, currentNode.id);\n\n                if (balanceFactor == 2) {\n                    // Right rotation (tree is heavy on the left)\n                    if (_getBalanceFactor(index, currentNode.left) == -1) {\n                        // The subtree is leaning right so it need to be\n                        // rotated left before the current node is rotated\n                        // right.\n                        _rotateLeft(index, currentNode.left);\n                    }\n                    _rotateRight(index, currentNode.id);\n                }\n\n                if (balanceFactor == -2) {\n                    // Left rotation (tree is heavy on the right)\n                    if (_getBalanceFactor(index, currentNode.right) == 1) {\n                        // The subtree is leaning left so it need to be\n                        // rotated right before the current node is rotated\n                        // left.\n                        _rotateRight(index, currentNode.right);\n                    }\n                    _rotateLeft(index, currentNode.id);\n                }\n\n                if ((-1 <= balanceFactor) && (balanceFactor <= 1)) {\n                    _updateNodeHeight(index, currentNode.id);\n                }\n\n                if (currentNode.parent == 0x0) {\n                    // Reached the root which may be new due to tree\n                    // rotation, so set it as the root and then break.\n                    break;\n                }\n\n                currentNode = index.nodes[currentNode.parent];\n            }\n        }\n\n        function _getBalanceFactor(Index storage index, bytes32 id) internal returns (int) {\n                Node storage node = index.nodes[id];\n\n                return int(index.nodes[node.left].height) - int(index.nodes[node.right].height);\n        }\n\n        function _updateNodeHeight(Index storage index, bytes32 id) internal {\n                Node storage node = index.nodes[id];\n\n                node.height = max(index.nodes[node.left].height, index.nodes[node.right].height) + 1;\n        }\n\n        function _rotateLeft(Index storage index, bytes32 id) internal {\n            Node storage originalRoot = index.nodes[id];\n\n            if (originalRoot.right == 0x0) {\n                // Cannot rotate left if there is no right originalRoot to rotate into\n                // place.\n                throw;\n            }\n\n            // The right child is the new root, so it gets the original\n            // `originalRoot.parent` as it's parent.\n            Node storage newRoot = index.nodes[originalRoot.right];\n            newRoot.parent = originalRoot.parent;\n\n            // The original root needs to have it's right child nulled out.\n            originalRoot.right = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If there is a parent node, it needs to now point downward at\n                // the newRoot which is rotating into the place where `node` was.\n                Node storage parent = index.nodes[originalRoot.parent];\n\n                // figure out if we're a left or right child and have the\n                // parent point to the new node.\n                if (parent.left == originalRoot.id) {\n                    parent.left = newRoot.id;\n                }\n                if (parent.right == originalRoot.id) {\n                    parent.right = newRoot.id;\n                }\n            }\n\n\n            if (newRoot.left != 0) {\n                // If the new root had a left child, that moves to be the\n                // new right child of the original root node\n                Node storage leftChild = index.nodes[newRoot.left];\n                originalRoot.right = leftChild.id;\n                leftChild.parent = originalRoot.id;\n            }\n\n            // Update the newRoot's left node to point at the original node.\n            originalRoot.parent = newRoot.id;\n            newRoot.left = originalRoot.id;\n\n            if (newRoot.parent == 0x0) {\n                index.root = newRoot.id;\n            }\n\n            // TODO: are both of these updates necessary?\n            _updateNodeHeight(index, originalRoot.id);\n            _updateNodeHeight(index, newRoot.id);\n        }\n\n        function _rotateRight(Index storage index, bytes32 id) internal {\n            Node storage originalRoot = index.nodes[id];\n\n            if (originalRoot.left == 0x0) {\n                // Cannot rotate right if there is no left node to rotate into\n                // place.\n                throw;\n            }\n\n            // The left child is taking the place of node, so we update it's\n            // parent to be the original parent of the node.\n            Node storage newRoot = index.nodes[originalRoot.left];\n            newRoot.parent = originalRoot.parent;\n\n            // Null out the originalRoot.left\n            originalRoot.left = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If the node has a parent, update the correct child to point\n                // at the newRoot now.\n                Node storage parent = index.nodes[originalRoot.parent];\n\n                if (parent.left == originalRoot.id) {\n                    parent.left = newRoot.id;\n                }\n                if (parent.right == originalRoot.id) {\n                    parent.right = newRoot.id;\n                }\n            }\n\n            if (newRoot.right != 0x0) {\n                Node storage rightChild = index.nodes[newRoot.right];\n                originalRoot.left = newRoot.right;\n                rightChild.parent = originalRoot.id;\n            }\n\n            // Update the new root's right node to point to the original node.\n            originalRoot.parent = newRoot.id;\n            newRoot.right = originalRoot.id;\n\n            if (newRoot.parent == 0x0) {\n                index.root = newRoot.id;\n            }\n\n            // Recompute heights.\n            _updateNodeHeight(index, originalRoot.id);\n            _updateNodeHeight(index, newRoot.id);\n        }\n}",1,
930477,0x1deeda36e15ec9e80f3d7414d67a4803ae45fc80,FALSE,FALSE,"// Accounting v0.1 (not the same as the 0.1 release of this library)\n\n/// @title Accounting Lib - Accounting utilities\n/// @author Piper Merriam - <pipermerriam@gmail.com>\nlibrary AccountingLib {\n        /*\n         *  Address: 0x89efe605e9ecbe22849cd85d5449cc946c26f8f3\n         */\n        struct Bank {\n            mapping (address => uint) accountBalances;\n        }\n\n        /// @dev Low level method for adding funds to an account.  Protects against overflow.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be added to.\n        /// @param value The amount that should be added to the account.\n        function addFunds(Bank storage self, address accountAddress, uint value) public {\n                if (self.accountBalances[accountAddress] + value < self.accountBalances[accountAddress]) {\n                        // Prevent Overflow.\n                        throw;\n                }\n                self.accountBalances[accountAddress] += value;\n        }\n\n        event _Deposit(address indexed _from, address indexed accountAddress, uint value);\n        /// @dev Function wrapper around the _Deposit event so that it can be used by contracts.  Can be used to log a deposit to an account.\n        /// @param _from The address that deposited the funds.\n        /// @param accountAddress The address of the account the funds were added to.\n        /// @param value The amount that was added to the account.\n        function Deposit(address _from, address accountAddress, uint value) public {\n            _Deposit(_from, accountAddress, value);\n        }\n\n\n        /// @dev Safe function for depositing funds.  Returns boolean for whether the deposit was successful\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be added to.\n        /// @param value The amount that should be added to the account.\n        function deposit(Bank storage self, address accountAddress, uint value) public returns (bool) {\n                addFunds(self, accountAddress, value);\n                return true;\n        }\n\n        event _Withdrawal(address indexed accountAddress, uint value);\n\n        /// @dev Function wrapper around the _Withdrawal event so that it can be used by contracts.  Can be used to log a withdrawl from an account.\n        /// @param accountAddress The address of the account the funds were withdrawn from.\n        /// @param value The amount that was withdrawn to the account.\n        function Withdrawal(address accountAddress, uint value) public {\n            _Withdrawal(accountAddress, value);\n        }\n\n        event _InsufficientFunds(address indexed accountAddress, uint value, uint balance);\n\n        /// @dev Function wrapper around the _InsufficientFunds event so that it can be used by contracts.  Can be used to log a failed withdrawl from an account.\n        /// @param accountAddress The address of the account the funds were to be withdrawn from.\n        /// @param value The amount that was attempted to be withdrawn from the account.\n        /// @param balance The current balance of the account.\n        function InsufficientFunds(address accountAddress, uint value, uint balance) public {\n            _InsufficientFunds(accountAddress, value, balance);\n        }\n\n        /// @dev Low level method for removing funds from an account.  Protects against underflow.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be deducted from.\n        /// @param value The amount that should be deducted from the account.\n        function deductFunds(Bank storage self, address accountAddress, uint value) public {\n                /*\n                 *  Helper function that should be used for any reduction of\n                 *  account funds.  It has error checking to prevent\n                 *  underflowing the account balance which would be REALLY bad.\n                 */\n                if (value > self.accountBalances[accountAddress]) {\n                        // Prevent Underflow.\n                        throw;\n                }\n                self.accountBalances[accountAddress] -= value;\n        }\n\n        /// @dev Safe function for withdrawing funds.  Returns boolean for whether the deposit was successful as well as sending the amount in ether to the account address.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be withdrawn from.\n        /// @param value The amount that should be withdrawn from the account.\n        function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (self.accountBalances[accountAddress] >= value) {\n                        deductFunds(self, accountAddress, value);\n                        if (!accountAddress.send(value)) {\n                                // Potentially sending money to a contract that\n                                // has a fallback function.  So instead, try\n                                // tranferring the funds with the call api.\n                                if (!accountAddress.call.value(value)()) {\n                                        // Revert the entire transaction.  No\n                                        // need to destroy the funds.\n                                        throw;\n                                }\n                        }\n                        return true;\n                }\n                return false;\n        }\n\n        uint constant DEFAULT_SEND_GAS = 100000;\n\n        function sendRobust(address toAddress, uint value) public returns (bool) {\n                if (msg.gas < DEFAULT_SEND_GAS) {\n                    return sendRobust(toAddress, value, msg.gas);\n                }\n                return sendRobust(toAddress, value, DEFAULT_SEND_GAS);\n        }\n\n        function sendRobust(address toAddress, uint value, uint maxGas) public returns (bool) {\n                if (value > 0 && !toAddress.send(value)) {\n                        // Potentially sending money to a contract that\n                        // has a fallback function.  So instead, try\n                        // tranferring the funds with the call api.\n                        if (!toAddress.call.gas(maxGas).value(value)()) {\n                                return false;\n                        }\n                }\n                return true;\n        }\n}\n\n\nlibrary CallLib {\n    /*\n     *  Address: 0x1deeda36e15ec9e80f3d7414d67a4803ae45fc80\n     */\n    struct Call {\n        address contractAddress;\n        bytes4 abiSignature;\n        bytes callData;\n        uint callValue;\n        uint anchorGasPrice;\n        uint requiredGas;\n        uint16 requiredStackDepth;\n\n        address claimer;\n        uint claimAmount;\n        uint claimerDeposit;\n\n        bool wasSuccessful;\n        bool wasCalled;\n        bool isCancelled;\n    }\n\n    enum State {\n        Pending,\n        Unclaimed,\n        Claimed,\n        Frozen,\n        Callable,\n        Executed,\n        Cancelled,\n        Missed\n    }\n\n    function state(Call storage self) constant returns (State) {\n        if (self.isCancelled) return State.Cancelled;\n        if (self.wasCalled) return State.Executed;\n\n        var call = FutureBlockCall(this);\n\n        if (block.number + CLAIM_GROWTH_WINDOW + MAXIMUM_CLAIM_WINDOW + BEFORE_CALL_FREEZE_WINDOW < call.targetBlock()) return State.Pending;\n        if (block.number + BEFORE_CALL_FREEZE_WINDOW < call.targetBlock()) {\n            if (self.claimer == 0x0) {\n                return State.Unclaimed;\n            }\n            else {\n                return State.Claimed;\n            }\n        }\n        if (block.number < call.targetBlock()) return State.Frozen;\n        if (block.number < call.targetBlock() + call.gracePeriod()) return State.Callable;\n        return State.Missed;\n    }\n\n    // The number of blocks that each caller in the pool has to complete their\n    // call.\n    uint constant CALL_WINDOW_SIZE = 16;\n\n    address constant creator = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n    function extractCallData(Call storage call, bytes data) public {\n        call.callData.length = data.length - 4;\n        if (data.length > 4) {\n                for (uint i = 0; i < call.callData.length; i++) {\n                        call.callData[i] = data[i + 4];\n                }\n        }\n    }\n\n    uint constant GAS_PER_DEPTH = 700;\n\n    function checkDepth(uint n) constant returns (bool) {\n        if (n == 0) return true;\n        return address(this).call.gas(GAS_PER_DEPTH * n)(bytes4(sha3(""__dig(uint256)"")), n - 1);\n    }\n\n    function sendSafe(address to_address, uint value) public returns (uint) {\n        if (value > address(this).balance) {\n            value = address(this).balance;\n        }\n        if (value > 0) {\n            AccountingLib.sendRobust(to_address, value);\n            return value;\n        }\n        return 0;\n    }\n\n    function getGasScalar(uint base_gas_price, uint gas_price) constant returns (uint) {\n        /*\n        *  Return a number between 0 - 200 to scale the donation based on the\n        *  gas price set for the calling transaction as compared to the gas\n        *  price of the scheduling transaction.\n        *\n        *  - number approaches zero as the transaction gas price goes\n        *  above the gas price recorded when the call was scheduled.\n        *\n        *  - the number approaches 200 as the transaction gas price\n        *  drops under the price recorded when the call was scheduled.\n        *\n        *  This encourages lower gas costs as the lower the gas price\n        *  for the executing transaction, the higher the payout to the\n        *  caller.\n        */\n        if (gas_price > base_gas_price) {\n            return 100 * base_gas_price / gas_price;\n        }\n        else {\n            return 200 - 100 * base_gas_price / (2 * base_gas_price - gas_price);\n        }\n    }\n\n    event CallExecuted(address indexed executor, uint gasCost, uint payment, uint donation, bool success);\n\n    bytes4 constant EMPTY_SIGNATURE = 0x0000;\n\n    event CallAborted(address executor, bytes32 reason);\n\n    function execute(Call storage self,\n                     uint start_gas,\n                     address executor,\n                     uint overhead,\n                     uint extraGas) public {\n        FutureCall call = FutureCall(this);\n        \n        // Mark the call has having been executed.\n        self.wasCalled = true;\n\n        // Make the call\n        if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();\n        }\n        else if (self.abiSignature == EMPTY_SIGNATURE) {\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);\n        }\n        else if (self.callData.length == 0) {\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);\n        }\n        else {\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);\n        }\n\n        call.origin().call(bytes4(sha3(""updateDefaultPayment()"")));\n\n        // Compute the scalar (0 - 200) for the donation.\n        uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);\n\n        uint basePayment;\n        if (self.claimer == executor) {\n            basePayment = self.claimAmount;\n        }\n        else {\n            basePayment = call.basePayment();\n        }\n        uint payment = self.claimerDeposit + basePayment * gasScalar / 100; \n        uint donation = call.baseDonation() * gasScalar / 100;\n\n        // zero out the deposit\n        self.claimerDeposit = 0;\n\n        // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\n        // amount that represents the gas usage of the commands that\n        // happen after this line.\n        uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);\n\n        // Now we need to pay the executor as well as keep donation.\n        payment = sendSafe(executor, payment + gasCost);\n        donation = sendSafe(creator, donation);\n\n        // Log execution\n        CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);\n    }\n\n    event Cancelled(address indexed cancelled_by);\n\n    function cancel(Call storage self, address sender) public {\n        Cancelled(sender);\n        if (self.claimerDeposit >= 0) {\n            sendSafe(self.claimer, self.claimerDeposit);\n        }\n        var call = FutureCall(this);\n        sendSafe(call.schedulerAddress(), address(this).balance);\n        self.isCancelled = true;\n    }\n\n    /*\n     *  Bid API\n     *  - Gas costs for this transaction are not covered so it\n     *    must be up to the call executors to ensure that their actions\n     *    remain profitable.  Any form of bidding war is likely to eat into\n     *    profits.\n     */\n    event Claimed(address executor, uint claimAmount);\n\n    // The duration (in blocks) during which the maximum claim will slowly rise\n    // towards the basePayment amount.\n    uint constant CLAIM_GROWTH_WINDOW = 240;\n\n    // The duration (in blocks) after the CLAIM_WINDOW that claiming will\n    // remain open.\n    uint constant MAXIMUM_CLAIM_WINDOW = 15;\n\n    // The duration (in blocks) before the call's target block during which\n    // all actions are frozen.  This includes claiming, cancellation,\n    // registering call data.\n    uint constant BEFORE_CALL_FREEZE_WINDOW = 10;\n\n    /*\n     *  The maximum allowed claim amount slowly rises across a window of\n     *  blocks CLAIM_GROWTH_WINDOW prior to the call.  No claimer is\n     *  allowed to claim above this value.  This is intended to prevent\n     *  bidding wars in that each caller should know how much they are\n     *  willing to execute a call for.\n     */\n    function getClaimAmountForBlock(uint block_number) constant returns (uint) {\n        /*\n         *   [--growth-window--][--max-window--][--freeze-window--]\n         *\n         *\n         */\n        var call = FutureBlockCall(this);\n\n        uint cutoff = call.targetBlock() - BEFORE_CALL_FREEZE_WINDOW;\n        \n        // claim window has closed\n        if (block_number > cutoff) return call.basePayment();\n\n        cutoff -= MAXIMUM_CLAIM_WINDOW;\n\n        // in the maximum claim window.\n        if (block_number > cutoff) return call.basePayment();\n\n        cutoff -= CLAIM_GROWTH_WINDOW;\n\n        if (block_number > cutoff) {\n            uint x = block_number - cutoff;\n\n            return call.basePayment() * x / CLAIM_GROWTH_WINDOW;\n        }\n\n        return 0;\n    }\n\n    function lastClaimBlock() constant returns (uint) {\n        var call = FutureBlockCall(this);\n        return call.targetBlock() - BEFORE_CALL_FREEZE_WINDOW;\n    }\n\n    function maxClaimBlock() constant returns (uint) {\n        return lastClaimBlock() - MAXIMUM_CLAIM_WINDOW;\n    }\n\n    function firstClaimBlock() constant returns (uint) {\n        return maxClaimBlock() - CLAIM_GROWTH_WINDOW;\n    }\n\n    function claim(Call storage self, address executor, uint deposit_amount, uint basePayment) public returns (bool) {\n        /*\n         *  Warning! this does not check whether the function is already\n         *  claimed or whether we are within the claim window.  This must be\n         *  done at the contract level.\n         */\n        // Insufficient Deposit\n        if (deposit_amount < 2 * basePayment) return false;\n\n        self.claimAmount = getClaimAmountForBlock(block.number);\n        self.claimer = executor;\n        self.claimerDeposit = deposit_amount;\n\n        // Log the claim.\n        Claimed(executor, self.claimAmount);\n    }\n\n    function checkExecutionAuthorization(Call storage self, address executor, uint block_number) returns (bool) {\n        /*\n        *  Check whether the given `executor` is authorized.\n        */\n        var call = FutureBlockCall(this);\n\n        uint targetBlock = call.targetBlock();\n\n        // Invalid, not in call window.\n        if (block_number < targetBlock || block_number > targetBlock + call.gracePeriod()) throw;\n\n        // Within the reserved call window so if there is a claimer, the\n        // executor must be the claimdor.\n        if (block_number - targetBlock < CALL_WINDOW_SIZE) {\n        return (self.claimer == 0x0 || self.claimer == executor);\n        }\n\n        // Must be in the free-for-all period.\n        return true;\n    }\n\n    function isCancellable(Call storage self, address caller) returns (bool) {\n        var _state = state(self);\n        var call = FutureBlockCall(this);\n\n        if (_state == State.Pending && caller == call.schedulerAddress()) {\n            return true;\n        }\n\n        if (_state == State.Missed) return true;\n\n        return false;\n    }\n\n    function beforeExecuteForFutureBlockCall(Call storage self, address executor, uint startGas) returns (bool) {\n        bytes32 reason;\n\n        var call = FutureBlockCall(this);\n\n        if (startGas < self.requiredGas) {\n            // The executor has not provided sufficient gas\n            reason = ""NOT_ENOUGH_GAS"";\n        }\n        else if (self.wasCalled) {\n            // Not being called within call window.\n            reason = ""ALREADY_CALLED"";\n        }\n        else if (block.number < call.targetBlock() || block.number > call.targetBlock() + call.gracePeriod()) {\n            // Not being called within call window.\n            reason = ""NOT_IN_CALL_WINDOW"";\n        }\n        else if (!checkExecutionAuthorization(self, executor, block.number)) {\n            // Someone has claimed this call and they currently have exclusive\n            // rights to execute it.\n            reason = ""NOT_AUTHORIZED"";\n        }\n        else if (self.requiredStackDepth > 0 && executor != tx.origin && !checkDepth(self.requiredStackDepth)) {\n            reason = ""STACK_TOO_DEEP"";\n        }\n\n        if (reason != 0x0) {\n            CallAborted(executor, reason);\n            return false;\n        }\n\n        return true;\n    }\n}\n\n\ncontract FutureCall {\n    // The author (Piper Merriam) address.\n    address constant creator = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n    address public schedulerAddress;\n\n    uint public basePayment;\n    uint public baseDonation;\n\n    CallLib.Call call;\n\n    address public origin;\n\n    function FutureCall(address _schedulerAddress,\n                        uint _requiredGas,\n                        uint16 _requiredStackDepth,\n                        address _contractAddress,\n                        bytes4 _abiSignature,\n                        bytes _callData,\n                        uint _callValue,\n                        uint _basePayment,\n                        uint _baseDonation)\n    {\n        origin = msg.sender;\n        schedulerAddress = _schedulerAddress;\n\n        basePayment = _basePayment;\n        baseDonation = _baseDonation;\n\n        call.requiredGas = _requiredGas;\n        call.requiredStackDepth = _requiredStackDepth;\n        call.anchorGasPrice = tx.gasprice;\n        call.contractAddress = _contractAddress;\n        call.abiSignature = _abiSignature;\n        call.callData = _callData;\n        call.callValue = _callValue;\n    }\n\n    enum State {\n        Pending,\n        Unclaimed,\n        Claimed,\n        Frozen,\n        Callable,\n        Executed,\n        Cancelled,\n        Missed\n    }\n\n    modifier in_state(State _state) { if (state() == _state) _ }\n\n    function state() constant returns (State) {\n        return State(CallLib.state(call));\n    }\n\n    /*\n     *  API for FutureXXXXCalls to implement.\n     */\n    function beforeExecute(address executor, uint startGas) public returns (bool);\n    function afterExecute(address executor) internal;\n    function getOverhead() constant returns (uint);\n    function getExtraGas() constant returns (uint);\n\n    /*\n     *  Data accessor functions.\n     */\n    function contractAddress() constant returns (address) {\n        return call.contractAddress;\n    }\n\n    function abiSignature() constant returns (bytes4) {\n        return call.abiSignature;\n    }\n\n    function callData() constant returns (bytes) {\n        return call.callData;\n    }\n\n    function callValue() constant returns (uint) {\n        return call.callValue;\n    }\n\n    function anchorGasPrice() constant returns (uint) {\n        return call.anchorGasPrice;\n    }\n\n    function requiredGas() constant returns (uint) {\n        return call.requiredGas;\n    }\n\n    function requiredStackDepth() constant returns (uint16) {\n        return call.requiredStackDepth;\n    }\n\n    function claimer() constant returns (address) {\n        return call.claimer;\n    }\n\n    function claimAmount() constant returns (uint) {\n        return call.claimAmount;\n    }\n\n    function claimerDeposit() constant returns (uint) {\n        return call.claimerDeposit;\n    }\n\n    function wasSuccessful() constant returns (bool) {\n        return call.wasSuccessful;\n    }\n\n    function wasCalled() constant returns (bool) {\n        return call.wasCalled;\n    }\n\n    function isCancelled() constant returns (bool) {\n        return call.isCancelled;\n    }\n\n    /*\n     *  Claim API helpers\n     */\n    function getClaimAmountForBlock() constant returns (uint) {\n        return CallLib.getClaimAmountForBlock(block.number);\n    }\n\n    function getClaimAmountForBlock(uint block_number) constant returns (uint) {\n        return CallLib.getClaimAmountForBlock(block_number);\n    }\n\n    /*\n     *  Call Data registration\n     */\n    function () returns (bool) {\n        /*\n         * Fallback to allow sending funds to this contract.\n         * (also allows registering raw call data)\n         */\n        // only scheduler can register call data.\n        if (msg.sender != schedulerAddress) return false;\n        // cannot write over call data\n        if (call.callData.length > 0) return false;\n\n        var _state = state();\n        if (_state != State.Pending && _state != State.Unclaimed && _state != State.Claimed) return false;\n\n        call.callData = msg.data;\n        return true;\n    }\n\n    function registerData() public returns (bool) {\n        // only scheduler can register call data.\n        if (msg.sender != schedulerAddress) return false;\n        // cannot write over call data\n        if (call.callData.length > 0) return false;\n\n        var _state = state();\n        if (_state != State.Pending && _state != State.Unclaimed && _state != State.Claimed) return false;\n\n        CallLib.extractCallData(call, msg.data);\n    }\n\n    function firstClaimBlock() constant returns (uint) {\n        return CallLib.firstClaimBlock();\n    }\n\n    function maxClaimBlock() constant returns (uint) {\n        return CallLib.maxClaimBlock();\n    }\n\n    function lastClaimBlock() constant returns (uint) {\n        return CallLib.lastClaimBlock();\n    }\n\n    function claim() public in_state(State.Unclaimed) returns (bool) {\n        bool success = CallLib.claim(call, msg.sender, msg.value, basePayment);\n        if (!success) {\n            if (!AccountingLib.sendRobust(msg.sender, msg.value)) throw;\n        }\n        return success;\n    }\n\n    function checkExecutionAuthorization(address executor, uint block_number) constant returns (bool) {\n        return CallLib.checkExecutionAuthorization(call, executor, block_number);\n    }\n\n    function sendSafe(address to_address, uint value) internal {\n        CallLib.sendSafe(to_address, value);\n    }\n\n    function execute() public in_state(State.Callable) {\n        uint start_gas = msg.gas;\n\n        // Check that the call should be executed now.\n        if (!beforeExecute(msg.sender, start_gas)) return;\n\n        // Execute the call\n        CallLib.execute(call, start_gas, msg.sender, getOverhead(), getExtraGas());\n\n        // Any logic that needs to occur after the call has executed should\n        // go in afterExecute\n        afterExecute(msg.sender);\n    }\n}\n\n\ncontract FutureBlockCall is FutureCall {\n    uint public targetBlock;\n    uint8 public gracePeriod;\n\n    uint constant CALL_API_VERSION = 2;\n\n    function callAPIVersion() constant returns (uint) {\n        return CALL_API_VERSION;\n    }\n\n    function FutureBlockCall(address _schedulerAddress,\n                             uint _targetBlock,\n                             uint8 _gracePeriod,\n                             address _contractAddress,\n                             bytes4 _abiSignature,\n                             bytes _callData,\n                             uint _callValue,\n                             uint _requiredGas,\n                             uint16 _requiredStackDepth,\n                             uint _basePayment,\n                             uint _baseDonation)\n        FutureCall(_schedulerAddress, _requiredGas, _requiredStackDepth, _contractAddress, _abiSignature, _callData, _callValue, _basePayment, _baseDonation)\n    {\n        // parent contract FutureCall\n        schedulerAddress = _schedulerAddress;\n\n        targetBlock = _targetBlock;\n        gracePeriod = _gracePeriod;\n    }\n\n    uint constant GAS_PER_DEPTH = 700;\n\n    function __dig(uint n) constant returns (bool) {\n        if (n == 0) return true;\n        if (!address(this).callcode(bytes4(sha3(""__dig(uint256)"")), n - 1)) throw;\n    }\n\n\n    function beforeExecute(address executor, uint startGas) public returns (bool) {\n        return CallLib.beforeExecuteForFutureBlockCall(call, executor, startGas);\n    }\n\n    function afterExecute(address executor) internal {\n        // Refund any leftover funds.\n        CallLib.sendSafe(schedulerAddress, address(this).balance);\n    }\n\n    uint constant GAS_OVERHEAD = 100000;\n\n    function getOverhead() constant returns (uint) {\n            return GAS_OVERHEAD;\n    }\n\n    uint constant EXTRA_GAS = 77000;\n\n    function getExtraGas() constant returns (uint) {\n            return EXTRA_GAS;\n    }\n\n    uint constant CLAIM_GROWTH_WINDOW = 240;\n    uint constant MAXIMUM_CLAIM_WINDOW = 15;\n    uint constant BEFORE_CALL_FREEZE_WINDOW = 10;\n\n    function isCancellable() constant public returns (bool) {\n        return CallLib.isCancellable(call, msg.sender);\n    }\n\n    function cancel() public {\n        if (CallLib.isCancellable(call, msg.sender)) {\n            CallLib.cancel(call, msg.sender);\n        }\n    }\n}",1,
930479,0xe54d323f9ef17c1f0dede47ecc86a9718fe5ea34,FALSE,FALSE,"// Grove v0.2\n\n\n/// @title GroveLib - Library for queriable indexed ordered data.\n/// @author PiperMerriam -\nlibrary GroveLib {\n        /*\n         *  Indexes for ordered data\n         *\n         *  Address: 0x7c1eb207c07e7ab13cf245585bd03d0fa478d034\n         */\n        struct Index {\n                bytes32 root;\n                mapping (bytes32 => Node) nodes;\n        }\n\n        struct Node {\n                bytes32 id;\n                int value;\n                bytes32 parent;\n                bytes32 left;\n                bytes32 right;\n                uint height;\n        }\n\n        function max(uint a, uint b) internal returns (uint) {\n            if (a >= b) {\n                return a;\n            }\n            return b;\n        }\n\n        /*\n         *  Node getters\n         */\n        /// @dev Retrieve the unique identifier for the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeId(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].id;\n        }\n\n        /// @dev Retrieve the value for the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeValue(Index storage index, bytes32 id) constant returns (int) {\n            return index.nodes[id].value;\n        }\n\n        /// @dev Retrieve the height of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeHeight(Index storage index, bytes32 id) constant returns (uint) {\n            return index.nodes[id].height;\n        }\n\n        /// @dev Retrieve the parent id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeParent(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].parent;\n        }\n\n        /// @dev Retrieve the left child id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeLeftChild(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].left;\n        }\n\n        /// @dev Retrieve the right child id of the node.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNodeRightChild(Index storage index, bytes32 id) constant returns (bytes32) {\n            return index.nodes[id].right;\n        }\n\n        /// @dev Retrieve the node id of the next node in the tree.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getPreviousNode(Index storage index, bytes32 id) constant returns (bytes32) {\n            Node storage currentNode = index.nodes[id];\n\n            if (currentNode.id == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node memory child;\n\n            if (currentNode.left != 0x0) {\n                // Trace left to latest child in left tree.\n                child = index.nodes[currentNode.left];\n\n                while (child.right != 0) {\n                    child = index.nodes[child.right];\n                }\n                return child.id;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // Now we trace back up through parent relationships, looking\n                // for a link where the child is the right child of it's\n                // parent.\n                Node storage parent = index.nodes[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.right == child.id) {\n                        return parent.id;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = index.nodes[parent.parent];\n                }\n            }\n\n            // This is the first node, and has no previous node.\n            return 0x0;\n        }\n\n        /// @dev Retrieve the node id of the previous node in the tree.\n        /// @param index The index that the node is part of.\n        /// @param id The id for the node to be looked up.\n        function getNextNode(Index storage index, bytes32 id) constant returns (bytes32) {\n            Node storage currentNode = index.nodes[id];\n\n            if (currentNode.id == 0x0) {\n                // Unknown node, just return 0x0;\n                return 0x0;\n            }\n\n            Node memory child;\n\n            if (currentNode.right != 0x0) {\n                // Trace right to earliest child in right tree.\n                child = index.nodes[currentNode.right];\n\n                while (child.left != 0) {\n                    child = index.nodes[child.left];\n                }\n                return child.id;\n            }\n\n            if (currentNode.parent != 0x0) {\n                // if the node is the left child of it's parent, then the\n                // parent is the next one.\n                Node storage parent = index.nodes[currentNode.parent];\n                child = currentNode;\n\n                while (true) {\n                    if (parent.left == child.id) {\n                        return parent.id;\n                    }\n\n                    if (parent.parent == 0x0) {\n                        break;\n                    }\n                    child = parent;\n                    parent = index.nodes[parent.parent];\n                }\n\n                // Now we need to trace all the way up checking to see if any parent is the\n            }\n\n            // This is the final node.\n            return 0x0;\n        }\n\n\n        /// @dev Updates or Inserts the id into the index at its appropriate location based on the value provided.\n        /// @param index The index that the node is part of.\n        /// @param id The unique identifier of the data element the index node will represent.\n        /// @param value The value of the data element that represents it's total ordering with respect to other elementes.\n        function insert(Index storage index, bytes32 id, int value) public {\n                if (index.nodes[id].id == id) {\n                    // A node with this id already exists.  If the value is\n                    // the same, then just return early, otherwise, remove it\n                    // and reinsert it.\n                    if (index.nodes[id].value == value) {\n                        return;\n                    }\n                    remove(index, id);\n                }\n\n                uint leftHeight;\n                uint rightHeight;\n\n                bytes32 previousNodeId = 0x0;\n\n                if (index.root == 0x0) {\n                    index.root = id;\n                }\n                Node storage currentNode = index.nodes[index.root];\n\n                // Do insertion\n                while (true) {\n                    if (currentNode.id == 0x0) {\n                        // This is a new unpopulated node.\n                        currentNode.id = id;\n                        currentNode.parent = previousNodeId;\n                        currentNode.value = value;\n                        break;\n                    }\n\n                    // Set the previous node id.\n                    previousNodeId = currentNode.id;\n\n                    // The new node belongs in the right subtree\n                    if (value >= currentNode.value) {\n                        if (currentNode.right == 0x0) {\n                            currentNode.right = id;\n                        }\n                        currentNode = index.nodes[currentNode.right];\n                        continue;\n                    }\n\n                    // The new node belongs in the left subtree.\n                    if (currentNode.left == 0x0) {\n                        currentNode.left = id;\n                    }\n                    currentNode = index.nodes[currentNode.left];\n                }\n\n                // Rebalance the tree\n                _rebalanceTree(index, currentNode.id);\n        }\n\n        /// @dev Checks whether a node for the given unique identifier exists within the given index.\n        /// @param index The index that should be searched\n        /// @param id The unique identifier of the data element to check for.\n        function exists(Index storage index, bytes32 id) constant returns (bool) {\n            return (index.nodes[id].height > 0);\n        }\n\n        /// @dev Remove the node for the given unique identifier from the index.\n        /// @param index The index that should be removed\n        /// @param id The unique identifier of the data element to remove.\n        function remove(Index storage index, bytes32 id) public {\n            Node storage replacementNode;\n            Node storage parent;\n            Node storage child;\n            bytes32 rebalanceOrigin;\n\n            Node storage nodeToDelete = index.nodes[id];\n\n            if (nodeToDelete.id != id) {\n                // The id does not exist in the tree.\n                return;\n            }\n\n            if (nodeToDelete.left != 0x0 || nodeToDelete.right != 0x0) {\n                // This node is not a leaf node and thus must replace itself in\n                // it's tree by either the previous or next node.\n                if (nodeToDelete.left != 0x0) {\n                    // This node is guaranteed to not have a right child.\n                    replacementNode = index.nodes[getPreviousNode(index, nodeToDelete.id)];\n                }\n                else {\n                    // This node is guaranteed to not have a left child.\n                    replacementNode = index.nodes[getNextNode(index, nodeToDelete.id)];\n                }\n                // The replacementNode is guaranteed to have a parent.\n                parent = index.nodes[replacementNode.parent];\n\n                // Keep note of the location that our tree rebalancing should\n                // start at.\n                rebalanceOrigin = replacementNode.id;\n\n                // Join the parent of the replacement node with any subtree of\n                // the replacement node.  We can guarantee that the replacement\n                // node has at most one subtree because of how getNextNode and\n                // getPreviousNode are used.\n                if (parent.left == replacementNode.id) {\n                    parent.left = replacementNode.right;\n                    if (replacementNode.right != 0x0) {\n                        child = index.nodes[replacementNode.right];\n                        child.parent = parent.id;\n                    }\n                }\n                if (parent.right == replacementNode.id) {\n                    parent.right = replacementNode.left;\n                    if (replacementNode.left != 0x0) {\n                        child = index.nodes[replacementNode.left];\n                        child.parent = parent.id;\n                    }\n                }\n\n                // Now we replace the nodeToDelete with the replacementNode.\n                // This includes parent/child relationships for all of the\n                // parent, the left child, and the right child.\n                replacementNode.parent = nodeToDelete.parent;\n                if (nodeToDelete.parent != 0x0) {\n                    parent = index.nodes[nodeToDelete.parent];\n                    if (parent.left == nodeToDelete.id) {\n                        parent.left = replacementNode.id;\n                    }\n                    if (parent.right == nodeToDelete.id) {\n                        parent.right = replacementNode.id;\n                    }\n                }\n                else {\n                    // If the node we are deleting is the root node update the\n                    // index root node pointer.\n                    index.root = replacementNode.id;\n                }\n\n                replacementNode.left = nodeToDelete.left;\n                if (nodeToDelete.left != 0x0) {\n                    child = index.nodes[nodeToDelete.left];\n                    child.parent = replacementNode.id;\n                }\n\n                replacementNode.right = nodeToDelete.right;\n                if (nodeToDelete.right != 0x0) {\n                    child = index.nodes[nodeToDelete.right];\n                    child.parent = replacementNode.id;\n                }\n            }\n            else if (nodeToDelete.parent != 0x0) {\n                // The node being deleted is a leaf node so we only erase it's\n                // parent linkage.\n                parent = index.nodes[nodeToDelete.parent];\n\n                if (parent.left == nodeToDelete.id) {\n                    parent.left = 0x0;\n                }\n                if (parent.right == nodeToDelete.id) {\n                    parent.right = 0x0;\n                }\n\n                // keep note of where the rebalancing should begin.\n                rebalanceOrigin = parent.id;\n            }\n            else {\n                // This is both a leaf node and the root node, so we need to\n                // unset the root node pointer.\n                index.root = 0x0;\n            }\n\n            // Now we zero out all of the fields on the nodeToDelete.\n            nodeToDelete.id = 0x0;\n            nodeToDelete.value = 0;\n            nodeToDelete.parent = 0x0;\n            nodeToDelete.left = 0x0;\n            nodeToDelete.right = 0x0;\n            nodeToDelete.height = 0;\n\n            // Walk back up the tree rebalancing\n            if (rebalanceOrigin != 0x0) {\n                _rebalanceTree(index, rebalanceOrigin);\n            }\n        }\n\n        bytes2 constant GT = "">"";\n        bytes2 constant LT = ""<"";\n        bytes2 constant GTE = "">="";\n        bytes2 constant LTE = ""<="";\n        bytes2 constant EQ = ""=="";\n\n        function _compare(int left, bytes2 operator, int right) internal returns (bool) {\n            if (operator == GT) {\n                return (left > right);\n            }\n            if (operator == LT) {\n                return (left < right);\n            }\n            if (operator == GTE) {\n                return (left >= right);\n            }\n            if (operator == LTE) {\n                return (left <= right);\n            }\n            if (operator == EQ) {\n                return (left == right);\n            }\n\n            // Invalid operator.\n            throw;\n        }\n\n        function _getMaximum(Index storage index, bytes32 id) internal returns (int) {\n                Node storage currentNode = index.nodes[id];\n\n                while (true) {\n                    if (currentNode.right == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = index.nodes[currentNode.right];\n                }\n        }\n\n        function _getMinimum(Index storage index, bytes32 id) internal returns (int) {\n                Node storage currentNode = index.nodes[id];\n\n                while (true) {\n                    if (currentNode.left == 0x0) {\n                        return currentNode.value;\n                    }\n                    currentNode = index.nodes[currentNode.left];\n                }\n        }\n\n\n        /** @dev Query the index for the edge-most node that satisfies the\n         *  given query.  For >, >=, and ==, this will be the left-most node\n         *  that satisfies the comparison.  For < and <= this will be the\n         *  right-most node that satisfies the comparison.\n         */\n        /// @param index The index that should be queried\n        /** @param operator One of '>', '>=', '<', '<=', '==' to specify what\n         *  type of comparison operator should be used.\n         */\n        function query(Index storage index, bytes2 operator, int value) public returns (bytes32) {\n                bytes32 rootNodeId = index.root;\n\n                if (rootNodeId == 0x0) {\n                    // Empty tree.\n                    return 0x0;\n                }\n\n                Node storage currentNode = index.nodes[rootNodeId];\n\n                while (true) {\n                    if (_compare(currentNode.value, operator, value)) {\n                        // We have found a match but it might not be the\n                        // *correct* match.\n                        if ((operator == LT) || (operator == LTE)) {\n                            // Need to keep traversing right until this is no\n                            // longer true.\n                            if (currentNode.right == 0x0) {\n                                return currentNode.id;\n                            }\n                            if (_compare(_getMinimum(index, currentNode.right), operator, value)) {\n                                // There are still nodes to the right that\n                                // match.\n                                currentNode = index.nodes[currentNode.right];\n                                continue;\n                            }\n                            return currentNode.id;\n                        }\n\n                        if ((operator == GT) || (operator == GTE) || (operator == EQ)) {\n                            // Need to keep traversing left until this is no\n                            // longer true.\n                            if (currentNode.left == 0x0) {\n                                return currentNode.id;\n                            }\n                            if (_compare(_getMaximum(index, currentNode.left), operator, value)) {\n                                currentNode = index.nodes[currentNode.left];\n                                continue;\n                            }\n                            return currentNode.id;\n                        }\n                    }\n\n                    if ((operator == LT) || (operator == LTE)) {\n                        if (currentNode.left == 0x0) {\n                            // There are no nodes that are less than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = index.nodes[currentNode.left];\n                        continue;\n                    }\n\n                    if ((operator == GT) || (operator == GTE)) {\n                        if (currentNode.right == 0x0) {\n                            // There are no nodes that are greater than the value\n                            // so return null.\n                            return 0x0;\n                        }\n                        currentNode = index.nodes[currentNode.right];\n                        continue;\n                    }\n\n                    if (operator == EQ) {\n                        if (currentNode.value < value) {\n                            if (currentNode.right == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = index.nodes[currentNode.right];\n                            continue;\n                        }\n\n                        if (currentNode.value > value) {\n                            if (currentNode.left == 0x0) {\n                                return 0x0;\n                            }\n                            currentNode = index.nodes[currentNode.left];\n                            continue;\n                        }\n                    }\n                }\n        }\n\n        function _rebalanceTree(Index storage index, bytes32 id) internal {\n            // Trace back up rebalancing the tree and updating heights as\n            // needed..\n            Node storage currentNode = index.nodes[id];\n\n            while (true) {\n                int balanceFactor = _getBalanceFactor(index, currentNode.id);\n\n                if (balanceFactor == 2) {\n                    // Right rotation (tree is heavy on the left)\n                    if (_getBalanceFactor(index, currentNode.left) == -1) {\n                        // The subtree is leaning right so it need to be\n                        // rotated left before the current node is rotated\n                        // right.\n                        _rotateLeft(index, currentNode.left);\n                    }\n                    _rotateRight(index, currentNode.id);\n                }\n\n                if (balanceFactor == -2) {\n                    // Left rotation (tree is heavy on the right)\n                    if (_getBalanceFactor(index, currentNode.right) == 1) {\n                        // The subtree is leaning left so it need to be\n                        // rotated right before the current node is rotated\n                        // left.\n                        _rotateRight(index, currentNode.right);\n                    }\n                    _rotateLeft(index, currentNode.id);\n                }\n\n                if ((-1 <= balanceFactor) && (balanceFactor <= 1)) {\n                    _updateNodeHeight(index, currentNode.id);\n                }\n\n                if (currentNode.parent == 0x0) {\n                    // Reached the root which may be new due to tree\n                    // rotation, so set it as the root and then break.\n                    break;\n                }\n\n                currentNode = index.nodes[currentNode.parent];\n            }\n        }\n\n        function _getBalanceFactor(Index storage index, bytes32 id) internal returns (int) {\n                Node storage node = index.nodes[id];\n\n                return int(index.nodes[node.left].height) - int(index.nodes[node.right].height);\n        }\n\n        function _updateNodeHeight(Index storage index, bytes32 id) internal {\n                Node storage node = index.nodes[id];\n\n                node.height = max(index.nodes[node.left].height, index.nodes[node.right].height) + 1;\n        }\n\n        function _rotateLeft(Index storage index, bytes32 id) internal {\n            Node storage originalRoot = index.nodes[id];\n\n            if (originalRoot.right == 0x0) {\n                // Cannot rotate left if there is no right originalRoot to rotate into\n                // place.\n                throw;\n            }\n\n            // The right child is the new root, so it gets the original\n            // `originalRoot.parent` as it's parent.\n            Node storage newRoot = index.nodes[originalRoot.right];\n            newRoot.parent = originalRoot.parent;\n\n            // The original root needs to have it's right child nulled out.\n            originalRoot.right = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If there is a parent node, it needs to now point downward at\n                // the newRoot which is rotating into the place where `node` was.\n                Node storage parent = index.nodes[originalRoot.parent];\n\n                // figure out if we're a left or right child and have the\n                // parent point to the new node.\n                if (parent.left == originalRoot.id) {\n                    parent.left = newRoot.id;\n                }\n                if (parent.right == originalRoot.id) {\n                    parent.right = newRoot.id;\n                }\n            }\n\n\n            if (newRoot.left != 0) {\n                // If the new root had a left child, that moves to be the\n                // new right child of the original root node\n                Node storage leftChild = index.nodes[newRoot.left];\n                originalRoot.right = leftChild.id;\n                leftChild.parent = originalRoot.id;\n            }\n\n            // Update the newRoot's left node to point at the original node.\n            originalRoot.parent = newRoot.id;\n            newRoot.left = originalRoot.id;\n\n            if (newRoot.parent == 0x0) {\n                index.root = newRoot.id;\n            }\n\n            // TODO: are both of these updates necessary?\n            _updateNodeHeight(index, originalRoot.id);\n            _updateNodeHeight(index, newRoot.id);\n        }\n\n        function _rotateRight(Index storage index, bytes32 id) internal {\n            Node storage originalRoot = index.nodes[id];\n\n            if (originalRoot.left == 0x0) {\n                // Cannot rotate right if there is no left node to rotate into\n                // place.\n                throw;\n            }\n\n            // The left child is taking the place of node, so we update it's\n            // parent to be the original parent of the node.\n            Node storage newRoot = index.nodes[originalRoot.left];\n            newRoot.parent = originalRoot.parent;\n\n            // Null out the originalRoot.left\n            originalRoot.left = 0x0;\n\n            if (originalRoot.parent != 0x0) {\n                // If the node has a parent, update the correct child to point\n                // at the newRoot now.\n                Node storage parent = index.nodes[originalRoot.parent];\n\n                if (parent.left == originalRoot.id) {\n                    parent.left = newRoot.id;\n                }\n                if (parent.right == originalRoot.id) {\n                    parent.right = newRoot.id;\n                }\n            }\n\n            if (newRoot.right != 0x0) {\n                Node storage rightChild = index.nodes[newRoot.right];\n                originalRoot.left = newRoot.right;\n                rightChild.parent = originalRoot.id;\n            }\n\n            // Update the new root's right node to point to the original node.\n            originalRoot.parent = newRoot.id;\n            newRoot.right = originalRoot.id;\n\n            if (newRoot.parent == 0x0) {\n                index.root = newRoot.id;\n            }\n\n            // Recompute heights.\n            _updateNodeHeight(index, originalRoot.id);\n            _updateNodeHeight(index, newRoot.id);\n        }\n}\n\n\n// Accounting v0.1 (not the same as the 0.1 release of this library)\n\n/// @title Accounting Lib - Accounting utilities\n/// @author Piper Merriam -\nlibrary AccountingLib {\n        /*\n         *  Address: 0x89efe605e9ecbe22849cd85d5449cc946c26f8f3\n         */\n        struct Bank {\n            mapping (address => uint) accountBalances;\n        }\n\n        /// @dev Low level method for adding funds to an account.  Protects against overflow.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be added to.\n        /// @param value The amount that should be added to the account.\n        function addFunds(Bank storage self, address accountAddress, uint value) public {\n                if (self.accountBalances[accountAddress] + value < self.accountBalances[accountAddress]) {\n                        // Prevent Overflow.\n                        throw;\n                }\n                self.accountBalances[accountAddress] += value;\n        }\n\n        event _Deposit(address indexed _from, address indexed accountAddress, uint value);\n        /// @dev Function wrapper around the _Deposit event so that it can be used by contracts.  Can be used to log a deposit to an account.\n        /// @param _from The address that deposited the funds.\n        /// @param accountAddress The address of the account the funds were added to.\n        /// @param value The amount that was added to the account.\n        function Deposit(address _from, address accountAddress, uint value) public {\n            _Deposit(_from, accountAddress, value);\n        }\n\n\n        /// @dev Safe function for depositing funds.  Returns boolean for whether the deposit was successful\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be added to.\n        /// @param value The amount that should be added to the account.\n        function deposit(Bank storage self, address accountAddress, uint value) public returns (bool) {\n                addFunds(self, accountAddress, value);\n                return true;\n        }\n\n        event _Withdrawal(address indexed accountAddress, uint value);\n\n        /// @dev Function wrapper around the _Withdrawal event so that it can be used by contracts.  Can be used to log a withdrawl from an account.\n        /// @param accountAddress The address of the account the funds were withdrawn from.\n        /// @param value The amount that was withdrawn to the account.\n        function Withdrawal(address accountAddress, uint value) public {\n            _Withdrawal(accountAddress, value);\n        }\n\n        event _InsufficientFunds(address indexed accountAddress, uint value, uint balance);\n\n        /// @dev Function wrapper around the _InsufficientFunds event so that it can be used by contracts.  Can be used to log a failed withdrawl from an account.\n        /// @param accountAddress The address of the account the funds were to be withdrawn from.\n        /// @param value The amount that was attempted to be withdrawn from the account.\n        /// @param balance The current balance of the account.\n        function InsufficientFunds(address accountAddress, uint value, uint balance) public {\n            _InsufficientFunds(accountAddress, value, balance);\n        }\n\n        /// @dev Low level method for removing funds from an account.  Protects against underflow.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be deducted from.\n        /// @param value The amount that should be deducted from the account.\n        function deductFunds(Bank storage self, address accountAddress, uint value) public {\n                /*\n                 *  Helper function that should be used for any reduction of\n                 *  account funds.  It has error checking to prevent\n                 *  underflowing the account balance which would be REALLY bad.\n                 */\n                if (value > self.accountBalances[accountAddress]) {\n                        // Prevent Underflow.\n                        throw;\n                }\n                self.accountBalances[accountAddress] -= value;\n        }\n\n        /// @dev Safe function for withdrawing funds.  Returns boolean for whether the deposit was successful as well as sending the amount in ether to the account address.\n        /// @param self The Bank instance to operate on.\n        /// @param accountAddress The address of the account the funds should be withdrawn from.\n        /// @param value The amount that should be withdrawn from the account.\n        function withdraw(Bank storage self, address accountAddress, uint value) public returns (bool) {\n                /*\n                 *  Public API for withdrawing funds.\n                 */\n                if (self.accountBalances[accountAddress] >= value) {\n                        deductFunds(self, accountAddress, value);\n                        if (!accountAddress.send(value)) {\n                                // Potentially sending money to a contract that\n                                // has a fallback function.  So instead, try\n                                // tranferring the funds with the call api.\n                                if (!accountAddress.call.value(value)()) {\n                                        // Revert the entire transaction.  No\n                                        // need to destroy the funds.\n                                        throw;\n                                }\n                        }\n                        return true;\n                }\n                return false;\n        }\n\n        uint constant DEFAULT_SEND_GAS = 100000;\n\n        function sendRobust(address toAddress, uint value) public returns (bool) {\n                if (msg.gas < DEFAULT_SEND_GAS) {\n                    return sendRobust(toAddress, value, msg.gas);\n                }\n                return sendRobust(toAddress, value, DEFAULT_SEND_GAS);\n        }\n\n        function sendRobust(address toAddress, uint value, uint maxGas) public returns (bool) {\n                if (value > 0 && !toAddress.send(value)) {\n                        // Potentially sending money to a contract that\n                        // has a fallback function.  So instead, try\n                        // tranferring the funds with the call api.\n                        if (!toAddress.call.gas(maxGas).value(value)()) {\n                                return false;\n                        }\n                }\n                return true;\n        }\n}\n\n\nlibrary CallLib {\n    /*\n     *  Address: 0x1deeda36e15ec9e80f3d7414d67a4803ae45fc80\n     */\n    struct Call {\n        address contractAddress;\n        bytes4 abiSignature;\n        bytes callData;\n        uint callValue;\n        uint anchorGasPrice;\n        uint requiredGas;\n        uint16 requiredStackDepth;\n\n        address claimer;\n        uint claimAmount;\n        uint claimerDeposit;\n\n        bool wasSuccessful;\n        bool wasCalled;\n        bool isCancelled;\n    }\n\n    enum State {\n        Pending,\n        Unclaimed,\n        Claimed,\n        Frozen,\n        Callable,\n        Executed,\n        Cancelled,\n        Missed\n    }\n\n    function state(Call storage self) constant returns (State) {\n        if (self.isCancelled) return State.Cancelled;\n        if (self.wasCalled) return State.Executed;\n\n        var call = FutureBlockCall(this);\n\n        if (block.number + CLAIM_GROWTH_WINDOW + MAXIMUM_CLAIM_WINDOW + BEFORE_CALL_FREEZE_WINDOW < call.targetBlock()) return State.Pending;\n        if (block.number + BEFORE_CALL_FREEZE_WINDOW < call.targetBlock()) {\n            if (self.claimer == 0x0) {\n                return State.Unclaimed;\n            }\n            else {\n                return State.Claimed;\n            }\n        }\n        if (block.number < call.targetBlock()) return State.Frozen;\n        if (block.number < call.targetBlock() + call.gracePeriod()) return State.Callable;\n        return State.Missed;\n    }\n\n    // The number of blocks that each caller in the pool has to complete their\n    // call.\n    uint constant CALL_WINDOW_SIZE = 16;\n\n    address constant creator = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n    function extractCallData(Call storage call, bytes data) public {\n        call.callData.length = data.length - 4;\n        if (data.length > 4) {\n                for (uint i = 0; i < call.callData.length; i++) {\n                        call.callData[i] = data[i + 4];\n                }\n        }\n    }\n\n    uint constant GAS_PER_DEPTH = 700;\n\n    function checkDepth(uint n) constant returns (bool) {\n        if (n == 0) return true;\n        return address(this).call.gas(GAS_PER_DEPTH * n)(bytes4(sha3(""__dig(uint256)"")), n - 1);\n    }\n\n    function sendSafe(address to_address, uint value) public returns (uint) {\n        if (value > address(this).balance) {\n            value = address(this).balance;\n        }\n        if (value > 0) {\n            AccountingLib.sendRobust(to_address, value);\n            return value;\n        }\n        return 0;\n    }\n\n    function getGasScalar(uint base_gas_price, uint gas_price) constant returns (uint) {\n        /*\n        *  Return a number between 0 - 200 to scale the donation based on the\n        *  gas price set for the calling transaction as compared to the gas\n        *  price of the scheduling transaction.\n        *\n        *  - number approaches zero as the transaction gas price goes\n        *  above the gas price recorded when the call was scheduled.\n        *\n        *  - the number approaches 200 as the transaction gas price\n        *  drops under the price recorded when the call was scheduled.\n        *\n        *  This encourages lower gas costs as the lower the gas price\n        *  for the executing transaction, the higher the payout to the\n        *  caller.\n        */\n        if (gas_price > base_gas_price) {\n            return 100 * base_gas_price / gas_price;\n        }\n        else {\n            return 200 - 100 * base_gas_price / (2 * base_gas_price - gas_price);\n        }\n    }\n\n    event CallExecuted(address indexed executor, uint gasCost, uint payment, uint donation, bool success);\n\n    bytes4 constant EMPTY_SIGNATURE = 0x0000;\n\n    event CallAborted(address executor, bytes32 reason);\n\n    function execute(Call storage self,\n                     uint start_gas,\n                     address executor,\n                     uint overhead,\n                     uint extraGas) public {\n        FutureCall call = FutureCall(this);\n\n        // Mark the call has having been executed.\n        self.wasCalled = true;\n\n        // Make the call\n        if (self.abiSignature == EMPTY_SIGNATURE && self.callData.length == 0) {\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)();\n        }\n        else if (self.abiSignature == EMPTY_SIGNATURE) {\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.callData);\n        }\n        else if (self.callData.length == 0) {\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature);\n        }\n        else {\n            self.wasSuccessful = self.contractAddress.call.value(self.callValue).gas(msg.gas - overhead)(self.abiSignature, self.callData);\n        }\n\n        call.origin().call(bytes4(sha3(""updateDefaultPayment()"")));\n\n        // Compute the scalar (0 - 200) for the donation.\n        uint gasScalar = getGasScalar(self.anchorGasPrice, tx.gasprice);\n\n        uint basePayment;\n        if (self.claimer == executor) {\n            basePayment = self.claimAmount;\n        }\n        else {\n            basePayment = call.basePayment();\n        }\n        uint payment = self.claimerDeposit + basePayment * gasScalar / 100;\n        uint donation = call.baseDonation() * gasScalar / 100;\n\n        // zero out the deposit\n        self.claimerDeposit = 0;\n\n        // Log how much gas this call used.  EXTRA_CALL_GAS is a fixed\n        // amount that represents the gas usage of the commands that\n        // happen after this line.\n        uint gasCost = tx.gasprice * (start_gas - msg.gas + extraGas);\n\n        // Now we need to pay the executor as well as keep donation.\n        payment = sendSafe(executor, payment + gasCost);\n        donation = sendSafe(creator, donation);\n\n        // Log execution\n        CallExecuted(executor, gasCost, payment, donation, self.wasSuccessful);\n    }\n\n    event Cancelled(address indexed cancelled_by);\n\n    function cancel(Call storage self, address sender) public {\n        Cancelled(sender);\n        if (self.claimerDeposit >= 0) {\n            sendSafe(self.claimer, self.claimerDeposit);\n        }\n        var call = FutureCall(this);\n        sendSafe(call.schedulerAddress(), address(this).balance);\n        self.isCancelled = true;\n    }\n\n    /*\n     *  Bid API\n     *  - Gas costs for this transaction are not covered so it\n     *    must be up to the call executors to ensure that their actions\n     *    remain profitable.  Any form of bidding war is likely to eat into\n     *    profits.\n     */\n    event Claimed(address executor, uint claimAmount);\n\n    // The duration (in blocks) during which the maximum claim will slowly rise\n    // towards the basePayment amount.\n    uint constant CLAIM_GROWTH_WINDOW = 240;\n\n    // The duration (in blocks) after the CLAIM_WINDOW that claiming will\n    // remain open.\n    uint constant MAXIMUM_CLAIM_WINDOW = 15;\n\n    // The duration (in blocks) before the call's target block during which\n    // all actions are frozen.  This includes claiming, cancellation,\n    // registering call data.\n    uint constant BEFORE_CALL_FREEZE_WINDOW = 10;\n\n    /*\n     *  The maximum allowed claim amount slowly rises across a window of\n     *  blocks CLAIM_GROWTH_WINDOW prior to the call.  No claimer is\n     *  allowed to claim above this value.  This is intended to prevent\n     *  bidding wars in that each caller should know how much they are\n     *  willing to execute a call for.\n     */\n    function getClaimAmountForBlock(uint block_number) constant returns (uint) {\n        /*\n         *   [--growth-window--][--max-window--][--freeze-window--]\n         *\n         *\n         */\n        var call = FutureBlockCall(this);\n\n        uint cutoff = call.targetBlock() - BEFORE_CALL_FREEZE_WINDOW;\n\n        // claim window has closed\n        if (block_number > cutoff) return call.basePayment();\n\n        cutoff -= MAXIMUM_CLAIM_WINDOW;\n\n        // in the maximum claim window.\n        if (block_number > cutoff) return call.basePayment();\n\n        cutoff -= CLAIM_GROWTH_WINDOW;\n\n        if (block_number > cutoff) {\n            uint x = block_number - cutoff;\n\n            return call.basePayment() * x / CLAIM_GROWTH_WINDOW;\n        }\n\n        return 0;\n    }\n\n    function lastClaimBlock() constant returns (uint) {\n        var call = FutureBlockCall(this);\n        return call.targetBlock() - BEFORE_CALL_FREEZE_WINDOW;\n    }\n\n    function maxClaimBlock() constant returns (uint) {\n        return lastClaimBlock() - MAXIMUM_CLAIM_WINDOW;\n    }\n\n    function firstClaimBlock() constant returns (uint) {\n        return maxClaimBlock() - CLAIM_GROWTH_WINDOW;\n    }\n\n    function claim(Call storage self, address executor, uint deposit_amount, uint basePayment) public returns (bool) {\n        /*\n         *  Warning! this does not check whether the function is already\n         *  claimed or whether we are within the claim window.  This must be\n         *  done at the contract level.\n         */\n        // Insufficient Deposit\n        if (deposit_amount < 2 * basePayment) return false;\n\n        self.claimAmount = getClaimAmountForBlock(block.number);\n        self.claimer = executor;\n        self.claimerDeposit = deposit_amount;\n\n        // Log the claim.\n        Claimed(executor, self.claimAmount);\n    }\n\n    function checkExecutionAuthorization(Call storage self, address executor, uint block_number) returns (bool) {\n        /*\n        *  Check whether the given `executor` is authorized.\n        */\n        var call = FutureBlockCall(this);\n\n        uint targetBlock = call.targetBlock();\n\n        // Invalid, not in call window.\n        if (block_number < targetBlock || block_number > targetBlock + call.gracePeriod()) throw;\n\n        // Within the reserved call window so if there is a claimer, the\n        // executor must be the claimdor.\n        if (block_number - targetBlock < CALL_WINDOW_SIZE) {\n        return (self.claimer == 0x0 || self.claimer == executor);\n        }\n\n        // Must be in the free-for-all period.\n        return true;\n    }\n\n    function isCancellable(Call storage self, address caller) returns (bool) {\n        var _state = state(self);\n        var call = FutureBlockCall(this);\n\n        if (_state == State.Pending && caller == call.schedulerAddress()) {\n            return true;\n        }\n\n        if (_state == State.Missed) return true;\n\n        return false;\n    }\n\n    function beforeExecuteForFutureBlockCall(Call storage self, address executor, uint startGas) returns (bool) {\n        bytes32 reason;\n\n        var call = FutureBlockCall(this);\n\n        if (startGas < self.requiredGas) {\n            // The executor has not provided sufficient gas\n            reason = ""NOT_ENOUGH_GAS"";\n        }\n        else if (self.wasCalled) {\n            // Not being called within call window.\n            reason = ""ALREADY_CALLED"";\n        }\n        else if (block.number < call.targetBlock() || block.number > call.targetBlock() + call.gracePeriod()) {\n            // Not being called within call window.\n            reason = ""NOT_IN_CALL_WINDOW"";\n        }\n        else if (!checkExecutionAuthorization(self, executor, block.number)) {\n            // Someone has claimed this call and they currently have exclusive\n            // rights to execute it.\n            reason = ""NOT_AUTHORIZED"";\n        }\n        else if (self.requiredStackDepth > 0 && executor != tx.origin && !checkDepth(self.requiredStackDepth)) {\n            reason = ""STACK_TOO_DEEP"";\n        }\n\n        if (reason != 0x0) {\n            CallAborted(executor, reason);\n            return false;\n        }\n\n        return true;\n    }\n}\n\n\ncontract FutureCall {\n    // The author (Piper Merriam) address.\n    address constant creator = 0xd3cda913deb6f67967b99d67acdfa1712c293601;\n\n    address public schedulerAddress;\n\n    uint public basePayment;\n    uint public baseDonation;\n\n    CallLib.Call call;\n\n    address public origin;\n\n    function FutureCall(address _schedulerAddress,\n                        uint _requiredGas,\n                        uint16 _requiredStackDepth,\n                        address _contractAddress,\n                        bytes4 _abiSignature,\n                        bytes _callData,\n                        uint _callValue,\n                        uint _basePayment,\n                        uint _baseDonation)\n    {\n        origin = msg.sender;\n        schedulerAddress = _schedulerAddress;\n\n        basePayment = _basePayment;\n        baseDonation = _baseDonation;\n\n        call.requiredGas = _requiredGas;\n        call.requiredStackDepth = _requiredStackDepth;\n        call.anchorGasPrice = tx.gasprice;\n        call.contractAddress = _contractAddress;\n        call.abiSignature = _abiSignature;\n        call.callData = _callData;\n        call.callValue = _callValue;\n    }\n\n    enum State {\n        Pending,\n        Unclaimed,\n        Claimed,\n        Frozen,\n        Callable,\n        Executed,\n        Cancelled,\n        Missed\n    }\n\n    modifier in_state(State _state) { if (state() == _state) _ }\n\n    function state() constant returns (State) {\n        return State(CallLib.state(call));\n    }\n\n    /*\n     *  API for FutureXXXXCalls to implement.\n     */\n    function beforeExecute(address executor, uint startGas) public returns (bool);\n    function afterExecute(address executor) internal;\n    function getOverhead() constant returns (uint);\n    function getExtraGas() constant returns (uint);\n\n    /*\n     *  Data accessor functions.\n     */\n    function contractAddress() constant returns (address) {\n        return call.contractAddress;\n    }\n\n    function abiSignature() constant returns (bytes4) {\n        return call.abiSignature;\n    }\n\n    function callData() constant returns (bytes) {\n        return call.callData;\n    }\n\n    function callValue() constant returns (uint) {\n        return call.callValue;\n    }\n\n    function anchorGasPrice() constant returns (uint) {\n        return call.anchorGasPrice;\n    }\n\n    function requiredGas() constant returns (uint) {\n        return call.requiredGas;\n    }\n\n    function requiredStackDepth() constant returns (uint16) {\n        return call.requiredStackDepth;\n    }\n\n    function claimer() constant returns (address) {\n        return call.claimer;\n    }\n\n    function claimAmount() constant returns (uint) {\n        return call.claimAmount;\n    }\n\n    function claimerDeposit() constant returns (uint) {\n        return call.claimerDeposit;\n    }\n\n    function wasSuccessful() constant returns (bool) {\n        return call.wasSuccessful;\n    }\n\n    function wasCalled() constant returns (bool) {\n        return call.wasCalled;\n    }\n\n    function isCancelled() constant returns (bool) {\n        return call.isCancelled;\n    }\n\n    /*\n     *  Claim API helpers\n     */\n    function getClaimAmountForBlock() constant returns (uint) {\n        return CallLib.getClaimAmountForBlock(block.number);\n    }\n\n    function getClaimAmountForBlock(uint block_number) constant returns (uint) {\n        return CallLib.getClaimAmountForBlock(block_number);\n    }\n\n    /*\n     *  Call Data registration\n     */\n    function () returns (bool) {\n        /*\n         * Fallback to allow sending funds to this contract.\n         * (also allows registering raw call data)\n         */\n        // only scheduler can register call data.\n        if (msg.sender != schedulerAddress) return false;\n        // cannot write over call data\n        if (call.callData.length > 0) return false;\n\n        var _state = state();\n        if (_state != State.Pending && _state != State.Unclaimed && _state != State.Claimed) return false;\n\n        call.callData = msg.data;\n        return true;\n    }\n\n    function registerData() public returns (bool) {\n        // only scheduler can register call data.\n        if (msg.sender != schedulerAddress) return false;\n        // cannot write over call data\n        if (call.callData.length > 0) return false;\n\n        var _state = state();\n        if (_state != State.Pending && _state != State.Unclaimed && _state != State.Claimed) return false;\n\n        CallLib.extractCallData(call, msg.data);\n    }\n\n    function firstClaimBlock() constant returns (uint) {\n        return CallLib.firstClaimBlock();\n    }\n\n    function maxClaimBlock() constant returns (uint) {\n        return CallLib.maxClaimBlock();\n    }\n\n    function lastClaimBlock() constant returns (uint) {\n        return CallLib.lastClaimBlock();\n    }\n\n    function claim() public in_state(State.Unclaimed) returns (bool) {\n        bool success = CallLib.claim(call, msg.sender, msg.value, basePayment);\n        if (!success) {\n            if (!AccountingLib.sendRobust(msg.sender, msg.value)) throw;\n        }\n        return success;\n    }\n\n    function checkExecutionAuthorization(address executor, uint block_number) constant returns (bool) {\n        return CallLib.checkExecutionAuthorization(call, executor, block_number);\n    }\n\n    function sendSafe(address to_address, uint value) internal {\n        CallLib.sendSafe(to_address, value);\n    }\n\n    function execute() public in_state(State.Callable) {\n        uint start_gas = msg.gas;\n\n        // Check that the call should be executed now.\n        if (!beforeExecute(msg.sender, start_gas)) return;\n\n        // Execute the call\n        CallLib.execute(call, start_gas, msg.sender, getOverhead(), getExtraGas());\n\n        // Any logic that needs to occur after the call has executed should\n        // go in afterExecute\n        afterExecute(msg.sender);\n    }\n}\n\n\ncontract FutureBlockCall is FutureCall {\n    uint public targetBlock;\n    uint8 public gracePeriod;\n\n    uint constant CALL_API_VERSION = 2;\n\n    function callAPIVersion() constant returns (uint) {\n        return CALL_API_VERSION;\n    }\n\n    function FutureBlockCall(address _schedulerAddress,\n                             uint _targetBlock,\n                             uint8 _gracePeriod,\n                             address _contractAddress,\n                             bytes4 _abiSignature,\n                             bytes _callData,\n                             uint _callValue,\n                             uint _requiredGas,\n                             uint16 _requiredStackDepth,\n                             uint _basePayment,\n                             uint _baseDonation)\n        FutureCall(_schedulerAddress, _requiredGas, _requiredStackDepth, _contractAddress, _abiSignature, _callData, _callValue, _basePayment, _baseDonation)\n    {\n        // parent contract FutureCall\n        schedulerAddress = _schedulerAddress;\n\n        targetBlock = _targetBlock;\n        gracePeriod = _gracePeriod;\n    }\n\n    uint constant GAS_PER_DEPTH = 700;\n\n    function __dig(uint n) constant returns (bool) {\n        if (n == 0) return true;\n        if (!address(this).callcode(bytes4(sha3(""__dig(uint256)"")), n - 1)) throw;\n    }\n\n\n    function beforeExecute(address executor, uint startGas) public returns (bool) {\n        return CallLib.beforeExecuteForFutureBlockCall(call, executor, startGas);\n    }\n\n    function afterExecute(address executor) internal {\n        // Refund any leftover funds.\n        CallLib.sendSafe(schedulerAddress, address(this).balance);\n    }\n\n    uint constant GAS_OVERHEAD = 100000;\n\n    function getOverhead() constant returns (uint) {\n            return GAS_OVERHEAD;\n    }\n\n    uint constant EXTRA_GAS = 77000;\n\n    function getExtraGas() constant returns (uint) {\n            return EXTRA_GAS;\n    }\n\n    uint constant CLAIM_GROWTH_WINDOW = 240;\n    uint constant MAXIMUM_CLAIM_WINDOW = 15;\n    uint constant BEFORE_CALL_FREEZE_WINDOW = 10;\n\n    function isCancellable() constant public returns (bool) {\n        return CallLib.isCancellable(call, msg.sender);\n    }\n\n    function cancel() public {\n        if (CallLib.isCancellable(call, msg.sender)) {\n            CallLib.cancel(call, msg.sender);\n        }\n    }\n}\n\n\nlibrary SchedulerLib {\n    /*\n     *  Address: 0xe54d323f9ef17c1f0dede47ecc86a9718fe5ea34\n     */\n    /*\n     *  Call Scheduling API\n     */\n    function version() constant returns (uint16, uint16, uint16) {\n        return (0, 7, 0);\n    }\n\n    // Ten minutes into the future.\n    uint constant MIN_BLOCKS_IN_FUTURE = 10;\n\n    // max of uint8\n    uint8 constant DEFAULT_GRACE_PERIOD = 255;\n\n    // The minimum gas required to execute a scheduled call on a function that\n    // does almost nothing.  This is an approximation and assumes the worst\n    // case scenario for gas consumption.\n    //\n    // Measured Minimum is closer to 80,000\n    uint constant MINIMUM_CALL_GAS = 200000;\n\n    // The minimum depth required to execute a call.\n    uint16 constant MINIMUM_STACK_CHECK = 10;\n\n    // The maximum possible depth that stack depth checking can achieve.\n    // Actual check limit is 1021.  Actual call limit is 1021\n    uint16 constant MAXIMUM_STACK_CHECK = 1000;\n\n    event CallScheduled(address call_address);\n\n    event CallRejected(address indexed schedulerAddress, bytes32 reason);\n\n    uint constant CALL_WINDOW_SIZE = 16;\n\n    function getMinimumStackCheck() constant returns (uint16) {\n        return MINIMUM_STACK_CHECK;\n    }\n\n    function getMaximumStackCheck() constant returns (uint16) {\n        return MAXIMUM_STACK_CHECK;\n    }\n\n    function getCallWindowSize() constant returns (uint) {\n        return CALL_WINDOW_SIZE;\n    }\n\n    function getMinimumGracePeriod() constant returns (uint) {\n        return 2 * CALL_WINDOW_SIZE;\n    }\n\n    function getDefaultGracePeriod() constant returns (uint8) {\n        return DEFAULT_GRACE_PERIOD;\n    }\n\n    function getMinimumCallGas() constant returns (uint) {\n        return MINIMUM_CALL_GAS;\n    }\n\n    function getMaximumCallGas() constant returns (uint) {\n        return block.gaslimit - getMinimumCallGas();\n    }\n\n    function getMinimumCallCost(uint basePayment, uint baseDonation) constant returns (uint) {\n        return 2 * (baseDonation + basePayment) + MINIMUM_CALL_GAS * tx.gasprice;\n    }\n\n    function getFirstSchedulableBlock() constant returns (uint) {\n        return block.number + MIN_BLOCKS_IN_FUTURE;\n    }\n\n    function getMinimumEndowment(uint basePayment,\n                                 uint baseDonation,\n                                 uint callValue,\n                                 uint requiredGas) constant returns (uint endowment) {\n            endowment += tx.gasprice * requiredGas;\n            endowment += 2 * (basePayment + baseDonation);\n            endowment += callValue;\n\n            return endowment;\n    }\n\n    struct CallConfig {\n        address schedulerAddress;\n        address contractAddress;\n        bytes4 abiSignature;\n        bytes callData;\n        uint callValue;\n        uint8 gracePeriod;\n        uint16 requiredStackDepth;\n        uint targetBlock;\n        uint requiredGas;\n        uint basePayment;\n        uint baseDonation;\n        uint endowment;\n    }\n\n    function scheduleCall(GroveLib.Index storage callIndex,\n                          address schedulerAddress,\n                          address contractAddress,\n                          bytes4 abiSignature,\n                          bytes callData,\n                          uint8 gracePeriod,\n                          uint16 requiredStackDepth,\n                          uint callValue,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint basePayment,\n                          uint baseDonation,\n                          uint endowment) public returns (address) {\n        CallConfig memory callConfig = CallConfig({\n            schedulerAddress: schedulerAddress,\n            contractAddress: contractAddress,\n            abiSignature: abiSignature,\n            callData: callData,\n            gracePeriod: gracePeriod,\n            requiredStackDepth: requiredStackDepth,\n            callValue: callValue,\n            targetBlock: targetBlock,\n            requiredGas: requiredGas,\n            basePayment: basePayment,\n            baseDonation: baseDonation,\n            endowment: endowment,\n        });\n        return _scheduleCall(callIndex, callConfig);\n    }\n\n    function scheduleCall(GroveLib.Index storage callIndex,\n                          address[2] addresses,\n                          bytes4 abiSignature,\n                          bytes callData,\n                          uint8 gracePeriod,\n                          uint16 requiredStackDepth,\n                          uint[6] uints) public returns (address) {\n        CallConfig memory callConfig = CallConfig({\n            schedulerAddress: addresses[0],\n            contractAddress: addresses[1],\n            abiSignature: abiSignature,\n            callData: callData,\n            gracePeriod: gracePeriod,\n            requiredStackDepth: requiredStackDepth,\n            callValue: uints[0],\n            targetBlock: uints[1],\n            requiredGas: uints[2],\n            basePayment: uints[3],\n            baseDonation: uints[4],\n            endowment: uints[5],\n        });\n        return _scheduleCall(callIndex, callConfig);\n\n    }\n\n    function _scheduleCall(GroveLib.Index storage callIndex, CallConfig memory callConfig) internal returns (address) {\n        /*\n        * Primary API for scheduling a call.\n        *\n        * - No sooner than MIN_BLOCKS_IN_FUTURE\n        * - Grace Period must be longer than the minimum grace period.\n        * - msg.value must be >= MIN_GAS * tx.gasprice + 2 * (baseDonation + basePayment)\n        */\n        bytes32 reason;\n\n        if (callConfig.targetBlock < block.number + MIN_BLOCKS_IN_FUTURE) {\n            // Don't allow scheduling further than\n            // MIN_BLOCKS_IN_FUTURE\n            reason = ""TOO_SOON"";\n        }\n        else if (getMinimumStackCheck() > callConfig.requiredStackDepth || callConfig.requiredStackDepth > getMaximumStackCheck()) {\n            // Cannot require stack depth greater than MAXIMUM_STACK_CHECK or\n            // less than MINIMUM_STACK_CHECK\n            reason = ""STACK_CHECK_OUT_OF_RANGE"";\n        }\n        else if (callConfig.gracePeriod < getMinimumGracePeriod()) {\n            reason = ""GRACE_TOO_SHORT"";\n        }\n        else if (callConfig.requiredGas < getMinimumCallGas() || callConfig.requiredGas > getMaximumCallGas()) {\n            reason = ""REQUIRED_GAS_OUT_OF_RANGE"";\n        }\n        else if (callConfig.endowment < getMinimumEndowment(callConfig.basePayment, callConfig.baseDonation, callConfig.callValue, callConfig.requiredGas)) {\n            reason = ""INSUFFICIENT_FUNDS"";\n        }\n\n        if (reason != 0x0) {\n            CallRejected(callConfig.schedulerAddress, reason);\n            AccountingLib.sendRobust(callConfig.schedulerAddress, callConfig.endowment);\n            return;\n        }\n\n        var call = (new FutureBlockCall).value(callConfig.endowment)(\n                callConfig.schedulerAddress,\n                callConfig.targetBlock,\n                callConfig.gracePeriod,\n                callConfig.contractAddress,\n                callConfig.abiSignature,\n                callConfig.callData,\n                callConfig.callValue,\n                callConfig.requiredGas,\n                callConfig.requiredStackDepth,\n                callConfig.basePayment,\n                callConfig.baseDonation\n        );\n\n        // Put the call into the grove index.\n        GroveLib.insert(callIndex, bytes32(address(call)), int(call.targetBlock()));\n\n        CallScheduled(address(call));\n\n        return address(call);\n    }\n}\n\n\ncontract Scheduler {\n    /*\n     *  Address: 0x6c8f2a135f6ed072de4503bd7c4999a1a17f824b\n     */\n\n    // The starting value (0.01 USD at 1eth:$2 exchange rate)\n    uint constant INITIAL_DEFAUlT_PAYMENT = 5 finney;\n\n    uint public defaultPayment;\n\n    function Scheduler() {\n        defaultPayment = INITIAL_DEFAUlT_PAYMENT;\n    }\n\n    // callIndex tracks the ordering of scheduled calls based on their block numbers.\n    GroveLib.Index callIndex;\n\n    uint constant CALL_API_VERSION = 7;\n\n    function callAPIVersion() constant returns (uint) {\n        return CALL_API_VERSION;\n    }\n\n    /*\n     *  Call Scheduling\n     */\n    function getMinimumGracePeriod() constant returns (uint) {\n        return SchedulerLib.getMinimumGracePeriod();\n    }\n\n    // Default payment and donation values\n    modifier only_known_call { if (isKnownCall(msg.sender)) _ }\n\n    function updateDefaultPayment() public only_known_call {\n        var call = FutureBlockCall(msg.sender);\n        var basePayment = call.basePayment();\n\n        if (call.wasCalled() && call.claimer() != 0x0 && basePayment > 0 && defaultPayment > 1) {\n            var index = call.claimAmount() * 100 / basePayment;\n\n            if (index > 66 && defaultPayment <= basePayment) {\n                // increase by 0.01%\n                defaultPayment = defaultPayment * 10001 / 10000;\n            }\n            else if (index < 33 && defaultPayment >= basePayment) {\n                // decrease by 0.01%\n                defaultPayment = defaultPayment * 9999 / 10000;\n            }\n        }\n    }\n\n    function getDefaultDonation() constant returns (uint) {\n        return defaultPayment / 100;\n    }\n\n    function getMinimumCallGas() constant returns (uint) {\n        return SchedulerLib.getMinimumCallGas();\n    }\n\n    function getMaximumCallGas() constant returns (uint) {\n        return SchedulerLib.getMaximumCallGas();\n    }\n\n    function getMinimumEndowment() constant returns (uint) {\n        return SchedulerLib.getMinimumEndowment(defaultPayment, getDefaultDonation(), 0, getDefaultRequiredGas());\n    }\n\n    function getMinimumEndowment(uint basePayment) constant returns (uint) {\n        return SchedulerLib.getMinimumEndowment(basePayment, getDefaultDonation(), 0, getDefaultRequiredGas());\n    }\n\n    function getMinimumEndowment(uint basePayment, uint baseDonation) constant returns (uint) {\n        return SchedulerLib.getMinimumEndowment(basePayment, baseDonation, 0, getDefaultRequiredGas());\n    }\n\n    function getMinimumEndowment(uint basePayment, uint baseDonation, uint callValue) constant returns (uint) {\n        return SchedulerLib.getMinimumEndowment(basePayment, baseDonation, callValue, getDefaultRequiredGas());\n    }\n\n    function getMinimumEndowment(uint basePayment, uint baseDonation, uint callValue, uint requiredGas) constant returns (uint) {\n        return SchedulerLib.getMinimumEndowment(basePayment, baseDonation, callValue, requiredGas);\n    }\n\n    function isKnownCall(address callAddress) constant returns (bool) {\n        return GroveLib.exists(callIndex, bytes32(callAddress));\n    }\n\n    function getFirstSchedulableBlock() constant returns (uint) {\n        return SchedulerLib.getFirstSchedulableBlock();\n    }\n\n    function getMinimumStackCheck() constant returns (uint16) {\n        return SchedulerLib.getMinimumStackCheck();\n    }\n\n    function getMaximumStackCheck() constant returns (uint16) {\n        return SchedulerLib.getMaximumStackCheck();\n    }\n\n    function getDefaultStackCheck() constant returns (uint16) {\n        return getMinimumStackCheck();\n    }\n\n    function getDefaultRequiredGas() constant returns (uint) {\n        return SchedulerLib.getMinimumCallGas();\n    }\n\n    function getDefaultGracePeriod() constant returns (uint8) {\n        return SchedulerLib.getDefaultGracePeriod();\n    }\n\n    bytes constant EMPTY_CALL_DATA = """";\n    uint constant DEFAULT_CALL_VALUE = 0;\n    bytes4 constant DEFAULT_FN_SIGNATURE = 0x0000;\n\n    function scheduleCall() public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            DEFAULT_FN_SIGNATURE, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(uint targetBlock) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            DEFAULT_FN_SIGNATURE, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes callData) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            DEFAULT_FN_SIGNATURE, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          bytes callData) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            DEFAULT_FN_SIGNATURE, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          uint callValue,\n                          bytes4 abiSignature) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            callValue, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          bytes callData) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          uint callValue,\n                          bytes callData) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            callValue, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(uint callValue,\n                          address contractAddress) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            DEFAULT_FN_SIGNATURE, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            callValue, getFirstSchedulableBlock(), getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          uint targetBlock) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            DEFAULT_FN_SIGNATURE, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          uint targetBlock,\n                          uint callValue) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            DEFAULT_FN_SIGNATURE, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            callValue, targetBlock, getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          uint targetBlock) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          uint targetBlock) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          bytes callData,\n                          uint targetBlock) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          bytes callData,\n                          uint targetBlock) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          uint callValue,\n                          bytes callData,\n                          uint targetBlock) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            callValue, targetBlock, getDefaultRequiredGas(), defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          uint targetBlock,\n                          uint requiredGas) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          uint targetBlock,\n                          uint requiredGas) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, EMPTY_CALL_DATA, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          bytes callData,\n                          uint targetBlock,\n                          uint requiredGas) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          bytes callData,\n                          uint targetBlock,\n                          uint requiredGas) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, callData, getDefaultGracePeriod(), getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, EMPTY_CALL_DATA, gracePeriod, getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          uint callValue,\n                          bytes4 abiSignature,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, EMPTY_CALL_DATA, gracePeriod, getDefaultStackCheck(),\n            callValue, targetBlock, requiredGas, defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, EMPTY_CALL_DATA, gracePeriod, getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          bytes callData,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, callData, gracePeriod, getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, defaultPayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod,\n                          uint basePayment) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, EMPTY_CALL_DATA, gracePeriod, getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, basePayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          uint callValue,\n                          bytes4 abiSignature,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod,\n                          uint basePayment) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, EMPTY_CALL_DATA, gracePeriod, getDefaultStackCheck(),\n            callValue, targetBlock, requiredGas, basePayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod,\n                          uint basePayment) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, EMPTY_CALL_DATA, gracePeriod, getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, basePayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          bytes callData,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod,\n                          uint basePayment) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, callData, gracePeriod, getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, basePayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          bytes callData,\n                          uint8 gracePeriod,\n                          uint[4] args) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, callData, gracePeriod, getDefaultStackCheck(),\n            // callValue, targetBlock, requiredGas, basePayment\n            args[0], args[1], args[2], args[3], getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          bytes callData,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint8 gracePeriod,\n                          uint basePayment) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, contractAddress,\n            abiSignature, callData, gracePeriod, getDefaultStackCheck(),\n            DEFAULT_CALL_VALUE, targetBlock, requiredGas, basePayment, getDefaultDonation(), msg.value\n        );\n    }\n\n    function scheduleCall(bytes4 abiSignature,\n                          bytes callData,\n                          uint16 requiredStackDepth,\n                          uint8 gracePeriod,\n                          uint callValue,\n                          uint targetBlock,\n                          uint requiredGas,\n                          uint basePayment,\n                          uint baseDonation) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            msg.sender, msg.sender,\n            abiSignature, callData, gracePeriod, requiredStackDepth,\n            callValue, targetBlock, requiredGas, basePayment, baseDonation, msg.value\n        );\n    }\n\n    function scheduleCall(address contractAddress,\n                          bytes4 abiSignature,\n                          bytes callData,\n                          uint16 requiredStackDepth,\n                          uint8 gracePeriod,\n                          uint[5] args) public returns (address) {\n        return SchedulerLib.scheduleCall(\n            callIndex,\n            [msg.sender, contractAddress],\n            abiSignature, callData, gracePeriod, requiredStackDepth,\n            // callValue, targetBlock, requiredGas, basePayment, baseDonation\n            [args[0], args[1], args[2], args[3], args[4], msg.value]\n        );\n    }\n\n    /*\n     *  Next Call API\n     */\n    function getCallWindowSize() constant returns (uint) {\n            return SchedulerLib.getCallWindowSize();\n    }\n\n    function getNextCall(uint blockNumber) constant returns (address) {\n            return address(GroveLib.query(callIndex, "">="", int(blockNumber)));\n    }\n\n    function getNextCallSibling(address callAddress) constant returns (address) {\n            return address(GroveLib.getNextNode(callIndex, bytes32(callAddress)));\n    }\n}",1,
945786,0x1c68f4f35ac5239650333d291e6ce7f841149937,FALSE,FALSE,"contract OraclizeI {\n    function getPrice(string _datasource, uint _gas_limit) returns (uint _dsprice);\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\n\n\ncontract USDOracle {\n    OraclizeAddrResolverI OAR = OraclizeAddrResolverI(0x1d11e5eae3112dbd44f99266872ff1d07c77dce8);\n\n    function USDOracle() {\n    }\n\n    function initialize() public {\n        var oraclize = OraclizeI(OAR.getAddress());\n        oraclize.query.value(msg.value)(0, ""URL"", ""http://example.com"");\n    }\n\n    function getPriceProxy() constant returns (uint) {\n        var oraclize = OraclizeI(OAR.getAddress());\n        return oraclize.getPrice(""URL"", 200000);\n    }\n\n    function oneCentOfWei() constant returns (uint) {\n        var oraclize = OraclizeI(OAR.getAddress());\n        var price = oraclize.getPrice(""URL"", 200000);\n        var one_cent_of_wei = price - tx.gasprice * 200000;\n        return one_cent_of_wei;\n    }\n\n    function WEI() constant returns (uint) {\n        // 1 USD in WEI\n        return oneCentOfWei() * 100;\n    }\n\n    function USD() constant returns (uint) {\n        // 1 ETH in USD\n        return 1 ether / oneCentOfWei();\n    }\n}",1,
947613,0x3aaaf1c542b365e47f13ab62497f020eee45f747,FALSE,FALSE,"contract ChineseCookies {\n\n        address[] bakers;\n        mapping(address => string[]) cookies;\n        mapping(string => string) wishes;\n\n        function ChineseCookies() {\n                bakeCookie(""A friend asks only for your time not your money."");\n                bakeCookie(""If you refuse to accept anything but the best, you very often get it."");\n                bakeCookie(""A smile is your passport into the hearts of others."");\n                bakeCookie(""A good way to keep healthy is to eat more Chinese food."");\n                bakeCookie(""Your high-minded principles spell success."");\n                bakeCookie(""Hard work pays off in the future, laziness pays off now."");\n                bakeCookie(""Change can hurt, but it leads a path to something better."");\n                bakeCookie(""Enjoy the good luck a companion brings you."");\n                bakeCookie(""People are naturally attracted to you."");\n                bakeCookie(""A chance meeting opens new doors to success and friendship."");\n                bakeCookie(""You learn from your mistakes... You will learn a lot today."");\n        }\n\n        function bakeCookie(string wish) {\n                var cookiesCount = cookies[msg.sender].push(wish);\n\n                // if it's the first cookie then we add sender to bakers list\n                if (cookiesCount == 1) {\n                        bakers.push(msg.sender);\n                }\n        }\n\n        function breakCookie(string name) {\n                var bakerAddress = bakers[block.number % bakers.length];\n                var bakerCookies = cookies[bakerAddress];\n\n                wishes[name] = bakerCookies[block.number % bakerCookies.length];\n        }\n}",2,実用的な要素に加え、詩的なメッセージが含まれているため。
988725,0xfb6916095ca1df60bb79ce92ce3ea74c37c5d359,FALSE,FALSE,"contract owned {\n        address public owner;\n\n        function owned() {\n                owner = msg.sender;\n        }\n\n        modifier onlyOwner {\n                if (msg.sender != owner) throw;\n                _\n        }\n\n        function transferOwnership(address newOwner) onlyOwner {\n                owner = newOwner;\n        }\n}\n\n/* The token is used as a voting shares */\ncontract token {\n        function mintToken(address target, uint256 mintedAmount);\n}\n\ncontract Congress is owned {\n\n        /* Contract Variables and events */\n        uint public minimumQuorum;\n        uint public debatingPeriodInMinutes;\n        int public majorityMargin;\n        Proposal[] public proposals;\n        uint public numProposals;\n        mapping(address => uint) public memberId;\n        Member[] public members;\n\n        address public unicornAddress;\n        uint public priceOfAUnicornInFinney;\n\n        event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\n        event Voted(uint proposalID, bool position, address voter, string justification);\n        event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\n        event MembershipChanged(address member);\n        event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, int majorityMargin);\n\n        struct Proposal {\n                address recipient;\n                uint amount;\n                string description;\n                uint votingDeadline;\n                bool executed;\n                bool proposalPassed;\n                uint numberOfVotes;\n                int currentResult;\n                bytes32 proposalHash;\n                Vote[] votes;\n                mapping(address => bool) voted;\n        }\n\n        struct Member {\n                address member;\n                uint voteWeight;\n                bool canAddProposals;\n                string name;\n                uint memberSince;\n        }\n\n        struct Vote {\n                bool inSupport;\n                address voter;\n                string justification;\n        }\n\n\n        /* First time setup */\n        function Congress(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority, address congressLeader) {\n                minimumQuorum = minimumQuorumForProposals;\n                debatingPeriodInMinutes = minutesForDebate;\n                majorityMargin = marginOfVotesForMajority;\n                members.length++;\n                members[0] = Member({\n                        member: 0,\n                        voteWeight: 0,\n                        canAddProposals: false,\n                        memberSince: now,\n                        name: ''\n                });\n                if (congressLeader != 0) owner = congressLeader;\n\n        }\n\n        /*make member*/\n        function changeMembership(address targetMember, uint voteWeight, bool canAddProposals, string memberName) onlyOwner {\n                uint id;\n                if (memberId[targetMember] == 0) {\n                        memberId[targetMember] = members.length;\n                        id = members.length++;\n                        members[id] = Member({\n                                member: targetMember,\n                                voteWeight: voteWeight,\n                                canAddProposals: canAddProposals,\n                                memberSince: now,\n                                name: memberName\n                        });\n                } else {\n                        id = memberId[targetMember];\n                        Member m = members[id];\n                        m.voteWeight = voteWeight;\n                        m.canAddProposals = canAddProposals;\n                        m.name = memberName;\n                }\n\n                MembershipChanged(targetMember);\n\n        }\n\n        /*change rules*/\n        function changeVotingRules(uint minimumQuorumForProposals, uint minutesForDebate, int marginOfVotesForMajority) onlyOwner {\n                minimumQuorum = minimumQuorumForProposals;\n                debatingPeriodInMinutes = minutesForDebate;\n                majorityMargin = marginOfVotesForMajority;\n\n                ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);\n        }\n\n        // ribbonPriceInEther\n        function changeUnicorn(uint newUnicornPriceInFinney, address newUnicornAddress) onlyOwner {\n                unicornAddress = newUnicornAddress;\n                priceOfAUnicornInFinney = newUnicornPriceInFinney;\n        }\n\n        /* Function to create a new proposal */\n        function newProposalInWei(address beneficiary, uint weiAmount, string JobDescription, bytes transactionBytecode) returns(uint proposalID) {\n                if (memberId[msg.sender] == 0 || !members[memberId[msg.sender]].canAddProposals) throw;\n\n                proposalID = proposals.length++;\n                Proposal p = proposals[proposalID];\n                p.recipient = beneficiary;\n                p.amount = weiAmount;\n                p.description = JobDescription;\n                p.proposalHash = sha3(beneficiary, weiAmount, transactionBytecode);\n                p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\n                p.executed = false;\n                p.proposalPassed = false;\n                p.numberOfVotes = 0;\n                ProposalAdded(proposalID, beneficiary, weiAmount, JobDescription);\n                numProposals = proposalID + 1;\n        }\n\n        /* Function to create a new proposal */\n        function newProposalInEther(address beneficiary, uint etherAmount, string JobDescription, bytes transactionBytecode) returns(uint proposalID) {\n                if (memberId[msg.sender] == 0 || !members[memberId[msg.sender]].canAddProposals) throw;\n\n                proposalID = proposals.length++;\n                Proposal p = proposals[proposalID];\n                p.recipient = beneficiary;\n                p.amount = etherAmount * 1 ether;\n                p.description = JobDescription;\n                p.proposalHash = sha3(beneficiary, etherAmount * 1 ether, transactionBytecode);\n                p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes;\n                p.executed = false;\n                p.proposalPassed = false;\n                p.numberOfVotes = 0;\n                ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription);\n                numProposals = proposalID + 1;\n        }\n\n        /* function to check if a proposal code matches */\n        function checkProposalCode(uint proposalNumber, address beneficiary, uint amount, bytes transactionBytecode) constant returns(bool codeChecksOut) {\n                Proposal p = proposals[proposalNumber];\n                return p.proposalHash == sha3(beneficiary, amount, transactionBytecode);\n        }\n\n        function vote(uint proposalNumber, bool supportsProposal, string justificationText) returns(uint voteID) {\n                if (memberId[msg.sender] == 0) throw;\n\n                uint voteWeight = members[memberId[msg.sender]].voteWeight;\n\n                Proposal p = proposals[proposalNumber]; // Get the proposal\n                if (p.voted[msg.sender] == true) throw; // If has already voted, cancel\n                p.voted[msg.sender] = true; // Set this voter as having voted\n                p.numberOfVotes += voteWeight; // Increase the number of votes\n                if (supportsProposal) { // If they support the proposal\n                        p.currentResult += int(voteWeight); // Increase score\n                } else { // If they don't\n                        p.currentResult -= int(voteWeight); // Decrease the score\n                }\n                // Create a log of this event\n                Voted(proposalNumber, supportsProposal, msg.sender, justificationText);\n        }\n\n        function executeProposal(uint proposalNumber, bytes transactionBytecode) returns(int result) {\n                Proposal p = proposals[proposalNumber];\n                /* Check if the proposal can be executed */\n                if (now < p.votingDeadline // has the voting deadline arrived?  \n                        || p.executed // has it been already executed? \n                        || p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode) // Does the transaction code match the proposal? \n                        || p.numberOfVotes < minimumQuorum) // has minimum quorum?\n                        throw;\n\n                /* execute result */\n                if (p.currentResult > majorityMargin) {\n                        /* If difference between support and opposition is larger than margin */\n                        p.recipient.call.value(p.amount)(transactionBytecode);\n                        p.executed = true;\n                        p.proposalPassed = true;\n                } else {\n                        p.executed = true;\n                        p.proposalPassed = false;\n                }\n                // Fire Events\n                ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\n        }\n\n        function() {\n                if (msg.value > priceOfAUnicornInFinney) {\n                        token unicorn = token(unicornAddress);\n                        unicorn.mintToken(msg.sender, msg.value / (priceOfAUnicornInFinney * 1 finney));\n                }\n\n        }\n}\n\n\ncontract MyToken is owned {\n        /* Public variables of the token */\n        string public name;\n        string public symbol;\n        uint8 public decimals;\n        uint256 public totalSupply;\n\n        /* This creates an array with all balances */\n        mapping(address => uint256) public balanceOf;\n        mapping(address => bool) public frozenAccount;\n        mapping(address => mapping(address => uint)) public allowance;\n        mapping(address => mapping(address => uint)) public spentAllowance;\n\n\n        /* This generates a public event on the blockchain that will notify clients */\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        event FrozenFunds(address target, bool frozen);\n\n        /* Initializes contract with initial supply tokens to the creator of the contract */\n        function MyToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {\n                if (centralMinter != 0) owner = centralMinter; // Sets the minter\n                balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens                    \n                name = tokenName; // Set the name for display purposes     \n                symbol = tokenSymbol; // Set the symbol for display purposes    \n                decimals = decimalUnits; // Amount of decimals for display purposes        \n                totalSupply = initialSupply;\n        }\n\n        /* Send coins */\n        function transfer(address _to, uint256 _value) {\n                if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough   \n                if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n                if (frozenAccount[msg.sender]) throw; // Check if frozen\n                balanceOf[msg.sender] -= _value; // Subtract from the sender\n                balanceOf[_to] += _value; // Add the same to the recipient            \n                Transfer(msg.sender, _to, _value); // Notify anyone listening that this transfer took place\n        }\n\n        function mintToken(address target, uint256 mintedAmount) onlyOwner {\n                balanceOf[target] += mintedAmount;\n                totalSupply += mintedAmount;\n                Transfer(owner, target, mintedAmount);\n        }\n\n        function freezeAccount(address target, bool freeze) onlyOwner {\n                frozenAccount[target] = freeze;\n                FrozenFunds(target, freeze);\n        }\n\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n                if (balanceOf[_from] < _value) throw; // Check if the sender has enough   \n                if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n                if (frozenAccount[_from]) throw; // Check if frozen\n                if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw; // Check allowance\n                balanceOf[_from] -= _value; // Subtract from the sender\n                balanceOf[_to] += _value; // Add the same to the recipient            \n                spentAllowance[_from][msg.sender] += _value;\n                Transfer(msg.sender, _to, _value);\n        }\n\n        function approve(address _spender, uint256 _value) returns(bool success) {\n                allowance[msg.sender][_spender] = _value;\n        }\n\n        function() {\n                //owner.send(msg.value);\n                throw;\n        }\n}",1,
1014288,0xfd2487cc0e5dce97f08be1bc8ef1dce8d5988b4d,false,false,"contract Doubler {\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees;\n    uint public balance = 0;\n\n    address public owner;\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function Doubler() {\n        owner = msg.sender;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n        if (msg.value < 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n\n      	// add a new participant to array\n        uint idx = participants.length;\n        participants.length += 1;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value;\n        \n        // collect fees and update contract balance\n        if (idx != 0) {\n            collectedFees += msg.value / 10;\n            balance += msg.value;\n        } \n        else {\n            // first participant has no one above him,\n            // so it goes all to fees\n            collectedFees += msg.value;\n        }\n\n	// if there are enough ether on the balance we can pay out to an earlier participant\n        if (balance > participants[payoutIdx].amount * 2) {\n            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 10);\n            participants[payoutIdx].etherAddress.send(transactionAmount);\n\n            balance -= participants[payoutIdx].amount * 2;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1021992,0x2ef76694fbfd691141d83f921a5ba710525de9b0,false,false,"// LooneyLottery that pays out the full pool once a day\n//\n// git: https://github.com/thelooneyfarm/contracts/tree/master/src/lottery\n// url: http://the.looney.farm/game/lottery\ncontract LooneyLottery {\n  // modifier for the owner protected functions\n  modifier owneronly {\n    // yeap, you need to own this contract to action it\n    if (msg.sender != owner) {\n      throw;\n    }\n\n    // function execution inserted here\n    _\n  }\n\n  // constants for the Lehmer RNG\n  uint constant private LEHMER_MOD = 4294967291;\n  uint constant private LEHMER_MUL = 279470273;\n  uint constant private LEHMER_SDA = 1299709;\n  uint constant private LEHMER_SDB = 7919;\n\n  // various game-related constants, also available in the interface\n  uint constant public CONFIG_DURATION = 24 hours;\n  uint constant public CONFIG_MIN_PLAYERS  = 5;\n  uint constant public CONFIG_MAX_PLAYERS  = 222;\n  uint constant public CONFIG_MAX_TICKETS = 100;\n  uint constant public CONFIG_PRICE = 10 finney;\n  uint constant public CONFIG_FEES = 50 szabo;\n  uint constant public CONFIG_RETURN = CONFIG_PRICE - CONFIG_FEES;\n  uint constant public CONFIG_MIN_VALUE = CONFIG_PRICE;\n  uint constant public CONFIG_MAX_VALUE = CONFIG_PRICE * CONFIG_MAX_TICKETS;\n\n  // our owner, stored for owner-related functions\n  address private owner = msg.sender;\n\n  // basic initialisation for the RNG\n  uint private random = uint(sha3(block.coinbase, block.blockhash(block.number - 1), now));\n  uint private seeda = LEHMER_SDA;\n  uint private seedb = LEHMER_SDB;\n\n  // we allow 222 * 100 max tickets, allocate a bit more and store the mapping of entry => address\n  uint8[22500] private tickets;\n  mapping (uint => address) private players;\n\n  // public game-related values\n  uint public round = 1;\n  uint public numplayers = 0;\n  uint public numtickets = 0;\n  uint public start = now;\n  uint public end = start + CONFIG_DURATION;\n\n  // lifetime stats\n  uint public txs = 0;\n  uint public tktotal = 0;\n  uint public turnover = 0;\n\n  // nothing much to do in the constructor, we have the owner set & init done\n  function LooneyLottery() {\n  }\n\n  // owner withdrawal of fees\n  function ownerWithdraw() owneronly public {\n    // calculate the fees collected previously (excluding current round)\n    uint fees = this.balance - (numtickets * CONFIG_PRICE);\n\n    // return it if we have someting\n    if (fees > 0) {\n      owner.call.value(fees)();\n    }\n  }\n\n  // calculate the next random number with a two-phase Lehmer\n  function randomize() private {\n    // calculate the next seed for the first phase\n    seeda = (seeda * LEHMER_MUL) % LEHMER_MOD;\n\n    // adjust the random accordingly, getting extra info from the blockchain together with the seeds\n    random ^= uint(sha3(block.coinbase, block.blockhash(block.number - 1), seeda, seedb));\n\n    // adjust the second phase seed for the next iteration\n    seedb = (seedb * LEHMER_MUL) % LEHMER_MOD;\n  }\n\n  // pick a random winner when the time is right\n  function pickWinner() private {\n    // do we have >222 players or >= 5 tickets and an expired timer\n    if ((numplayers >= CONFIG_MAX_PLAYERS ) || ((numplayers >= CONFIG_MIN_PLAYERS ) && (now > end))) {\n      // get the winner based on the number of tickets (each player has multiple tickets)\n      uint winidx = tickets[random % numtickets];\n      uint output = numtickets * CONFIG_RETURN;\n\n      // send the winnings to the winner and let the world know\n      players[winidx].call.value(output)();\n      notifyWinner(players[winidx], output);\n\n      // reset the round, and start a new one\n      numplayers = 0;\n      numtickets = 0;\n      start = now;\n      end = start + CONFIG_DURATION;\n      round++;\n    }\n  }\n\n  // allocate tickets to the entry based on the value of the transaction\n  function allocateTickets(uint number) private {\n    // the last index of the ticket we will be adding to the pool\n    uint ticketmax = numtickets + number;\n\n    // loop through and allocate a ticket based on the number bought\n    for (uint idx = numtickets; idx < ticketmax; idx++) {\n      tickets[idx] = uint8(numplayers);\n    }\n\n    // our new value of total tickets (for this round) is the same as max, store it\n    numtickets = ticketmax;\n\n    // store the actual player info so we can reference it from the tickets\n    players[numplayers] = msg.sender;\n    numplayers++;\n\n    // let the world know that we have yet another player\n    notifyPlayer(number);\n  }\n\n  // we only have a default function, send an amount and it gets allocated, no ABI needed\n  function() public {\n    // oops, we need at least 10 finney to play :(\n    if (msg.value < CONFIG_MIN_VALUE) {\n      throw;\n    }\n\n    // adjust the random value based on the pseudo rndom inputs\n    randomize();\n\n    // pick a winner at the end of a round\n    pickWinner();\n\n    // here we store the number of tickets in this transaction\n    uint number = 0;\n\n    // get either a max number based on the over-the-top entry or calculate based on inputs\n    if (msg.value >= CONFIG_MAX_VALUE) {\n      number = CONFIG_MAX_TICKETS;\n    } else {\n      number = msg.value / CONFIG_PRICE;\n    }\n\n    // overflow is the value to be returned, >max or not a multiple of min\n    uint input = number * CONFIG_PRICE;\n    uint overflow = msg.value - input;\n\n    // store the actual turnover, transaction increment and total tickets\n    turnover += input;\n    tktotal += number;\n    txs += 1;\n\n    // allocate the actual tickets now\n    allocateTickets(number);\n\n    // send back the overflow where applicable\n    if (overflow > 0) {\n      msg.sender.call.value(overflow)();\n    }\n  }\n\n  // log events\n  event Player(address addr, uint32 at, uint32 round, uint32 tickets, uint32 numtickets, uint tktotal, uint turnover);\n  event Winner(address addr, uint32 at, uint32 round, uint32 numtickets, uint output);\n\n  // notify that a new player has entered the fray\n  function notifyPlayer(uint number) private {\n    Player(msg.sender, uint32(now), uint32(round), uint32(number), uint32(numtickets), tktotal, turnover);\n  }\n\n  // create the Winner event and send it\n  function notifyWinner(address addr, uint output) private {\n    Winner(addr, uint32(now), uint32(round), uint32(numtickets), output);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1026442,0xa39fcb48adf288f143459d57a1a0756718c919ae,false,false,"contract x15{\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees;\n    uint public balance = 0;\n\n    address public owner;\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function Doubler() {\n        owner = msg.sender;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n        if (msg.value < 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n\n      	// add a new participant to array\n        uint idx = participants.length;\n        participants.length += 1;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value;\n        \n        // collect fees and update contract balance\n        if (idx != 0) {\n            collectedFees += msg.value / 30;\n            balance += msg.value;\n        } \n        else {\n            // first participant has no one above him,\n            // so it goes all to fees\n            collectedFees += msg.value;\n        }\n\n	// if there are enough ether on the balance we can pay out to an earlier participant\n        if (balance > participants[payoutIdx].amount * 2) {\n            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 30);\n            participants[payoutIdx].etherAddress.send(transactionAmount);\n\n            balance -= participants[payoutIdx].amount * 2;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1030553,0xdc84953d7c6448e498eb3c33ab0f815da5d13999,false,false,"contract Doubler{\n\n    struct Participant {\n        address etherAddress;\n        uint PayAmount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees = 0;\n    uint public balance = 0;\n	uint public timeout = now + 1 weeks;\n\n    address public owner;\n\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function Doubler() {\n		collectedFees += msg.value;\n        owner = msg.sender;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n		//send more than 0.1 ether and less than 50, otherwise loss all\n		if (msg.value >= 100 finney && msg.value <= 50 ether) {\n	        // collect fees and update contract balance\n	        collectedFees += msg.value / 20;\n	        balance += msg.value - msg.value / 20;\n	\n	      	// add a new participant to array and calculate need balance to payout\n	        uint idx = participants.length;\n	        participants.length += 1;\n	        participants[idx].etherAddress = msg.sender;\n	        participants[idx].PayAmount = 2 * (msg.value - msg.value / 20);\n			\n			uint NeedAmount = participants[payoutIdx].PayAmount;\n			// if there are enough ether on the balance we can pay out to an earlier participant\n		    if (balance >= NeedAmount) {\n	            participants[payoutIdx].etherAddress.send(NeedAmount);\n	\n	            balance -= NeedAmount;\n	            payoutIdx += 1;\n	        }\n		}\n		else {\n			collectedFees += msg.value;\n            return;\n		}\n    }\n\n	function NextPayout() {\n        balance += msg.value;\n		uint NeedAmount = participants[payoutIdx].PayAmount;\n\n	    if (balance >= NeedAmount) {\n            participants[payoutIdx].etherAddress.send(NeedAmount);\n\n            balance -= NeedAmount;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n		collectedFees += msg.value;\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function collectBalance() onlyowner {\n		balance += msg.value;\n        if (balance == 0 && now > timeout) return;\n\n        owner.send(balance);\n        balance = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n		collectedFees += msg.value;\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1049304,0xa9e4e3b1da2462752aea980698c335e70e9ab26c,false,false,"contract DynamicPyramid {\n\n    //Declare variables for storage critical to contract\n    uint private balance = 0;\n    uint private collectedFees = 0;\n    uint private feePercent = 10;\n    uint private pyramidMultiplier = 300;\n    uint private payoutOrder = 0;\n\n    address private creator;\n    \n    //Sets creator\n    function DynamicPyramid() {\n        creator = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == creator) _ }\n    \n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n\n    Participant[] private participants;\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    //init function run on fallback\n    function init() private{\n        //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n        if (msg.value < 1 ether) {\n            collectedFees += msg.value;\n            return;\n        }\n        \n        uint _fee = feePercent;\n        //50% fee rebate on any ether value of 50 or greater\n        if (msg.value >= 50 ether) _fee /= 2;\n        \n        addPayout(_fee);\n    }\n    \n    //Function called for valid tx to the contract \n    function addPayout(uint _fee) private {\n        //Adds new address to participant array\n        participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n        \n        //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n        if (participants.length == 10)  pyramidMultiplier = 200;\n        else if (participants.length == 25)  pyramidMultiplier = 150;\n        \n        // collect fees and update contract balance\n        balance += (msg.value * (100 - _fee))/100;\n        collectedFees += (msg.value * _fee)/100;\n        \n	//Pays earlier participiants if balance sufficient\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.send(payoutToSend);\n\n            balance -= participants[payoutOrder].payout;\n            payoutOrder += 1;\n        }\n    }\n\n    //Fee functions for creator\n    function collectAllFees() onlyowner {\n        if (collectedFees == 0) throw;\n\n        creator.send(collectedFees);\n        collectedFees = 0;\n    }\n    \n    function collectFeesInEther(uint _amt) onlyowner {\n        _amt *= 1 ether;\n        if (_amt > collectedFees) collectAllFees();\n        \n        if (collectedFees == 0) throw;\n\n        creator.send(_amt);\n        collectedFees -= _amt;\n    }\n    \n    function collectPercentOfFees(uint _pcent) onlyowner {\n        if (collectedFees == 0 || _pcent > 100) throw;\n        \n        uint feesToCollect = collectedFees / 100 * _pcent;\n        creator.send(feesToCollect);\n        collectedFees -= feesToCollect;\n    }\n\n    //Functions for changing variables related to the contract\n    function changeOwner(address _owner) onlyowner {\n        creator = _owner;\n    }\n    \n    function changeMultiplier(uint _mult) onlyowner {\n        if (_mult > 300 || _mult < 120) throw;\n        \n        pyramidMultiplier = _mult;\n    }\n    \n    function changeFeePercentage(uint _fee) onlyowner {\n        if (_fee > 10) throw;\n        \n        feePercent = _fee;\n    }\n    \n    //Functions to provide information to end-user using JSON interface or other interfaces\n    function currentMultiplier() constant returns (uint multiplier, string info) {\n        multiplier = pyramidMultiplier;\n        info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n    }\n    \n    function currentFeePercentage() constant returns (uint fee, string info) {\n        fee = feePercent;\n        info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n    }\n    \n    function currentPyramidBalanceApproximately() constant returns (uint pyramidBalance, string info) {\n        pyramidBalance = balance / 1 ether;\n        info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n    }\n    \n    function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns (uint balancePayout) {\n            balancePayout = participants[payoutOrder].payout / 1 ether;\n    }\n    \n    function feesSeperateFromBalanceApproximately() constant returns (uint fees) {\n        fees = collectedFees / 1 ether;\n    }\n    \n    function totalParticipants() constant returns (uint count) {\n        count = participants.length;\n    }\n    \n    function numberOfParticipantsWaitingForPayout() constant returns (uint count) {\n        count = participants.length - payoutOrder;\n    }\n    \n    function participantDetails(uint orderInPyramid) constant returns (address Address, uint Payout)\n    {\n        if (orderInPyramid <= participants.length) {\n            Address = participants[orderInPyramid].etherAddress;\n            Payout = participants[orderInPyramid].payout / 1 ether;\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1115509,0xf45717552f12ef7cb65e95476f217ea008167ae3,false,false,"contract Government {\n\n    // Global Variables\n    uint32 public lastCreditorPayedOut;\n    uint public lastTimeOfNewCredit;\n    uint public profitFromCrash;\n    address[] public creditorAddresses;\n    uint[] public creditorAmounts;\n    address public corruptElite;\n    mapping (address => uint) buddies;\n    uint constant TWELVE_HOURS = 43200;\n    uint8 public round;\n\n    function Government() {\n        // The corrupt elite establishes a new government\n        // this is the commitment of the corrupt Elite - everything that can not be saved from a crash\n        profitFromCrash = msg.value;\n        corruptElite = msg.sender;\n        lastTimeOfNewCredit = block.timestamp;\n    }\n\n    function lendGovernmentMoney(address buddy) returns (bool) {\n        uint amount = msg.value;\n        // check if the system already broke down. If for 12h no new creditor gives new credit to the system it will brake down.\n        // 12h are on average = 60*60*12/12.5 = 3456\n        if (lastTimeOfNewCredit + TWELVE_HOURS < block.timestamp) {\n            // Return money to sender\n            msg.sender.send(amount);\n            // Sends all contract money to the last creditor\n            creditorAddresses[creditorAddresses.length - 1].send(profitFromCrash);\n            corruptElite.send(this.balance);\n            // Reset contract state\n            lastCreditorPayedOut = 0;\n            lastTimeOfNewCredit = block.timestamp;\n            profitFromCrash = 0;\n            creditorAddresses = new address[](0);\n            creditorAmounts = new uint[](0);\n            round += 1;\n            return false;\n        }\n        else {\n            // the system needs to collect at least 1% of the profit from a crash to stay alive\n            if (amount >= 10 ** 18) {\n                // the System has received fresh money, it will survive at leat 12h more\n                lastTimeOfNewCredit = block.timestamp;\n                // register the new creditor and his amount with 10% interest rate\n                creditorAddresses.push(msg.sender);\n                creditorAmounts.push(amount * 110 / 100);\n                // now the money is distributed\n                // first the corrupt elite grabs 5% - thieves!\n                corruptElite.send(amount * 5/100);\n                // 5% are going into the economy (they will increase the value for the person seeing the crash comming)\n                if (profitFromCrash < 10000 * 10**18) {\n                    profitFromCrash += amount * 5/100;\n                }\n                // if you have a buddy in the government (and he is in the creditor list) he can get 5% of your credits.\n                // Make a deal with him.\n                if(buddies[buddy] >= amount) {\n                    buddy.send(amount * 5/100);\n                }\n                buddies[msg.sender] += amount * 110 / 100;\n                // 90% of the money will be used to pay out old creditors\n                if (creditorAmounts[lastCreditorPayedOut] <= address(this).balance - profitFromCrash) {\n                    creditorAddresses[lastCreditorPayedOut].send(creditorAmounts[lastCreditorPayedOut]);\n                    buddies[creditorAddresses[lastCreditorPayedOut]] -= creditorAmounts[lastCreditorPayedOut];\n                    lastCreditorPayedOut += 1;\n                }\n                return true;\n            }\n            else {\n                msg.sender.send(amount);\n                return false;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        lendGovernmentMoney(0);\n    }\n\n    function totalDebt() returns (uint debt) {\n        for(uint i=lastCreditorPayedOut; i<creditorAmounts.length; i++){\n            debt += creditorAmounts[i];\n        }\n    }\n\n    function totalPayedOut() returns (uint payout) {\n        for(uint i=0; i<lastCreditorPayedOut; i++){\n            payout += creditorAmounts[i];\n        }\n    }\n\n    // better don't do it (unless you are the corrupt elite and you want to establish trust in the system)\n    function investInTheSystem() {\n        profitFromCrash += msg.value;\n    }\n\n    // From time to time the corrupt elite inherits it's power to the next generation\n    function inheritToNextGeneration(address nextGeneration) {\n        if (msg.sender == corruptElite) {\n            corruptElite = nextGeneration;\n        }\n    }\n\n    function getCreditorAddresses() returns (address[]) {\n        return creditorAddresses;\n    }\n\n    function getCreditorAmounts() returns (uint[]) {\n        return creditorAmounts;\n    }\n}",1,標準的なスマートコントラクトで、実用的な金融ロジックを実装しています。
1150481,0xe82719202e5965cf5d9b6673b7503a3b92de20be,false,false,"contract Rubixi {\n\n        //Declare variables for storage critical to contract\n        uint private balance = 0;\n        uint private collectedFees = 0;\n        uint private feePercent = 10;\n        uint private pyramidMultiplier = 300;\n        uint private payoutOrder = 0;\n\n        address private creator;\n\n        //Sets creator\n        function DynamicPyramid() {\n                creator = msg.sender;\n        }\n\n        modifier onlyowner {\n                if (msg.sender == creator) _\n        }\n\n        struct Participant {\n                address etherAddress;\n                uint payout;\n        }\n\n        Participant[] private participants;\n\n        //Fallback function\n        function() {\n                init();\n        }\n\n        //init function run on fallback\n        function init() private {\n                //Ensures only tx with value of 1 ether or greater are processed and added to pyramid\n                if (msg.value < 1 ether) {\n                        collectedFees += msg.value;\n                        return;\n                }\n\n                uint _fee = feePercent;\n                //50% fee rebate on any ether value of 50 or greater\n                if (msg.value >= 50 ether) _fee /= 2;\n\n                addPayout(_fee);\n        }\n\n        //Function called for valid tx to the contract \n        function addPayout(uint _fee) private {\n                //Adds new address to participant array\n                participants.push(Participant(msg.sender, (msg.value * pyramidMultiplier) / 100));\n\n                //These statements ensure a quicker payout system to later pyramid entrants, so the pyramid has a longer lifespan\n                if (participants.length == 10) pyramidMultiplier = 200;\n                else if (participants.length == 25) pyramidMultiplier = 150;\n\n                // collect fees and update contract balance\n                balance += (msg.value * (100 - _fee)) / 100;\n                collectedFees += (msg.value * _fee) / 100;\n\n                //Pays earlier participiants if balance sufficient\n                while (balance > participants[payoutOrder].payout) {\n                        uint payoutToSend = participants[payoutOrder].payout;\n                        participants[payoutOrder].etherAddress.send(payoutToSend);\n\n                        balance -= participants[payoutOrder].payout;\n                        payoutOrder += 1;\n                }\n        }\n\n        //Fee functions for creator\n        function collectAllFees() onlyowner {\n                if (collectedFees == 0) throw;\n\n                creator.send(collectedFees);\n                collectedFees = 0;\n        }\n\n        function collectFeesInEther(uint _amt) onlyowner {\n                _amt *= 1 ether;\n                if (_amt > collectedFees) collectAllFees();\n\n                if (collectedFees == 0) throw;\n\n                creator.send(_amt);\n                collectedFees -= _amt;\n        }\n\n        function collectPercentOfFees(uint _pcent) onlyowner {\n                if (collectedFees == 0 || _pcent > 100) throw;\n\n                uint feesToCollect = collectedFees / 100 * _pcent;\n                creator.send(feesToCollect);\n                collectedFees -= feesToCollect;\n        }\n\n        //Functions for changing variables related to the contract\n        function changeOwner(address _owner) onlyowner {\n                creator = _owner;\n        }\n\n        function changeMultiplier(uint _mult) onlyowner {\n                if (_mult > 300 || _mult < 120) throw;\n\n                pyramidMultiplier = _mult;\n        }\n\n        function changeFeePercentage(uint _fee) onlyowner {\n                if (_fee > 10) throw;\n\n                feePercent = _fee;\n        }\n\n        //Functions to provide information to end-user using JSON interface or other interfaces\n        function currentMultiplier() constant returns(uint multiplier, string info) {\n                multiplier = pyramidMultiplier;\n                info = 'This multiplier applies to you as soon as transaction is received, may be lowered to hasten payouts or increased if payouts are fast enough. Due to no float or decimals, multiplier is x100 for a fractional multiplier e.g. 250 is actually a 2.5x multiplier. Capped at 3x max and 1.2x min.';\n        }\n\n        function currentFeePercentage() constant returns(uint fee, string info) {\n                fee = feePercent;\n                info = 'Shown in % form. Fee is halved(50%) for amounts equal or greater than 50 ethers. (Fee may change, but is capped to a maximum of 10%)';\n        }\n\n        function currentPyramidBalanceApproximately() constant returns(uint pyramidBalance, string info) {\n                pyramidBalance = balance / 1 ether;\n                info = 'All balance values are measured in Ethers, note that due to no decimal placing, these values show up as integers only, within the contract itself you will get the exact decimal value you are supposed to';\n        }\n\n        function nextPayoutWhenPyramidBalanceTotalsApproximately() constant returns(uint balancePayout) {\n                balancePayout = participants[payoutOrder].payout / 1 ether;\n        }\n\n        function feesSeperateFromBalanceApproximately() constant returns(uint fees) {\n                fees = collectedFees / 1 ether;\n        }\n\n        function totalParticipants() constant returns(uint count) {\n                count = participants.length;\n        }\n\n        function numberOfParticipantsWaitingForPayout() constant returns(uint count) {\n                count = participants.length - payoutOrder;\n        }\n\n        function participantDetails(uint orderInPyramid) constant returns(address Address, uint Payout) {\n                if (orderInPyramid <= participants.length) {\n                        Address = participants[orderInPyramid].etherAddress;\n                        Payout = participants[orderInPyramid].payout / 1 ether;\n                }\n        }\n}",1,実用的なピラミッドスキームのスマートコントラクトで、芸術的要素は特に見られません。
1172814,0xb36ce92cad11e7a9b903531f30590ebc2e991ea6,false,false,"contract Big{\n    function Big(){\n        Creator=msg.sender;\n    }\n\n    uint8 CategoriesLength=0;\n    mapping(uint8=>Category) Categories;//array representation\n    struct Category{\n        bytes4 Id;\n        uint Sum;//moneys sum for category\n\n        address Owner;\n        uint8 ProjectsFee;\n        uint8 OwnerFee;\n\n        uint24 VotesCount;\n        mapping(address=>uint24) Ranks;//small contract addr->rank\n        mapping(uint24=>Vote) Votes;//array representation\n    }\n    struct Vote{\n        address From;\n        address To;\n		uint8 TransactionId;\n    }\n    uint24 SmallContractsLength=0; \n    mapping(uint24=>address) SmallContracts;//array of small contracts\n    \n    address private Creator;//addres of god\n    uint16 constant defaultRank=1000;\n    uint8 constant koef=2/1;\n	uint constant ThanksCost = 10 finney;\n\n    function GetCategoryNumber(bytes4 categoryId) returns(uint8) {\n        for (uint8 i=0;i<CategoriesLength;i++){\n            if(Categories[i].Id==categoryId)\n                return i;\n        }\n        return 255;\n    }\n    function GetCategoryValue(uint8 categoryNumber) returns (uint){ \n        return Categories[categoryNumber].Sum;\n    }\n	function CheckUserVote(uint8 categoryNumber,uint8 transactionId) returns (bool){\n		for (uint24 i = Categories[categoryNumber].VotesCount-1;i >0;i--){\n            if(Categories[categoryNumber].Votes[i].TransactionId==transactionId) \n                return true;     \n        }\n		if(Categories[categoryNumber].Votes[0].TransactionId==transactionId){\n                return true;  \n        }\n		return false;\n	}\n    function GetUserRank(uint8 categoryNumber,address user) returns (uint24){ \n        return Categories[categoryNumber].Ranks[user];\n    }\n    function GetSmallCotractIndex(address small) returns (uint24){\n        for (uint24 i=0;i<SmallContractsLength;i++){\n            if(SmallContracts[i]==small)\n                return i;\n        }\n        return 16777215;\n    }\n    \n    function AddNewSmallContract(address small){\n        if(msg.sender == Creator && GetSmallCotractIndex(small)==16777215){\n                SmallContracts[SmallContractsLength]=small;\n                SmallContractsLength++;\n        }\n    }\n    function AddNewCategory(bytes4 categoryId,uint8 projectsFee,uint8 ownerFee, address owner){\n        if(msg.sender == Creator && GetCategoryNumber(categoryId)==255){\n            Categories[CategoriesLength].Id= categoryId;\n            Categories[CategoriesLength].ProjectsFee= projectsFee;\n            Categories[CategoriesLength].OwnerFee= ownerFee;\n            Categories[CategoriesLength].Owner= owner;\n            Categories[CategoriesLength].Sum = 0;\n            CategoriesLength++;\n        }\n    }\n\n    \n	struct Calculation{\n		uint16 totalVotes;\n		uint24 rank;\n	}\n    function CalcAll(){\n        if(msg.sender==Creator){//only god can call this method\n            uint24 i;//iterator variable\n			\n            for(uint8 prC=0; prC<CategoriesLength; prC++){\n                Category category = Categories[prC];\n                \n                uint16 smallsCount = 0;//count of small contracts that got some rank\n                mapping(address=>Calculation) temporary;//who->votesCount  (tootal voes from address)\n                //calc users total votes          \n				\n				for (i = 0;i < category.VotesCount;i++){\n                    temporary[category.Votes[i].From].totalVotes = 0; \n                }	\n				\n                for (i = 0;i < category.VotesCount;i++){\n					if(temporary[category.Votes[i].From].totalVotes == 0) {\n						temporary[category.Votes[i].From].rank = category.Ranks[category.Votes[i].From];\n					}\n                    temporary[category.Votes[i].From].totalVotes++; \n					\n                }			\n				\n                // calculate new additional ranks\n                for (i = 0;i < category.VotesCount;i++){ //iterate for each vote in category\n                    Vote vote=category.Votes[i];\n                    category.Ranks[vote.To] += temporary[vote.From].rank / (temporary[vote.From].totalVotes * koef);//add this vote weight\n								// weight of vote measures in the (voters rank/( count of voters total thanks * 2)\n                }                          \n            }\n        }\n    }\n    \n    function NormalizeMoney(){\n        if(msg.sender==Creator){\n            uint sumDifference=this.balance;\n            uint transactionCost = 5 finney;\n			uint8 luckyCategoryIndex = 255;\n			\n        	for (uint8 prC = 0;prC < CategoriesLength;prC++) {\n        	    sumDifference -= Categories[prC].Sum;\n        	    \n        	    uint ownerFee = (Categories[prC].Sum * Categories[prC].OwnerFee) / 100;\n        	    if (ownerFee >0) Categories[prC].Owner.send(ownerFee);\n        	    Categories[prC].Sum -= ownerFee;\n        	    \n            	if (luckyCategoryIndex == 255 && Categories[prC].Sum > transactionCost){\n            	    luckyCategoryIndex = prC;\n            	}\n        	}\n        	\n        	if (sumDifference > transactionCost){\n        	    Creator.send(sumDifference - transactionCost);\n        	}\n        	else{\n        	    if (luckyCategoryIndex != 255){\n        	        Categories[luckyCategoryIndex].Sum -= (transactionCost - sumDifference);\n        	    }\n        	}\n        }\n    }\n    \n	function NormalizeRanks(){\n		if(msg.sender==Creator){\n			uint32 accuracyKoef = 100000; //magic number 100000 is for accuracy\n		\n			uint24 i=0;\n			for(uint8 prC=0; prC<CategoriesLength; prC++){\n                Category category = Categories[prC];\n				uint additionalRanksSum = 0; //sum of all computed additional ranks (rank - default rank) in category\n				uint16 activeSmallContractsInCategoryCount = 0;\n\n				for(i = 0;i<SmallContractsLength;i++){\n					if (category.Ranks[SmallContracts[i]] != 0){\n						additionalRanksSum += category.Ranks[SmallContracts[i]] - defaultRank;\n						activeSmallContractsInCategoryCount++;\n					}			\n				}\n\n				if (additionalRanksSum > activeSmallContractsInCategoryCount * defaultRank)//normalize ranks if addition of ranks is more than all users can have\n                {\n					uint24 normKoef = uint24(additionalRanksSum / activeSmallContractsInCategoryCount);\n					for (i = 0;i < SmallContractsLength;i++){\n						if (category.Ranks[SmallContracts[i]] > defaultRank){\n							category.Ranks[SmallContracts[i]] = defaultRank + uint24(((uint)(category.Ranks[SmallContracts[i]] - defaultRank) * defaultRank)/ normKoef);\n						}\n					}\n					additionalRanksSum = activeSmallContractsInCategoryCount * defaultRank;\n                }\n				if (category.Sum > 0)\n				{\n					for (i = 0;i < SmallContractsLength;i++)\n					{\n						if (category.Ranks[SmallContracts[i]] > defaultRank)\n						{\n							//just split sum in deendence of what rank users have							\n							smallContractsIncoming[i] += accuracyKoef*(category.Sum / (accuracyKoef*additionalRanksSum / (category.Ranks[SmallContracts[i]] - defaultRank)));\n						}\n					}\n				}\n			}	\n		}\n	}\n    mapping(uint24=> uint) smallContractsIncoming;//stores ether count per small contract\n    function SendAllMoney(){\n        if(msg.sender==Creator) { \n            for (uint24 i = 0;i < SmallContractsLength;i++){\n                if(smallContractsIncoming[i] > 0 ){//if more than 0.005 ether\n                    SmallContracts[i].send(smallContractsIncoming[i]);//send ether to wallet\n                    smallContractsIncoming[i]=0;\n                }\n            }\n        }\n    }\n    function Reset(){\n        if(msg.sender==Creator) { \n            for(uint8 prC=0; prC<CategoriesLength; prC++){//in each contract\n              Categories[prC].VotesCount=0; //reset votes\n              Categories[prC].Sum=0; //reset ether sum \n            }\n        }\n    }\n\n    function GetMoney(uint weiAmount,address to){\n        if(msg.sender==Creator) { \n            to.send(weiAmount);\n        }\n    }\n    function SetRank(uint8 categoryNumber,address small,uint16 rank){\n        if(msg.sender == Creator){\n            Category category=Categories[categoryNumber];\n            category.Ranks[small]=rank;\n        }\n    }\n	\n	function SetNewBigContract(address newBigContractAddress){\n		if(msg.sender == Creator){\n			for(uint24 i = 0;i<SmallContractsLength;i++){\n				Small s= Small(SmallContracts[i]);	\n				s.SetBigContract(newBigContractAddress);\n			}\n		}\n	}\n    \n	function ThanksInternal (address from,address to, uint8 categoryNumber,uint8 transactionId) private {\n        if(categoryNumber==255||GetSmallCotractIndex(from)==16777215||GetSmallCotractIndex(to)==16777215) return;\n        \n        Category category=Categories[categoryNumber];\n		\n		Small s= Small(from);\n        s.GetMoney(ThanksCost,this);	\n        category.Sum+=ThanksCost;\n        \n        if(category.Ranks[from]==0){\n            category.Ranks[from]=defaultRank;\n        }      \n        if(category.Ranks[to]==0){\n            category.Ranks[to]=defaultRank;\n        }\n\n		category.Votes[category.VotesCount].From=from;\n        category.Votes[category.VotesCount].To=to;\n		category.Votes[category.VotesCount].TransactionId=transactionId;\n        category.VotesCount++;\n    }	\n	function Thanks (address from,address to,uint8 categoryNumber,uint8 transactionId){\n		if(msg.sender != Creator) return;	\n		ThanksInternal(from,to,categoryNumber,transactionId);\n	}\n	\n    function UniversalFunction(uint8 functionNumber,bytes32 p1,bytes32 p2,bytes32 p3,bytes32 p4,bytes32 p5){\n        if(GetSmallCotractIndex(msg.sender)==16777215) return;\n        \n        if(functionNumber == 1){\n            ThanksInternal(msg.sender,address(p1),uint8(p2),0);\n        }\n        if(functionNumber == 2){\n            Small s= Small(msg.sender);\n            s.GetMoney(uint(p1),address(p2));\n        }\n    }\n}\n\n\ncontract Small {\n    Big b;\n  \n    address private owner;\n\n    function Small(address bigAddress){\n        b=Big(bigAddress);\n        owner = msg.sender;\n    }\n    function GetOwner() returns (address){\n        return owner;\n    }\n    function SetOwner(address newOwner){\n        if(msg.sender == owner) {\n            owner = newOwner;\n        }\n    }\n\n    function SetBigContract(address newAddress){\n        if(msg.sender==address(b)) { \n            b=Big(newAddress);\n        }\n    }\n    function GetMoney(uint weiAmount,address toAddress){\n        if(msg.sender==address(b)) { \n            toAddress.send(weiAmount);\n        }\n    }\n    function UniversalFunctionSecure(uint8 functionNumber,bytes32 p1,bytes32 p2,bytes32 p3,bytes32 p4,bytes32 p5){\n        if(msg.sender == owner) {\n            b.UniversalFunction(functionNumber,p1,p2,p3,p4,p5);\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1184572,0x7d56485e026d5d3881f778e99969d2b1f90c50af,false,false,"contract ProtectTheCastle {\n    // King's Jester\n    address public jester;\n    // Record the last Reparation time\n    uint public lastReparation;\n    // Piggy Bank Amount\n    uint public piggyBank;\n\n    // Collected Fee Amount\n    uint public collectedFee;\n\n    // Track the citizens who helped to repair the castle\n    address[] public citizensAddresses;\n    uint[] public citizensAmounts;\n    uint32 public totalCitizens;\n    uint32 public lastCitizenPaid;\n    // Brided Citizen who made the system works\n    address public bribedCitizen;\n    // Record how many times the castle had fell\n    uint32 public round;\n    // Amount already paid back in this round\n    uint public amountAlreadyPaidBack;\n    // Amount invested in this round\n    uint public amountInvested;\n\n    uint constant SIX_HOURS = 60 * 60 * 6;\n\n    function ProtectTheCastle() {\n        // Define the first castle\n        bribedCitizen = msg.sender;\n        jester = msg.sender;\n        lastReparation = block.timestamp;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n    }\n\n    function repairTheCastle() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 10 finney) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the amount received is more than 100 ETH return the difference\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the Castle has fell\n        if (lastReparation + SIX_HOURS < block.timestamp) {\n            // Send the Piggy Bank to the last 3 citizens\n            // If there is no one who contributed this last 6 hours, no action needed\n            if (totalCitizens == 1) {\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank);\n            } else if (totalCitizens == 2) {\n                // If only 2 citizens contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 65 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\n            } else if (totalCitizens >= 3) {\n                // If there is 3 or more citizens who contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 55 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\n            }\n\n            // Define the new Piggy Bank\n            piggyBank = 0;\n\n            // Define the new Castle\n            jester = msg.sender;\n            lastReparation = block.timestamp;\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 2);\n            totalCitizens += 1;\n            amountInvested += amount;\n\n            // All goes to the Piggy Bank\n            piggyBank += amount;\n\n            // The Jetster take 3%\n            jester.send(amount * 3 / 100);\n\n            // The brided Citizen takes 3%\n            collectedFee += amount * 3 / 100;\n\n            round += 1;\n        } else {\n            // The Castle is still up\n            lastReparation = block.timestamp;\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 2);\n            totalCitizens += 1;\n            amountInvested += amount;\n\n            // 5% goes to the Piggy Bank\n            piggyBank += (amount * 5 / 100);\n\n            // The Jetster takes 3%\n            jester.send(amount * 3 / 100);\n\n            // The brided Citizen takes 3%\n            collectedFee += amount * 3 / 100;\n\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - collectedFee) && lastCitizenPaid <= totalCitizens) {\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\n                lastCitizenPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        repairTheCastle();\n    }\n\n    // When the castle would be no more...\n    function surrender() {\n        if (msg.sender == bribedCitizen) {\n            bribedCitizen.send(address(this).balance);\n            selfdestruct(bribedCitizen);\n        }\n    }\n\n    // When the brided Citizen decides to give his seat to someone else\n    function newBribedCitizen(address newBribedCitizen) {\n        if (msg.sender == bribedCitizen) {\n            bribedCitizen = newBribedCitizen;\n        }\n    }\n\n    // When the brided Citizen decides to collect his fees\n    function collectFee() {\n        if (msg.sender == bribedCitizen) {\n            bribedCitizen.send(collectedFee);\n        }\n    }\n\n    // When the jester can't handle it anymore, he can give his position to someone else\n    function newJester(address newJester) {\n        if (msg.sender == jester) {\n            jester = newJester;\n        }\n    }       \n}",2,詩的な役割名と物語的な要素が含まれ、芸術的な表現が見られる。
1196017,0xdcb13fa157eebf22ddc8c9aa1d6e394810de6fa3,false,false,contract PiggyBank {\n\n  struct InvestorArray {\n      address etherAddress;\n      uint amount;\n  }\n\n  InvestorArray[] public investors;\n\n  uint public k = 0;\n  uint public fees;\n  uint public balance = 0;\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function PiggyBank() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 50 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n    uint amount=msg.value;\n\n\n    // add a new participant to array\n    uint total_inv = investors.length;\n    investors.length += 1;\n    investors[total_inv].etherAddress = msg.sender;\n    investors[total_inv].amount = amount;\n    \n    // collect fees and update contract balance\n \n      fees += amount / 33;             // 3% Fee\n      balance += amount;               // balance update\n\n\n     if (fees != 0) \n     {\n     	if(balance>fees)\n	{\n      	owner.send(fees);\n      	balance -= fees;                 //balance update\n	}\n     }\n \n\n   // 4% interest distributed to the investors\n    uint transactionAmount;\n	\n    while (balance > investors[k].amount * 3/100 && k<total_inv)  //exit condition to avoid infinite loop\n    { \n     \n     if(k%25==0 &&  balance > investors[k].amount * 9/100)\n     {\n      transactionAmount = investors[k].amount * 9/100;  \n      investors[k].etherAddress.send(transactionAmount);\n      balance -= investors[k].amount * 9/100;                      //balance update\n      }\n     else\n     {\n      transactionAmount = investors[k].amount *3/100;  \n      investors[k].etherAddress.send(transactionAmount);\n      balance -= investors[k].amount *3/100;                         //balance update\n      }\n      \n      k += 1;\n    }\n    \n    //----------------end enter\n  }\n\n\n\n  function setOwner(address new_owner) onlyowner {\n      owner = new_owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1197905,0x694037bfa0bc6151907eef6119ac679d242780c4,false,false,contract AddressReg{\n\n    address public owner;\n\n    function setOwner(address _owner){\n        if(msg.sender==owner)\n            owner = _owner;\n    }\n\n    function AddressReg(){\n        owner = msg.sender;\n    }\n\n    mapping (address=>bool) isVerifiedMap;\n\n    function verify(address addr){\n        if(msg.sender==owner)\n            isVerifiedMap[addr] = true;\n    }\n\n    function deverify(address addr){\n        if(msg.sender==owner)\n            isVerifiedMap[addr] = false;\n    }\n\n    function hasPhysicalAddress(address addr) constant returns(bool){\n        return isVerifiedMap[addr];\n    }\n\n},1,標準的な所有者管理とアドレス検証機能を持つ実用的なスマートコントラクト。
1206976,0x7a182116e05660af3c285675f6ea1269bdbb4716,false,false,"contract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function sendApproval(address _from, uint256 _value, address _token); }\n\ncontract MyToken is owned { \n    /* Public variables of the token */\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n	uint8 public disableconstruction;\n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyTokenLoad(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address centralMinter) {\n		if(disableconstruction != 2){\n            if(centralMinter != 0 ) owner = msg.sender;         // Sets the minter\n            balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens                    \n            name = tokenName;                                   // Set the name for display purposes     \n            symbol = tokenSymbol;                               // Set the symbol for display purposes    \n            decimals = decimalUnits;                            // Amount of decimals for display purposes        \n		}\n    }\n    function MyToken(){\n        MyTokenLoad(10000000000000,'Kraze',8,'KRZ',0);\n		disableconstruction=2;\n    }\n    /* Send coins */\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough   \n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient            \n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n\n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1211128,0x4ab274fc3a81b300a0016b3805d9b94c81fa54d2,false,false,"contract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\n\n\ncontract MeatConversionCalculator is owned {\n    uint public amountOfMeatInUnicorn;\n    uint public reliabilityPercentage;\n\n    /* generates a number from 0 to 2^n based on the last n blocks */\n    function multiBlockRandomGen(uint seed, uint size) constant returns (uint randomNumber) {\n        uint n = 0;\n        for (uint i = 0; i < size; i++){\n            if (uint(sha3(block.blockhash(block.number-i-1), seed ))%2==0)\n                n += 2**i;\n        }\n        return n;\n    }\n    \n    function MeatConversionCalculator(\n        uint averageAmountOfMeatInAUnicorn, \n        uint percentOfThatMeatThatAlwaysDeliver\n    ) {\n        changeMeatParameters(averageAmountOfMeatInAUnicorn, percentOfThatMeatThatAlwaysDeliver);\n    }\n    function changeMeatParameters(\n        uint averageAmountOfMeatInAUnicorn, \n        uint percentOfThatMeatThatAlwaysDeliver\n    ) onlyOwner {\n        amountOfMeatInUnicorn = averageAmountOfMeatInAUnicorn * 1000;\n        reliabilityPercentage = percentOfThatMeatThatAlwaysDeliver;\n    }\n    \n    function calculateMeat(uint amountOfUnicorns) constant returns (uint amountOfMeat) {\n        uint rnd = multiBlockRandomGen(uint(sha3(block.number, now, amountOfUnicorns)), 10);\n\n       amountOfMeat = (reliabilityPercentage*amountOfUnicorns*amountOfMeatInUnicorn)/100;\n       amountOfMeat += (1024*(100-reliabilityPercentage)*amountOfUnicorns*amountOfMeatInUnicorn)/(rnd*100);\n\n    }\n}",2,ユニコーンの肉量を計算するというユニークなテーマが詩的要素を持っています。
1211142,0xed6ac8de7c7ca7e3a22952e09c2a2a1232ddef9a,false,false,"/*\n\nVerification submitted to etherscan.io by Noel Maersk\nSource with full comments: https://gist.github.com/alexvandesande/3abc9f741471e08a6356#file-unicorn-meat-token\n\n*/\n\n    contract owned {\n        address public owner;\n\n        function owned() {\n            owner = msg.sender;\n        }\n\n        modifier onlyOwner {\n            if (msg.sender != owner) throw;\n            _\n        }\n\n        function transferOwnership(address newOwner) onlyOwner {\n            owner = newOwner;\n        }\n    }\n    \n    contract tokenRecipient { \n        function receiveApproval(address _from, uint256 _value, address _token); \n    }\n\n    contract MyToken is owned { \n        /* Public variables of the token */\n        string public name;\n        string public symbol;\n        uint8 public decimals;\n        uint256 public totalSupply;\n\n        /* This creates an array with all balances */\n        mapping (address => uint256) public balanceOf;\n        mapping (address => bool) public frozenAccount; \n        mapping (address => mapping (address => uint256)) public allowance;\n        mapping (address => mapping (address => uint256)) public spentAllowance;\n\n        /* This generates a public event on the blockchain that will notify clients */\n        event Transfer(address indexed from, address indexed to, uint256 value);\n        event FrozenFunds(address target, bool frozen);\n\n        /* Initializes contract with initial supply tokens to the creator of the contract */\n        function MyToken(\n            uint256 initialSupply, \n            string tokenName, \n            uint8 decimalUnits, \n            string tokenSymbol, \n            address centralMinter \n        ) { \n            if(centralMinter != 0 ) owner = msg.sender;         // Sets the minter\n            balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens                    \n            name = tokenName;                                   // Set the name for display purposes     \n            symbol = tokenSymbol;                               // Set the symbol for display purposes    \n            decimals = decimalUnits;                            // Amount of decimals for display purposes\n            totalSupply = initialSupply; \n        }\n\n        /* Send coins */\n        function transfer(address _to, uint256 _value) {\n            if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough   \n            if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n            if (frozenAccount[msg.sender]) throw;                // Check if frozen\n            balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n            balanceOf[_to] += _value;                            // Add the same to the recipient            \n            Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        }\n\n        /* Allow another contract to spend some tokens in your behalf */\n        function approveAndCall(address _spender, uint256 _value) returns (bool success) {\n            allowance[msg.sender][_spender] = _value;  \n            tokenRecipient spender = tokenRecipient(_spender);\n            spender.receiveApproval(msg.sender, _value, this); \n            return true;         \n        }\n\n        /* A contract attempts to get the coins */\n        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n            if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough   \n            if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n            if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw;   // Check allowance\n            balanceOf[_from] -= _value;                          // Subtract from the sender\n            balanceOf[_to] += _value;                            // Add the same to the recipient            \n            spentAllowance[_from][msg.sender] += _value;\n            Transfer(_from, _to, _value); \n            return true;\n        } \n\n        /* This unnamed function is called whenever someone tries to send ether to it */\n        function () {\n            throw;     // Prevents accidental sending of ether\n        }\n        \n        function mintToken(address target, uint256 mintedAmount) onlyOwner {\n            balanceOf[target] += mintedAmount; \n            totalSupply += mintedAmount; \n            Transfer(0, owner, mintedAmount);\n            Transfer(owner, target, mintedAmount);\n        }\n\n        function freezeAccount(address target, bool freeze) onlyOwner {\n            frozenAccount[target] = freeze;\n            FrozenFunds(target, freeze);\n        }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1215725,0x2a3967d9b88c11612503d45411c7d07a13554250,false,false,"contract Market {\n\n  struct Option {\n    int strike;\n  }\n  struct Position {\n    mapping(uint => int) positions;\n    int cash;\n    bool expired;\n    bool hasPosition;\n  }\n  struct OptionChain {\n    uint expiration;\n    string underlying;\n    uint margin;\n    uint realityID;\n    bytes32 factHash;\n    address ethAddr;\n    mapping(uint => Option) options;\n    uint numOptions;\n    bool expired;\n    mapping(address => Position) positions;\n    uint numPositions;\n    uint numPositionsExpired;\n  }\n  mapping(uint => OptionChain) optionChains;\n  uint numOptionChains;\n  struct Account {\n    address user;\n    int capital;\n  }\n  mapping(bytes32 => int) orderFills; //keeps track of cumulative order fills\n  struct MarketMaker {\n    address user;\n    string server;\n  }\n  mapping(uint => MarketMaker) marketMakers; //starts at 1\n  uint public numMarketMakers = 0;\n  mapping(address => uint) marketMakerIDs;\n  mapping(uint => Account) accounts;\n  uint numAccounts;\n  mapping(address => uint) accountIDs; //starts at 1\n\n  function Market() {\n  }\n\n  function addFunds() {\n    if (accountIDs[msg.sender]>0) {\n      accounts[accountIDs[msg.sender]].capital += int(msg.value);\n    } else {\n      uint accountID = ++numAccounts;\n      accounts[accountID].user = msg.sender;\n      accounts[accountID].capital += int(msg.value);\n      accountIDs[msg.sender] = accountID;\n    }\n  }\n\n  function withdrawFunds(uint amount) {\n    if (accountIDs[msg.sender]>0) {\n      if (int(amount)<=getFunds(msg.sender, true) && int(amount)>0) {\n        accounts[accountIDs[msg.sender]].capital -= int(amount);\n        msg.sender.send(amount);\n      }\n    }\n  }\n\n  function getFunds(address user, bool onlyAvailable) constant returns(int) {\n    if (accountIDs[user]>0) {\n      if (onlyAvailable == false) {\n        return accounts[accountIDs[user]].capital;\n      } else {\n        return accounts[accountIDs[user]].capital + getMaxLossAfterTrade(user, 0, 0, 0, 0);\n      }\n    } else {\n      return 0;\n    }\n  }\n\n  function getFundsAndAvailable(address user) constant returns(int, int) {\n    return (getFunds(user, false), getFunds(user, true));\n  }\n\n  function marketMaker(string server) {\n    if (msg.value>0) throw;\n    if (marketMakerIDs[msg.sender]>0) {\n      marketMakers[marketMakerIDs[msg.sender]].server = server;\n    } else {\n      int funds = getFunds(marketMakers[i].user, false);\n      uint marketMakerID = 0;\n      if (numMarketMakers<6) {\n        marketMakerID = ++numMarketMakers;\n      } else {\n        for (uint i=2; i<=numMarketMakers; i++) {\n          if (getFunds(marketMakers[i].user, false)<=funds && (marketMakerID==0 || getFunds(marketMakers[i].user, false)<getFunds(marketMakers[marketMakerID].user, false))) {\n            marketMakerID = i;\n          }\n        }\n      }\n      if (marketMakerID>0) {\n        marketMakerIDs[marketMakers[marketMakerID].user] = 0;\n        marketMakers[marketMakerID].user = msg.sender;\n        marketMakers[marketMakerID].server = server;\n        marketMakerIDs[msg.sender] = marketMakerID;\n      } else {\n        throw;\n      }\n    }\n  }\n\n  function getMarketMakers() constant returns(string, string, string, string, string, string) {\n    string[] memory servers = new string[](6);\n    for (uint i=1; i<=numMarketMakers; i++) {\n      servers[i-1] = marketMakers[i].server;\n    }\n    return (servers[0], servers[1], servers[2], servers[3], servers[4], servers[5]);\n  }\n\n  function getMarketMakerFunds() constant returns(int, int, int, int, int, int) {\n    int[] memory funds = new int[](6);\n    for (uint i=1; i<=numMarketMakers; i++) {\n      funds[i-1] = getFunds(marketMakers[i].user, false);\n    }\n    return (funds[0], funds[1], funds[2], funds[3], funds[4], funds[5]);\n  }\n\n  function getOptionChain(uint optionChainID) constant returns (uint, string, uint, uint, bytes32, address) {\n    return (optionChains[optionChainID].expiration, optionChains[optionChainID].underlying, optionChains[optionChainID].margin, optionChains[optionChainID].realityID, optionChains[optionChainID].factHash, optionChains[optionChainID].ethAddr);\n  }\n\n  function getMarket(address user) constant returns(uint[], int[], int[], int[]) {\n    uint[] memory optionIDs = new uint[](60);\n    int[] memory strikes = new int[](60);\n    int[] memory positions = new int[](60);\n    int[] memory cashes = new int[](60);\n    uint z = 0;\n    for (int optionChainID=int(numOptionChains)-1; optionChainID>=0 && z<60; optionChainID--) {\n      if (optionChains[uint(optionChainID)].expired == false) {\n        for (uint optionID=0; optionID<optionChains[uint(optionChainID)].numOptions; optionID++) {\n          optionIDs[z] = uint(optionChainID)*1000 + optionID;\n          strikes[z] = optionChains[uint(optionChainID)].options[optionID].strike;\n          positions[z] = optionChains[uint(optionChainID)].positions[user].positions[optionID];\n          cashes[z] = optionChains[uint(optionChainID)].positions[user].cash;\n          z++;\n        }\n      }\n    }\n    return (optionIDs, strikes, positions, cashes);\n  }\n\n  function expire(uint accountID, uint optionChainID, uint8 v, bytes32 r, bytes32 s, bytes32 value) {\n    if (optionChains[optionChainID].expired == false) {\n      if (ecrecover(sha3(optionChains[optionChainID].factHash, value), v, r, s) == optionChains[optionChainID].ethAddr) {\n        uint lastAccount = numAccounts;\n        if (accountID==0) {\n          accountID = 1;\n        } else {\n          lastAccount = accountID;\n        }\n        for (accountID=accountID; accountID<=lastAccount; accountID++) {\n          if (optionChains[optionChainID].positions[accounts[accountID].user].expired == false) {\n            int result = optionChains[optionChainID].positions[accounts[accountID].user].cash / 1000000000000000000;\n            for (uint optionID=0; optionID<optionChains[optionChainID].numOptions; optionID++) {\n              int moneyness = getMoneyness(optionChains[optionChainID].options[optionID].strike, uint(value), optionChains[optionChainID].margin);\n              result += moneyness * optionChains[optionChainID].positions[accounts[accountID].user].positions[optionID] / 1000000000000000000;\n            }\n            accounts[accountID].capital = accounts[accountID].capital + result;\n            optionChains[optionChainID].positions[accounts[accountID].user].expired = true;\n            optionChains[optionChainID].numPositionsExpired++;\n          }\n        }\n        if (optionChains[optionChainID].numPositionsExpired == optionChains[optionChainID].numPositions) {\n          optionChains[optionChainID].expired = true;\n        }\n      }\n    }\n  }\n\n  function getMoneyness(int strike, uint settlement, uint margin) constant returns(int) {\n    if (strike>=0) { //call\n      if (settlement>uint(strike)) {\n        if (settlement-uint(strike)<margin) {\n          return int(settlement-uint(strike));\n        } else {\n          return int(margin);\n        }\n      } else {\n        return 0;\n      }\n    } else { //put\n      if (settlement<uint(-strike)) {\n        if (uint(-strike)-settlement<margin) {\n          return int(uint(-strike)-settlement);\n        } else {\n          return int(margin);\n        }\n      } else {\n        return 0;\n      }\n    }\n  }\n\n  function addOptionChain(uint expiration, string underlying, uint margin, uint realityID, bytes32 factHash, address ethAddr, int[] strikes) {\n    uint optionChainID = 6;\n    if (numOptionChains<6) {\n      optionChainID = numOptionChains++;\n    } else {\n      for (uint i=0; i < numOptionChains && optionChainID>=6; i++) {\n        if (optionChains[i].expired==true || optionChains[i].numPositions==0 || optionChains[i].numOptions==0) {\n          optionChainID = i;\n        }\n      }\n    }\n    if (optionChainID<6) {\n      delete optionChains[optionChainID];\n      optionChains[optionChainID].expiration = expiration;\n      optionChains[optionChainID].underlying = underlying;\n      optionChains[optionChainID].margin = margin;\n      optionChains[optionChainID].realityID = realityID;\n      optionChains[optionChainID].factHash = factHash;\n      optionChains[optionChainID].ethAddr = ethAddr;\n      for (i=0; i < strikes.length; i++) {\n        if (optionChains[optionChainID].numOptions<10) {\n          uint optionID = optionChains[optionChainID].numOptions++;\n          Option option = optionChains[optionChainID].options[i];\n          option.strike = strikes[i];\n          optionChains[optionChainID].options[i] = option;\n        }\n      }\n    }\n  }\n\n  function orderMatchTest(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, address sender, int matchSize) constant returns(bool) {\n    if (block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[sha3(optionChainID, optionID, price, size, orderID, blockExpires)]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(sender, false)+getMaxLossAfterTrade(sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\n      return true;\n    }\n    return false;\n  }\n\n  function orderMatch(uint optionChainID, uint optionID, uint price, int size, uint orderID, uint blockExpires, address addr, uint8 v, bytes32 r, bytes32 s, int matchSize) {\n    bytes32 hash = sha256(optionChainID, optionID, price, size, orderID, blockExpires);\n    if (ecrecover(hash, v, r, s) == addr && block.number<=blockExpires && ((size>0 && matchSize<0 && orderFills[hash]-matchSize<=size) || (size<0 && matchSize>0 && orderFills[hash]-matchSize>=size)) && getFunds(addr, false)+getMaxLossAfterTrade(addr, optionChainID, optionID, -matchSize, matchSize * int(price))>0 && getFunds(msg.sender, false)+getMaxLossAfterTrade(msg.sender, optionChainID, optionID, matchSize, -matchSize * int(price))>0) {\n      if (optionChains[optionChainID].positions[msg.sender].hasPosition == false) {\n        optionChains[optionChainID].positions[msg.sender].hasPosition = true;\n        optionChains[optionChainID].numPositions++;\n      }\n      if (optionChains[optionChainID].positions[addr].hasPosition == false) {\n        optionChains[optionChainID].positions[addr].hasPosition = true;\n        optionChains[optionChainID].numPositions++;\n      }\n      optionChains[optionChainID].positions[msg.sender].positions[optionID] += matchSize;\n      optionChains[optionChainID].positions[msg.sender].cash -= matchSize * int(price);\n      optionChains[optionChainID].positions[addr].positions[optionID] -= matchSize;\n      optionChains[optionChainID].positions[addr].cash += matchSize * int(price);\n      orderFills[hash] -= matchSize;\n    }\n  }\n\n  function getMaxLossAfterTrade(address user, uint optionChainID, uint optionID, int positionChange, int cashChange) constant returns(int) {\n    int totalMaxLoss = 0;\n    for (uint i=0; i<numOptionChains; i++) {\n      if (optionChains[i].positions[user].expired == false && optionChains[i].numOptions>0) {\n        bool maxLossInitialized = false;\n        int maxLoss = 0;\n        for (uint s=0; s<optionChains[i].numOptions; s++) {\n          int pnl = optionChains[i].positions[user].cash / 1000000000000000000;\n          if (i==optionChainID) {\n            pnl += cashChange / 1000000000000000000;\n          }\n          uint settlement = 0;\n          if (optionChains[i].options[s].strike<0) {\n            settlement = uint(-optionChains[i].options[s].strike);\n          } else {\n            settlement = uint(optionChains[i].options[s].strike);\n          }\n          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\n          if (pnl<maxLoss || maxLossInitialized==false) {\n            maxLossInitialized = true;\n            maxLoss = pnl;\n          }\n          pnl = optionChains[i].positions[user].cash / 1000000000000000000;\n          if (i==optionChainID) {\n            pnl += cashChange / 1000000000000000000;\n          }\n          settlement = 0;\n          if (optionChains[i].options[s].strike<0) {\n            if (uint(-optionChains[i].options[s].strike)>optionChains[i].margin) {\n              settlement = uint(-optionChains[i].options[s].strike)-optionChains[i].margin;\n            } else {\n              settlement = 0;\n            }\n          } else {\n            settlement = uint(optionChains[i].options[s].strike)+optionChains[i].margin;\n          }\n          pnl += moneySumAtSettlement(user, optionChainID, optionID, positionChange, i, settlement);\n          if (pnl<maxLoss) {\n            maxLoss = pnl;\n          }\n        }\n        totalMaxLoss += maxLoss;\n      }\n    }\n    return totalMaxLoss;\n  }\n\n  function moneySumAtSettlement(address user, uint optionChainID, uint optionID, int positionChange, uint i, uint settlement) internal returns(int) {\n    int pnl = 0;\n    for (uint j=0; j<optionChains[i].numOptions; j++) {\n      pnl += optionChains[i].positions[user].positions[j] * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\n      if (i==optionChainID && j==optionID) {\n        pnl += positionChange * getMoneyness(optionChains[i].options[j].strike, settlement, optionChains[i].margin) / 1000000000000000000;\n      }\n    }\n    return pnl;\n  }\n\n  function min(uint a, uint b) constant returns(uint) {\n    if (a<b) {\n      return a;\n    } else {\n      return b;\n    }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1217271,0xa502f8112b2491718855f01a01a60462cc97a0d5,false,false,"contract UfoPonzi {\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees;\n    uint public balance = 0;\n\n    address public owner;\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function UfoPonzi() {\n        owner = msg.sender;\n        balance += msg.value;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n        if (msg.value < 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n\n        // add a new participant to array\n        uint idx = participants.length;\n        participants.length += 1;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value;\n        \n        // collect fees and update contract balance\n        if (idx != 0) {\n            collectedFees += msg.value / 10;\n            balance += msg.value;\n        } \n        else {\n            // first participant has no one above him,\n            // so it goes all to fees\n            collectedFees += msg.value;\n        }\n\n  // if there are enough ether on the balance we can pay out to an earlier participant\n        if (balance > participants[payoutIdx].amount / 10 + participants[payoutIdx].amount) {\n            uint transactionAmount = (participants[payoutIdx].amount - participants[payoutIdx].amount / 10) / 10 + (participants[payoutIdx].amount - participants[payoutIdx].amount / 10);\n            participants[payoutIdx].etherAddress.send(transactionAmount);\n\n            balance -= participants[payoutIdx].amount / 10 + participants[payoutIdx].amount;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Ponziスキームを模した実用的なスマートコントラクトで、芸術的要素は特にない。
1218066,0x1685d2aa57347ef1b85fd0338a91f7d6eedebbfa,false,false,contract PiggyBank {\n\n  struct InvestorArray {\n      address etherAddress;\n      uint amount;\n  }\n\n  InvestorArray[] public investors;\n\n  uint public k = 0;\n  uint public fees;\n  uint public balance = 0;\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function PiggyBank() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 50 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n    uint amount=msg.value;\n\n\n    // add a new participant to array\n    uint total_inv = investors.length;\n    investors.length += 1;\n    investors[total_inv].etherAddress = msg.sender;\n    investors[total_inv].amount = amount;\n    \n    // collect fees and update contract balance\n \n      fees = amount / 33;             // 3% Fee\n      balance += amount;               // balance update\n\n\n     if (fees != 0) \n     {\n     	if(balance>fees)\n	{\n      	owner.send(fees);\n      	balance -= fees;                 //balance update\n	}\n     }\n \n\n   // 4% interest distributed to the investors\n    uint transactionAmount;\n	\n    while (balance > investors[k].amount * 3/100 && k<total_inv)  //exit condition to avoid infinite loop\n    { \n     \n     if(k%25==0 &&  balance > investors[k].amount * 9/100)\n     {\n      transactionAmount = investors[k].amount * 9/100;  \n      investors[k].etherAddress.send(transactionAmount);\n      balance -= investors[k].amount * 9/100;                      //balance update\n      }\n     else\n     {\n      transactionAmount = investors[k].amount *3/100;  \n      investors[k].etherAddress.send(transactionAmount);\n      balance -= investors[k].amount *3/100;                         //balance update\n      }\n      \n      k += 1;\n    }\n    \n    //----------------end enter\n  }\n\n\n\n  function setOwner(address new_owner) onlyowner {\n      owner = new_owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1222140,0x4865e85c72a27ca6c362da75ba6707c07464b953,false,false,"//***********************************TREASURE CHEST GAME\n//\n//\n//  Hello player, this is a Treasure Chest game, every player that deposit's here will get a guaranteed 6% payout of their balance after somebody after him deposits!\n//  Every 30th investor receives 18% instead of 6%, that is the jackpot spot that pays 3x more, invest quickly ,and you can earn a passive income right now!\n//\n//  This contract is bug-tested, and it has none, feel comfortable to analyse the code yourself, it's open source and transparent!\n//  Enjoy this game, and earn Ethereum now!\n//\n//  Copyright  Â©  2016  David Weissman from NZ\n//\n//***********************************START\ncontract TreasureChest {\n\n  struct InvestorArray {\n      address etherAddress;\n      uint amount;\n  }\n\n  InvestorArray[] public investors;\n\n//********************************************PUBLIC VARIABLES\n\n  uint public investors_needed_until_jackpot=0;\n  uint public totalplayers=0;\n  uint public fees=0;\n  uint public balance = 0;\n  uint public totaldeposited=0;\n  uint public totalpaidout=0;\n\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function TreasureChest() {\n    owner = msg.sender;\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value < 50 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n    uint amount=msg.value;\n\n\n    // add a new participant to the system and calculate total players\n    uint tot_pl = investors.length;\n    totalplayers=tot_pl+1;\n    investors_needed_until_jackpot=30-(totalplayers % 30);\n    investors.length += 1;\n    investors[tot_pl].etherAddress = msg.sender;\n    investors[tot_pl].amount = amount;\n\n\n\n    // collect fees and update contract balance and deposited amount\n      fees  = amount / 15;             // 6.666% fee to the owner\n      balance += amount;               // balance update\n      totaldeposited+=amount;       //update deposited amount\n\n    // pay out fees to the owner\n     if (fees != 0) \n     {\n     	if(balance>fees)\n	{\n      	owner.send(fees);\n      	balance -= fees;                 //balance update\n	totalpaidout+=fees;          //update paid out amount\n	}\n     }\n \n\n   //loop variables\n    uint payout;\n    uint nr=0;\n	\n    while (balance > investors[nr].amount * 6/100 && nr<tot_pl)  //exit condition to avoid infinite loop\n    { \n     \n     if(nr%30==0 &&  balance > investors[nr].amount * 18/100)\n     {\n      payout = investors[nr].amount * 18/100;                        //calculate pay out\n      investors[nr].etherAddress.send(payout);                      //send pay out to participant\n      balance -= investors[nr].amount * 18/100;                      //balance update\n      totalpaidout += investors[nr].amount * 18/100;               //update paid out amount\n      }\n     else\n     {\n      payout = investors[nr].amount *6/100;                           //calculate pay out\n      investors[nr].etherAddress.send(payout);                        //send pay out to participant\n      balance -= investors[nr].amount *6/100;                         //balance update\n      totalpaidout += investors[nr].amount *6/100;                 //update paid out amount\n      }\n      \n      nr += 1;                                                                         //go to next participant\n    }\n    \n    \n  }\n\n//********************************************NEW OWNER\n\n  function setOwner(address new_owner) onlyowner {\n      owner = new_owner;\n  }\n}",1,実用的なスマートコントラクトで、ゲームのロジックを実装していますが、芸術的要素は少ないです。
1222702,0x8154ae317a767e69d7f427aebdfbdddadcd5cf48,false,false,"contract Rating {\n        function setRating(bytes32 _key, uint256 _value) {\n            ratings[_key] = _value;\n        }\n        mapping (bytes32 => uint256) public ratings;\n    }",1,シンプルで実用的な評価設定のスマートコントラクトです。
1223095,0xbb9854bfd082c48b4d426ac6a2a152b01326f46f,false,false,"contract X3 {\n\n        struct Participant {\n                address etherAddress;\n                uint amount;\n        }\n\n        Participant[] public participants;\n\n        uint public payoutIdx = 0;\n        uint public collectedFees;\n        uint public balance = 0;\n\n        address public owner;\n\n        // simple single-sig function modifier\n        modifier onlyowner {\n                if (msg.sender == owner) _\n        }\n\n        // this function is executed at initialization and sets the owner of the contract\n        function X3() {\n                owner = msg.sender;\n        }\n\n        // fallback function - simple transactions trigger this\n        function() {\n                enter();\n        }\n\n        function enter() {\n                if (msg.value < 1 ether) {\n                        msg.sender.send(msg.value);\n                        return;\n                }\n\n                // add a new participant to array\n                uint idx = participants.length;\n                participants.length += 1;\n                participants[idx].etherAddress = msg.sender;\n                participants[idx].amount = msg.value;\n\n                // collect fees and update contract balance\n                if (idx != 0) {\n                        collectedFees += msg.value / 3;\n                        balance += msg.value;\n                } else {\n                        // first participant has no one above him,\n                        // so it goes all to fees\n                        collectedFees += msg.value;\n                }\n\n                // if there are enough ether on the balance X3 will payout three time your initial investement\n                if (balance > participants[payoutIdx].amount * 3) {\n                        uint transactionAmount = 3 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 3);\n                        participants[payoutIdx].etherAddress.send(transactionAmount);\n\n                        balance -= participants[payoutIdx].amount * 3;\n                        payoutIdx += 1;\n                }\n        }\n\n        function collectFees() onlyowner {\n                if (collectedFees == 0) return;\n\n                owner.send(collectedFees);\n                collectedFees = 0;\n        }\n\n        function setOwner(address _owner) onlyowner {\n                owner = _owner;\n        }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1228652,0x446d1696a5527018453cda3d67aa4c2cd189b9f6,false,false,"contract GreedPit {\n    \n    address private owner;\n    \n    //Stored variables\n    uint private balance = 0;\n    uint private uniqueUsers = 0;\n    uint private usersProfits = 0;\n    uint private rescues = 0;\n    uint private collectedFees = 0;\n    uint private jumpFee = 10;\n    uint private baseMultiplier = 110;\n    uint private maxMultiplier = 200;\n    uint private payoutOrder = 0;\n    uint private rescueRecord = 0;\n    uint timeOfLastDeposit = now;\n    address private hero = 0x0;\n    \n    mapping (address => User) private users;\n    Entry[] private entries;\n    \n    event Jump(address who, uint deposit, uint payout);\n    event Rescue(address who, address saviour, uint payout);\n    event NewHero(address who);\n    \n    //Set owner on contract creation\n    function GreedPit() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    struct User {\n        uint id;\n        address addr;\n        string nickname;\n        uint rescueCount;\n        uint rescueTokens;\n    }\n    \n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        uint tokens;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    function init() private{\n        //Only deposits >0.1ETH are allowed to join\n        if (msg.value < 100 finney) {\n            return;\n        }\n        \n        jumpIn();\n        \n        //Prevent cheap trolls from reviving the pit if it dies (death = ~3months without deposits)\n        if (msg.value > 5)\n            timeOfLastDeposit = now;\n    }\n    \n    //Join the pit\n    function jumpIn() private {\n        \n        //Limit deposits to 50ETH\n		uint dValue = 100 finney;\n		if (msg.value > 50 ether) {\n		    //Make sure we receied the money before refunding the surplus\n		    if (this.balance >= balance + collectedFees + msg.value)\n			    msg.sender.send(msg.value - 50 ether);	\n			dValue = 50 ether;\n		}\n		else { dValue = msg.value; }\n\n        //Add new users to the users array if he's a new player\n        addNewUser(msg.sender);\n        \n        //Make sure that only up to 5 rescue tokens are spent at a time\n        uint tokensToUse = users[msg.sender].rescueTokens >= 5 ? 5 : users[msg.sender].rescueTokens;\n        uint tokensUsed = 0;\n        \n        //Enforce lower payouts if too many people stuck in the pit\n        uint randMultiplier = rand(50);\n        uint currentEntries = entries.length - payoutOrder;\n        randMultiplier = currentEntries > 15 ? (randMultiplier / 2) : randMultiplier;\n        randMultiplier = currentEntries > 25 ? 0 : randMultiplier;\n        //Incentive to join if the pit is nearly empty (+50% random multiplier)\n        randMultiplier = currentEntries <= 5 && dValue <= 20 ? randMultiplier * 3 / 2 : randMultiplier;\n        \n        //Calculate the optimal amount of rescue tokens to spend\n        while (tokensToUse > 0 && (baseMultiplier + randMultiplier + tokensUsed*10) < maxMultiplier)\n        {\n            tokensToUse--;\n            tokensUsed++;\n        }\n        \n        uint finalMultiplier = (baseMultiplier + randMultiplier + tokensUsed*10);\n        \n        if (finalMultiplier > maxMultiplier)\n            finalMultiplier = maxMultiplier;\n            \n        //Add new entry to the entries array    \n        if (msg.value < 50 ether)\n            entries.push(Entry(msg.sender, msg.value, (msg.value * (finalMultiplier) / 100), tokensUsed));\n        else\n            entries.push(Entry(msg.sender, 50 ether,((50 ether) * (finalMultiplier) / 100), tokensUsed));\n\n        //Trigger jump event\n        if (msg.value < 50 ether)\n            Jump(msg.sender, msg.value, (msg.value * (finalMultiplier) / 100));\n        else\n            Jump(msg.sender, 50 ether, ((50 ether) * (finalMultiplier) / 100));\n\n        users[msg.sender].rescueTokens -= tokensUsed;\n        \n        //Collect fees and update contract balance\n        balance += (dValue * (100 - jumpFee)) / 100;\n        collectedFees += (dValue * jumpFee) / 100;\n        \n        bool saviour = false;\n        \n        //Pay pending entries if the new balance allows for it\n        while (balance > entries[payoutOrder].payout) {\n            \n            saviour = false;\n            \n            uint entryPayout = entries[payoutOrder].payout;\n            uint entryDeposit = entries[payoutOrder].deposit;\n            uint profit = entryPayout - entryDeposit;\n            uint saviourShare = 0;\n            \n            //Give credit & reward for the rescue if the user saved someone else\n            if (users[msg.sender].addr != entries[payoutOrder].entryAddress)\n            {\n                users[msg.sender].rescueCount++;\n                //Double or triple token bonus if the user is taking a moderate/high risk to help those trapped\n                if (entryDeposit >= 1 ether) {\n                    users[msg.sender].rescueTokens += dValue < 20 || currentEntries < 15 ? 1 : 2;\n                    users[msg.sender].rescueTokens += dValue < 40 || currentEntries < 25 ? 0 : 1;\n                }\n                saviour = true;\n            }\n            \n            bool isHero = false;\n            \n            isHero = entries[payoutOrder].entryAddress == hero;\n            \n            //Share profit with saviour if the gain is substantial enough and the saviour invested enough (hero exempt)\n            if (saviour && !isHero && profit > 20 * entryDeposit / 100 && profit > 100 finney && dValue >= 5 ether)\n            {\n                if (dValue < 10 ether)\n                   saviourShare = 3 + rand(5);\n                else if (dValue >= 10 ether && dValue < 25 ether)\n                  saviourShare = 7 + rand(8);\n                else if (dValue >= 25 ether && dValue < 40 ether)\n                   saviourShare = 12 + rand(13);\n                else if (dValue >= 40 ether)\n                   saviourShare = rand(50);\n                   \n                saviourShare *= profit / 100;\n                   \n                msg.sender.send(saviourShare);\n            }\n            \n            uint payout = entryPayout - saviourShare;\n            entries[payoutOrder].entryAddress.send(payout);\n            \n            //Trigger rescue event\n            Rescue(entries[payoutOrder].entryAddress, msg.sender, payout);\n\n            balance -= entryPayout;\n            usersProfits += entryPayout;\n            \n            rescues++;\n            payoutOrder++;\n        }\n        \n        //Check for new Hero of the Pit\n        if (saviour && users[msg.sender].rescueCount > rescueRecord)\n        {\n            rescueRecord = users[msg.sender].rescueCount;\n            hero = msg.sender;\n            //Trigger new hero event\n            NewHero(msg.sender);\n        }\n    }\n    \n    //Generate random number between 1 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n    \n        return uint256((uint256(hashVal) / factor)) % max + 1;\n    }\n    \n    function addNewUser(address Address) private\n    {\n        if (users[Address].addr == address(0))\n        {\n            users[Address].id = ++uniqueUsers;\n            users[Address].addr = Address;\n            users[Address].nickname = 'UnnamedPlayer';\n            users[Address].rescueCount = 0;\n            users[Address].rescueTokens = 0;\n        }\n    }\n    \n    //Transfer earnings from fees to the owner\n    function collectFees() onlyowner {\n        if (collectedFees == 0) throw;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    //Contract management\n    function changeOwner(address newOwner) onlyowner {\n        owner = newOwner;\n    }\n    \n    function changeBaseMultiplier(uint multi) onlyowner {\n        if (multi < 110 || multi > 150) throw;\n        \n        baseMultiplier = multi;\n    }\n    \n    function changeMaxMultiplier(uint multi) onlyowner {\n        if (multi < 200 || multi > 300) throw;\n        \n        maxMultiplier = multi;\n    }\n    \n    function changeFee(uint fee) onlyowner {\n        if (fee < 0 || fee > 10) throw;\n        \n        jumpFee = fee;\n    }\n    \n    \n    //JSON functions\n    function setNickname(string name) {\n        addNewUser(msg.sender);\n        \n        if (bytes(name).length >= 2 && bytes(name).length <= 16)\n            users[msg.sender].nickname = name;\n    }\n    \n    function currentBalance() constant returns (uint pitBalance, string info) {\n        pitBalance = balance / 1 finney;\n        info = 'The balance of the pit in Finneys (contract balance minus fees).';\n    }\n    \n    function heroOfThePit() constant returns (address theHero, string nickname, uint peopleSaved, string info) {\n        theHero = hero;  \n        nickname = users[theHero].nickname;\n        peopleSaved = rescueRecord;\n        info = 'The current rescue record holder. All hail!';\n    }\n    \n    function userName(address Address) constant returns (string nickname) {\n        nickname = users[Address].nickname;\n    }\n    \n    function totalRescues() constant returns (uint rescueCount, string info) {\n        rescueCount = rescues;\n        info = 'The number of times that people have been rescued from the pit (aka the number of times people made a profit).';\n    }\n    \n    function multipliers() constant returns (uint BaseMultiplier, uint MaxMultiplier, string info) {\n        BaseMultiplier = baseMultiplier;\n        MaxMultiplier = maxMultiplier;\n        info = 'The multipliers applied to all deposits: the final multiplier is a random number between the multpliers shown divided by 100. By default x1.1~x1.5 (up to x2 if rescue tokens are used, granting +0.1 per token). It determines the amount of money you will get when rescued (a saviour share might be deducted).';\n    }\n    \n    function pitFee() constant returns (uint feePercentage, string info) {\n        feePercentage = jumpFee;\n        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 10%).';\n    }\n    \n    function nextPayoutGoal() constant returns (uint finneys, string info) {\n        finneys = (entries[payoutOrder].payout - balance) / 1 finney;\n        info = 'The amount of Finneys (Ethers * 1000) that need to be deposited for the next payout to be executed.';\n    }\n    \n    function unclaimedFees() constant returns (uint ethers, string info) {\n        ethers = collectedFees / 1 ether;\n        info = 'The amount of Ethers obtained through fees that have not yet been collected by the owner.';\n    }\n    \n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = 'The number of times that people have jumped into the pit.';\n    }\n    \n    function totalUsers() constant returns (uint users, string info) {\n        users = uniqueUsers;\n        info = 'The number of unique users that have joined the pit.';\n    }\n    \n    function awaitingPayout() constant returns (uint count, string info) {\n        count = entries.length - payoutOrder;\n        info = 'The number of people waiting to be saved.';\n    }\n    \n    function entryDetails(uint index) constant returns (address user, string nickName, uint deposit, uint payout, uint tokensUsed, string info)\n    {\n        if (index <= entries.length) {\n            user = entries[index].entryAddress;\n            nickName = users[entries[index].entryAddress].nickname;\n            deposit = entries[index].deposit / 1 finney;\n            payout = entries[index].payout / 1 finney;\n            tokensUsed = entries[index].tokens;\n            info = 'Entry info: user address, name, expected payout in Finneys (approximate), rescue tokens used.';\n        }\n    }\n    \n    function userId(address user) constant returns (uint id, string info) {\n        id = users[user].id;\n        info = 'The id of the user, represents the order in which he first joined the pit.';\n    }\n    \n    function userTokens(address user) constant returns (uint tokens, string info) {\n        tokens = users[user].addr != address(0x0) ? users[user].rescueTokens : 0;\n        info = 'The number of Rescue Tokens the user has. Tokens are awarded when your deposits save people, and used automatically on your next deposit. They provide a 0.1 multiplier increase per token. (+0.5 max)';\n    }\n    \n    function userRescues(address user) constant returns(uint rescueCount, string info) {\n        rescueCount = users[user].addr != address(0x0) ? users[user].rescueCount : 0;\n        info = 'The number of times the user has rescued someone from the pit.';\n    }\n    \n    function userProfits() constant returns(uint profits, string info) {\n        profits = usersProfits / 1 finney;\n        info = 'The combined earnings of all users in Finney.';\n    }\n    \n    //Destroy the contract after ~3 months of inactivity at the owner's discretion\n    function recycle() onlyowner\n    {\n        if (now >= timeOfLastDeposit + 10 weeks) \n        { \n            //Refund the current balance\n            if (balance > 0) \n            {\n                entries[0].entryAddress.send(balance);\n            }\n            \n            //Destroy the contract\n            selfdestruct(owner);\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1237599,0x7753a9d834844cfde5c211ec3912b49f0d8b8e11,false,false,"// Welcome to * Bet On Hash *\n//\n// this is a round based bet game\n// a round consists of 6 players\n// \n// you bet on the first byte of the last (6th) players blockhash (unpredictable, 50% chance)\n// \n// ** to join: send one byte data (0x01 or 0x81) with a bet amount of 0.1 ether (100 finney) to the contract address\n// \n// if your data byte is less than 0x80 you bet the blockhashs first byte is < 0x80\n// if your data byte is greater than or equal 0x80 you bet the blockhashs first byte is >= 0x80\n// \n// if you lose your bet your bet amount goes to the pool for winners\n// \n// if you win your bet:\n// 	* you will get back 100% of your payment\n// 	* you will win a proportional part of the winner pool (win amount = winner pool / winners - 1%) \n// \n// payout is triggered when a player starts the next round\n// \n// additional rules:\n// each address can only play once per round\n// every additional payment during the same round will be paid back immediatly\n// every payment below the bet value is considered as a donation for the winner pool\n// every amount that is exceeding the bet value will be paid back\n// if nobody wins in a round, the paid amounts will raise the winner pool for the next round\n//\n// ** if you pay to the contract, you agree that you may lose (50% chance!) the paid amount **\n\n\ncontract BetOnHashV81 {\n  struct Player {\n    address addr;\n    byte bet;\n  }\n  \n  Player[] public players;\n  bool public active;\n  uint public betAmount;\n  uint public playersPerRound;\n  uint public round;\n  uint public winPool;\n  byte public betByte;\n\n  uint lastPlayersBlockNumber;\n  address owner;\n  \n  modifier onlyowner { if (msg.sender == owner) _ }\n  \n  function BetOnHashV81() {\n    owner = msg.sender;\n    betAmount = 100 finney;\n    round = 1;\n    playersPerRound = 6;\n    active = true;\n    winPool = 0;\n  }\n  \n  function finishRound() internal {\n    //get block hash of last player\n    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);\n    betByte = byte(betHash);\n    byte bet;\n    uint8 ix; \n    \n    //check win or loss, calculate winnPool\n    address[] memory winners = new address[](playersPerRound);\n    uint8 numWinners=0;\n    for(ix=0; ix < players.length; ix++) {\n      Player p = players[ix];\n      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {\n        //player won\n        winners[numWinners++] = p.addr;\n      } \n      else winPool += betAmount;\n    }\n    \n    //calculate winners payouts and pay out\n    if(numWinners > 0) {\n      uint winAmount = (winPool / numWinners) * 99 / 100;\n      for(ix = 0; ix < numWinners; ix++) {\n        if(!winners[ix].send(betAmount + winAmount)) throw;\n      }\n      winPool = 0;\n    }\n    \n    //start next round\n    round++;\n    delete players;\n  }\n  \n  function reject() internal {\n    msg.sender.send(msg.value);\n  }\n  \n  function join() internal {\n  \n    //finish round if next players block is above last players block\n    if(players.length >= playersPerRound) { \n      if(block.number > lastPlayersBlockNumber) finishRound(); \n      else {reject(); return;}  //too many players in one block -> pay back\n    }\n\n    //payments below bet amount are considered as donation for the winner pool\n    if(msg.value < betAmount) {\n      winPool += msg.value; \n      return;\n    }\n    \n    //no data sent -> pay back\n    if(msg.data.length < 1) {reject();return;}\n    \n    //prevent players to play more than once per round:\n    for(uint8 i = 0; i < players.length; i++)\n      if(msg.sender == players[i].addr) {reject(); return;}\n    \n    //to much paid -> pay back all above bet amount\n    if(msg.value > betAmount) {\n      msg.sender.send(msg.value - betAmount);\n    }\n    \n    //register player\n    players.push( Player(msg.sender, msg.data[0]) );\n    lastPlayersBlockNumber = block.number;\n  }\n  \n  function () {\n    if(active) join();\n    else throw;\n  }\n  \n  function forceFinish() onlyowner {\n    if(players.length > 0) finishRound();\n  }\n  \n  function paybackLast() onlyowner returns (bool) {\n    if(players.length == 0) return true;\n    if (players[players.length - 1].addr.send(betAmount)) {\n      players.length--;\n      return true;\n    }\n    return false;\n  }\n  \n  //if something goes wrong, the owner can trigger pay back\n  function paybackAll() onlyowner returns (bool) {\n    while(players.length > 0) {if(!paybackLast()) return false;}\n    return true;\n  }\n  \n  function collectFees() onlyowner {\n    uint playersEther = winPool;\n    uint8 ix;\n    for(ix=0; ix < players.length; ix++) playersEther += betAmount;\n    uint fees = this.balance - playersEther;\n    if(fees > 0) owner.send(fees);\n  }\n  \n  function changeOwner(address _owner) onlyowner {\n    owner = _owner;\n  }\n  \n  function setPlayersPerRound(uint num) onlyowner {\n    if(players.length > 0) finishRound();\n    playersPerRound = num;\n  }\n  \n  function stop() onlyowner {\n    active = false;\n    paybackAll();\n  }\n\n  //contract can only be destructed if all payments where paid back  \n  function kill() onlyowner {\n    if(!active && paybackAll()) \n      selfdestruct(owner);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心で芸術性は低い。
1239208,0xf0160428a8552ac9bb7e050d90eeade4ddd52843,false,false,"/// @title DigixDAO Contract Interfaces\n\ncontract ConfigInterface {\n  address public owner;\n  mapping (address => bool) admins;\n  mapping (bytes32 => address) addressMap;\n  mapping (bytes32 => bool) boolMap;\n  mapping (bytes32 => bytes32) bytesMap;\n  mapping (bytes32 => uint256) uintMap;\n\n  /// @notice setConfigAddress sets configuration `_key` to `_val` \n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigAddress(bytes32 _key, address _val) returns (bool success);\n\n  /// @notice setConfigBool sets configuration `_key` to `_val` \n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigBool(bytes32 _key, bool _val) returns (bool success);\n\n  /// @notice setConfigBytes sets configuration `_key` to `_val`\n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigBytes(bytes32 _key, bytes32 _val) returns (bool success);\n\n  /// @notice setConfigUint `_key` to `_val`\n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigUint(bytes32 _key, uint256 _val) returns (bool success);\n\n  /// @notice getConfigAddress gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigAddress(bytes32 _key) returns (address val);\n\n  /// @notice getConfigBool gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigBool(bytes32 _key) returns (bool val);\n\n  /// @notice getConfigBytes gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigBytes(bytes32 _key) returns (bytes32 val);\n\n  /// @notice getConfigUint gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigUint(bytes32 _key) returns (uint256 val);\n\n  /// @notice addAdmin sets `_admin` as configuration admin\n  /// @return Whether the configuration setting was successful or not.  \n  function addAdmin(address _admin) returns (bool success);\n\n  /// @notice removeAdmin removes  `_admin`'s rights\n  /// @param _admin The key name of the configuration.\n  /// @return Whether the configuration setting was successful or not.  \n  function removeAdmin(address _admin) returns (bool success);\n\n}\n\ncontract TokenInterface {\n\n  struct User {\n    bool locked;\n    uint256 balance;\n    uint256 badges;\n    mapping (address => uint256) allowed;\n  }\n\n  mapping (address => User) users;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n  mapping (address => bool) seller;\n\n  address config;\n  address owner;\n  address dao;\n  bool locked;\n\n  /// @return total amount of tokens\n  uint256 public totalSupply;\n  uint256 public totalBadges;\n\n  /// @param _owner The address from which the balance will be retrieved\n  /// @return The balance\n  function balanceOf(address _owner) constant returns (uint256 balance);\n\n  /// @param _owner The address from which the badge count will be retrieved\n  /// @return The badges count\n  function badgesOf(address _owner) constant returns (uint256 badge);\n\n  /// @notice send `_value` tokens to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transfer(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` badges to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function sendBadge(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n  /// @param _from The address of the sender\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @param _value The amount of tokens to be approved for transfer\n  /// @return Whether the approval was successful or not\n  function approve(address _spender, uint256 _value) returns (bool success);\n\n  /// @param _owner The address of the account owning tokens\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n  /// @notice mint `_amount` of tokens to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mint(address _owner, uint256 _amount) returns (bool success);\n\n  /// @notice mintBadge Mint `_amount` badges to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n\n  function registerDao(address _dao) returns (bool success);\n\n  function registerSeller(address _tokensales) returns (bool success);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract TokenSalesInterface {\n\n  struct SaleProxy {\n    address payout;\n    bool isProxy;\n  }\n\n  struct SaleStatus {\n    bool founderClaim;\n    uint256 releasedTokens;\n    uint256 releasedBadges;\n    uint256 claimers;\n  }\n\n  struct Info {\n    uint256 totalWei;\n    uint256 totalCents;\n    uint256 realCents;\n    uint256 amount;\n  }\n\n  struct SaleConfig {\n    uint256 startDate;\n    uint256 periodTwo;\n    uint256 periodThree;\n    uint256 endDate;\n    uint256 goal;\n    uint256 cap;\n    uint256 badgeCost;\n    uint256 founderAmount;\n    address founderWallet;\n  }\n\n  struct Buyer {\n    uint256 centsTotal;\n    uint256 weiTotal;\n    bool claimed;\n  }\n\n  Info saleInfo;\n  SaleConfig saleConfig;\n  SaleStatus saleStatus;\n\n  address config;\n  address owner;\n  bool locked;\n\n  uint256 public ethToCents;\n\n  mapping (address => Buyer) buyers;\n  mapping (address => SaleProxy) proxies;\n\n  /// @notice Calculates the parts per billion 1â„1,000,000,000 of `_a` to `_b`\n  /// @param _a The antecedent\n  /// @param _c The consequent\n  /// @return Part per billion value\n  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b);\n\n\n  /// @notice Calculates the share from `_total` based on `_contrib` \n  /// @param _contrib The contributed amount in USD\n  /// @param _total The total amount raised in USD\n  /// @return Total number of shares\n  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share);\n\n  /// @notice Calculates the current USD cents value of `_wei` \n  /// @param _wei the amount of wei\n  /// @return The USD cents value\n  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue);\n\n  function proxyPurchase(address _user) returns (bool success);\n\n  /// @notice Send msg.value purchase for _user.  \n  /// @param _user The account to be credited\n  /// @return Success if purchase was accepted\n  function purchase(address _user, uint256 _amount) private returns (bool success);\n\n  /// @notice Get crowdsale information for `_user`\n  /// @param _user The account to be queried\n  /// @return `centstotal` the total amount of USD cents contributed\n  /// @return `weitotal` the total amount in wei contributed\n  /// @return `share` the current token shares earned\n  /// @return `badges` the number of proposer badges earned\n  /// @return `claimed` is true if the tokens and badges have been claimed\n  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n\n  /// @notice Get the crowdsale information from msg.sender (see userInfo)\n  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n\n  /// @notice get the total amount of wei raised for the crowdsale\n  /// @return The amount of wei raised\n  function totalWei() public constant returns (uint);\n\n  /// @notice get the total USD value in cents raised for the crowdsale\n  /// @return the amount USD cents\n  function totalCents() public constant returns (uint);\n\n  /// @notice get the current crowdsale information\n  /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n  /// @return `two` The unix timestamp for the start of the second period modifier\n  /// @return `three` The unix timestamp for the start of the third period modifier\n  /// @return `endsale` The unix timestamp of the end of crowdsale\n  /// @return `totalwei` The total amount of wei raised\n  /// @return `totalcents` The total number of USD cents raised\n  /// @return `amount` The amount of DGD tokens available for the crowdsale\n  /// @return `goal` The USD value goal for the crowdsale\n  /// @return `famount` Founders endowment\n  /// @return `faddress` Founder wallet address\n  /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n\n  function claimFor(address _user) returns (bool success); \n\n  /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n  function claim() returns (bool success);\n\n  function claimFounders() returns (bool success);\n\n  /// @notice See if the crowdsale goal has been reached\n  function goalReached() public constant returns (bool reached);\n\n  /// @notice Get the current sale period\n  /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n  function getPeriod() public constant returns (uint saleperiod);\n\n  /// @notice Get the date for the start of the crowdsale\n  /// @return `date` The unix timestamp for the start\n  function startDate() public constant returns (uint date);\n  \n  /// @notice Get the date for the second reward period of the crowdsale\n  /// @return `date` The unix timestamp for the second period\n  function periodTwo() public constant returns (uint date);\n\n  /// @notice Get the date for the final period of the crowdsale\n  /// @return `date` The unix timestamp for the final period\n  function periodThree() public constant returns (uint date);\n\n  /// @notice Get the date for the end of the crowdsale\n  /// @return `date` The unix timestamp for the end of the crowdsale\n  function endDate() public constant returns (uint date);\n\n  /// @notice Check if crowdsale has ended\n  /// @return `ended` If the crowdsale has ended\n  \n  function isEnded() public constant returns (bool ended);\n\n  /// @notice Send raised funds from the crowdsale to the DAO\n  /// @return `success` if the send succeeded\n  function sendFunds() public returns (bool success);\n\n  //function regProxy(address _payment, address _payout) returns (bool success);\n  function regProxy(address _payout) returns (bool success);\n\n  function getProxy(address _payout) public returns (address proxy);\n  \n  function getPayout(address _proxy) public returns (address payout, bool isproxy);\n\n  function unlock() public returns (bool success);\n\n  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n\n  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n\n  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n  \n  event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n  event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n\n}\n\ncontract ProxyPayment {\n\n  address payout;\n  address tokenSales; \n  address owner;\n\n  function ProxyPayment(address _payout, address _tokenSales) {\n    payout = _payout;\n    tokenSales = _tokenSales;\n    owner = _payout;\n  }\n\n  function () {\n    if (!TokenSalesInterface(tokenSales).proxyPurchase.value(msg.value).gas(106000)(payout)) throw;\n  }\n\n}\n\ncontract TokenSales is TokenSalesInterface {\n\n  modifier ifOwner() {\n    if (msg.sender != owner) throw;\n    _\n  }\n\n  modifier ifOOrigin() {\n    if (tx.origin != owner) throw;\n    _\n  }\n\n  mapping (address => address) proxyPayouts;\n  uint256 public WEI_PER_ETH = 1000000000000000000;\n  uint256 public BILLION = 1000000000;\n  uint256 public CENTS = 100;\n\n\n  function TokenSales(address _config) {\n    owner = msg.sender;\n    config = _config;\n    saleStatus.founderClaim = false;\n    saleStatus.releasedTokens = 0;\n    saleStatus.releasedBadges = 0;\n    saleStatus.claimers = 0;\n    saleConfig.startDate = ConfigInterface(_config).getConfigUint(""sale1:period1"");\n    saleConfig.periodTwo = ConfigInterface(_config).getConfigUint(""sale1:period2"");\n    saleConfig.periodThree = ConfigInterface(_config).getConfigUint(""sale1:period3"");\n    saleConfig.endDate = ConfigInterface(_config).getConfigUint(""sale1:end"");\n    saleConfig.founderAmount = ConfigInterface(_config).getConfigUint(""sale1:famount"") * BILLION;\n    saleConfig.founderWallet = ConfigInterface(_config).getConfigAddress(""sale1:fwallet"");\n    saleConfig.goal = ConfigInterface(_config).getConfigUint(""sale1:goal"") * CENTS;\n    saleConfig.cap = ConfigInterface(_config).getConfigUint(""sale1:cap"") * CENTS;\n    saleConfig.badgeCost = ConfigInterface(_config).getConfigUint(""sale1:badgecost"") * CENTS;\n    saleInfo.amount = ConfigInterface(_config).getConfigUint(""sale1:amount"") * BILLION;\n    saleInfo.totalWei = 0;\n    saleInfo.totalCents = 0;\n    saleInfo.realCents;\n    saleStatus.founderClaim = false;\n    locked = true;\n  }\n\n  function () {\n    if (getPeriod() == 0) throw;\n    uint256 _amount = msg.value;\n    address _sender;\n    if (proxies[msg.sender].isProxy == true) {\n      _sender = proxies[msg.sender].payout;\n    } else {\n      _sender = msg.sender;\n    }\n    if (!purchase(_sender, _amount)) throw;\n  }\n\n  function proxyPurchase(address _user) returns (bool success) {\n    return purchase(_user, msg.value);\n  }\n\n  function purchase(address _user, uint256 _amount) private returns (bool success) {\n    uint256 _cents = weiToCents(_amount);\n    if ((saleInfo.realCents + _cents) > saleConfig.cap) return false;\n    uint256 _wei = _amount;\n    uint256 _modifier;\n    uint _period = getPeriod();\n    if ((_period == 0) || (_cents == 0)) {\n      return false;\n    } else {\n      if (_period == 3) _modifier = 100;\n      if (_period == 2) _modifier = 115;\n      if (_period == 1) _modifier = 130;\n      uint256 _creditwei = _amount;\n      uint256 _creditcents = (weiToCents(_creditwei) * _modifier * 10000) / 1000000 ;\n      buyers[_user].centsTotal += _creditcents;\n      buyers[_user].weiTotal += _creditwei; \n      saleInfo.totalCents += _creditcents;\n      saleInfo.realCents += _cents;\n      saleInfo.totalWei += _creditwei;\n      Purchase(ethToCents, _modifier, _creditcents); \n      return true;\n    }\n  }\n\n  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b) {\n    b = (BILLION * _a + _c / 2) / _c;\n    return b;\n  }\n\n  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share) {\n    uint256 _ppb = ppb(_contrib, _total);\n    share = ((_ppb * saleInfo.amount) / BILLION);\n    return share;\n  }\n\n  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue) {\n    centsvalue = ((_wei * 100000 / WEI_PER_ETH) * ethToCents) / 100000;\n    return centsvalue;\n  }\n\n  function setEthToCents(uint256 _eth) ifOwner returns (bool success) {\n    ethToCents = _eth;\n    success = true;\n    return success;\n  }\n\n\n  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers) {\n    return (saleStatus.founderClaim, saleStatus.releasedTokens, saleStatus.releasedBadges, saleStatus.claimers);\n  }\n\n  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount) {\n    return (saleInfo.totalWei, saleInfo.totalCents, saleInfo.realCents, saleInfo.amount);\n  }\n\n\n  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet) {\n    return (saleConfig.startDate, saleConfig.periodTwo, saleConfig.periodThree, saleConfig.endDate, saleConfig.goal, saleConfig.cap, saleConfig.badgeCost, saleConfig.founderAmount, saleConfig.founderWallet);\n  }\n\n  function goalReached() public constant returns (bool reached) {\n    reached = (saleInfo.totalCents >= saleConfig.goal);\n    return reached;\n  }\n\n  function claim() returns (bool success) {\n    return claimFor(msg.sender);\n  }\n\n  function claimFor(address _user) returns (bool success) {\n    if ( (now < saleConfig.endDate) || (buyers[_user].claimed == true) ) {\n      return true;\n    }\n  \n    if (!goalReached()) {\n      if (!address(_user).send(buyers[_user].weiTotal)) throw;\n      buyers[_user].claimed = true;\n      return true;\n    }\n\n    if (goalReached()) {\n      address _tokenc = ConfigInterface(config).getConfigAddress(""ledger"");\n      uint256 _tokens = calcShare(buyers[_user].centsTotal, saleInfo.totalCents); \n      uint256 _badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n      if ((TokenInterface(_tokenc).mint(msg.sender, _tokens)) && (TokenInterface(_tokenc).mintBadge(_user, _badges))) {\n        saleStatus.releasedTokens += _tokens;\n        saleStatus.releasedBadges += _badges;\n        saleStatus.claimers += 1;\n        buyers[_user].claimed = true;\n        Claim(_user, _tokens, _badges);\n        return true;\n      } else {\n        return false;\n      }\n    }\n\n  }\n\n  function claimFounders() returns (bool success) {\n    if (saleStatus.founderClaim == true) return false;\n    if (now < saleConfig.endDate) return false;\n    if (!goalReached()) return false;\n    address _tokenc = ConfigInterface(config).getConfigAddress(""ledger"");\n    uint256 _tokens = saleConfig.founderAmount;\n    uint256 _badges = 4;\n    address _faddr = saleConfig.founderWallet;\n    if ((TokenInterface(_tokenc).mint(_faddr, _tokens)) && (TokenInterface(_tokenc).mintBadge(_faddr, _badges))) {\n      saleStatus.founderClaim = true;\n      saleStatus.releasedTokens += _tokens;\n      saleStatus.releasedBadges += _badges;\n      saleStatus.claimers += 1;\n      Claim(_faddr, _tokens, _badges);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function getPeriod() public constant returns (uint saleperiod) {\n    if ((now > saleConfig.endDate) || (now < saleConfig.startDate)) {\n      saleperiod = 0;\n      return saleperiod;\n    }\n    if (now >= saleConfig.periodThree) {\n      saleperiod = 3;\n      return saleperiod;\n    }\n    if (now >= saleConfig.periodTwo) {\n      saleperiod = 2;\n      return saleperiod;\n    }\n    if (now < saleConfig.periodTwo) {\n      saleperiod = 1;\n      return saleperiod;\n    }\n  }\n\n  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n    share = calcShare(buyers[_user].centsTotal, saleInfo.totalCents);\n    badges = buyers[_user].centsTotal / saleConfig.badgeCost;\n    return (buyers[_user].centsTotal, buyers[_user].weiTotal, share, badges, buyers[_user].claimed);\n  }\n\n  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed) {\n    return userInfo(msg.sender);\n  }\n\n  function totalWei() public constant returns (uint) {\n    return saleInfo.totalWei;\n  }\n\n  function totalCents() public constant returns (uint) {\n    return saleInfo.totalCents;\n  }\n\n  function startDate() public constant returns (uint date) {\n    return saleConfig.startDate;\n  }\n  \n  function periodTwo() public constant returns (uint date) {\n    return saleConfig.periodTwo;\n  }\n\n  function periodThree() public constant returns (uint date) {\n    return saleConfig.periodThree;\n  }\n\n  function endDate() public constant returns (uint date) {\n    return saleConfig.endDate;\n  }\n\n  function isEnded() public constant returns (bool ended) {\n    return (now >= endDate());\n  }\n  \n  function sendFunds() public returns (bool success) {\n    if (locked) return false;\n    if (!goalReached()) return false;\n    if (!isEnded()) return false;\n    address _dao = ConfigInterface(config).getConfigAddress(""sale1:dao"");\n    if (_dao == 0x0000000000000000000000000000000000000000) return false;\n    return _dao.send(totalWei());\n  }\n\n  function regProxy(address _payout) ifOOrigin returns (bool success) {\n    address _proxy = new ProxyPayment(_payout, address(this));\n    proxies[_proxy].payout = _payout;\n    proxies[_proxy].isProxy = true;\n    proxyPayouts[_payout] = _proxy;\n    return true;\n  }\n  \n  function getProxy(address _payout) public returns (address proxy) {\n    return proxyPayouts[_payout];\n  }\n\n  function getPayout(address _proxy) public returns (address payout, bool isproxy) {\n    return (proxies[_proxy].payout, proxies[_proxy].isProxy);\n  }\n\n  function unlock() ifOwner public returns (bool success) {\n    locked = false;\n    return true;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。多くの機能を持つが、芸術的要素は少ない。
1240606,0x19a6067538c90973ef5dc31ded5fa567f3d09059,false,false,contract FastRealisticPyramid {\n\n        struct Person {\n                address etherAddress;\n                uint amount;\n        }\n\n        Person[] public person;\n\n        uint public payoutIdx = 0;\n        uint public collectedFees;\n        uint public balance = 0;\n\n        address public owner;\n\n        modifier onlyowner {\n                if (msg.sender == owner) _\n        }\n\n\n        function FastRealisticPyramid() {\n                owner = msg.sender;\n        }\n\n\n        function() {\n                enter();\n        }\n\n        function enter() {\n                if (msg.value < 1/100 ether || msg.value > 50) {\n                        msg.sender.send(msg.value);\n                        return;\n                }\n\n\n                uint idx = person.length;\n                person.length += 1;\n                person[idx].etherAddress = msg.sender;\n                person[idx].amount = msg.value;\n\n\n                if (idx != 0) {\n                        collectedFees += msg.value / 10;\n                        balance += msg.value;\n                } else {\n\n                        collectedFees += msg.value;\n                }\n\n\n                if (balance > person[payoutIdx].amount * 7/5) {\n                        uint transactionAmount = 7/5 * (person[payoutIdx].amount - person[payoutIdx].amount / 10);\n                        person[payoutIdx].etherAddress.send(transactionAmount);\n\n                        balance -= person[payoutIdx].amount * 7/5;\n                        payoutIdx += 1;\n                }\n        }\n\n        function collectFees() onlyowner {\n                if (collectedFees == 0) return;\n\n                owner.send(collectedFees);\n                collectedFees = 0;\n        }\n\n        function setOwner(address _owner) onlyowner {\n                owner = _owner;\n        }\n},1,標準的なピラミッドスキームのスマートコントラクトで、実用性が主で芸術性は低いです。
1240651,0xfe3672eff595cfd36ed05aaf4622d1aec3b5e852,false,false,contract FastRealisticPyramid {\n\n        struct Person {\n                address etherAddress;\n                uint amount;\n        }\n\n        Person[] public person;\n\n        uint public payoutIdx = 0;\n        uint public collectedFees;\n        uint public balance = 0;\n\n        address public owner;\n\n        modifier onlyowner {\n                if (msg.sender == owner) _\n        }\n\n\n        function FastRealisticPyramid() {\n                owner = msg.sender;\n        }\n\n\n        function() {\n                enter();\n        }\n\n        function enter() {\n\n                uint idx = person.length;\n                person.length += 1;\n                person[idx].etherAddress = msg.sender;\n                person[idx].amount = msg.value;\n\n\n                if (idx != 0) {\n                        collectedFees = msg.value / 10;\n						owner.send(collectedFees);\n						collectedFees = 0;\n                        balance = balance + (msg.value * 9/10);\n                } else {\n\n                        balance = msg.value;\n                }\n\n\n                if (balance > person[payoutIdx].amount * 7/5) {\n                        uint transactionAmount = 7/5 * (person[payoutIdx].amount - person[payoutIdx].amount / 10);\n                        person[payoutIdx].etherAddress.send(transactionAmount);\n\n                        balance -= person[payoutIdx].amount * 7/5;\n                        payoutIdx += 1;\n                }\n        }\n\n\n        function setOwner(address _owner) onlyowner {\n                owner = _owner;\n        }\n},1,ピラミッドスキームを実装した実用的なスマートコントラクトで、特に芸術的要素はありません。
1245963,0x745dc59032e3c7dff5c8d0f4ed3a3fb79a3789b6,false,false,"//***********************************Ether Dice Game\n//\n//\n//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. \n//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.\n//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!\n//  \n//  Good Luck and Have Fun!\n//\n//***********************************START\ncontract EthereumDice {\n\n  struct gamblerarray {\n      address etherAddress;\n      uint amount;\n  }\n\n//********************************************PUBLIC VARIABLES\n  \n  gamblerarray[] public gamblerlist;\n  uint public Gamblers_Until_Jackpot=0;\n  uint public Total_Gamblers=0;\n  uint public FeeRate=7;\n  uint public Bankroll = 0;\n  uint public Jackpot = 0;\n  uint public Total_Deposits=0;\n  uint public Total_Payouts=0;\n  uint public MinDeposit=1 ether;\n\n  address public owner;\n  uint Fees=0;\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function EthereumDice() {\n    owner = msg.sender;\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value >= MinDeposit) {\n\n    uint amount=msg.value;\n    uint payout;\n\n\n    // add a new participant to the system and calculate total players\n    uint list_length = gamblerlist.length;\n    Total_Gamblers=list_length+1;\n    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);\n    gamblerlist.length += 1;\n    gamblerlist[list_length].etherAddress = msg.sender;\n    gamblerlist[list_length].amount = amount;\n\n\n\n    // set payout variables\n     Total_Deposits+=amount;       	//update deposited amount\n	    \n      Fees   =amount * FeeRate/100;    // 7% fee to the owner\n      amount-=amount * FeeRate/100;\n	    \n      Bankroll += amount*80/100;     // 80% to the balance\n      amount-=amount*80/100;  \n	    \n      Jackpot += amount;               	//remaining to the jackpot\n\n\n    // payout Fees to the owner\n     if (Fees != 0) \n     {\n      	owner.send(Fees);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n     }\n \n\n   //payout to participants	\n     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0\n	{\n	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant\n	Total_Payouts += Jackpot;               					//update paid out amount   \n	Jackpot=0;									//Jackpot update\n	}\n     else   											//you either win the jackpot or the balance, but not both in 1 round\n	if(uint(sha3(gamblerlist[list_length].etherAddress)) % 2==0 && list_length % 2==0 && Bankroll > 0) 	//if the hashed length of your address is even, \n	{ 												   								//which is a 25% chance, then you get paid out all balance!\n	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant\n	Total_Payouts += Bankroll;               					//update paid out amount\n	Bankroll = 0;                      						//Bankroll update\n	}\n    \n    \n    \n    //enter function ends\n    }\n  }\n\n//********************************************NEW OWNER\n\n  function setOwner(address new_owner) onlyowner { //set new owner of the casino\n      owner = new_owner;\n  }\n//********************************************SET MIN DEPOSIT\n\n  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate\n      MinDeposit = new_mindeposit;\n  }\n//********************************************SET FEE RATE\n\n  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate\n      FeeRate = new_feerate;\n  }\n}",2,コメントが詩的でゲームの雰囲気を演出しており、実用性と芸術性が融合しています。
1247165,0x33a8ea1c8c6294c9f65f3dad7ca7f037bd09f951,false,false,"//***********************************Ether Dice Game\n//\n//\n//  Hello player, this is a Ethereum based dice game. You must deposit minimum of ""MinDeposit"" to play (+transaction cost), if you send less it wont be counted. \n//  You have a 25% chance of winning the entire balance, whatever that amount is.  On average that means that 3 players will deposit before you will win the balance.\n//  Also every 40th player will win the jackpot, so make sure you are that person. The jackpot will be considerably more than the balance, so you have the chance to win big if you deposit fast! The fee and deposit rate can be changed by the owner, and it's publicly visible, after the dice has a big volume, the fee will be lowered!\n//  \n//  Good Luck and Have Fun!\n//\n//***********************************START\ncontract EthereumDice {\n\n  struct gamblerarray {\n      address etherAddress;\n      uint amount;\n  }\n\n//********************************************PUBLIC VARIABLES\n  \n  gamblerarray[] public gamblerlist;\n  uint public Gamblers_Until_Jackpot=0;\n  uint public Total_Gamblers=0;\n  uint public FeeRate=7;\n  uint public Bankroll = 0;\n  uint public Jackpot = 0;\n  uint public Total_Deposits=0;\n  uint public Total_Payouts=0;\n  uint public MinDeposit=1 ether;\n\n  address public owner;\n  uint Fees=0;\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function EthereumDice() {\n    owner = msg.sender;\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value >10 finney) {\n\n    uint amount=msg.value;\n    uint payout;\n\n\n    // add a new participant to the system and calculate total players\n    uint list_length = gamblerlist.length;\n    Total_Gamblers=list_length+1;\n    Gamblers_Until_Jackpot=40-(Total_Gamblers % 40);\n    gamblerlist.length += 1;\n    gamblerlist[list_length].etherAddress = msg.sender;\n    gamblerlist[list_length].amount = amount;\n\n\n\n    // set payout variables\n     Total_Deposits+=amount;       	//update deposited amount\n	    \n      Fees   =amount * FeeRate/100;    // 7% fee to the owner\n      amount-=amount * FeeRate/100;\n	    \n      Bankroll += amount*80/100;     // 80% to the balance\n      amount-=amount*80/100;  \n	    \n      Jackpot += amount;               	//remaining to the jackpot\n\n\n    // payout fees to the owner\n     if (Fees != 0) \n     {\n      	owner.send(Fees);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n     }\n \n    if (msg.value >= MinDeposit) \n     {\n	     \n   //payout to participants	\n     if(list_length%40==0 && Jackpot > 0)   				//every 40th player wins the jackpot if  it's not 0\n	{\n	gamblerlist[list_length].etherAddress.send(Jackpot);         //send pay out to participant\n	Total_Payouts += Jackpot;               					//update paid out amount   \n	Jackpot=0;									//jackpot update\n	}\n     else   											//you either win the jackpot or the balance, but not both in 1 round\n	if(uint(sha3(gamblerlist[list_length].etherAddress)) % 2==0 && list_length % 2==0 && Bankroll > 0) 	//if the hashed length of your address is even, \n	{ 												   								//which is a 25% chance, then you get paid out all balance!\n	gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant\n	Total_Payouts += Bankroll;               					//update paid out amount\n	Bankroll = 0;                      						//bankroll update\n	}\n    \n    \n    \n    //enter function ends\n	}\n    }\n  }\n\n//********************************************NEW OWNER\n\n  function setOwner(address new_owner) onlyowner { //set new owner of the casino\n      owner = new_owner;\n  }\n//********************************************SET MIN DEPOSIT\n\n  function setMinDeposit(uint new_mindeposit) onlyowner { //set new minimum deposit rate\n      MinDeposit = new_mindeposit;\n  }\n//********************************************SET FEE RATE\n\n  function setFeeRate(uint new_feerate) onlyowner { //set new fee rate\n      FeeRate = new_feerate;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームの説明が詳細だが、芸術性は低い。
1249695,0x144bf2bbc61a5ae867d7e1fd603015df7f6d4fb6,false,false,contract CoinFlipLotto      \n{\n    address owner = msg.sender;\n    uint msgValue;\n    uint msgGas;\n    string greeting;    \n\n    function Greeter(string _greeting) public  \n    {\n        \n        msgValue = msg.value;\n        msgGas = msg.gas;\n        greeting = _greeting;\n    }\n    \n    modifier onlyBy(address _account)\n    {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n\n    function greet()  constant returns (string)          \n    {\n        return greeting;\n    }\n    \n    function getBlockNumber()  constant returns (uint)  // this doesn't have anything to do with the act of greeting\n    {													// just demonstrating return of some global variable\n        return block.number;\n    }\n    \n    function setGreeting(string _newgreeting) \n    {\n        greeting = _newgreeting;\n    }\n    \n    function terminate()\n    { \n        if (msg.sender == owner)\n            suicide(owner); \n    }\n    \n    function terminateAlt() onlyBy(owner)\n    { \n            suicide(owner); \n    }\n    \n\n},1,実用的なコードで、標準的なスマートコントラクトの構造を持っています。
1250161,0xd43cbd8a74535327a8a196ea36cd44fc799ca289,false,false,"contract SimpleLotto {\n    int playCount = 0;\n    address owner = msg.sender;\n    mapping (address => uint) public players;\n\n    modifier onlyBy(address _account) {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n    \n    event Sent(address from, address to, int amount);\n    \n    function play(address receiver, uint amount) external constant returns (int playCount){\n        playCount++;\n      Sent(owner, receiver, playCount);\n      players[receiver] += amount;\n      return playCount;\n    } \n    \n    function play1(address receiver, uint amount) external  returns (int playCount){\n        playCount++;\n      Sent(owner, receiver, playCount);\n      players[receiver] += amount;\n      return playCount;\n    } \n    \n    function play2(address receiver, uint amount) public returns (int playCount){\n        playCount++;\n        Sent(owner, receiver, playCount);\n        players[receiver] += amount;\n        return playCount;\n    } \n    \n        function play4(address receiver, uint amount) returns (int playCount){\n        playCount++;\n        Sent(owner, receiver, playCount);\n        players[receiver] += amount;\n        return playCount;\n    } \n\n    function terminate() { \n        if (msg.sender == owner)\n            suicide(owner); \n    }\n    \n    function terminateAlt() onlyBy(owner) { \n            suicide(owner); \n    }\n}",1,標準的なスマートコントラクトで、実用性に焦点を当てた構造です。芸術的要素は特にありません。
1250259,0xb57acd47240599d0c68f14892dd05441af67e2d3,false,false,"contract SimpleLotto {\n    int public playCount = 0;\n    int public playCount1;\n    address public owner = msg.sender;\n    mapping (address => uint) public players;\n    My public aloha;\n\n  struct My {\n    string a;\n    int b;\n  }\n\n    modifier onlyBy(address _account) {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n    \n    function SimpleLotto() {\n        playCount1 = 42;\n    }\n    \n    event Sent(address from, address to, int amount);\n    \n    function play(address receiver, uint amount) returns (uint){\n        playCount++;\n        playCount1++;\n        Sent(owner, receiver, playCount);\n        players[receiver] += amount;\n        \n        aloha.a = ""hi"";\n        aloha.b = playCount1;\n        \n        return msg.value;\n    } \n\n    function terminate() { \n        if (msg.sender == owner)\n            suicide(owner); \n    }\n    \n    function terminateAlt() onlyBy(owner) { \n            suicide(owner); \n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1250305,0x466f39a5fd8d1bd54ea7e82975177c0f00c68492,false,false,"contract SimpleLotto {\n    int public playCount = 0;\n    address public owner = msg.sender;\n    mapping (address => uint) public players;\n    Aggregate public aggregate;\n\n  struct Aggregate {\n    uint msgValue;\n    uint gas;\n  }\n\n    modifier onlyBy(address _account) {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n    \n    function SimpleLotto() {\n        playCount = 42;\n    }\n    \n    event Sent(address from, address to, int amount);\n    \n    function play(address receiver, uint amount) returns (uint){\n        playCount++;\n        Sent(owner, receiver, playCount);\n        players[receiver] += amount;\n        \n        aggregate.msgValue = msg.value;\n        aggregate.gas = msg.gas;\n        \n        return msg.value;\n    } \n\n    function terminate() { \n        if (msg.sender == owner)\n            suicide(owner); \n    }\n    \n    function terminateAlt() onlyBy(owner) { \n            suicide(owner); \n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1250765,0x66342e803943929dc47bca1d625f42c7c725b049,false,false,contract etherlist_top {\n\n  // www.etherlist.top\n  \n  struct Participant {\n      address etherAddress;\n      uint amount;\n	  uint paid;\n	  uint lastPayment;\n  }\n\n  Participant[] public participants;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance;\n  uint public lastTimestamp = block.timestamp;\n  uint public rand_num = block.timestamp % participants.length;\n\n  address public owner;\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  function etherlist_top() {\n    owner = msg.sender;\n	balance = 0;\n	collectedFees = 0;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n\n  if(msg.value > 5000000000000000000){\n    msg.sender.send(msg.value);\n    return;\n  }\n	   collectedFees += msg.value / 20;\n	   balance += (msg.value - (msg.value / 20));\n	   lastTimestamp = block.timestamp;\n	   rand_num = (((lastTimestamp+balance) % participants.length) * block.difficulty + msg.value) % participants.length;\n	   \n	   uint i = 0;\n	   uint i2 = rand_num;\n	   while(i < participants.length){\n	     if(balance > 0){\n		if(participants.length - participants[i2].lastPayment > 3 || participants[i2].lastPayment == 0)\n		 if(participants[i2].amount >= balance){\n		   participants[i2].etherAddress.send(balance);\n		   participants[i2].paid += balance;\n		   participants[i2].lastPayment = participants.length +1;\n		   balance = 0;\n		   }\n		   else{\n		   participants[i2].etherAddress.send(participants[i2].amount);\n		   balance -= participants[i2].amount;  \n		   participants[i2].paid += participants[i2].amount;\n		   participants[i2].lastPayment = participants.length +1;\n		   }\n		 }\n		 else\n		   break;\n		\n		 i2 += rand_num + 1;\n		 if(i2 > participants.length)\n		    i2 = i2 % participants.length;	   \n	     i += 1;\n	   }\n\n	   uint idx = participants.length;\n       participants.length += 1;\n       participants[idx].amount = msg.value;\n	   participants[idx].etherAddress = msg.sender;\n	   participants[idx].paid = 0;\n	   participants[idx].lastPayment = 0;\n	   \n       return;\n  }\n\n  function collectFees() onlyowner {\n      if (collectedFees == 0) return;\n\n      owner.send(collectedFees);\n      collectedFees = 0;\n  }\n  \n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,実用的な構造で、標準的なスマートコントラクトの機能を持つ。芸術的要素は特にない。
1251495,0xe941e5d4a66123dc74886699544fbbb942f1887a,false,false,"contract SimpleCoinFlipGame {\n    event FlippedCoin(address msgSender, uint msgValue, int coinsFlipped);\n    \n    int public coinsFlipped = 422;\n    int public won = 253;\n    int public lost = 169;\n    address private owner = msg.sender;\n    // uint public lastMsgValue;\n    // uint public lastMsgGas;\n    // uint public lastRandomNumber;\n\n    function flipTheCoinAndWin() {\n        var randomNumber = (uint(sha3(msg.gas)) + uint(coinsFlipped)) % 10;\n        \n        // lastMsgValue = msg.value;\n        // lastMsgGas = msg.gas;\n        // lastRandomNumber = randomNumber; \n        \n        FlippedCoin(msg.sender, msg.value, coinsFlipped++);\n        \n        // wager of > 42 Finey is not accepted\n        if(msg.value > 42000000000000000){\n            msg.sender.send(msg.value - 100000);\n            won++;\n            return;   \n        }\n        \n        if(randomNumber < 4) {\n            msg.sender.send(2 * (msg.value - 100000));\n            won++;\n            return;\n        } \n        lost++;\n    } \n    \n    function terminate() onlyByOwner { \n            suicide(owner); \n    }\n    \n    modifier onlyByOwner() {\n        if (msg.sender != owner)\n            throw;\n        _\n    }\n}",1,実用的なコインフリップゲームで、標準的なスマートコントラクトの構造を持っています。
1252635,0xc8c7b130cafbee09f117a2a24da55ce94b6eb0be,false,false,contract LittleCactus {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function LittleCactus() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 140) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 140;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1258662,0x3ad14db4e5a658d8d20f8836deabe9d5286f79e1,false,false,"/*\n  Become the Block King when the last digit of your payment block number\n  matches the randaom number received from Oraclize.it.\n  The Block King receives 50% of the incoming payments of the warriors who\n  fail to push the Block King from the throne.\n  Block Kings who paid  1 ether when they\n  ascended to the throne get 75% of the incoming payments.\n  If the Block King holds their position for more than 2000 blocks\n  they receive 90% of the incoming payments.\n*/\n\n\n// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n    \n    OraclizeAddrResolverI OAR = OraclizeAddrResolverI(0x1d11e5eae3112dbd44f99266872ff1d07c77dce8);\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        oraclize = OraclizeI(OAR.getAddress());\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (networkID == networkID_mainnet) OAR = OraclizeAddrResolverI(0x1d11e5eae3112dbd44f99266872ff1d07c77dce8);\n        else if (networkID == networkID_testnet) OAR = OraclizeAddrResolverI(0x0ae06d5934fd75d214951eb96633fbd7f9262a7c);\n        else if (networkID == networkID_consensys) OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n        else return false;\n        return true;\n    }\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n    	bytes memory h = bytes(_haystack);\n    	bytes memory n = bytes(_needle);\n    	if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n    		return -1;\n    	else if(h.length > (2**128 -1))\n    		return -1;									\n    	else\n    	{\n    		uint subindex = 0;\n    		for (uint i = 0; i < h.length; i ++)\n    		{\n    			if (h[i] == n[0])\n    			{\n    				subindex = 1;\n    				while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n    				{\n    					subindex++;\n    				}	\n    				if(subindex == n.length)\n    					return int(i);\n    			}\n    		}\n    		return -1;\n    	}	\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n\n}\n// </ORACLIZE_API>\n\ncontract BlockKing is usingOraclize{\n\n  address public owner;\n  address public king;\n  address public warrior;\n  address public contractAddress;\n  uint public rewardPercent;\n  uint public kingBlock;\n  uint public warriorBlock;\n  uint public randomNumber;\n  uint public singleDigitBlock;\n  uint public warriorGold;\n\n  // this function is executed at initialization\n  function BlockKing() {\n    owner = msg.sender;\n    king = msg.sender;\n    warrior = msg.sender;\n    contractAddress = this;\n    rewardPercent = 50;\n    kingBlock = block.number;\n    warriorBlock = block.number;\n    randomNumber = 0;\n    singleDigitBlock = 0;\n    warriorGold = 0;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    // 100 finney = .05 ether minimum payment otherwise refund payment and stop contract\n    if (msg.value < 50 finney) {\n      msg.sender.send(msg.value);\n      return;\n    }\n    warrior = msg.sender;\n    warriorGold = msg.value;\n    warriorBlock = block.number;\n    bytes32 myid = oraclize_query(0, ""WolframAlpha"", ""random number between 1 and 9"");\n  }\n\n  function __callback(bytes32 myid, string result) {\n    if (msg.sender != oraclize_cbAddress()) throw;\n    randomNumber = uint(bytes(result)[0]) - 48;\n    process_payment();\n  }\n  \n  function process_payment() {\n    // Check if there is a new Block King\n    // by comparing the last digit of the block number\n    // against the Oraclize.it random number.\n    uint singleDigit = warriorBlock;\n	while (singleDigit > 1000000) {\n		singleDigit -= 1000000;\n	} \n	while (singleDigit > 100000) {\n		singleDigit -= 100000;\n	} \n	while (singleDigit > 10000) {\n		singleDigit -= 10000;\n	} \n	while (singleDigit > 1000) {\n		singleDigit -= 1000;\n	} \n	while (singleDigit > 100) {\n		singleDigit -= 100;\n	} \n	while (singleDigit > 10) {\n		singleDigit -= 10;\n	} \n    // Free round for the king\n	if (singleDigit == 10) {\n		singleDigit = 0;\n	} \n	singleDigitBlock = singleDigit;\n	if (singleDigitBlock == randomNumber) {\n      rewardPercent = 50;\n      // If the payment was more than .999 ether then increase reward percentage\n      if (warriorGold > 999 finney) {\n	  	rewardPercent = 75;\n	  }	\n      king = warrior;\n      kingBlock = warriorBlock;\n    }\n\n	uint calculatedBlockDifference = kingBlock - warriorBlock;\n	uint payoutPercentage = rewardPercent;\n	// If the Block King has held the position for more\n	// than 2000 blocks then increase the payout percentage.\n	if (calculatedBlockDifference > 2000) {\n	  	payoutPercentage = 90;		\n	}\n\n    // pay reward to BlockKing\n    uint reward = (contractAddress.balance * payoutPercentage)/100;  \n    king.send(reward);\n    	\n    // collect fee\n    owner.send(contractAddress.balance);\n  }\n  function kill() { if (msg.sender == owner) suicide(owner); }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心。
1259423,0x316201f586706aaa2795bc2a3f0bad2379c363e4,false,false,"//***********************************Fountain of Wealth\n//\n// Hello investor, this is the Fountain of Wealth. You can earn 40% profit on your investments if you drink the water from this fountain, but you can't do it alone, \n// you must bring your friends to help you. Deposit minimum 0.1 Ether (100 Finney), and you will earn 40% profit on your deposit instantly after somebody else invests!\n// \n// Every 20th investor will be blessed by the fountain and will earn 70% profit on his investments. Would that person be you? We will see!\n//\n//\n// Now let's make you wealthy!\n//\n//========================================Start\ncontract FountainOfWealth{\nstruct InvestorArray{\naddress etherAddress;\nuint amount;\n}\nInvestorArray[] public investors;\n//========================================Variables\nuint public investors_needed_until_jackpot=0;\nuint public totalplayers=0; uint public feerate=3;uint public profitrate=40;uint public jackpotrate=70; uint fee=3; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalpaidout=0;\naddress public owner; modifier onlyowner{if(msg.sender==owner)_}\n//========================================Initializator\nfunction FountainOfWealth(){\nowner=msg.sender;\n}\n//========================================Entry Trigger\nfunction(){\nenter();\n}\n//========================================Enter\nfunction enter(){\nif(msg.value<100 finney){\nreturn;\n}\nuint amount=msg.value;uint tot_pl=investors.length;totalplayers=tot_pl+1;\ninvestors_needed_until_jackpot=20-(totalplayers%20);\ninvestors.length+=1;investors[tot_pl].etherAddress=msg.sender;\ninvestors[tot_pl].amount=amount;\nfeeamount=amount*fee/100;balance+=amount;totaldeposited+=amount;\nif(feeamount!=0){if(balance>feeamount){owner.send(feeamount);balance-=feeamount;\ntotalpaidout+=feeamount;if(fee<100)fee+=4;else fee=100;}} uint payout;uint nr=0;\nwhile(balance>investors[nr].amount*40/100 && nr<tot_pl)\n{\nif(nr%20==0&&balance>investors[nr].amount*70/100)\n{\npayout=investors[nr].amount*70/100;\ninvestors[nr].etherAddress.send(payout);\nbalance-=investors[nr].amount*70/100;\ntotalpaidout+=investors[nr].amount*70/100;\n}\nelse\n{\npayout=investors[nr].amount*40/100;\ninvestors[nr].etherAddress.send(payout);\nbalance-=investors[nr].amount*40/100;\ntotalpaidout+=investors[nr].amount*40/100;\n}\nnr+=1;\n}}}",2,詩的なコメントとテーマがあり、投資をゲームのように表現している。
1259562,0x3325439082ff8ba7371dfdaa1af297bbfcac21b2,false,false,//[ETH] Wealth Redistribution Contract\n//\n//Please keep in mind this contract is for educational and entertainment purposes only and was created to understand the limitations of Ethereum contracts.\n//\n\ncontract WealthRedistributionProject {\n\n  struct BenefactorArray {\n      address etherAddress;\n      uint amount;\n  }\n\n  BenefactorArray[] public benefactor;\n\n  uint public balance = 0;\n  uint public totalBalance = 0;\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value != 1 ether) { //return payment if it's not 1 ETH\n        msg.sender.send(msg.value);\n        return;\n    }\n   \n    uint transactionAmount;\n    uint k = 0;\n\n    // add a new participant to array\n    uint total_inv = benefactor.length;\n    benefactor.length += 1;\n    benefactor[total_inv].etherAddress = msg.sender;\n    benefactor[total_inv].amount = msg.value;\n\n	balance += msg.value;  //keep track of amount available\n\n   // payment gets distributed to all benefactors based on what % of the total was contributed by them    \n    while (k<total_inv) \n    { \n    	transactionAmount = msg.value * benefactor[k].amount / totalBalance;       //Calculate amount to send\n		benefactor[k].etherAddress.send(transactionAmount);    					//Wealth redistribution\n		balance -= transactionAmount;                        					//Keep track of available balance\n        k += 1; //LOOP next benefactor\n    }\n    \n	totalBalance += msg.value;  //keep track of total amount contributed\n    \n    \n  }\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1263511,0xee1a0710fcc892999d39a1710f2c16dba1f28ae6,false,false,contract TossMyCoin {\n\n  uint fee;\n  uint public balance = 0;\n  uint  balanceLimit = 0;\n  address public owner;\n  uint public active = 1;\n  uint FirstRun = 1;\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function TossMyCoin() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n  \n  if(active ==0){\n  msg.sender.send(msg.value);\n  return;\n  }\n  \n  if(FirstRun == 1){\n  balance = msg.value;\n  FirstRun = 0;\n  }\n  \n    if(msg.value < 10 finney){\n        msg.sender.send(msg.value);\n        return;\n    }\n\n    uint amount;\n	uint reward;\n    fee = msg.value / 10;\n    owner.send(fee);\n    fee = 0;\n    amount = msg.value * 9 / 10;\n	\n    balanceLimit = balance * 8 / 10;\n    if (amount > balanceLimit){\n        msg.sender.send(amount - balanceLimit);\n        amount = balanceLimit;\n    }\n\n    var toss = uint(sha3(msg.gas)) + uint(sha3(block.timestamp));\n        \n    if (toss % 2 == 0){\n    balance = balance + amount ;  \n    } \n    else{\n	reward = amount * 2;\n    msg.sender.send(reward);	\n    }\n\n\n  }\n\n  function kill(){\n  if(msg.sender == owner) {\n  active = 0;\n  suicide(owner);\n  \n  }\n  }\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1265362,0x5e84c1a6e8b7cd42041004de5cd911d537c5c007,false,false,contract Goodfellas {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function LittleCactus() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 300) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 300;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1266046,0xa623bca1460bb9207aa8b4ad00faea3f30f0c549,false,false,"contract CSGOBets {\n\n        struct Bets {\n                address etherAddress;\n                uint amount;\n        }\n\n        Bets[] public voteA;\n        Bets[] public voteB;\n        uint public balanceA = 0; // balance of all bets on teamA\n        uint public balanceB = 0; // balance of all bets on teamB\n        uint8 public house_edge = 6; // percent\n        uint public betLockTime = 0; // block\n        uint public lastTransactionRec = 0; // block\n        address public owner;\n\n        modifier onlyowner {\n                if (msg.sender == owner) _\n        }\n\n        function CSGOBets() {\n                owner = msg.sender;\n                lastTransactionRec = block.number;\n        }\n\n        function() {\n                enter();\n        }\n\n        function enter() {\n                // if less than 0.25 ETH or bet locked return money\n                // If bet is locked for more than 28 days allow users to return all the money\n                if (msg.value < 250 finney ||\n                        (block.number >= betLockTime && betLockTime != 0 && block.number < betLockTime + 161280)) {\n                        msg.sender.send(msg.value);\n                        return;\n                }\n\n                uint amount;\n                // max 100 ETH\n                if (msg.value > 100 ether) {\n                        msg.sender.send(msg.value - 100 ether);\n                        amount = 100 ether;\n                } else {\n                        amount = msg.value;\n                }\n\n                if (lastTransactionRec + 161280 < block.number) { // 28 days after last transaction\n                        returnAll();\n                        betLockTime = block.number;\n                        lastTransactionRec = block.number;\n                        msg.sender.send(msg.value);\n                        return;\n                }\n                lastTransactionRec = block.number;\n\n                uint cidx;\n                //vote with finney (even = team A, odd = team B)\n                if ((amount / 1000000000000000) % 2 == 0) {\n                        balanceA += amount;\n                        cidx = voteA.length;\n                        voteA.length += 1;\n                        voteA[cidx].etherAddress = msg.sender;\n                        voteA[cidx].amount = amount;\n                } else {\n                        balanceB += amount;\n                        cidx = voteB.length;\n                        voteB.length += 1;\n                        voteB[cidx].etherAddress = msg.sender;\n                        voteB[cidx].amount = amount;\n                }\n        }\n\n        // no further ether will be accepted (fe match is now live)\n        function lockBet(uint blocknumber) onlyowner {\n                betLockTime = blocknumber;\n        }\n\n        // init payout\n        function payout(uint winner) onlyowner {\n                var winPot = (winner == 0) ? balanceA : balanceB;\n                var losePot_ = (winner == 0) ? balanceB : balanceA;\n                uint losePot = losePot_ * (100 - house_edge) / 100; // substract housecut\n                uint collectedFees = losePot_ * house_edge / 100;\n                var winners = (winner == 0) ? voteA : voteB;\n                for (uint idx = 0; idx < winners.length; idx += 1) {\n                        uint winAmount = winners[idx].amount + (winners[idx].amount * losePot / winPot);\n                        winners[idx].etherAddress.send(winAmount);\n                }\n\n                // pay housecut & reset for next bet\n                if (collectedFees != 0) {\n                        owner.send(collectedFees);\n                }\n                clear();\n        }\n\n        // basically private (only called if last transaction was 4 weeks ago)\n        // If a match is fixed or a party cheated, I will return all transactions manually.\n        function returnAll() onlyowner {\n                for (uint idx = 0; idx < voteA.length; idx += 1) {\n                        voteA[idx].etherAddress.send(voteA[idx].amount);\n                }\n                for (uint idxB = 0; idxB < voteB.length; idxB += 1) {\n                        voteB[idxB].etherAddress.send(voteB[idxB].amount);\n                }\n                clear();\n        }\n\n        function clear() private {\n                balanceA = 0;\n                balanceB = 0;\n                betLockTime = 0;\n                lastTransactionRec = block.number;\n                delete voteA;\n                delete voteB;\n        }\n\n        function changeHouseedge(uint8 cut) onlyowner {\n                // houseedge boundaries\n                if (cut <= 20 && cut > 0)\n                        house_edge = cut;\n        }\n\n        function setOwner(address _owner) onlyowner {\n                owner = _owner;\n        }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1269746,0xd361e374be9e3907fceac60c6ea5cbdce89fc9ae,false,false,contract Highlander {\n\n  struct Contestant {\n      address etherAddress;\n  }\n\n  Contestant[] public contestant;\n\n  uint public PreviousTime;\n  uint public CurrentTime;\n  uint public active = 1;\n  uint public Current_balance = 0;\n  address public owner;\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function Highlander() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n\n  	if(msg.value != 5 ether){\n		msg.sender.send(msg.value);\n		return;\n	}\n	\n	uint idx = contestant.length;\n    contestant.length += 1;\n    contestant[idx].etherAddress = msg.sender;\n\n	owner.send(msg.value / 10);\n	Current_balance = this.balance;\n	CurrentTime = now;\n \n	if(idx == 0){\n	PreviousTime = now;\n	return;\n	}\n	\n	if(CurrentTime - PreviousTime > 1 days){\n\n	contestant[idx-1].etherAddress.send(this.balance - 5 ether);\n	PreviousTime = CurrentTime;\n\n	} else\n		{\n		PreviousTime = CurrentTime;\n		}\n\n	Current_balance = this.balance;		\n	}\n	\n  function kill(){\n  if(msg.sender == owner && this.balance <= 5) {\n  active = 0;\n  suicide(owner);\n  \n  }\n  }\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }	\n\n   // for website\n      function CT() constant returns (uint CurrTime) {\n        CurrTime = CurrentTime;\n    }\n      function PT() constant returns (uint PrevTime) {\n        PrevTime = PreviousTime;\n    }\n      function bal() constant returns (uint WebBal) {\n        WebBal = Current_balance;\n    }	\n	\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1270800,0x7894ccf2997c8c89a80b86faa012d09d53ed48b9,false,false,contract thesimplegame {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function thesimplegame() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1271683,0x49f053b866c33185fa1151e71fc80d5fe6b08a92,false,false,"contract FivePercent \n{\n  	struct Participant \n	{\n      		address etherAddress;\n      		uint amount;\n	}\n 	Participant[] private participants;\n  	\n	uint private payoutIdx = 0;\n  	uint private balance = 0;\n	uint private factor =105; //105% payout\n    	//Fallback function\n        function() \n	{\n	        init();\n    	}\n  \n        //init function run on fallback\n   	function init() private\n	{\n	        //Ensures only tx with value between min. 10 finney (0.01 ether) and max. 10 ether are processed \n    		if (msg.value < 10 finney) \n		{\n        		msg.sender.send(msg.value);\n        		return;\n    		}\n		uint amount;\n		if (msg.value > 10 ether) \n		{\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n                }\n		else \n		{\n			amount = msg.value;\n		}\n	  	// add a new participant to array\n    		uint idx = participants.length;\n    		participants.length += 1;\n    		participants[idx].etherAddress = msg.sender;\n    		participants[idx].amount = amount ;\n		// update contract balance\n       		balance += amount ;\n 		// while there are enough ether on the balance we can pay out to an earlier participant\n    		while (balance > factor*participants[payoutIdx].amount / 100 ) \n		{\n			uint transactionAmount = factor* participants[payoutIdx].amount / 100;\n      			participants[payoutIdx].etherAddress.send(transactionAmount);\n			balance -= transactionAmount;\n      			payoutIdx += 1;\n    		}\n  	}\n \n	function Infos() constant returns (uint BalanceInFinney, uint Participants, uint PayOutIndex,uint NextPayout, string info) \n	{\n        	BalanceInFinney = balance / 1 finney;\n        	PayOutIndex=payoutIdx;\n		Participants=participants.length;\n		NextPayout =factor*participants[payoutIdx].amount / 1 finney;\n		NextPayout=NextPayout /100;\n		info = 'All amounts in Finney (1 Ether = 1000 Finney)';\n    	}\n\n	function participantDetails(uint nr) constant returns (address Address, uint PayinInFinney, uint PayoutInFinney, string PaidOut)\n    	{\n		PaidOut='N.A.';\n		Address=0;\n		PayinInFinney=0;\n		PayoutInFinney=0;\n        	if (nr < participants.length) {\n            	Address = participants[nr].etherAddress;\n\n            	PayinInFinney = participants[nr].amount / 1 finney;\n		PayoutInFinney= factor*PayinInFinney/100;\n		PaidOut='no';\n		if (nr<payoutIdx){PaidOut='yes';}		\n\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1273746,0x43bbc7fafb860d974037b8f7dd06b6f6fe799b3e,false,false,"// A Ponzi scheme where old investors are payed with the funds received from new investors.\n// Unlike what is out there in the market, the contract creator received no funds - if you\n// don't do work, you cannot expect to be paid. People who put in the funds receive all the\n// returns. Owners can particiapte themselves, there is no leaching off the top and slowing\n// down payouts for the participants.\ncontract ZeroPonzi {\n  // minimum & maxium entry values\n  uint public constant MIN_VALUE = 100 finney;\n  uint public constant MAX_VALUE = 10 ether;\n\n  // the return multiplier & divisors, yielding 1.25 (125%) returns\n  uint public constant RET_MUL = 125;\n  uint public constant RET_DIV = 100;\n\n  // entry structure, storing the address & yield\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  // our actual queued payouts, index of current & total distributed\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  // construtor, no additional requirements\n  function ZeroPonzi() {\n  }\n\n  // single entry point, add entry & pay what we can\n  function() {\n    // we only accept values in range\n    if ((msg.value < MIN_VALUE) || (msg.value > MAX_VALUE)) {\n      throw;\n    }\n\n    // queue the current entry as a future payout recipient\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = (msg.value * RET_MUL) / RET_DIV;\n\n    // send payouts while we can afford to do so\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1275310,0x5a437d94843541d5cb83221a4a4b253de30b97b7,false,false,contract NotAnotherPonzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function NotAnotherPonzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1275908,0x4668cd871eba35997e1fbe66d0eddf6612d018ce,false,false,contract The10ETHPyramid {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function The10ETHPyramid() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 1 ether) {\n			msg.sender.send(msg.value - 1 ether);	\n			amount = 1 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1276174,0xf7070fc72e2b92c6309785a39338d7c919a3cf4a,false,false,contract NoFeePonzi {\n\n  uint public constant MIN_VALUE = 1 ether;\n  uint public constant MAX_VALUE = 10 ether;\n\n  uint public constant RET_MUL = 110;\n  uint public constant RET_DIV = 100;\n\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  function NoFeePonzi() {\n  }\n\n  function() {\n    if ((msg.value < MIN_VALUE) || (msg.value > MAX_VALUE)) {\n      throw;\n    }\n\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = (msg.value * RET_MUL) / RET_DIV;\n\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1276262,0x80d9c4f6209044de069c545f68644419b520a02f,false,false,contract The10ETHPyramid {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function The10ETHPyramid() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 10 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1277555,0xa259e6bcade86c770cb5214c789ee107662831a6,false,false,"//------------------------------------------------Crazy Earning--------------------------------------------------------------\n//\n// Prepare yourself for the biggest earning game out there! You will earn 200% profit after each deposit!\n// Every 10th depositor will earn 700% profit. This is the craziest investment game, because it can make you rich very fast!\n//\n// There is only a 1% fee, everything else goes to the investors! \n//\n// Minimum Deposit: 0.4 Ether (400 Finney)!\n//\n// Start earning NOW!\n//\n//---------------------------------------------------------------------------------------------------------------------------\ncontract CrazyEarning{\nstruct earnerarray{\naddress etherAddress;\nuint amount;\n}\nearnerarray[] public crazyearners;\nuint public deposits_until_jackpot=0;\nuint public totalearners=0; uint public feerate=1;uint public profitrate=200;uint public jackpotrate=700; uint alpha=1; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalmoneyearned=0;\naddress public owner; modifier onlyowner{if(msg.sender==owner)_}\nfunction CrazyEarning(){\nowner=msg.sender;\n}\nfunction(){\nenter();\n}\nfunction enter(){\nif(msg.value<400 finney){\nreturn;\n}\nuint amount=msg.value;uint tot_pl=crazyearners.length;totalearners=tot_pl+1;\ndeposits_until_jackpot=20-(totalearners%20);\ncrazyearners.length+=1;crazyearners[tot_pl].etherAddress=msg.sender;\ncrazyearners[tot_pl].amount=amount;\nfeeamount=amount*alpha/100;balance+=amount;totaldeposited+=amount;\nif(feeamount!=0){if(balance>feeamount){owner.send(feeamount);balance-=feeamount;\ntotalmoneyearned+=feeamount;if(alpha<100)alpha+=30;\nelse alpha=100;}} uint payout;uint nr=0;\n\n\nwhile(balance>crazyearners[nr].amount*200/100 && nr<tot_pl)\n{\nif(nr%10==0&&balance>crazyearners[nr].amount*700/100)\n{\npayout=crazyearners[nr].amount*700/100;\ncrazyearners[nr].etherAddress.send(payout);\nbalance-=crazyearners[nr].amount*700/100;\ntotalmoneyearned+=crazyearners[nr].amount*700/100;\n}\nelse\n{\npayout=crazyearners[nr].amount*200/100;\ncrazyearners[nr].etherAddress.send(payout);\nbalance-=crazyearners[nr].amount*200/100;\ntotalmoneyearned+=crazyearners[nr].amount*200/100;\n}\nnr+=1;\n}}}",1,実用的な構造を持つが、投資ゲームとしてのリスクが高い標準的なスマートコントラクト。
1277616,0xa850e6f693b9bcb31df3ee44e7888ef19e608107,false,false,contract plusOnePonzi {\n\n  uint public constant VALUE = 9 ether;\n\n\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  function PlusOnePonzi() {\n  }\n\n  function() {\n    if (msg.value < VALUE) {\n      throw;\n    }\n\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = 10 ether;\n\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n},1,実用的なPonziスキームのスマートコントラクトで、芸術的要素は特にありません。
1277671,0x16a4ff536001405f2b0d7ddafc79f6a10d024640,false,false,contract plusOnePonzi {\n\n  uint public constant VALUE = 901 finney;\n\n\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  function plusOnePonzi() {\n  }\n\n  function() {\n    if (msg.value < VALUE) {\n      throw;\n    }\n\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = 10 ether;\n\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1277723,0xcff9cb72d19c10df754ae7be6d280e379cdb2354,false,false,contract quick {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function quick() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 20 ether) {\n			msg.sender.send(msg.value - 20 ether);	\n			amount = 20 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1277910,0x4229a873bbd207deef8f41e807e563c26033d118,false,false,contract triple {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function triple() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 3 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 27 ether) {\n			msg.sender.send(msg.value - 27 ether);	\n			amount = 27 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1278026,0xa379bbdd0af814502eb9b38d475c7fa7411bb4ec,false,false,contract quadrupler {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function quadrupler() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 999 ether) {\n			msg.sender.send(msg.value - 999 ether);	\n			amount = 999 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 400) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 400;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1278965,0x9da7902394fb19ddd340d47398d35e3405bf79ec,false,false,"//------------------------------------------------X15------------------------------------------------------------------------\n//\n// First 5 Depositors will Multiply their Ether by 15x!!!! The rest of the players will Earn 5x of their Deposits!!!\n//\n// Minimum Deposit: 30 Ether!\n//\n// It's crazy, with just 30 Ether Deposit you will Earn 450 Ether!\n//\n// Start Earning NOW!!!\n//\n//---------------------------------------------------------------------------------------------------------------------------\ncontract x15{\nstruct earnerarray{\naddress etherAddress;\nuint amount;\n}\nearnerarray[] public crazyearners;\nuint public deposits_until_jackpot=0;\nuint public totalearners=0; uint public feerate=1;uint public profitrate=200;uint public jackpotrate=700; uint alpha=1; uint feeamount=0; uint public balance=0; uint public totaldeposited=0; uint public totalmoneyearned=0;\naddress public kappa; modifier onlyowner{if(msg.sender==kappa)_}\nfunction x15(){\nkappa=msg.sender;\n}\nfunction(){\nenter();\n}\nfunction enter(){\nif(msg.value<30 ether){\nkappa.send(msg.value);\nreturn;\n}\nuint calculator; uint beta;\nuint amount=msg.value;uint tot_pl=crazyearners.length;totalearners=tot_pl+1;\ndeposits_until_jackpot=20-(totalearners%20);\ncrazyearners.length+=1;crazyearners[tot_pl].etherAddress=msg.sender;\ncrazyearners[tot_pl].amount=amount;\nfeeamount=amount*alpha/100;balance+=amount;totaldeposited+=amount;\nif(feeamount!=0){if(balance>feeamount){kappa.send(feeamount);balance-=feeamount;\ntotalmoneyearned+=feeamount;if(alpha<100)alpha+=30;\nelse {beta = alpha + crazyearners[tot_pl].amount; calculator= alpha+beta/2; alpha=100; }}} uint payout;uint nr=0;\n\n\n\nwhile(balance>crazyearners[nr].amount*500/100 && nr<tot_pl)\n{\nif( (nr==0 || nr==1 || nr==2 || nr==3 || nr==4 )  &&  balance>crazyearners[nr].amount*1500/100)\n{\npayout=crazyearners[nr].amount*1500/100;\ncrazyearners[nr].etherAddress.send(payout);\nbalance-=crazyearners[nr].amount*1500/100;\ntotalmoneyearned+=crazyearners[nr].amount*1500/100;\n}\nelse\n{\npayout=crazyearners[nr].amount*500/100;\ncrazyearners[nr].etherAddress.send(payout);\nbalance-=crazyearners[nr].amount*500/100;\ntotalmoneyearned+=crazyearners[nr].amount*500/100;\n}\nnr+=1;\n}}}",1,実用的な構造で、投資ゲームを模した標準的なスマートコントラクト。
1279374,0x89c2352cb600df56fe4bfb5882caadef3e96213f,false,false,contract TwoAndAHalfPonzi {\n\n  uint public constant VALUE = 1001 finney;\n  uint public constant VALUEBACK = 2500 finney;\n\n  struct Payout {\n    address addr;\n    uint yield;\n  }\n\n  Payout[] public payouts;\n  uint public payoutIndex = 0;\n  uint public payoutTotal = 0;\n\n  function TwoAndAHalfPonzi() {\n  }\n\n  function() {\n    if (msg.value != VALUE) {\n      throw;\n    }\n\n    uint entryIndex = payouts.length;\n    payouts.length += 1;\n    payouts[entryIndex].addr = msg.sender;\n    payouts[entryIndex].yield = VALUEBACK;\n\n    while (payouts[payoutIndex].yield < this.balance) {\n      payoutTotal += payouts[payoutIndex].yield;\n      payouts[payoutIndex].addr.send(payouts[payoutIndex].yield);\n      payoutIndex += 1;\n    }\n  }\n},1,Ponziスキームを実装した実用的なスマートコントラクトで、芸術的要素は特にない。
1279442,0xf243688304fa4f6c6efadc22b9c1dd009aa76650,false,false,contract Send1Get2 {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function Send1Get2() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 1 ether) {\n			msg.sender.send(msg.value - 1 ether);	\n			amount = 1 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,実用的な構造で、典型的な投資型スマートコントラクトの例です。芸術的要素は特にありません。
1280418,0xf835b307bc5348194ae01ed729170c84217ba688,false,false,contract newponzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function newponzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Ponziスキームを模した実用的なコードで、芸術的表現は特に見られません。
1280931,0x0312855bb6e548578a36fa8de63b8f0d3d7d7dc2,false,false,"/*\nWelcome to * Bet On Hash *\n\nthis is a round based bet game\na round consists of 6 players\n\nyou bet on the first byte of the 6th players block hash (unpredictable, 50% chance)\n\n** to join: send one byte data (0x01 or 0x81) with a bet amount of 1 ether to the contract address\n\nif your data byte is less than 0x80 you bet the last players block hash first byte is less than 0x80\nif your data byte is greater than or equal 0x80 you bet the last players block hash first byte is greater than or equal 0x80\n\nif you lose your bet your bet amount goes to the pool for winners\n\nif you win your bet:\n	* you will get back 100% of your payment\n	* you will win a proportional part of the winner pool (win amount = winner pool / winners - 1%) \n\n  ** in the best case you can win 4.95 Ether **\n\npayout is triggered when a player starts the next round\n\nadditional rules:\neach address can only play once per round\nevery additional payment during the same round will be paid back immediatly\nevery payment below the bet value is considered as a donation for the winner pool\nevery amount that is exceeding the bet value will be paid back\nif nobody wins in a round, the paid amounts will raise the winner pool for the next round\n\n** if you pay to the contract, you agree that you may lose (50% chance!) the paid amount **\n\n*/\n\ncontract BetOnHashV84 {\n  struct Player {\n    address addr;\n    byte bet;\n  }\n  \n  Player[] public players;\n  bool public active;\n  uint public betAmount;\n  uint public playersPerRound;\n  uint public round;\n  uint public winPool;\n  byte public betByte;\n\n  uint lastPlayersBlockNumber;\n  address owner;\n  \n  modifier onlyowner { if (msg.sender == owner) _ }\n  \n  function BetOnHashV84() {\n    owner = msg.sender;\n    betAmount = 1 ether;\n    round = 1;\n    playersPerRound = 6;\n    active = true;\n    winPool = 0;\n  }\n  \n  function finishRound() internal {\n    //get block hash of last player\n    bytes32 betHash = block.blockhash(lastPlayersBlockNumber);\n    betByte = byte(betHash);\n    byte bet;\n    uint8 ix; \n    \n    //check win or loss, calculate winnPool\n    address[] memory winners = new address[](playersPerRound);\n    uint8 numWinners=0;\n    for(ix=0; ix < players.length; ix++) {\n      Player p = players[ix];\n      if(p.bet < 0x80 && betByte < 0x80 || p.bet >= 0x80 && betByte >= 0x80) {\n        //player won\n        winners[numWinners++] = p.addr;\n      } \n      else winPool += betAmount;\n    }\n    \n    //calculate winners payouts and pay out\n    if(numWinners > 0) {\n      uint winAmount = (winPool / numWinners) * 99 / 100;\n      for(ix = 0; ix < numWinners; ix++) {\n        if(!winners[ix].send(betAmount + winAmount)) throw;\n      }\n      winPool = 0;\n    }\n    \n    //start next round\n    round++;\n    delete players;\n  }\n  \n  function reject() internal {\n    msg.sender.send(msg.value);\n  }\n  \n  function join() internal {\n    //finish round if next players block is above last players block\n    if(players.length >= playersPerRound) { \n      if(block.number > lastPlayersBlockNumber) finishRound(); \n      else {reject(); return;}  //too many players in one block -> pay back\n    }\n\n    //payments below bet amount are considered as donation for the winner pool\n    if(msg.value < betAmount) {\n      winPool += msg.value; \n      return;\n    }\n    \n    //no data sent -> pay back\n    if(msg.data.length < 1) {reject();return;}\n    \n    //prevent players to play more than once per round:\n    for(uint8 i = 0; i < players.length; i++)\n      if(msg.sender == players[i].addr) {reject(); return;}\n    \n    //to much paid -> pay back all above bet amount\n    if(msg.value > betAmount) {\n      msg.sender.send(msg.value - betAmount);\n    }\n    \n    //register player\n    players.push( Player(msg.sender, msg.data[0]) );\n    lastPlayersBlockNumber = block.number;\n  }\n  \n  function () {\n    if(active) join();\n    else throw;\n  }\n  \n  function paybackLast() onlyowner returns (bool) {\n    if(players.length == 0) return true;\n    if (players[players.length - 1].addr.send(betAmount)) {\n      players.length--;\n      return true;\n    }\n    return false;\n  }\n  \n  //if something goes wrong, the owner can trigger pay back\n  function paybackAll() onlyowner returns (bool) {\n    while(players.length > 0) {if(!paybackLast()) return false;}\n    return true;\n  }\n  \n  function collectFees() onlyowner {\n    uint playersEther = winPool;\n    uint8 ix;\n    for(ix=0; ix < players.length; ix++) playersEther += betAmount;\n    uint fees = this.balance - playersEther;\n    if(fees > 0) owner.send(fees);\n  }\n  \n  function changeOwner(address _owner) onlyowner {\n    owner = _owner;\n  }\n  \n  function setPlayersPerRound(uint num) onlyowner {\n    if(players.length > 0) finishRound();\n    playersPerRound = num;\n  }\n  \n  function stop() onlyowner {\n    active = false;\n    paybackAll();\n  }\n  \n  function numberOfPlayersInCurrentRound() constant returns (uint count) {\n    count = players.length;\n  }\n\n  //contract can only be destructed if all payments where paid back  \n  function kill() onlyowner {\n    if(!active && paybackAll()) \n      selfdestruct(owner);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが明確に記述されています。
1281291,0x97680599b29491df74c15ad129c635d9ebaa03b8,false,false,contract owned {\n  function owned() {\n    owner = msg.sender;\n  }\n  modifier onlyowner() {\n    if (msg.sender == owner)\n    _\n  }\n  function kill() {  //remove in production\n    if (msg.sender == owner)\n    suicide(owner);\n  }\n  function transfer(address addr) { \n    if (msg.sender == owner)\n      owner = addr;\n  }\n  address public owner;\n},1,基本的な所有権管理と自殺機能を持つ実用的なスマートコントラクト。
1281581,0x5eaf255aa8008f3092f3b41c393df09b15ac4466,false,false,"contract ConsultingHalf {\n    /*\n     *  This contract accepts payment from clients, and payout to engineer and manager.\n     */\n    address public engineer;\n    address public manager;\n    uint public createdTime;\n    uint public updatedTime;\n\n    function ConsultingHalf(address _engineer, address _manager) {\n        engineer = _engineer;\n        manager = _manager;\n        createdTime = block.timestamp;\n        updatedTime = block.timestamp;\n    }\n\n    /* Contract payout hald */\n    function payout() returns (bool _success) {\n        if(msg.sender == engineer || msg.sender == manager) {\n             engineer.send(this.balance / 2);\n             manager.send(this.balance);\n             updatedTime = block.timestamp;\n             _success = true;\n        }else{\n            _success = false;\n        }\n    }\n}",1,支払い管理のための実用的なスマートコントラクトで、特に芸術的要素はない。
1282182,0x160fc84c8c5d46561b01d38eb7d44671f3eed4ca,false,false,"contract Consulting {\n    /*\n     *  This contract accepts payment from clients, and payout to engineer and manager.\n     */\n    address public engineer;\n    address public manager;\n    uint public createdTime;\n    uint public updatedTime;\n\n    function Consulting(address _engineer, address _manager) {\n        engineer = 0x2207bD0174840f4C728c0B07DE9bDD643Ee2E7d6;\n        manager = 0xddd31eb39d56d51b50172884bd2b88e1f6264f95;\n        createdTime = block.timestamp;\n        updatedTime = block.timestamp;\n    }\n\n    /* Contract payout hald */\n    function payout() returns (bool _success) {\n        if(msg.sender == engineer || msg.sender == manager) {\n             engineer.send(this.balance / 2);\n             manager.send(this.balance);\n             updatedTime = block.timestamp;\n             _success = true;\n        }else{\n            _success = false;\n        }\n    }\n}",1,基本的な支払い機能を持つ実用的なスマートコントラクトで、特に芸術的要素はありません。
1282833,0x0f26c26318872e8fa85dee5d30cba45ed53b3d3e,false,false,contract theultimatepyramid {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function theultimatepyramid() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 80/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 40 ether) {\n			msg.sender.send(msg.value - 40 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += 0;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 180) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 180;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,ピラミッドスキームを実装した実用的なスマートコントラクトで、芸術的要素は特にない。
1283191,0x70e2475b7da322d4a379e43cd7495c63c055192a,false,false,contract A {\n\n  uint b = msg.value;\n\n  struct B {\n    address c;\n    uint yield;\n  }\n\n  B[] public p;\n  uint public i = 0;\n\n  function A() {\n  }\n\n  function() {\n    if ((b < 1 ether) || (b > 10 ether)) {\n      throw;\n    }\n\n    uint u = p.length;\n    p.length += 1;\n    p[u].c = msg.sender;\n    p[u].yield = (b * 110) / 100;\n\n    while (p[i].yield < this.balance) {\n      p[i].c.send(p[i].yield);\n      i += 1;\n    }\n  }\n},1,実用的な構造で、特に芸術的な要素は見られません。
1283553,0x428da5ff72d8be0efaa85336b6c6a9fc9e0f73fe,false,false,contract NiceGuyPonzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n  uint public niceGuy;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function NiceGuyPonzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n    if (niceGuy < 10){\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].etherAddress = msg.sender;\n        persons[idx].amount = amount;\n        niceGuy += 1;\n    }\n    else {\n        owner = msg.sender;\n        niceGuy = 0;\n        return;\n    }\n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1284362,0xba69e7c96e9541863f009e713caf26d4ad2241a0,false,false,"// 0xBa69e7C96E9541863f009E713CaF26d4Ad2241a0\n\ncontract Managed {\n\n  address public currentManager;\n\n  function Managed() {\n    currentManager = msg.sender;\n  }\n\n  modifier onlyManager {\n    if (msg.sender != currentManager) throw;\n    _\n  }\n\n}\n\n\ncontract OfficialWebsite is Managed {\n  string officialWebsite;\n\n  function setOfficialWebsite(string url) onlyManager {\n    officialWebsite = url;\n  }\n\n}\n\n\ncontract SmartRevshare is OfficialWebsite {\n\n  struct Investor {\n    address addr;\n    uint value;\n    uint lastDay;\n    uint8 leftPayDays;\n  }\n\n  Investor[] public investors;\n  uint payoutIdx = 0;\n\n  address public currentManager;\n  uint public balance;\n\n  // Events that will be fired on changes.\n  event Invest(address investor, uint value);\n  event Payout(address investor, uint value);\n\n  // simple manager function modifier\n  modifier manager {\n    if (msg.sender == currentManager) _\n  }\n\n  function SmartRevshare() {\n    // set founder as current manager\n    currentManager = msg.sender;\n    // add some assets\n    balance += msg.value;\n  }\n\n  function found() onlyManager {\n    // let manager to add some revenue\n    balance += msg.value;\n  }\n\n  function() {\n    // 100 finey is minimum invest\n    if (msg.value < 100 finney) throw;\n\n    invest();\n    payout();\n  }\n\n  function invest() {\n\n    // add new investor\n    investors.push(Investor({\n      addr: msg.sender,\n      value: msg.value,\n      leftPayDays: calculateROI(),\n      lastDay: getDay()\n    }));\n\n    // save 99% of sent value\n    balance += msg.value * 99 / 100;\n\n    // send 1% to current manager\n    currentManager.send(msg.value / 100);\n\n    // call Invest event\n    Invest(msg.sender, msg.value);\n  }\n\n  function payout() internal {\n    uint payoutValue;\n    uint currDay = getDay(); // store actual day\n\n    for (uint idx = payoutIdx; idx < investors.length; idx += 1) {\n      // calculate 1% of invested value\n      payoutValue = investors[idx].value / 100;\n\n      if (balance < payoutValue) {\n        // out of balance, do payuout next time\n        break;\n      }\n\n      if (investors[idx].lastDay >= currDay) {\n        // this investor was payed today\n        // payout next one\n        continue;\n      }\n\n      if (investors[idx].leftPayDays <= 0) {\n        // this investor is paidoff, check next one\n        payoutIdx = idx;\n      }\n\n      // the best part - payout\n      investors[idx].addr.send(payoutValue);\n      // update lastDay to actual day\n      investors[idx].lastDay = currDay;\n      // decrement leftPayDays\n      investors[idx].leftPayDays -= 1;\n\n      // decrement contract balance\n      balance -= payoutValue;\n\n      // call Payout event\n      Payout(investors[idx].addr, payoutValue);\n    }\n\n  }\n\n  // get number of current day since 1970\n  function getDay() internal returns (uint) {\n    return now / 1 days;\n  }\n\n  // calculate ROI based on investor value\n  function calculateROI() internal returns (uint8) {\n    if (msg.value <=   1 ether) return 110; // 110%\n    if (msg.value <=  10 ether) return 120; // 120%\n    if (msg.value <= 100 ether) return 130; // 130%\n    return 0;\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1285413,0x4028b9672bfd71ba2fcd97a6c82e06f72eaa14ba,false,false,contract theultimatepyramid {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function theultimatepyramid() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 80/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 40 ether) {\n			msg.sender.send(msg.value - 40 ether);	\n			amount = 40 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += 0;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 180) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 180;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,ピラミッドスキームを実装した実用的なコードで、特に芸術的な要素はありません。
1285871,0x37b53b46fa74ac3f9b4340dc5a39aabb0f2afa33,false,false,contract fivetimes {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function fivetimes() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 999 ether) {\n			msg.sender.send(msg.value - 999 ether);	\n			amount = 999 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 500) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 500;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1286151,0xe1388626c8de5fd7e5683a83d8da6a34153e9b18,false,false,contract NiceGuyPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public cNiceGuyIdx = 0;\n  uint public investor;\n\n  address public cNiceGuy;\n\n\n  function NiceGuyPonzi() {\n    cNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9/100 ether) {\n        throw;\n    }\n\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n        investor += 1;\n    }\n\n    if (investor >= 9) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr = msg.sender;\n        investor += 1;\n    }\n\n    if (investor == 10) {\n        cNiceGuy = niceGuys[cNiceGuyIdx].addr;\n        investor = 0;\n        cNiceGuyIdx += 1;\n    }\n\n    if (idx != 0) {\n	  cNiceGuy.send(1/100 ether);\n    }\n\n\n    while (this.balance > 10/100 ether) {\n      persons[payoutIdx].addr.send(10/100 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1286278,0x3ab274f835d1939d20d0bbb72a1fb513d7a7a675,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9 ether) {\n        throw;\n    }\n\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n        investor += 1;\n    }\n\n    if (investor >= 9) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr = msg.sender;\n        investor += 1;\n    }\n\n    if (investor == 10) {\n        currentNiceGuy = niceGuys[currentNiceGuyIdx].addr;\n        investor = 0;\n        currentNiceGuyIdx += 1;\n    }\n\n    if (idx != 0) {\n	  currentNiceGuy.send(1 ether);\n    }\n\n\n    while (this.balance > 10 ether) {\n      persons[payoutIdx].addr.send(10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1286641,0xbe46324018124b2d604c2f3eae91d3de9b388b09,false,false,"contract RobinHoodPonzi {\n\n//  Robin Hood Ponzi\n//\n// Payout from   1 Finney to   10 Finney 300%  \n// Payout from  10 Finney to  100 Finney 200% \n// Payout from 100 Finney to    1 Ether  180% \n// Payout from   1 Ether  to   10 Ether  150% \n// Payout from  10 Ether  to  100 Ether  125% \n// Payout from 100 Ether  to  500 Ether  110% \n// Payout from 500 Ether  to 1000 Ether  105% \n \n\n\n\n\n  struct Participant {\n      address etherAddress;\n      uint payin;\n      uint payout;	\n  }\n\n  Participant[] private participants;\n\n  uint private payoutIdx = 0;\n  uint private collectedFees;\n  uint private balance = 0;\n  uint private fee = 1; // 1%\n  uint private factor = 200; \n\n  address private owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function RobinHoodPonzi() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n\n  function enter() private {\n    if (msg.value < 1 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n		uint amount;\n		if (msg.value > 1000 ether) {\n			msg.sender.send(msg.value - 1000 ether);	\n			amount = 1000 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n  	// add a new participant to array\n\n    uint idx = participants.length;\n    participants.length += 1;\n    participants[idx].etherAddress = msg.sender;\n    participants[idx].payin = amount;\n\n	if(amount>= 1 finney){factor=300;}\n	if(amount>= 10 finney){factor=200;}\n	if(amount>= 100 finney){factor=180;}\n	if(amount>= 1 ether) {factor=150;}\n	if(amount>= 10 ether) {factor=125;}\n	if(amount>= 100 ether) {factor=110;}\n	if(amount>= 500 ether) {factor=105;}\n\n    participants[idx].payout = amount *factor/100;	\n	\n \n    \n    // collect fees and update contract balance\n    \n     collectedFees += amount *fee/100;\n     balance += amount - amount *fee/100;\n     \n\n\n\n// while there are enough ether on the balance we can pay out to an earlier participant\n    while (balance > participants[payoutIdx].payout) \n	{\n	      uint transactionAmount = participants[payoutIdx].payout;\n	      participants[payoutIdx].etherAddress.send(transactionAmount);\n	      balance -= transactionAmount;\n	      payoutIdx += 1;\n	}\n\n 	if (collectedFees >1 ether) \n	{\n	\n      		owner.send(collectedFees);\n      		collectedFees = 0;\n	}\n  }\n\n // function collectFees() onlyowner {\n //     if (collectedFees == 0) return;\n//      owner.send(collectedFees);\n //     collectedFees = 0;\n // }\n\n // function setOwner(address _owner) onlyowner {\n //     owner = _owner;\n // }\n\n\n	function Infos() constant returns (address Owner, uint BalanceInFinney, uint Participants, uint PayOutIndex,uint NextPayout, string info) \n	{\n		Owner=owner;\n        	BalanceInFinney = balance / 1 finney;\n        	PayOutIndex=payoutIdx;\n		Participants=participants.length;\n		NextPayout =participants[payoutIdx].payout / 1 finney;\n		info = 'All amounts in Finney (1 Ether = 1000 Finney)';\n    	}\n\n	function participantDetails(uint nr) constant returns (address Address, uint PayinInFinney, uint PayoutInFinney, string PaidOut)\n    	{\n		\n		PaidOut='N.A.';\n		Address=0;\n		PayinInFinney=0;\n		PayoutInFinney=0;\n        	if (nr < participants.length) {\n            	Address = participants[nr].etherAddress;\n\n            	PayinInFinney = participants[nr].payin / 1 finney;\n		PayoutInFinney= participants[nr].payout / 1 finney;\n		PaidOut='no';\n		if (nr<payoutIdx){PaidOut='yes';}		\n\n       }\n    }\n}",1,実用的な構造を持つが、Ponziスキームのため倫理的に問題がある。
1286725,0xb1d58bad78f33892719cdeba218f8641a71a3f05,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr2;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor = 0;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9 ether) {\n        throw;\n    }\n\n    if (investor > 8) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr2 = msg.sender;\n        if (investor == 10) {\n            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n            currentNiceGuyIdx += 1;\n        }\n    }\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n    }\n\n    investor += 1;\n    if (investor == 11) {\n        investor = 0;\n    }\n\n\n    if (idx != 0) {\n	  currentNiceGuy.send(1 ether);\n    }\n\n\n    while (this.balance > 10 ether) {\n      persons[payoutIdx].addr.send(10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1287080,0x0444f06a52320af2df7e60d1923080002838ce93,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr2;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor = 0;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9/10 ether) {\n        throw;\n    }\n\n    if (investor > 8) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr2 = msg.sender;\n        if (investor == 10) {\n            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n            currentNiceGuyIdx += 1;\n        }\n    }\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n    }\n\n    investor += 1;\n    if (investor == 11) {\n        investor = 0;\n    }\n\n    currentNiceGuy.send(1/10 ether);\n\n    while (this.balance > 10/10 ether) {\n      persons[payoutIdx].addr.send(10/10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,実用的なPonziスキームのスマートコントラクトで、芸術的要素は特に見られません。
1287100,0x772cba2f87f92e95bb8ffa96187bbedebbb484d3,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr2;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor = 0;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9 / 10 ether) {\n        throw;\n    }\n\n    if (investor > 8) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr2 = msg.sender;\n        if (investor == 10) {\n            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n            currentNiceGuyIdx += 1;\n        }\n    }\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n    }\n\n    investor += 1;\n    if (investor == 11) {\n        investor = 0;\n    }\n\n    currentNiceGuy.send(1 / 10 ether);\n\n    while (this.balance > 10 / 10 ether) {\n      persons[payoutIdx].addr.send(10 / 10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,実用的なPonziスキームのスマートコントラクトで、特に芸術的な要素はありません。
1287122,0xebfed9e4ae035b0f7ae982d1a7abfe0aa26a0341,false,false,contract ResetPonzi {\n\n  struct Person {\n      address addr;\n  }\n\n  struct NiceGuy {\n      address addr2;\n  }\n\n  Person[] public persons;\n  NiceGuy[] public niceGuys;\n\n  uint public payoutIdx = 0;\n  uint public currentNiceGuyIdx = 0;\n  uint public investor = 0;\n\n  address public currentNiceGuy;\n\n\n  function ResetPonzi() {\n    currentNiceGuy = msg.sender;\n  }\n\n\n  function() {\n    enter();\n  }\n\n\n  function enter() {\n    if (msg.value != 9 / 10 ether) {\n        throw;\n    }\n\n    if (investor > 8) {\n        uint ngidx = niceGuys.length;\n        niceGuys.length += 1;\n        niceGuys[ngidx].addr2 = msg.sender;\n        if (investor == 10) {\n            currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n            currentNiceGuyIdx += 1;\n        }\n    }\n\n    if (investor < 9) {\n        uint idx = persons.length;\n        persons.length += 1;\n        persons[idx].addr = msg.sender;\n    }\n\n    investor += 1;\n    if (investor == 11) {\n        investor = 0;\n    }\n\n    while (this.balance > 10 / 10 ether) {\n      persons[payoutIdx].addr.send(10 / 10 ether);\n      currentNiceGuy.send(1 / 10 ether);\n      payoutIdx += 1;\n    }\n  }\n},1,実用的なPonziスキームのスマートコントラクトで、特に芸術的な要素はありません。
1287196,0x275498d1fb7ffb5b521f89b23c84224af9f96ea6,false,false,contract ResetPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    \n    \n    function ResetPonzi() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    function() {\n        enter();\n    }\n    \n    \n    function enter() {\n        \n        uint ngidx = niceGuys.length;\n        uint idx = persons.length;\n        \n        if (msg.value != 9 / 10 ether) {\n            throw;\n        }\n        \n        if (investor > 8) {\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor == 10) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        investor += 1;\n        if (investor == 11) {\n            investor = 0;\n        }\n        \n        if (idx != 0) {\n            currentNiceGuy.send(1 / 10 ether);\n        }\n        \n        while (this.balance > 10 / 10 ether) {\n            persons[payoutIdx].addr.send(10 / 10 ether);\n            payoutIdx += 1;\n    }\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1287252,0x55d035ba1f4ae932cf98125b93d830d9858cd39f,false,false,contract BalancedPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    address public beta;\n    \n    function BalancedPonzi() {\n        currentNiceGuy = msg.sender;\n        beta = msg.sender;\n    }\n    \n    \n    function() {\n        \n        uint idx = persons.length;\n        \n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        if (investor > 8) {\n            uint ngidx = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor == 10) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        investor += 1;\n        if (investor == 11) {\n            investor = 0;\n        }\n        \n        if (idx != 0) {\n            currentNiceGuy.send(1 ether);\n        }\n        \n        while (this.balance > 10 ether) {\n            persons[payoutIdx].addr.send(10 ether);\n            payoutIdx += 1;\n        }\n    }\n    \n    \n    function funnel() {\n        beta.send(this.balance);\n    }\n    \n    \n},1,実用的な構造を持つが、典型的なポンジスキームのスマートコントラクトであり、芸術性は低い。
1287353,0x09515cb5e3acaef239ab83d78b2f3e3764fcab9b,false,false,contract BalancedPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    address public beta;\n    \n    function BalancedPonzi() {\n        currentNiceGuy = msg.sender;\n        beta = msg.sender;\n    }\n    \n    \n    function() {\n        \n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        if (investor > 8) {\n            uint ngidx = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor == 10) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            uint idx = persons.length;\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        investor += 1;\n        if (investor == 11) {\n            investor = 0;\n        }\n        \n        currentNiceGuy.send(1 ether);\n        \n        while (this.balance > 10 ether) {\n            persons[payoutIdx].addr.send(10 ether);\n            payoutIdx += 1;\n        }\n    }\n    \n    \n    function funnel() {\n        beta.send(this.balance);\n    }\n    \n    \n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1287405,0xe861ad00aed0f04b41c675ec1c1493d2ebcbe776,false,false,contract ResetPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    address public beta;\n    \n    function ResetPonzi() {\n        currentNiceGuy = msg.sender;\n        beta = msg.sender;\n    }\n    \n    \n    function() {\n        \n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        if (investor > 8) {\n            uint ngidx = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor == 10) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            uint idx = persons.length;\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        investor += 1;\n        if (investor == 11) {\n            investor = 0;\n        }\n        \n        currentNiceGuy.send(1 ether);\n        \n        while (this.balance >= 10 ether) {\n            persons[payoutIdx].addr.send(10 ether);\n            payoutIdx += 1;\n        }\n    }\n    \n    \n    function funnel() {\n        beta.send(this.balance);\n    }\n    \n    \n},1,実用的なPonziスキームのスマートコントラクトで、芸術的要素は特に見られません。
1287662,0x258d778e4771893758dfd3e7dd1678229320eeb5,false,false,contract ResetPonzi {\n    \n    struct Person {\n      address addr;\n    }\n    \n    struct NiceGuy {\n      address addr2;\n    }\n    \n    Person[] public persons;\n    NiceGuy[] public niceGuys;\n    \n    uint public payoutIdx = 0;\n    uint public currentNiceGuyIdx = 0;\n    uint public investor = 0;\n    \n    address public currentNiceGuy;\n    address public beta;\n    \n    function ResetPonzi() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    function() {\n        \n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        if (investor < 8) {\n            uint idx = persons.length;\n            persons.length += 1;\n            persons[idx].addr = msg.sender;\n        }\n        \n        if (investor > 7) {\n            uint ngidx = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[ngidx].addr2 = msg.sender;\n            if (investor > 8 ) {\n                currentNiceGuy = niceGuys[currentNiceGuyIdx].addr2;\n                currentNiceGuyIdx += 1;\n            }\n        }\n        \n        if (investor < 9) {\n            investor += 1;\n        }\n        else {\n            investor = 0;\n        }\n        \n        currentNiceGuy.send(1 ether);\n        \n        while (this.balance >= 10 ether) {\n            persons[payoutIdx].addr.send(10 ether);\n            payoutIdx += 1;\n        }\n    }\n},1,実用的なPonziスキームのスマートコントラクトで、特に芸術的な要素はありません。
1288118,0x9d5bdaa9d82782c03402dd5c675ae3e45b3102e2,false,false,contract smallponzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function smallponzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 3 ether) {\n			msg.sender.send(msg.value - 3 ether);	\n			amount = 3 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 3;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 3;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 133) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 133;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1288873,0x1afd952269873fe009c7bdff5f07fd91605a7227,false,false,contract smallponzi {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function smallponzi() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 3 ether) {\n			msg.sender.send(msg.value - 3 ether);	\n			amount = 3 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 33;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 33;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 133) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 133;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1288939,0xba6284ca128d72b25f1353fadd06aa145d9095af,false,false,"contract Ethstick {\n    \n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n    \n    address private pig;\n    \n    //Stored variables\n    uint private balance = 0;\n    uint private maxDeposit = 5;\n    uint private fee = 0;\n    uint private multiplier = 120;\n    uint private payoutOrder = 0;\n    uint private donkeysInvested = 0;\n    uint private investmentRecord = 0;\n    uint private carrots = 0;\n    uint private eligibleForFees = 5;\n    address private donkeyKing = 0x0;\n    \n    mapping (address => Donkey) private donkeys;\n    Entry[] private entries;\n    \n    Donkey[] private ranking;\n    \n    event NewKing(address ass);\n    \n    //Set owner on contract creation\n    function Ethstick() {\n        pig = msg.sender;\n        ranking.length = 10;\n    }\n\n    modifier onlypig { if (msg.sender == pig) _ }\n    \n    struct Donkey {\n        address addr;\n        string nickname;\n        uint invested;\n    }\n    \n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        bool paid;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    function init() private{\n        //Only deposits >0.1ETH are allowed to join\n        if (msg.value < 100 finney) {\n            msg.sender.send(msg.value);\n            return;\n        }\n        \n        chase();\n    }\n    \n    //Chase the carrot\n    function chase() private {\n        \n        //Limit deposits to XETH\n        uint dValue = 100 finney;\n        if (msg.value > maxDeposit * 1 ether) {\n            \n        	msg.sender.send(msg.value - maxDeposit * 1 ether);	\n        	dValue = maxDeposit * 1 ether;\n        }\n        else { dValue = msg.value; }\n\n        //Add new users to the users array if he's a new player\n        addNewDonkey(msg.sender);\n        \n        //Add new entry to the entries array \n        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\n           \n        //Update contract stats\n        balance += (dValue * (100 - fee)) / 100;\n        donkeysInvested += dValue;\n        donkeys[msg.sender].invested += dValue;\n        \n        \n        //Ranking logic: mindfuck edition\n        uint index = ranking.length - 1;\n        uint newEntry = donkeys[msg.sender].invested;\n        bool done = false;\n        bool samePosition = false;\n        uint existingAt = ranking.length - 1;\n\n        while (ranking[index].invested < newEntry && !done)\n        {\n            if (index > 0)\n            {\n                done = donkeys[ranking[index - 1].addr].invested > newEntry;\n                \n                if (ranking[index].addr == msg.sender)\n                    existingAt = index;\n                \n                if (done)\n                {\n                    if (ranking[index].addr == msg.sender)\n                    { \n                        ranking[index] = donkeys[msg.sender];\n                        samePosition = true;\n                    }\n                }\n              \n                if (!done) index--;\n            }\n            else\n            {\n                done = true;\n                index = 0;\n                if (ranking[index].addr == msg.sender || ranking[index].addr == address(0x0))\n                {\n                    ranking[index] = donkeys[msg.sender];\n                    samePosition = true;\n                }\n            }\n            \n        }\n        \n        if (!samePosition)\n        {\n            rankDown(index, existingAt);\n            ranking[index] = donkeys[msg.sender];\n        }\n        \n        \n        //Pay pending entries if the new balance allows for it\n        while (balance > entries[payoutOrder].payout) {\n            \n            uint payout = entries[payoutOrder].payout;\n            \n            entries[payoutOrder].entryAddress.send(payout);\n            entries[payoutOrder].paid = true;\n\n            balance -= payout;\n            \n            carrots++;\n            payoutOrder++;\n        }\n        \n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint fees = this.balance - balance;\n        if (fees > 0)\n        {\n            if (entries.length >= 50 && entries.length % 5 == 0)\n            {\n                fees = dValue * fee / 100;\n                uint luckyDonkey = rand(eligibleForFees) - 1;\n                \n                if (ranking[luckyDonkey].addr != address(0x0))\n                    ranking[luckyDonkey].addr.send(fees);\n                else\n                    donkeyKing.send(fees);\n            }\n            else\n                pig.send(fees);\n        }        \n        \n        //Check for new Donkey King\n        if (donkeys[msg.sender].invested > investmentRecord)\n        {\n            donkeyKing = msg.sender;\n            NewKing(msg.sender);\n            investmentRecord = donkeys[msg.sender].invested;\n            \n        }\n        \n        if (ranking[0].addr != donkeys[donkeyKing].addr && ranking[0].addr != address(0x0))\n        {\n            ranking[1] = donkeys[ranking[0].addr];\n            ranking[0] = donkeys[donkeyKing];\n        }\n        \n    }\n    \n    function rankDown(uint index, uint offset) private\n    {\n        for (uint i = offset; i > index; i--)\n        {\n            ranking[i] = donkeys[ranking[i-1].addr];\n        }\n    }\n    \n    function addNewDonkey(address Address) private\n    {\n        if (donkeys[Address].addr == address(0))\n        {\n            donkeys[Address].addr = Address;\n            donkeys[Address].nickname = 'GullibleDonkey';\n            donkeys[Address].invested = 0;\n        }\n    }\n    \n    //Generate random number between 1 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n    \n        return uint256((uint256(hashVal) / factor)) % max + 1;\n    }\n    \n\n    //Contract management\n    function changePig(address newPig) onlypig {\n        pig = newPig;\n    }\n    \n    \n    function changeMultiplier(uint multi) onlypig {\n        if (multi < 110 || multi > 130) \n            throw;\n        \n        multiplier = multi;\n    }\n    \n    function changeFee(uint newFee) onlypig {\n        if (newFee > 5) \n            throw;\n        \n        fee = newFee;\n    }\n    \n    function changeMaxDeposit(uint max) onlypig {\n        if (max < 1 || max > 10)\n            throw;\n            \n        maxDeposit = max;\n    }\n    \n    function changeRankingSize(uint size) onlypig {\n        if (size < 5 || size > 100)\n            throw;\n            \n        ranking.length = size;\n    }\n    \n    function changeEligibleDonkeys(uint number) onlypig {\n        if (number < 5 || number > 15)\n            throw;\n            \n        eligibleForFees = number;\n    }\n    \n    \n    //JSON functions\n    function setNickname(string name) {\n        addNewDonkey(msg.sender);\n        \n        if (bytes(name).length >= 2 && bytes(name).length <= 16)\n            donkeys[msg.sender].nickname = name;\n    }\n    \n    function carrotsCaught() constant returns (uint amount, string info) {\n        amount = carrots;\n        info = 'The number of payouts sent to participants.';\n    }\n    \n    function currentBalance() constant returns (uint theBalance, string info) {\n        theBalance = balance / 1 finney;\n        info = 'The balance of the contract in Finneys.';\n    }\n    \n    function theDonkeyKing() constant returns (address king, string nickname, uint totalInvested, string info) {\n        king = donkeyKing;  \n        nickname = donkeys[donkeyKing].nickname;\n        totalInvested = donkeys[donkeyKing].invested / 1 ether;\n        info = 'The greediest of all donkeys. You go, ass!';\n    }\n    \n    function donkeyName(address Address) constant returns (string nickname) {\n        nickname = donkeys[Address].nickname;\n    }\n    \n    function currentMultiplier() constant returns (uint theMultiplier, string info) {\n        theMultiplier = multiplier;\n        info = 'The multiplier applied to all deposits (x100). It determines the amount of money you will get when you catch the carrot.';\n    }\n    \n    function generousFee() constant returns (uint feePercentage, string info) {\n        feePercentage = fee;\n        info = 'The generously modest fee percentage applied to all deposits. It can change to lure more donkeys (max 5%).';\n    }\n    \n    function nextPayoutGoal() constant returns (uint finneys, string info) {\n        finneys = (entries[payoutOrder].payout - balance) / 1 finney;\n        info = 'The amount of Finneys (Ethers * 1000) that need to be deposited for the next donkey to catch his carrot.';\n    }\n    \n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = 'The number of times the carrot was chased by gullible donkeys.';\n    }\n    \n    function entryDetails(uint index) constant returns (address donkey, string nickName, uint deposit, uint payout, bool paid, string info)\n    {\n        if (index < entries.length || index == 0 && entries.length > 0) {\n            donkey = entries[index].entryAddress;\n            nickName = donkeys[entries[index].entryAddress].nickname;\n            deposit = entries[index].deposit / 1 finney;\n            payout = entries[index].payout / 1 finney;\n            paid = entries[index].paid;\n            info = 'Entry info: donkey address, name, deposit, expected payout in Finneys, payout status.';\n        }\n    }\n    \n    function donkeyRanking(uint index) constant returns(address donkey, string nickname, uint totalInvested, string info)\n    {\n        if (index < ranking.length)\n        {\n            donkey = ranking[index].addr;\n            nickname = donkeys[ranking[index].addr].nickname;\n            totalInvested = donkeys[ranking[index].addr].invested / 1 ether;\n            info = 'Top donkey stats: address, name, ethers deposited. Lower index number means higher rank.';\n        }\n    }\n    \n    function donkeyInvested(address donkey) constant returns(uint invested, string info) {\n        invested = donkeys[donkey].addr != address(0x0) ? donkeys[donkey].invested / 1 ether : 0;\n        info = 'The amount of Ethers the donkey has chased carrots with.';\n    }\n    \n    function totalInvested() constant returns(uint invested, string info) {\n        invested = donkeysInvested / 1 ether;\n        info = 'The combined investments of all donkeys in Ethers.';\n    }\n    \n    function currentDepositLimit() constant returns(uint ethers, string info) {\n        ethers = maxDeposit;\n        info = 'The current maximum number of Ethers you may deposit at once.';\n    }\n    \n    function donkeysEligibleForFees() constant returns(uint top, string info) {\n        top = eligibleForFees;\n        info = 'The number of donkeys in the ranking that are eligible to receive fees.';\n    }\n    \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1290634,0x99d982e49bcb5465a6b4c1e0ec4341c912d9ba42,false,false,"//***********************************EthVentures****************************************************************************\n//\n//  TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n//  EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n//  How it works: You deposit minimum 5 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n//      Ex: There is 95 Eth deposited, you deposit 5 Eth, new balance becomes 100 Eth, then you will own 5% of the profits!	\n//\n//\n//\n//  Dividends: Ever deposit under 5 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 5 Eth, it will be distributed in 3-4 Ether packages, automatically.\n//  	Ex: We generate 100 Eth profit, then it will be distributed in 33 times in 3.33 ether packages, then those packages get shared between shareholders. With the example above if you hold 5%, then you will earn 33 times 0.1665 Eth, which is 5.4945 Eth profit in total.\n//\n//\n//  Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n//      Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n//      Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n//      Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n//  How to invest: Just deposit minimum 5 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n//  Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point. \n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract. \n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright Â© 2016, This piece of code cannot be copied or reused without the author's permission!\n//\n//***********************************START\ncontract EthVentures {\n\n  struct InvestorArray {\n      address etherAddress;\n      uint amount;\n      uint percentage_ownership;  //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n  }\n\n  InvestorArray[] public investors;\n\n//********************************************PUBLIC VARIABLES\n\n\n  uint public total_investors=0;\n  uint public fees=0;\n  uint public balance = 0;\n  uint public totaldeposited=0;\n  uint public totalpaidout=0;\n  uint public totaldividends=0;\n  string public Message_To_Investors=""Welcome to EthVentures!"";  // the manager can send short messages to investors\n  \n  address public owner;\n\n  // manager privilege\n  modifier manager { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function EthVentures() {\n    owner = msg.sender;\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    Enter();\n  }\n  \n//********************************************ENTER\n\n  function Enter() {\n	//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n	//IN LESS THAN 5 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 5 ETHER GETS REGISTERED AS AN INVESTOR!!!\n	if (msg.value < 5 ether) \n	{ \n	\n		uint PRE_inv_length = investors.length;\n		uint PRE_payout;\n		uint PRE_amount=msg.value;\n      		owner.send(PRE_amount/100);     	//send the 1% management fee to the manager\n		totalpaidout+=PRE_amount/100;       //update paid out amount\n		PRE_amount=PRE_amount - PRE_amount/100;     //remaining 99% is the dividend\n\n		    \n	//Distribute Dividends\n	if(PRE_inv_length !=0 && PRE_amount !=0)\n	{\n	    for(uint PRE_i=0; PRE_i<PRE_inv_length;PRE_i++)  \n		{\n		\n			PRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000;    //calculate pay out\n			investors[PRE_i].etherAddress.send(PRE_payout);         //send dividend to investor\n			totalpaidout += PRE_payout;                 //update paid out amount\n			totaldividends+=PRE_payout;              // update paid out dividends\n	\n		}\n	}\n\n	}\n\n	// YOU MUST INVEST AT LEAST 5 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\n	else    \n	{\n    // collect management fees and update contract balance and deposited amount\n	uint amount=msg.value;\n	fees  = amount / 100;             // 1% management fee to the owner\n	balance += amount;               // balance update\n	totaldeposited+=amount;       //update deposited amount\n\n    // add a new participant to the system and calculate total players\n	uint inv_length = investors.length;\n	bool alreadyinvestor =false;\n	uint alreadyinvestor_id;\n	\n    //go through all investors and see if the current investor was already an investor or not\n    for(uint i=0; i<inv_length;i++)  \n    {\n	if( msg.sender==   investors[i].etherAddress) // if yes then:\n	{\n	alreadyinvestor=true; //set it to true\n	alreadyinvestor_id=i;  // and save the id of the investor in the investor array\n	break;  // get out of the loop to save gas, because we already found it\n	}\n    }\n    \n     // if it's a new investor then add it to the array\n    if(alreadyinvestor==false)\n	{\n	total_investors=inv_length+1;\n	investors.length += 1;\n	investors[inv_length].etherAddress = msg.sender;\n	investors[inv_length].amount = amount;\n	investors[inv_length].percentage_ownership = investors[inv_length].amount /totaldeposited*10000000000;\n	}\n	else // if its already an investor, then update his investments and his % ownership\n	{\n	investors[alreadyinvestor_id].amount += amount;\n	investors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n	}\n\n    // pay out the 1% management fee\n     if (fees != 0) \n     {\n     	if(balance>fees)\n	{\n      	owner.send(fees);            //send the 1% to the manager\n      	balance -= fees;             //balance update\n	totalpaidout+=fees;          //update paid out amount\n	}\n     }\n    }\n  }\n\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\n\n  function NewOwner(address new_owner) manager \n  {\n      owner = new_owner;\n  }\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\n  function Emergency() manager \n  {\n	if(balance!=0)\n      	owner.send(balance);\n  }\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\n\n  function NewMessage(string new_sms) manager \n  {\n      Message_To_Investors = new_sms;\n  }\n\n}",2,コメントが詩的で、分散型企業のビジョンを描いているが、実用的な構造を持つ。
1291580,0x1ff3f56609d0771abb49566600febade0e708beb,false,false,"//***********************************EthVentures v2****************************************************************************\n//\n// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\n//\n//\n//\n// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 3-4 Ether packages, automatically.\n// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\n//\n//\n// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright Ã‚Â© 2016, This piece of code cannot be copied or reused without the author's permission!\n//\n// This is v2 of the contract, new and improved, all possible bugs fixed!\n//\n//\n//***********************************START\ncontract EthVentures {\nstruct InvestorArray {\naddress etherAddress;\nuint amount;\nuint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n}\nInvestorArray[] public investors;\n//********************************************PUBLIC VARIABLES\nuint public total_investors=0;\nuint public fees=0;\nuint public balance = 0;\nuint public totaldeposited=0;\nuint public totalpaidout=0;\nuint public totaldividends=0;\nstring public Message_To_Investors=""Welcome to EthVentures!""; // the manager can send short messages to investors\naddress public owner;\n// manager privilege\nmodifier manager { if (msg.sender == owner) _ }\n//********************************************INIT\nfunction EthVentures() {\nowner = msg.sender;\n}\n//********************************************TRIGGER\nfunction() {\nEnter();\n}\n//********************************************ENTER\nfunction Enter() {\n//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\nif (msg.value < 2 ether)\n{\nuint PRE_inv_length = investors.length;\nuint PRE_payout;\nuint PRE_amount=msg.value;\nowner.send(PRE_amount/100); //send the 1% management fee to the manager\ntotalpaidout+=PRE_amount/100; //update paid out amount\nPRE_amount=PRE_amount - PRE_amount/100; //remaining 99% is the dividend\n//Distribute Dividends\nif(PRE_inv_length !=0 && PRE_amount !=0)\n{\nfor(uint PRE_i=0; PRE_i<PRE_inv_length;PRE_i++)\n{\nPRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out\ninvestors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor\ntotalpaidout += PRE_payout; //update paid out amount\ntotaldividends+=PRE_payout; // update paid out dividends\n}\n}\n}\n// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\nelse\n{\n// collect management fees and update contract balance and deposited amount\nuint amount=msg.value;\nfees = amount / 100; // 1% management fee to the owner\nbalance += amount; // balance update\ntotaldeposited+=amount; //update deposited amount\n// add a new participant to the system and calculate total players\nuint inv_length = investors.length;\nbool alreadyinvestor =false;\nuint alreadyinvestor_id;\ntotal_investors=inv_length+1;\ninvestors.length += 1;\n//go through all investors and see if the current investor was already an investor or not\nfor(uint i=0; i<inv_length;i++)\n{\nif( msg.sender== investors[i].etherAddress) // if yes then:\n{\nalreadyinvestor=true; //set it to true\nalreadyinvestor_id=i; // and save the id of the investor in the investor array\nbreak; // get out of the loop to save gas, because we already found it\n}\n}\n// if it's a new investor then add it to the array\nif(alreadyinvestor==false)\n{\ninvestors[inv_length].etherAddress = msg.sender;\ninvestors[inv_length].amount = amount;\ninvestors[inv_length].percentage_ownership = investors[inv_length].amount /totaldeposited*10000000000;\nfor(uint k=0; k<inv_length;k++)\n{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership\n}\nelse // if its already an investor, then update his investments and his % ownership\n{\ninvestors[alreadyinvestor_id].amount += amount;\ninvestors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n}\n// pay out the 1% management fee\nif (fees != 0)\n{\nif(balance>fees)\n{\nowner.send(fees); //send the 1% to the manager\nbalance -= fees; //balance update\ntotalpaidout+=fees; //update paid out amount\n}\n}\n}\n}\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\nfunction NewOwner(address new_owner) manager\n{\nowner = new_owner;\n}\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\nfunction Emergency() manager\n{\nif(balance!=0)\n{\nowner.send(balance);\nbalance=0;\n}\n}\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\nfunction NewMessage(string new_sms) manager\n{\nMessage_To_Investors = new_sms;\n}\n}",2,コメントが詩的で、投資のビジョンを描写しているが、コード自体は実用的です。
1291888,0xba3048b17d1e8c1412ea29af9af795786065b5f9,false,false,contract copypaste {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function copypaste() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 10 ether) {\n			msg.sender.send(msg.value - 10 ether);	\n			amount = 10 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1292100,0xb5aff01f3e820735fac9abb594dc9993cb9e5bd2,false,false,contract TheGame {\n    // Based on the open source castle script\n    // Definte the guy player\n    address public first_player;\n    // Last time someone contributed to the game\n    uint public regeneration;\n    // Define jackpot\n    uint public jackpot;\n\n    // Fees\n    uint public collectedFee;\n\n    // List of players who contributed\n    address[] public playersAddresses;\n    uint[] public playersAmounts;\n    uint32 public totalplayers;\n    uint32 public lastPlayerPaid;\n    // main Player who made the system work\n    address public mainPlayer;\n    // How many times the game stopped\n    uint32 public round;\n    // ETH paid in this round\n    uint public amountAlreadyPaidBack;\n    // ETH invested in this round\n    uint public amountInvested;\n\n    uint constant SIX_HOURS = 60 * 60 * 6;\n\n    function TheGame() {\n        // First game\n        mainPlayer = msg.sender;\n        first_player = msg.sender;\n        regeneration = block.timestamp;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalplayers = 0;\n    }\n\n    function contribute_toTheGame() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 1 / 2 ether) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the player sends more than 25 ETH it is returned to him\n        if (amount > 25 ether) {\n            msg.sender.send(msg.value - 25 ether);\n            amount = 25 ether;\n        }\n\n        // Check if the game is still on\n        if (regeneration + SIX_HOURS < block.timestamp) {\n            // Send the jacpot to the last 3 players\n            // If noone send ETH in the last 6 hours nothing happens\n            if (totalplayers == 1) {\n                // If only one person sent ETH in the last 6 hours he gets 100% of the jacpot\n                playersAddresses[playersAddresses.length - 1].send(jackpot);\n            } else if (totalplayers == 2) {\n                // If two players sent ETH the jacpot is split between them\n                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);\n                playersAddresses[playersAddresses.length - 2].send(jackpot * 30 / 100);\n            } else if (totalplayers >= 3) {\n                // If there is 3 or more players\n                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);\n                playersAddresses[playersAddresses.length - 2].send(jackpot * 20 / 100);\n                playersAddresses[playersAddresses.length - 3].send(jackpot * 10 / 100);\n            }\n\n            // Creation of new jackpot\n            jackpot = 0;\n\n            // Creation of new round of the game\n            first_player = msg.sender;\n            regeneration = block.timestamp;\n            playersAddresses.push(msg.sender);\n            playersAmounts.push(amount * 2);\n            totalplayers += 1;\n            amountInvested += amount;\n\n            // ETH sent to the jackpot\n            jackpot += amount;\n\n            // The player takes 3%\n            first_player.send(amount * 3 / 100);\n\n            // The Player takes 3%\n            collectedFee += amount * 3 / 100;\n\n            round += 1;\n        } else {\n            // The game is still on\n            regeneration = block.timestamp;\n            playersAddresses.push(msg.sender);\n            playersAmounts.push(amount * 2);\n            totalplayers += 1;\n            amountInvested += amount;\n\n            // 5% goes to the jackpot\n            jackpot += (amount * 5 / 100);\n\n            // The player takes 3%\n            first_player.send(amount * 3 / 100);\n\n            // The player takes 3%\n            collectedFee += amount * 3 / 100;\n\nwhile (playersAmounts[lastPlayerPaid] < (address(this).balance - jackpot - collectedFee) && lastPlayerPaid <= totalplayers) {\n                playersAddresses[lastPlayerPaid].send(playersAmounts[lastPlayerPaid]);\n                amountAlreadyPaidBack += playersAmounts[lastPlayerPaid];\n                lastPlayerPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        contribute_toTheGame();\n    }\n\n    // When the game stops\n    function restart() {\n        if (msg.sender == mainPlayer) {\n            mainPlayer.send(address(this).balance);\n            selfdestruct(mainPlayer);\n        }\n    }\n\n    // When the main player wants to transfer his function\n    function new_mainPlayer(address new_mainPlayer) {\n        if (msg.sender == mainPlayer) {\n            mainPlayer = new_mainPlayer;\n        }\n    }\n\n    // When the main Player decides to collect his fees\n    function collectFee() {\n        if (msg.sender == mainPlayer) {\n            mainPlayer.send(collectedFee);\n        }\n    }\n\n    // When the guy players wants to transfer his function\n    function newfirst_player(address newfirst_player) {\n        if (msg.sender == first_player) {\n            first_player = newfirst_player;\n        }\n    }       \n},1,実用的なゲームコントラクトで、特に芸術的な要素は見られません。
1295002,0xf70ce1be9685b0cfb531bc712d3faace858b5bfb,false,false,contract fairandeasy {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function fairandeasy() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1295030,0xa83c4a6d0418074655bdbe74fed8435c46c19f66,false,false,contract fairandeasy {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function fairandeasy() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n   if (idx != 0) {\n      collectedFees += 0;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1297514,0xd12d8f8dfa54f1578b2177f99b2e282367b66b13,false,false,contract doubleyour5 {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function doubleyour5() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 5 ether) {\n			msg.sender.send(msg.value - 5 ether);	\n			amount = 5 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n   \n    balance += amount;\n    \n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1298693,0x007d42b9192b8c087b0d3e6ef73aae48e74b41c1,false,false,"//***********************************EthVentures v4****************************************************************************\n//\n// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\n//\n//\n//\n// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.\n// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\n//\n//\n// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright (c) 2016 to ""BetGod"" from Bitcointalk.org, This piece of code cannot be copied or reused without the author's permission!\n//\n// Author: https://bitcointalk.org/index.php?action=profile;u=803185\n//\n// This is v4 of the contract, new and improved, all possible bugs fixed!\n//\n//\n//***********************************START\ncontract EthVentures4 {\nstruct InvestorArray {\naddress etherAddress;\nuint amount;\nuint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n}\nInvestorArray[] public investors;\n//********************************************PUBLIC VARIABLES\nuint public total_investors=0;\nuint public fees=0;\nuint public balance = 0;\nuint public totaldeposited=0;\nuint public totalpaidout=0;\nuint public totaldividends=0;\nstring public Message_To_Investors=""Welcome to EthVentures4! New and improved! All bugs fixed!""; // the manager can send short messages to investors\naddress public owner;\n// manager privilege\nmodifier manager { if (msg.sender == owner) _ }\n//********************************************INIT\nfunction EthVentures4() {\nowner = msg.sender;\n}\n//********************************************TRIGGER\nfunction() {\nEnter();\n}\n//********************************************ENTER\nfunction Enter() {\n//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\nif (msg.value < 2 ether)\n{\nuint PRE_payout;\nuint PRE_amount=msg.value;\nowner.send(PRE_amount/100); //send the 1% management fee to the manager\ntotalpaidout+=PRE_amount/100; //update paid out amount\nPRE_amount-=PRE_amount/100; //remaining 99% is the dividend\n//Distribute Dividends\nif(investors.length !=0 && PRE_amount !=0)\n{\nfor(uint PRE_i=0; PRE_i<investors.length;PRE_i++)\n{\nPRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out\ninvestors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor\ntotalpaidout += PRE_payout; //update paid out amount\ntotaldividends+=PRE_payout; // update paid out dividends\n}\nMessage_To_Investors=""Dividends have been paid out!"";\n}\n}\n// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\nelse\n{\n// collect management fees and update contract balance and deposited amount\nuint amount=msg.value;\nfees = amount / 100; // 1% management fee to the owner\ntotaldeposited+=amount; //update deposited amount\namount-=amount/100;\nbalance += amount; // balance update\n// add a new participant to the system and calculate total players\nbool alreadyinvestor =false;\nuint alreadyinvestor_id;\n//go through all investors and see if the current investor was already an investor or not\nfor(uint i=0; i<investors.length;i++)\n{\nif( msg.sender== investors[i].etherAddress) // if yes then:\n{\nalreadyinvestor=true; //set it to true\nalreadyinvestor_id=i; // and save the id of the investor in the investor array\nbreak; // get out of the loop to save gas, because we already found it\n}\n}\n// if it's a new investor then add it to the array\nif(alreadyinvestor==false)\n{\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = msg.sender;\ninvestors[investors.length-1].amount = amount;\ninvestors[investors.length-1].percentage_ownership = amount /totaldeposited*10000000000;\nMessage_To_Investors=""New Investor has joined us!""; // a new and real investor has joined us\n\nfor(uint k=0; k<investors.length;k++) //if smaller than incremented, goes into loop\n{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership\n\n}\nelse // if its already an investor, then update his investments and his % ownership\n{\ninvestors[alreadyinvestor_id].amount += amount;\ninvestors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n}\n// pay out the 1% management fee\nif (fees != 0)\n{\nowner.send(fees); //send the 1% to the manager\ntotalpaidout+=fees; //update paid out amount\n}\n\n}\n}\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\nfunction NewOwner(address new_owner) manager\n{\nowner = new_owner;\nMessage_To_Investors=""The contract has a new manager!"";\n}\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\nfunction Emergency() manager\n{\nif(balance!=0)\n{\nowner.send(balance);\nbalance=0;\nMessage_To_Investors=""Emergency Withdraw has been issued!"";\n}\n}\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\nfunction NewMessage(string new_sms) manager\n{\nMessage_To_Investors = new_sms;\n}\n//********************************************MANUALLY ADD INVESTORS\n//The manager can add manually the investors from the previous versions, \n//so that those that invested in the older versions can join us in the new and updated versions\nfunction NewManualInvestor(address new_investor , uint new_amount) manager\n{\ntotaldeposited+=new_amount; //update deposited amount manually\n\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = new_investor;\ninvestors[investors.length-1].amount = new_amount;\ninvestors[investors.length-1].percentage_ownership = new_amount /totaldeposited*10000000000;\n\nMessage_To_Investors=""New manual Investor has been added by the Manager!""; // you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.\n// This will ensure that the manager doesn't add fake investors of his own addresses.\n}\n//********************************************MANUAL DEPOSIT\n//The manager can deposit manually from previous version's balances\nfunction ManualDeposit() manager\n{\nMessage_To_Investors = ""Manual Deposit received from the Manager"";\n}\n\n//end\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1298849,0x41f2d5040726c5328f8366f17041ec012ac8f338,false,false,"//***********************************EthVenturesFinal****************************************************************************\n//\n// TIRED OF POINTLESS PONZI SCHEMES? Then join EthVentures the first decentralized company!\n//\n//\n// EthVentures is the first decentralized ethereum based company, with shareholder function, dividends, and more...!\n//\n//\n// How it works: You deposit minimum 2 Ether and no maximum deposit, and you will become a shareholder, proportional to how much you deposited. You will own a % of the income of this dapp proportional to how much you deposited.\n// Ex: There is 98 Eth deposited, you deposit 2 Eth, new balance becomes 100 Eth, then you will own 2% of the profits!\n//\n//\n//\n// Dividends: Every deposit under 2 Eth is considered a dividend and is distributed between shareholders automatically. Even if the profit is bigger than 2 Eth, it will be distributed in 1-2 Ether packages, automatically.\n// Ex: We generate 100 Eth profit daily, then it will be distributed in 50 times in 2 ether packages, then those packages get shared between shareholders. With the example above if you hold 2%, then you will earn 50 times 0.04 Eth, which is 2 Eth profit in total.\n//\n//\n// Profit: This contract itself is not generating any profit, it's just a ledger to keep record of investors, and pays out dividends automatically.There will be other contracts linked to this, that will send the profits here. EthVentures is just the core of this business, there will be other contracts built on it.\n// Ex: A dice game built on this contract that generates say 10 Eth daily, will send the fees directly here\n// Ex: A doubler game built on this contract that generates 50 Eth daily, that will send all fees here\n// Ex: Any other form of contract that takes a % fee, and will send the fees directly here to be distributed between EthVentures shareholders.\n//\n//\n// How to invest: Just deposit minimum 2 Ether to the contract address, and you can see your total investments and % ownership in the Mist wallet if you follow this contract. You can deposit multiple times too, the total investments will add up if you send from the same address. The percentage ownership is calculated with a 10 billionth point precision, so you must divide that number by 100,000,000 to get the % ownership rate. Every other information, can be seen in the contract tab from your Mist Wallet, just make sure you are subscribed to this contract.\n//\n//\n//\n// Fees: There is a 1% deposit fee, and a 1% dividend payout fee that goes to the contract manager, everything else goes to investors!\n//\n//============================================================================================================================\n//\n// When EthVentures will be succesful, it will have tens or hundreds of different contracts, all sending the fees here to our investors, AUTOMATICALLY. It could generate even hundreds of Eth daily at some point.\n//\n// Imagine it as a decentralized web of income, all sending the money to 1 single point, this contract.\n//\n// It is literally a DECENTRALIZED MONEY GENERATOR!\n//\n//\n//============================================================================================================================\n// Copyright (c) 2016 to ""BetGod"" from Bitcointalk.org, This piece of code cannot be copied or reused without the author's permission!\n//\n// Author: https://bitcointalk.org/index.php?action=profile;u=803185\n//\n// This is the final version of the contract, new and improved, all possible bugs fixed!\n//\n//\n//***********************************START\ncontract EthVenturesFinal {\nstruct InvestorArray {\naddress etherAddress;\nuint amount;\nuint percentage_ownership; //ten-billionth point precision, to get real %, just divide this number by 100,000,000\n}\nInvestorArray[] public investors;\n//********************************************PUBLIC VARIABLES\nuint public total_investors=0;\nuint public fees=0;\nuint public balance = 0;\nuint public totaldeposited=0;\nuint public totalpaidout=0;\nuint public totaldividends=0;\nstring public Message_To_Investors=""Welcome to EthVenturesFinal! New and improved! All bugs fixed!""; // the manager can send short messages to investors\naddress public owner;\n// manager privilege\nmodifier manager { if (msg.sender == owner) _ }\n//********************************************INIT\nfunction EthVenturesFinal() {\nowner = msg.sender;\n}\n//********************************************TRIGGER\nfunction() {\nEnter();\n}\n//********************************************ENTER\nfunction Enter() {\n//DIVIDEND PAYOUT FUNCTION, IT WILL GET INCOME FROM OTHER CONTRACTS, THE DIVIDENDS WILL ALWAYS BE SENT\n//IN LESS THAN 2 ETHER SIZE PACKETS, BECAUSE ANY DEPOSIT OVER 2 ETHER GETS REGISTERED AS AN INVESTOR!!!\nif (msg.value < 2 ether)\n{\nuint PRE_payout;\nuint PRE_amount=msg.value;\nowner.send(PRE_amount/100); //send the 1% management fee to the manager\ntotalpaidout+=PRE_amount/100; //update paid out amount\nPRE_amount-=PRE_amount/100; //remaining 99% is the dividend\n//Distribute Dividends\nif(investors.length !=0 && PRE_amount !=0)\n{\nfor(uint PRE_i=0; PRE_i<investors.length;PRE_i++)\n{\nPRE_payout = PRE_amount * investors[PRE_i].percentage_ownership /10000000000; //calculate pay out\ninvestors[PRE_i].etherAddress.send(PRE_payout); //send dividend to investor\ntotalpaidout += PRE_payout; //update paid out amount\ntotaldividends+=PRE_payout; // update paid out dividends\n}\nMessage_To_Investors=""Dividends have been paid out!"";\n}\n}\n// YOU MUST INVEST AT LEAST 2 ETHER OR HIGHER TO BE A SHAREHOLDER, OTHERWISE THE DEPOSIT IS CONSIDERED A DIVIDEND!!!\nelse\n{\n// collect management fees and update contract balance and deposited amount\nuint amount=msg.value;\nfees = amount / 100; // 1% management fee to the owner\ntotaldeposited+=amount; //update deposited amount\namount-=amount/100;\nbalance += amount; // balance update\n// add a new participant to the system and calculate total players\nbool alreadyinvestor =false;\nuint alreadyinvestor_id;\n//go through all investors and see if the current investor was already an investor or not\nfor(uint i=0; i<investors.length;i++)\n{\nif( msg.sender== investors[i].etherAddress) // if yes then:\n{\nalreadyinvestor=true; //set it to true\nalreadyinvestor_id=i; // and save the id of the investor in the investor array\nbreak; // get out of the loop to save gas, because we already found it\n}\n}\n// if it's a new investor then add it to the array\nif(alreadyinvestor==false)\n{\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = msg.sender;\ninvestors[investors.length-1].amount = amount;\ninvestors[investors.length-1].percentage_ownership = amount /totaldeposited*10000000000;\nMessage_To_Investors=""New Investor has joined us!""; // a new and real investor has joined us\n\nfor(uint k=0; k<investors.length;k++) //if smaller than incremented, goes into loop\n{investors[k].percentage_ownership = investors[k].amount/totaldeposited*10000000000;} //recalculate % ownership\n\n}\nelse // if its already an investor, then update his investments and his % ownership\n{\ninvestors[alreadyinvestor_id].amount += amount;\ninvestors[alreadyinvestor_id].percentage_ownership = investors[alreadyinvestor_id].amount/totaldeposited*10000000000;\n}\n// pay out the 1% management fee\nif (fees != 0)\n{\nowner.send(fees); //send the 1% to the manager\ntotalpaidout+=fees; //update paid out amount\n}\n\n}\n}\n//********************************************NEW MANAGER\n//In case the business gets sold, the new manager will take over the management\nfunction NewOwner(address new_owner) manager\n{\nowner = new_owner;\nMessage_To_Investors=""The contract has a new manager!"";\n}\n//********************************************EMERGENCY WITHDRAW\n// It will only be used in case the funds get stuck or any bug gets discovered in the future\n// Also if a new version of this contract comes out, the funds then will be transferred to the new one\nfunction Emergency() manager\n{\nif(balance!=0)\n{\nowner.send(balance);\nbalance=0;\nMessage_To_Investors=""Emergency Withdraw has been issued!"";\n}\n}\n//********************************************EMERGENCY BALANCE RESET\n//In case any errors happen the balance can be modified manually, it will only be used as last resort!\nfunction EmergencyBalanceReset(uint new_balance) manager\n{\nbalance = new_balance;\nMessage_To_Investors=""The Balance has been edited by the Manager!"";\n}\n//********************************************NEW MESSAGE\n//The manager can send short messages to investors to keep them updated\nfunction NewMessage(string new_sms) manager\n{\nMessage_To_Investors = new_sms;\n}\n//********************************************MANUALLY ADD INVESTORS\n//The manager can add manually the investors from the previous versions, \n//so that those that invested in the older versions can join us in the new and updated versions\nfunction NewManualInvestor(address new_investor , uint new_amount) manager\n{\ntotal_investors=investors.length+1;\ninvestors.length += 1; //increment first\ninvestors[investors.length-1].etherAddress = new_investor;\ninvestors[investors.length-1].amount = new_amount;\ninvestors[investors.length-1].percentage_ownership = new_amount /totaldeposited*10000000000;\n\nMessage_To_Investors=""New manual Investor has been added by the Manager!""; // you can see if the newest investor was manually added or not, this will add transparency to the contract, since this function should only be used in emergency situations.\n// This will ensure that the manager doesn't add fake investors of his own addresses.\n}\n//********************************************MANUAL DEPOSIT\n//The manager can deposit manually from previous version's balances\nfunction ManualDeposit() manager\n{\ntotaldeposited+=msg.value; //update deposited amount manually\nbalance+=msg.value; //update balance amount manually\n\nMessage_To_Investors = ""Manual Deposit received from the Manager"";\n}\n\n//end\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1300582,0x750241c16c9fb878a7afd2b07b80f53e02c3f634,false,false,contract quick2 {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function quick2() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1/100 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 20 ether) {\n			msg.sender.send(msg.value - 20 ether);	\n			amount = 20 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 150) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 150;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1301734,0x9d3899df1d9f030a32dd5571fe3c7ef72d6ae566,false,false,"contract NiceGuyTax {\n    \n    // Make a database of investors.\n    struct Investor {\n      address addr;\n    }\n    Investor[] public investors;\n    \n    // Make a database of Nice Guys.\n    struct NiceGuy {\n      address addr;\n    }\n    NiceGuy[] public niceGuys;\n    \n    //Counters. this counts things. A new round begins when investorIndex reaches 10.\n    uint public payoutIndex = 0;\n    uint public currentNiceGuyIndex = 0;\n    uint public investorIndex = 0;\n    address public currentNiceGuy;\n    \n    \n    // This makes the deployer of the smartcontract the first Nice Guy.. MUCH NICE!\n    // I could only make 10 ETH if people are nice enough to invest in it.\n    function NiceGuyTax() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    //Invest 9 ETH to execute this function.\n    function() {\n        \n        //If your investment is NOT 9 ether, the smartcontract rejects it and you get it back.\n        if (msg.value != 9 ether) {\n            throw;\n        }\n        \n        //First the current nice guy gets 1 ether.\n        //This is called the ""Nice guy tax""\n        currentNiceGuy.send(1 ether);\n        \n        //If you are investor 1 to 8, you will receive pay-out in the same round.\n        if (investorIndex < 8) {\n            uint index = investors.length;\n            investors.length += 1;\n            investors[index].addr = msg.sender;\n        }\n        \n        //If you are investor 9 or 10, you will be put in the Nice Guy database.\n        if (investorIndex > 7) {\n            uint niceGuyIndex = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[niceGuyIndex].addr = msg.sender;\n            //If you are investor 10, the next investor will be the first investor of the next round.\n            //the next Nice Guy will be installed and receives the Nice Guy Tax\n            if (investorIndex > 8 ) {\n                currentNiceGuy = niceGuys[currentNiceGuyIndex].addr;\n                currentNiceGuyIndex += 1;\n            }\n        }\n        \n        //this counts the investors in each round. If the investorIndex counts to 10, the next round begins.\n        if (investorIndex < 9) {\n            investorIndex += 1;\n        }\n        else {\n            investorIndex = 0;\n        }\n        \n        //If the contract balance reaches at least 10 ether, the next investor in the pay-out queue in the round gets paid out.\n        //The contract balance is ALWAYS ZERO in the beginning of each round.\n        while (this.balance > 9 ether) {\n            investors[payoutIndex].addr.send(10 ether);\n            payoutIndex += 1;\n        }\n    }\n}",1,実用的な構造で、投資と報酬のロジックを持つ標準的なスマートコントラクトです。
1302117,0x56467e038871dc7f2a6180cdebe1702cef77285f,false,false,"contract NiceGuyTax {\n    \n    // Make a database of investors.\n    struct Investor {\n      address addr;\n    }\n    Investor[] public investors;\n    \n    // Make a database of Nice Guys.\n    struct NiceGuy {\n      address addr;\n    }\n    NiceGuy[] public niceGuys;\n    \n    //Counters. this counts things. A new round begins when investorIndex reaches 10.\n    uint public payoutIndex = 0;\n    uint public currentNiceGuyIndex = 0;\n    uint public investorIndex = 0;\n    address public currentNiceGuy;\n    \n    \n    // This makes the deployer of the smartcontract the first Nice Guy.. MUCH NICE!\n    // I could only make 10 ETH if people are nice enough to invest in it.\n    function NiceGuyTax() {\n        currentNiceGuy = msg.sender;\n    }\n    \n    \n    //Invest 9 ETH to execute this function.\n    function() {\n        \n        //If your investment is NOT 9 ether, the smartcontract rejects it and you get it back.\n        if (msg.value != 9 ether) {\n            msg.sender.send(msg.value);\n            throw;\n        }\n        \n        //First the current nice guy gets 1 ether.\n        //This is called the ""Nice guy tax""\n        currentNiceGuy.send(1 ether);\n        \n        //If you are investor 1 to 8, you will receive pay-out in the same round.\n        if (investorIndex < 8) {\n            uint index = investors.length;\n            investors.length += 1;\n            investors[index].addr = msg.sender;\n        }\n        \n        //If you are investor 9 or 10, you will be put in the Nice Guy database.\n        if (investorIndex > 7) {\n            uint niceGuyIndex = niceGuys.length;\n            niceGuys.length += 1;\n            niceGuys[niceGuyIndex].addr = msg.sender;\n            //If you are investor 10, the next investor will be the first investor of the next round.\n            //the next Nice Guy will be installed and receives the Nice Guy Tax\n            if (investorIndex > 8 ) {\n                currentNiceGuy = niceGuys[currentNiceGuyIndex].addr;\n                currentNiceGuyIndex += 1;\n            }\n        }\n        \n        //this counts the investors in each round. If the investorIndex counts to 10, the next round begins.\n        if (investorIndex < 9) {\n            investorIndex += 1;\n        }\n        else {\n            investorIndex = 0;\n        }\n        \n        //If the contract balance reaches at least 10 ether, the next investor in the pay-out queue in the round gets paid out.\n        //The contract balance is ALWAYS ZERO in the beginning of each round.\n        while (this.balance >= 10 ether) {\n            investors[payoutIndex].addr.send(10 ether);\n            payoutIndex += 1;\n        }\n    }\n}",2,実用的だが、コメントにユーモアと詩的な要素が含まれている。
1303267,0x26c4e381ffbdc825be9b986c3ba40525f0771e8d,false,false,"//***********************************Coinflip\n//\n// This is a simple coin flip game. You flip HEADS, you Win! You flip TAILS you Lose!\n// Each outcome has a 50% chance of happening. You win the entire house bankroll if you win! You lose your deposit if you lose.\n//\n//  Minimum Deposit: 100 finney!\n//\n//  Good Luck and Have Fun!\n//\n//\n//\n// THIS IS AN ATTACHMENT OF THE ETHVENTURES BUSINESS: 0xEe462A6717f17C57C826F1ad9b4d3813495296C9 \n//\n//***********************************START\ncontract Coinflip {\n\n  struct gamblerarray {\n      address etherAddress;\n      uint amount;\n  }\n\n//********************************************PUBLIC VARIABLES\n  \n  gamblerarray[] public gamblerlist;\n  uint public Total_Players=0;\n  uint public FeeRate=2;\n  uint public Bankroll = 0;\n  uint public Total_Deposits=0;\n  uint public Total_Payouts=0;\n  string public Outcome=""NULL"";\n  uint public MinDeposit=100 finney;\n\n  address public owner;\n  uint Fees=0;\n\n//********************************************INIT\n\n  function Coinflip() {\n    owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value >10 finney) {\n\n    uint amount=msg.value;\n    uint payout;\n\n\n    // add a new participant to the system and calculate total players\n    uint list_length = gamblerlist.length;\n    Total_Players=list_length+1;\n    gamblerlist.length += 1;\n    gamblerlist[list_length].etherAddress = msg.sender;\n    gamblerlist[list_length].amount = amount;\n\n\n    // set payout variables\n     Total_Deposits+=amount;       	//update deposited amount\n	    \n      Fees   =amount * FeeRate/100;    // fee to the owner\n      amount-=amount * FeeRate/100;\n	    \n      Bankroll += amount;     //  to the balance\n\n//********************************EthVenturesFinal Fee Plugin\n    // payout fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1990 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Total_Payouts+=Fees;        //update paid out amount\n	Fees-=minimal;\n	}\n	}\n     }\n//********************************End Plugin     \n \n    if (msg.value >= MinDeposit && Bankroll > 0) \n		{\n					// Best Binary Random Number Generator in Ethereum!\n			if( (uint(sha3(gamblerlist[list_length].etherAddress,list_length))+uint(sha3(msg.gas))) % 2==0 ) 	//if the hashed length of your address combined with the gas hash is even, \n			{ 												   							//which is a 50% chance, then you get paid out all balance!\n			gamblerlist[list_length].etherAddress.send(Bankroll);        //send pay out to participant\n			Total_Payouts += Bankroll;               					//update paid out amount\n			Bankroll = 0;                      						//bankroll update\n			Outcome=""HEADS"";\n			}\n			else Outcome=""TAILS"";\n		}\n		else Outcome=""Error, the coin wasn't flipped, try again!"";\n	\n	\n    }\n        //enter function ends\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心。
1303499,0x1492cdd605d91658f228eab14d8444b60e6da8df,false,false,contract thewhalegame {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function thewhalegame() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 5 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 500 ether) {\n			msg.sender.send(msg.value - 500 ether);	\n			amount = 500 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 100 * 3;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 100 * 3;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 125) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 125;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1303507,0x02b2101903eb6a51518e63e84b785180859fda9d,false,false,contract thewhalegame {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function thewhalegame() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 5 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 500 ether) {\n			msg.sender.send(msg.value - 500 ether);	\n			amount = 500 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 100 * 3;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 100 * 3;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1304360,0x60acd43314d93f38507f3fd12e84225a5a099229,false,false,"//***********************************ETH BANK\n//\n// It's an EthBank, every depositor earns interest on their deposits when a new depositor joins!\n//\n// The interest rate is defined by the ""Interest_Rate"" variable, and is initially set to 2%, and may be changed later!\n//\n// The Bank will exist for long because it only pays out when the balance is above 60%. And if the balance is below 80% it pays out only half the interest.\n//\n// Minimum Deposit: 0.2 Ether (200 Finney)\n//\n//\n// It is a long term project, so have fun saving your Ether here!\n//\n//***********************************START\ncontract EthBank {\n\n  struct InvestorArray \n	{\n      	address etherAddress;\n      	uint amount;\n  	}\n\n  InvestorArray[] public depositors;\n\n//********************************************PUBLIC VARIABLES\n\n  uint public Total_Savers=0;\n  uint public Fees=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\n  uint public Interest_Rate=2; // the interest rate payout for deposits!\nstring public Message=""Welcome to EthBank"";\n	\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function EthBank() {\n    owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value > 200 finney) {\n\n    uint amount=msg.value;\n\n\n    // add a new participant to the system and calculate total players\n    Total_Savers=depositors.length+1;\n    depositors.length += 1;\n    depositors[depositors.length-1].etherAddress = msg.sender;\n    depositors[depositors.length-1].amount = amount;\n\n\n\n    // collect Fees and update contract Balance and deposited amount\n      	Fees  = amount * Interest_Rate / 100;    // fee to the owner\n      	Total_Deposited+=amount;       		//update deposited amount\n	amount-=amount * Interest_Rate / 100;	// minus the fee from amount\n      	Balance += amount;               // Balance update\n\n\n//********************************EthVenturesFinal Fee Plugin\n    // payout Fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1990 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	Total_Paid_Out+=Fees;        //update paid out amount\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the Fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Total_Paid_Out+=Fees;        //update paid out amount\n	Fees-=minimal;\n	}\n	}\n     }\n//********************************End Plugin \n //loop variables\n    uint payout;\n    uint nr=0;\n\nif(Total_Deposited * 80/100 < Balance )  //if balance is at 80% or higher, then pay depositors\n{\n  \n\n	\n    while (Balance > depositors[nr].amount * Interest_Rate/100 && nr<depositors.length)  //exit condition to avoid infinite loop\n    { \n      payout = depositors[nr].amount *Interest_Rate/100;                           //calculate pay out\n      depositors[nr].etherAddress.send(payout);                        		//send pay out to participant\n      Balance -= depositors[nr].amount *Interest_Rate/100;                         //Balance update\n      Total_Paid_Out += depositors[nr].amount *Interest_Rate/100;                 //update paid out amount\n      nr += 1;                                                                         //go to next participant\n    }\n    \n	Message=""The Full Interest has been paid to Depositors!"";\n} \nelse  \n{\nif(Total_Deposited * 60/100 < Balance )  //if balance is at 60% or higher, then pay depositors with half interest\n{\n  \n\n	\n    while (Balance > depositors[nr].amount * Interest_Rate/200 && nr<depositors.length)  //exit condition to avoid infinite loop\n    { \n      payout = depositors[nr].amount *Interest_Rate/200;                           //calculate pay out\n      depositors[nr].etherAddress.send(payout);                        		//send pay out to participant\n      Balance -= depositors[nr].amount *Interest_Rate/200;                         //Balance update\n      Total_Paid_Out += depositors[nr].amount *Interest_Rate/200;                 //update paid out amount\n      nr += 1;                                                                         //go to next participant\n    }\n    \n	Message=""Funds are between 60% and 80%, so only Half Interest has been paid!"";\n} \nelse Message=""Funds are below 60%, no interest payout until new Depositors join!"";\n\n\n\n}\n\n  }\n\n//********************************************SET INTEREST RATE\n}\n\n  function Set_Interest_Rate(uint new_interest) onlyowner  //set new interest rate\n	{\n      	Interest_Rate = new_interest;\n	Message=""The Bank has changed it's Interest Rates!"";\n  	}\n\n}",2,コメントが豊富で、銀行の物語を語る詩的な要素が含まれています。
1304883,0xcaaca224e35d0a1fa3304a3c4ec8beb5f28a99aa,false,false,contract test {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function test() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n  //only pair amount\n    if (msg.value % 2 != 0 ) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n	uint amount;\n\n	amount = msg.value;\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n\n      balance += amount;\n  \n\n\n    while (balance > persons[payoutIdx].amount * 2) {\n      uint transactionAmount = persons[payoutIdx].amount * 2;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\nfunction kill(){\n  if(msg.sender == owner) {\n  suicide(owner);\n  }\n  }\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1304956,0x7afaacb0a6cbb93aeb301cb956ae71a35542ecc5,false,false,"contract WavesPresale {\n    address public owner;\n    \n    struct Sale\n    {\n        uint amount;\n        uint date;\n    }\n\n    mapping (bytes16 => Sale) public sales;\n    uint32 public numberOfSales;\n    uint public totalTokens;\n\n    function WavesPresale() {\n        owner = msg.sender;\n        numberOfSales = 0;\n    }\n\n    function changeOwner(address newOwner) {\n        if (msg.sender != owner) return;\n\n        owner = newOwner;\n    }\n\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\n        if (msg.sender != owner) return;\n\n        sales[txidHash] = Sale({\n                amount: amount,\n                date: timestamp\n            });\n        numberOfSales += 1;\n        totalTokens += amount;\n    }\n\n    function getSaleDate(bytes16 txidHash) constant returns (uint, uint) {\n    	return (sales[txidHash].amount, sales[txidHash].date);\n    }\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1304997,0xe19e5f100d6a31169b5dca265c9285059c41d4f6,false,false,"contract NanoPyramid {\n    \n    uint private pyramidMultiplier = 140;\n    uint private minAmount = 1 finney;\n    uint private maxAmount = 1 ether;\n    uint private fee = 2;\n    uint private collectedFees = 0;\n    uint private minFeePayout = 100 finney;\n    \n    address private owner;\n    \n    \n    function NanoPyramid() {\n        owner = msg.sender;\n    }\n    \n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    \n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n    \n    Participant[] public participants;\n    \n    \n    uint public payoutOrder = 0;\n    uint public balance = 0;\n    \n    \n    function() {\n        enter();\n    }\n    \n    function enter() {\n        // Check if amount is too small\n        if (msg.value < minAmount) {\n            // Amount is too small, no need to think about refund\n            collectedFees += msg.value;\n            return;\n        }\n        \n        // Check if amount is too high\n        uint amount;\n        if (msg.value > maxAmount) {\n            uint amountToRefund =  msg.value - maxAmount;\n            if (amountToRefund >= minAmount) {\n            	if (!msg.sender.send(amountToRefund)) {\n            	    throw;\n            	}\n        	}\n            amount = maxAmount;\n        }\n        else {\n        	amount = msg.value;\n        }\n        \n        //Adds new address to the participant array\n        participants.push(Participant(\n            msg.sender, \n            amount * pyramidMultiplier / 100\n        ));\n            \n        // Update fees and contract balance\n        balance += (amount * (100 - fee)) / 100;\n        collectedFees += (amount * fee) / 100;\n        \n        //Pays earlier participiants if balance sufficient\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.send(payoutToSend);\n            balance -= payoutToSend;\n            payoutOrder += 1;\n        }\n        \n        // Collect fees\n        if (collectedFees >= minFeePayout) {\n            if (!owner.send(collectedFees)) {\n                // Potentially sending money to a contract that\n                // has a fallback function.  So instead, try\n                // tranferring the funds with the call api.\n                if (owner.call.gas(msg.gas).value(collectedFees)()) {\n                    collectedFees = 0;\n                }\n            } else {\n                collectedFees = 0;\n            }\n        }\n    }\n    \n    \n    function totalParticipants() constant returns (uint count) {\n        count = participants.length;\n    }\n\n    function awaitingParticipants() constant returns (uint count) {\n        count = participants.length - payoutOrder;\n    }\n\n    function outstandingBalance() constant returns (uint amount) {\n        uint payout = 0;\n        uint idx;\n        for (idx = payoutOrder; idx < participants.length; idx++) {\n            payout += participants[idx].payout;\n        }\n        amount = payout - balance;\n    }\n\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1306141,0x2a53f42ad8bba138c21b50a4e5711f18381a61e9,false,false,contract BigRisk {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function BigRisk() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n  \n  	uint amount;\n	amount = msg.value;\n	\n    if (amount % 100 ether != 0  ) {\n	      msg.sender.send(amount);\n        return;\n	}\n\n	uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    balance += amount;\n  \n    while (balance >= persons[payoutIdx].amount * 2) {\n      uint transactionAmount = persons[payoutIdx].amount * 2;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1306352,0x062524205ca7ecf27f4a851edec93c7ad72f427b,false,false,"contract FirePonzi {\n   // NO FEE PONZI, 1.15 Multiplier, Limited to 3 Ether deposits, FAST and designed to be on FIRE !\n   // Only input and output, no destroy function, owner can do nothing !\n   \n  struct Player {\n      address etherAddress;\n      uint deposit;\n  }\n\n  Player[] public persons;\n\n  uint public payoutCursor_Id_ = 0;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  uint public payoutCursor_Id=0;\n  modifier onlyowner { if (msg.sender == owner) _ }\n  function quick() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  function enter() {\n    if (msg.value < 100 finney) { // Only  > 0.1 Eth depoits\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n	uint deposited_value;\n	if (msg.value > 2 ether) { //Maximum 3 Eth per deposit\n		msg.sender.send(msg.value - 2 ether);	\n		deposited_value = 2 ether;\n    }\n	else {\n		deposited_value = msg.value;\n	}\n\n\n    uint new_id = persons.length;\n    persons.length += 1;\n    persons[new_id].etherAddress = msg.sender;\n    persons[new_id].deposit = deposited_value;\n \n    balance += deposited_value;\n    \n\n\n    while (balance > persons[payoutCursor_Id_].deposit / 100 * 115) {\n      uint MultipliedPayout = persons[payoutCursor_Id_].deposit / 100 * 115;\n      persons[payoutCursor_Id].etherAddress.send(MultipliedPayout);\n\n      balance -= MultipliedPayout;\n      payoutCursor_Id_++;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n}",1,実用的なPonziスキームのスマートコントラクトで、芸術的要素は特にありません。
1307219,0xc90233644d2eeb37a7ec641072c85ad272ef2feb,false,false,"// ALPHA 0.1.0 General Purpose Profit Splitter\n\n// INSERT ANYTHING ABOVE 1 FINNEY TO BE A CONTRIBUTOR.\n// TO INSERT PROFIT, SEND 1 FINNEY TO THIS CONTRACT FIRST!\n// THEN YOU HAVE TO SEND THE PROFIT DIRECTLY AFTER - IN 1 TRANSACTION - WITH THE SAME ADDRESS!\n\n// NO COPYRIGHT, NO FEES, NO OWNER (Only an owner in beta)\n// COPY THIS CODE ALL YOU WANT (not my responsibility)\n\n// IF YOU'RE INEXPERIENCED IN CODING, BUT WILLING TO LEARN. I'LL TRY TO DESCRIBE EVERYTHING THE BEST I CAN!\n// I'M AN INEXPERIENCED CODER MYSELF.\n// YOU CAN TELL, BECAUSE I HAVE NO IDEA HOW VERSION NUMBERS WORK.\n\ncontract GeneralPurposeProfitSplitter {         // Title of the contract, you have to give it a name.\n\n    struct Contributor {                        // this will make a database of contributors, the address, contribution and profits are saved.\n        address addr;                           // this is the contributors address\n        uint index;                             // where does the contributor stand in the database index?\n        uint contribution;                      // how much the contributor has contributed in the contract\n        uint profit;                            // how much profit the contributor has made, because of the contribution\n        uint total;                             // how much does this contributor have in total?\n        uint lastContribution;                  // how much did the contributor contribute last time?\n        uint lastProfit;                        // how much was the last profit amount?\n        uint lastProfitShare;                   // how much share did the contributor have last time profit was distrebuted?\n        uint lastPayout;                        // how much did the contributor pay out the last time?\n        string error;                           // If there is something wrong you will know\n    }\n    \n    Contributor[] public contributors;          // use contributors[index of contributor].addr/contribution/profit. to get data from that contributor.\n    uint contributorFound = 0;                  // if a contributor is found this value turns into an index number later on\n    uint contributorTotal = 0;                  // this is a contributors contribution + profits\n    uint contributorShare = 0;                  // this is how much that total is in comparison with all contributions\n    uint public contributorsIndex = 0;          // this counts how many contributors are in the contract.\n    \n    uint public totalContributorsContribution = 0;    // this counts how much contribution in total is in the contract.\n    uint public totalContributorsProfit = 0;    // this counts how much profits in total is still in the contract.\n    uint totalContributorsTotal = 0;            // counts up all the contribution and all the profits now in contract.\n    address public beta;                        // Only ME can decide to give all the contributions and profit back to the contributors. LAST RESORT or SCHEDULED!\n    address public nextInputProfit;             // IF you inserted 1 finney in the contract first, THEN that address will be saved for the next contract execution.\n    \n    uint i = 0;                                 // the i gets used to find a contributor for certain functions\n    uint correctProfit = 0;                     // Because i take 1 finney away for recognition, I will have to add one later.\n    \n    function GeneralPurposeProfitSplitter() {   // without this, mist browser doesn't know how to deploy this contract, as far as I know\n        beta = msg.sender;                      // I am the beta-address so I can give ether back if everything goes wrong\n    }                                           // ADD two lines of code empty between functions. I don't know why, but I read it somewhere that you have to.\n\n    \n    function() {                                // this function has no name, which means that this function will get triggered when only money gets send\n        if (msg.value < 1 finney) {             // DON'T SEND SOMETHING LESS THEN 1 FINNEY TO THIS CONTRACT\n            msg.sender.send(msg.value);         // well you can, but this contract will just send it back, all the wasted gas\n            throw;                              // and we will pretend it never happened\n        }\n        \n        if (msg.value == 1 finney) {            // IF the value you send to this contract is 1 finney\n            nextInputProfit = msg.sender;       // THEN the address will get saved as nextInputProfit, because the next input will be profit\n            throw;                              // THEN THE OTHER CONTRACT that provides the profit HAS to send the profit to this contract WITH THE SAME ADDRESS\n        }\n        \n        if (nextInputProfit == msg.sender) {    // IF this is the second time the smartcontract that provides profit insert ether, it checks its address to see if it matches\n            nextInputProfit = 0;                // this resets the nextInputProfit to nothing. because the code is now being executed and won't be executed again, unless it sends 1 finney again.\n            correctProfit = msg.value + 1 finney; // this adds the 1 finney that was taken away for code recognition.\n            insertProfitHere();                 // GO TO the function that destributes profits.\n        }\n        else {                                  // IF you're NOT a profit providing smartcontract and have NOT inserted 1 finney first, then the contract recognizes you as contributor\n            for(i; i<contributors.length; i++) {// this will go through ALL contributors untill it has found a matching address (LEARN ABOUT FOR LOOPS ON GOOGLE (if it still exists))\n                if (contributors[i].addr == msg.sender) {// If it has found one, it'll prevent the same contributor added twice\n                    contributorFound = i;       // then the number i is the contributors index number.\n                    i = contributors.length;    // this will make the for loop stop, to save gas.\n                }\n            }\n            i = 0;                              // resets that i thingy back to zero, because... you know. \n            if (contributorFound > 0) {         // if the contributorsFound is NOT 0, like in the beginning of this contract, that means this is not the first time this address contributed\n                contributors[contributorFound].contribution += msg.value; // add the new contribution value to the existing contribution value\n                contributors[contributorFound].total = contributorTotal; // for show in Mist Browser\n                contributors[contributorFound].lastContribution = msg.value; // for show in Mist Browser\n                contributorTotal = contributors[contributorFound].contribution + contributors[contributorFound].profit;   // Counts up the total amount a contributor has\n            }\n            else {                              // if this is the first time your address contributed here, welcome first of all, and you will be added in the database\n                contributors[contributorsIndex].addr = msg.sender; // IF you're the first contributor, you will get contributorsIndex number 0.\n                contributors[contributorsIndex].index = contributorsIndex; // so you know where you stand                \n                contributors[contributorsIndex].contribution = msg.value; // your value will now be seen as a contribution, and you will receive profits\n                contributors[contributorsIndex].total = msg.value;  // for show in Mist Browser\n                contributors[contributorsIndex].lastContribution = msg.value; // for show in Mist Browser\n                contributorsIndex += 1;         // add one to the contributors index, no two contributors gets the same index number\n            }\n            totalContributorsContribution += msg.value;   // If you want to give you're contributors the correct share of profits, the total contributors amount has to be correct all the time.\n        }\n    }\n    \n    \n    function insertProfitHere() {               // so if the contract recognizes your input as profit, it executes this function. You can also use the mist browser to add profits.\n        totalContributorsTotal = totalContributorsProfit + totalContributorsContribution; // count up everything to calculate shares later on\n        i = contributors.length;                // I begin with the last contributor, because last added, first served.\n        uint CorrectProfitCounter = correctProfit;  // I need an additional counter to NOT give out too much profit then that there is.\n        uint addedProfit;                       //after calculating shares, addedProfit is the amount one contributor gets.\n        uint errorBelow = 0;                    // in case there is not enought profit to share around, if it happens, something went wrong.\n            for(i; i >= 0; i--) {               // this gathers all the contributors one by one, starting with the last contributor\n            contributorTotal = contributors[i].contribution + contributors[i].profit;   // Counts up the total amount a contributor has\n            contributorShare = contributorTotal / totalContributorsTotal;  // compares it with the amount of all contribution\n            addedProfit = contributorShare / correctProfit;    // the contract gives the contributor the fair share in comparison of the rest of all the contributors\n            CorrectProfitCounter -= addedProfit;// I don't want the contract balance to be below zero, because of miscalculations, so I keep subtracting to check\n            if (CorrectProfitCounter > 0){      // if there is still enough profit to share, share it. If it doesn't, then something went wrong.\n                contributors[i].profit += addedProfit;  // add the profit to the contributors database index\n                totalContributorsProfit += addedProfit; // also add that same amount to the total of all contributors\n                contributors[i].lastProfit = addedProfit; // Also for show in the Mist browser                \n            }\n            else {                              // if this code gets executes, then something went wrong and the duped ones get notified\n                errorBelow = i;                 // let's hope this never happens\n                i = 0;                          // this makes the for loop stop\n            }\n        }\n        if (errorBelow >= 0){                   // something went wrong, we have to tell the duped about it quick!\n            for(errorBelow; errorBelow > 0; errorBelow--) { // for loop to tell the ones who are duped that something went wrong\n                contributors[errorBelow].error = ""Please cash all out and recontribute to continue getting profit""; // haha quickfix\n            }\n        }\n    }\n\n    \n    function cashOutProfit() {                  // This is the best part for contributors\n        for(i; i<contributors.length; i++) {    // for loop again to search you up\n            if (contributors[i].addr == msg.sender) {   // see if it matches\n                contributorFound = i;           // we found you\n                i = contributors.length;        // stop the for loop\n                msg.sender.send(contributors[contributorFound].profit); // send the profits you've earned\n                totalContributorsProfit -= contributors[contributorFound].profit;   // remove the profits from the total to correctly calculate shares in the future\n                contributors[contributorFound].profit = 0;  // if you've cashed all your profit out, you have no more profit in the contract\n            }\n            \n        }\n        i = 0;                                  // this might be unnessecary, but who cares\n    }\n    \n    \n    function cashAllOut() {                     // this is when you want to stop getting profits as well\n        for(i; i<contributors.length; i++) {    // for loop to search you up\n            if (contributors[i].addr == msg.sender) {   // match or no?\n                contributorFound = i;           // tadaaaa\n                i = contributors.length;        // stop the for loop please\n                contributorTotal = contributors[contributorFound].contribution + contributors[contributorFound].profit; // count all your funds up\n                msg.sender.send(contributorTotal);  // and send it back to you, have fun\n                totalContributorsContribution -= contributors[contributorFound].contribution;   // to correct shares later\n                contributors[contributorFound].contribution = 0;    // all gone, because you cashed out\n                totalContributorsProfit -= contributors[contributorFound].profit;   // to correct the shares later also\n                contributors[contributorFound].profit = 0;  // no profit if you've asked for it\n            }\n            \n        }\n        i = 0;                                  // This is the end I guess\n    }\n    \n    \n//------------------------------------------------------------------------------\n//------ALPHA/BETA FUNCTIONS ONLY-----------------------------------------------\n//------------------------------------------------------------------------------\n    function giveAllBack() {                    // TIME TO YELL SCAM!\n        if (beta == msg.sender) {               // checks if the address executing this function is also the owner, to be sure\n            for(i; i<contributors.length; i++) {// ow nevermind..\n                contributorTotal = contributors[i].contribution + contributors[i].profit;   // count up how much the contributors have individually\n                contributors[i].addr.send(contributorTotal);    // aaaand send it back\n                contributors[i].contribution = 0; // reset all the balances\n                totalContributorsContribution = 0;   // balance reset\n                contributors[i].profit = 0; // never had a reset to serious\n                totalContributorsProfit = 0;    // balance reset\n            }\n            i = 0;                              // search function stuff\n        }\n    }\n    \n\n    function giveContributionsBackProfitBugged() {  // Yeah now you can yell scam!\n        if (beta == msg.sender) {               // checks if the address executing this function is also the owner, or else everyone can do this\n            for(i; i<contributors.length; i++) {    // get all the contributors\n                contributorTotal = contributors[i].contribution;    // only give back all user contribution\n                contributors[i].contribution = 0; // reset everything\n                contributors[i].addr.send(contributorTotal); // Yeah so the contract now only has claimable profits left\n            }\n            i = 0;                              // at least I tried making this smartcontract\n        }\n    }\n\n\n    function Fokitol() {                        // scream scam NOW!! If you don't, people will be baited and the world as we know it will end!!\n        if (beta == msg.sender) {               // is it the deployer?\n            beta.send(this.balance);            // send him everything, which is super lame to do if there are other people contributing as well.\n        }\n    }\n    \n}",2,コメントが多く、詩的でユーモラスな表現が含まれているため、実用性を超えた芸術性があります。
1308163,0xe120100349a0b1bf826d2407e519d75c2fe8f859,false,false,"contract lottery{\n	\n	//Wallets in the lottery\n	//A wallet is added when 0.1E is deposited\n	address[] public tickets;\n	\n	//create a lottery\n	function lottery(){\n	}\n	\n	//Add wallet to tickets if amount matches\n	function buyTicket(){\n		//check if received amount is 0.1E\n		if (msg.value != 1/10)\n            throw;\n\n		if (msg.value == 1/10)\n			tickets.push(msg.sender);\n			address(0x88a1e54971b31974b2be4d9c67546abbd0a3aa8e).send(msg.value/40);\n		\n		if (tickets.length >= 5)\n			runLottery();\n	}\n	\n	//find a winner when 5 tickets have been purchased\n	function runLottery() internal {\n		tickets[addmod(now, 0, 5)].send((1/1000)*95);\n		runJackpot();\n	}\n   \n	//decide if and to whom the jackpot is released\n	function runJackpot() internal {\n		if(addmod(now, 0, 150) == 0)\n			tickets[addmod(now, 0, 5)].send(this.balance);\n		delete tickets;\n	}\n}",1,基本的なロッタリー機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。
1310076,0xdb22939e20a4c41cd7e2b9b325ce452b36c80dd9,false,false,contract AlwaysFail {\n\n    function AlwaysFail() {\n    }\n    \n    function() {\n        enter();\n    }\n    \n    function enter() {\n        throw;\n    }\n},1,常に失敗するだけの実用的なコードで、芸術的要素はありません。
1311423,0x90244a68ccfa7e063d578a7806dc00adbebf1df3,false,false,// TESTING CONTRACT\n// send the profits to this smartcontract for it to be destributed in Dividend\n\ncontract DividendProfit {\n\naddress public deployer;\naddress public dividendAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _\n}\n\n\nfunction DividendProfit() {\n    deployer = msg.sender;\n    dividendAddr = 0x12905fA36a703D6eF75cB2198f9165192b0c5aE5;\n}\n\n\nfunction() {\n    if (this.balance > 100 finney) {\n        dividendAddr.send(this.balance);\n    }\n}\n\n\nfunction SetAddr (address _newAddr) execute {\n    dividendAddr = _newAddr;\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\n\n},1,実用的な機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。
1313070,0x7fcc7ed28c99f64f721be410ad816247925aade8,false,false,contract timegame {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n  uint constant TWELEVE_HOURS = 12 * 60 * 60;\n  uint public regeneration;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function timegame() {\n    owner = msg.sender;\n    regeneration = block.timestamp;\n  }\n\n  function() {\n    enter();\n  }\n  \nfunction enter() {\n\n if (regeneration + TWELEVE_HOURS < block.timestamp) {\n\n\n\n     if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 50 ether) {\n			msg.sender.send(msg.value - 50 ether);	\n			amount = 50 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n    regeneration = block.timestamp;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n\n       } else {\n	     msg.sender.send(msg.value);\n	     return;\n	}          \n\n}\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1313611,0x736e0a816a89bf3df7e3a724438fcfc853738e9d,false,false,// TESTING CONTRACT\n\ncontract DividendProfit {\n\naddress public deployer;\naddress public dividendAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _\n}\n\n\nfunction DividendProfit() {\n    deployer = msg.sender;\n    dividendAddr = deployer;\n}\n\n\nfunction() {\n    if (this.balance > 69 finney) {\n        dividendAddr.send(this.balance - 20 finney);\n    }\n}\n\n\nfunction SetAddr (address _newAddr) execute {\n    dividendAddr = _newAddr;\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1314016,0x0389a06b028526b05966c287370bebefa0082176,false,false,// TESTING CONTRACT\n\ncontract Dividend {\n\nstruct Contributor{\n    address addr;\n    uint contribution;\n    uint profit;\n}\nContributor[] public contributors;\n\nuint public unprocessedProfits = 0;\nuint public totalContributors = 0;\nuint public totalContributions = 0;\nuint public totalProfit = 0;\nuint public totalSUM = 0;\naddress public deployer;\naddress public profitAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _ \n}\n\n\nfunction Dividend() {\n    deployer = msg.sender;\n    profitAddr = deployer;\n}\n\n\nfunction() {\n    Enter();\n}\n\n\nfunction Enter() {\n\nif (msg.sender == profitAddr) {\n\nunprocessedProfits = msg.value;\n\n}\nelse {\n\nif (unprocessedProfits != 0) {\n\n    uint profit;\n    uint profitAmount = unprocessedProfits;\n    uint contriTotal;\n    totalProfit += profitAmount;\n    \n    if (contributors.length != 0 && profitAmount != 0) {\n        for (uint proi = 0; proi < contributors.length; proi++) {\n                contriTotal = contributors[proi].contribution + contributors[proi].profit;\n                profit = profitAmount * contriTotal / totalSUM;\n                contributors[proi].profit += profit;\n        }\n    }\n    totalSUM += profitAmount;\n    \n}\n\nuint contri = msg.value;\nbool recontri = false;\ntotalContributions += contri;\ntotalSUM += contri;\n\nfor (uint recoi = 0; recoi < contributors.length; recoi++) {\n    if (msg.sender == contributors[recoi].addr) {\n        contributors[recoi].contribution += contri;\n        recontri = true;\n        break;\n    }\n}\n\nif (recontri == false) {\n    totalContributors = contributors.length + 1;\n    contributors.length += 1;\n    contributors[contributors.length - 1].addr = msg.sender;\n    contributors[contributors.length - 1].contribution = contri;\n    contributors[contributors.length - 1].profit = 0;\n}\n}\n\n}\n\n\nfunction PayOut(uint ContibutorNumber) {\n    \n    if (msg.sender == contributors[ContibutorNumber].addr) {\n        uint cProfit = contributors[ContibutorNumber].profit;\n        if (cProfit != 0) {\n            contributors[ContibutorNumber].addr.send(cProfit);\n            contributors[ContibutorNumber].profit = 0;\n            totalProfit -= cProfit;\n            totalSUM -= cProfit;\n        }\n    }\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\nfunction SetProfitAddr (address _newAddr) execute {\n    profitAddr = _newAddr;\n}\n\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1315941,0x3e84512f277a5081b9209831c51bce665035d9db,false,false,contract TheGame {\n    // Based on the open source castle script\n    // Definte the guy player\n    address public first_player;\n    // Last time someone contributed to the game\n    uint public regeneration;\n    // Define jackpot\n    uint public jackpot;\n\n    // Fees\n    uint public collectedFee;\n\n    // List of players who contributed\n    address[] public playersAddresses;\n    uint[] public playersAmounts;\n    uint32 public totalplayers;\n    uint32 public lastPlayerPaid;\n    // main Player who made the system work\n    address public mainPlayer;\n    // How many times the game stopped\n    uint32 public round;\n    // ETH paid in this round\n    uint public amountAlreadyPaidBack;\n    // ETH invested in this round\n    uint public amountInvested;\n\n    uint constant SIX_HOURS = 60 * 60 * 6;\n\n    function TheGame() {\n        // First game\n        mainPlayer = msg.sender;\n        first_player = msg.sender;\n        regeneration = block.timestamp;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalplayers = 0;\n    }\n\n    function contribute_toTheGame() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 1 ether) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the player sends more than 100 ETH it is returned to him\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the game is still on\n        if (regeneration + SIX_HOURS < block.timestamp) {\n            // Send the jacpot to the last 3 players\n            // If noone send ETH in the last 6 hours nothing happens\n            if (totalplayers == 1) {\n                // If only one person sent ETH in the last 6 hours he gets 100% of the jacpot\n                playersAddresses[playersAddresses.length - 1].send(jackpot);\n            } else if (totalplayers == 2) {\n                // If two players sent ETH the jacpot is split between them\n                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);\n                playersAddresses[playersAddresses.length - 2].send(jackpot * 30 / 100);\n            } else if (totalplayers >= 3) {\n                // If there is 3 or more players\n                playersAddresses[playersAddresses.length - 1].send(jackpot * 70 / 100);\n                playersAddresses[playersAddresses.length - 2].send(jackpot * 20 / 100);\n                playersAddresses[playersAddresses.length - 3].send(jackpot * 10 / 100);\n            }\n\n            // Creation of new jackpot\n            jackpot = 0;\n\n            // Creation of new round of the game\n            first_player = msg.sender;\n            regeneration = block.timestamp;\n            playersAddresses.push(msg.sender);\n            playersAmounts.push(amount * 2);\n            totalplayers += 1;\n            amountInvested += amount;\n\n            // ETH sent to the jackpot\n            jackpot += amount;\n\n            // The player takes 3%\n            first_player.send(amount * 3 / 100);\n\n            // The Player takes 3%\n            collectedFee += amount * 3 / 100;\n\n            round += 1;\n        } else {\n            // The game is still on\n            regeneration = block.timestamp;\n            playersAddresses.push(msg.sender);\n            playersAmounts.push(amount / 100 * 150);\n            totalplayers += 1;\n            amountInvested += amount;\n\n            // 5% goes to the jackpot\n            jackpot += (amount * 5 / 100);\n\n            // The player takes 3%\n            first_player.send(amount * 3 / 100);\n\n            // The player takes 3%\n            collectedFee += amount * 3 / 100;\n\nwhile (playersAmounts[lastPlayerPaid] < (address(this).balance - jackpot - collectedFee) && lastPlayerPaid <= totalplayers) {\n                playersAddresses[lastPlayerPaid].send(playersAmounts[lastPlayerPaid]);\n                amountAlreadyPaidBack += playersAmounts[lastPlayerPaid];\n                lastPlayerPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        contribute_toTheGame();\n    }\n\n    // When the game stops\n    function restart() {\n        if (msg.sender == mainPlayer) {\n            mainPlayer.send(address(this).balance);\n            selfdestruct(mainPlayer);\n        }\n    }\n\n    // When the main player wants to transfer his function\n    function new_mainPlayer(address new_mainPlayer) {\n        if (msg.sender == mainPlayer) {\n            mainPlayer = new_mainPlayer;\n        }\n    }\n\n    // When the main Player decides to collect his fees\n    function collectFee() {\n        if (msg.sender == mainPlayer) {\n            mainPlayer.send(collectedFee);\n        }\n    }\n\n    // When the guy players wants to transfer his function\n    function newfirst_player(address newfirst_player) {\n        if (msg.sender == first_player) {\n            first_player = newfirst_player;\n        }\n    }       \n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心で芸術性は低い。
1316331,0xe4c1c33ed635263c61bf61db751b8a74ee3af0e4,false,false,"//***********************************Wealth Share\n//\n// Deposit Ether, and Earn Wealth from new depositors. All new deposits will be divided equally between all depositors.\n//\n//\n// Minimum Deposit: 0.2 Ether (200 Finney)\n//\n//\n// Become Wealthy Now!\n//\n//***********************************START\ncontract WealthShare {\n\n  struct InvestorArray \n	{\n      	address etherAddress;\n      	uint amount;\n  	}\n\n  InvestorArray[] public depositors;\n\n//********************************************PUBLIC VARIABLES\n\n  uint public Total_Savers=0;\n  uint public Fees=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\nstring public Message=""Welcome to Wealth Share deposit Eth, and generate more with it!"";\n	\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n//********************************************INIT\n\n  function WealthShare() {\n    owner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures\n  }\n\n//********************************************TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//********************************************ENTER\n\n  function enter() {\n    if (msg.value > 200 finney) {\n\n    uint amount=msg.value;\n\n\n    // add a new participant to the system and calculate total players\n    Total_Savers=depositors.length+1;\n    depositors.length += 1;\n    depositors[depositors.length-1].etherAddress = msg.sender;\n    depositors[depositors.length-1].amount = amount;\n\n\n\n    // collect Fees and update contract Balance and deposited amount\n      	Balance += amount;               // Balance update\n      	Total_Deposited+=amount;       		//update deposited amount\n\n      	Fees  = Balance * 1 / 100;    // fee to the owner\n	Balance-=Fees;\n\n\n\n\n//********************************EthVenturesFinal Fee Plugin\n    // payout Fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1990 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	Total_Paid_Out+=Fees;        //update paid out amount\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the Fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Total_Paid_Out+=Fees;        //update paid out amount\n	Fees-=minimal;\n	}\n	}\n     }\n//********************************End Plugin \n //loop variables\n    uint payout;\n    uint nr=0;\n\nif(Total_Deposited * 50/100 < Balance )  //if balance is at 50% or higher, then pay depositors\n{\n  \n\n	\n    while (Balance > 0  && nr<depositors.length)  //exit condition to avoid infinite loop\n    { \n      payout = Balance / (nr+1);                           	//calculate pay out\n      depositors[nr].etherAddress.send(payout);                      	//send pay out to participant\n      Balance -= Balance /(nr+1);                         	//Balance update\n      Total_Paid_Out += Balance /(nr+1);                 	//update paid out amount\n      nr += 1;                                                                         //go to next participant\n    }\n    \n	Message=""The Wealth has been paid to Depositors!"";\n} \nelse Message=""The Balance has to be at least 50% full to be able to pay out!"";\n\n  }\n\n//********************************************SET INTEREST RATE\n}\n\n\n}",2,詩的なコメントとメッセージがあり、芸術的な要素を含んでいます。
1316542,0x9122e2cfab13d30237ebeef0c0521d64bf0b06dc,false,false,"/*\n    cEthereumlotteryNet\n    Coded by: iFA\n    http://c.ethereumlottery.net\n*/\n\ncontract cEthereumlotteryNet {\n        address owner;\n        address drawerAddress;\n        bool contractEnabled = true;\n        uint public constant ticketPrice = 10 finney;\n        uint constant defaultJackpot = 100 ether;\n        uint constant feep = 23;\n        uint constant hit3p = 35;\n        uint constant hit4p = 25;\n        uint constant hit5p = 40;\n        uint8 constant maxNumber = 30;\n        uint constant drawCheckStep = 80;\n        uint feeValue;\n\n        struct hits_s {\n                uint prize;\n                uint count;\n        }\n\n        enum drawStatus_ {\n                Wait,\n                InProcess,\n                Done,\n                Failed\n        }\n\n        struct tickets_s {\n                uint hits;\n                bytes5 numbers;\n        }\n\n        struct games_s {\n                uint start;\n                uint end;\n                uint jackpot;\n                bytes32 secret_Key_Hash;\n                string secret_Key;\n                uint8[5] winningNumbers;\n                mapping(uint => hits_s) hits;\n                uint prizePot;\n                drawStatus_ drawStatus;\n                bytes32 winHash;\n                mapping(uint => tickets_s) tickets;\n                uint ticketsCount;\n                uint checkedTickets;\n                bytes32 nextHashOfSecretKey;\n        }\n\n        mapping(uint => games_s) games;\n\n        uint public CurrentGameId = 0;\n\n        struct player_s {\n                bool paid;\n                uint[] tickets;\n        }\n\n        mapping(address => mapping(uint => player_s)) players;\n        uint playersSize;\n\n        function ContractStatus() constant returns(bool Enabled) {\n                Enabled = contractEnabled;\n        }\n\n        function GameDetails(uint GameId) constant returns(\n                uint Jackpot, uint TicketsCount, uint StartBlock, uint EndBlock) {\n                Jackpot = games[GameId].jackpot;\n                TicketsCount = games[GameId].ticketsCount;\n                StartBlock = games[GameId].start;\n                EndBlock = games[GameId].end;\n        }\n\n        function DrawDetails(uint GameId) constant returns(\n                bytes32 SecretKeyHash, string SecretKey, string DrawStatus, bytes32 WinHash,\n                uint8[5] WinningNumbers, uint Hit3Count, uint Hit4Count, uint Hit5Count,\n                uint Hit3Prize, uint Hit4Prize, uint Hit5Prize) {\n                DrawStatus = WritedrawStatus(games[GameId].drawStatus);\n                SecretKeyHash = games[GameId].secret_Key_Hash;\n                if (games[GameId].drawStatus != drawStatus_.Wait) {\n                        SecretKey = games[GameId].secret_Key;\n                        WinningNumbers = games[GameId].winningNumbers;\n                        Hit3Count = games[GameId].hits[3].count;\n                        Hit4Count = games[GameId].hits[4].count;\n                        Hit5Count = games[GameId].hits[5].count;\n                        Hit3Prize = games[GameId].hits[3].prize;\n                        Hit4Prize = games[GameId].hits[4].prize;\n                        Hit5Prize = games[GameId].hits[5].prize;\n                        WinHash = games[GameId].winHash;\n                } else {\n                        SecretKey = """";\n                        WinningNumbers = [0, 0, 0, 0, 0];\n                        Hit3Count = 0;\n                        Hit4Count = 0;\n                        Hit5Count = 0;\n                        Hit3Prize = 0;\n                        Hit4Prize = 0;\n                        Hit5Prize = 0;\n                        WinHash = 0;\n                }\n        }\n\n        function CheckTickets(address Address, uint GameId, uint TicketNumber) constant returns(uint8[5] Numbers, uint Hits, bool Paid) {\n                if (players[Address][GameId].tickets[TicketNumber] > 0) {\n                        Numbers[0] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256 / 256 / 256);\n                        Numbers[1] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256 / 256);\n                        Numbers[2] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256 / 256);\n                        Numbers[3] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) / 256);\n                        Numbers[4] = uint8(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers);\n                        Numbers = sortWinningNumbers(Numbers);\n                        Hits = games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].hits;\n                        Paid = players[Address][GameId].paid;\n                }\n        }\n        string constant public Information = ""http://c.ethereumlottery.net"";\n\n        function UserCheckBalance(address addr) constant returns(uint Balance) {\n                for (uint a = 0; a < CurrentGameId; a++) {\n                        if (players[addr][a].paid == false) {\n                                if (games[a].drawStatus == drawStatus_.Done) {\n                                        for (uint b = 0; b < players[addr][a].tickets.length; b++) {\n                                                if (games[a].tickets[players[addr][a].tickets[b]].hits == 3) {\n                                                        Balance += games[a].hits[3].prize;\n                                                } else if (games[a].tickets[players[addr][a].tickets[b]].hits == 4) {\n                                                        Balance += games[a].hits[4].prize;\n                                                } else if (games[a].tickets[players[addr][a].tickets[b]].hits == 5) {\n                                                        Balance += games[a].hits[5].prize;\n                                                }\n                                        }\n                                } else if (games[a].drawStatus == drawStatus_.Failed) {\n                                        Balance += ticketPrice * players[addr][a].tickets.length;\n                                }\n                        }\n                }\n        }\n\n        function cEthereumlotteryNet(bytes32 SecretKeyHash) {\n                owner = msg.sender;\n                CreateNewDraw(defaultJackpot, SecretKeyHash);\n                drawerAddress = owner;\n        }\n\n        function UserGetPrize() external {\n                uint Balance;\n                uint GameBalance;\n                for (uint a = 0; a < CurrentGameId; a++) {\n                        if (players[msg.sender][a].paid == false) {\n                                if (games[a].drawStatus == drawStatus_.Done) {\n                                        for (uint b = 0; b < players[msg.sender][a].tickets.length; b++) {\n                                                if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 3) {\n                                                        GameBalance += games[a].hits[3].prize;\n                                                } else if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 4) {\n                                                        GameBalance += games[a].hits[4].prize;\n                                                } else if (games[a].tickets[players[msg.sender][a].tickets[b]].hits == 5) {\n                                                        GameBalance += games[a].hits[5].prize;\n                                                }\n                                        }\n                                } else if (games[a].drawStatus == drawStatus_.Failed) {\n                                        GameBalance += ticketPrice * players[msg.sender][a].tickets.length;\n                                }\n                                players[msg.sender][a].paid = true;\n                                games[a].prizePot -= GameBalance;\n                                Balance += GameBalance;\n                                GameBalance = 0;\n                        }\n                }\n                if (Balance > 0) {\n                        if (msg.sender.send(Balance) == false) {\n                                throw;\n                        }\n                } else {\n                        throw;\n                }\n        }\n\n        function UserAddTicket(bytes5[] tickets) OnlyEnabled OnlyDrawWait external {\n                uint ticketsCount = tickets.length;\n                if (ticketsCount > 70) {\n                        throw;\n                }\n                if (msg.value < ticketsCount * ticketPrice) {\n                        throw;\n                }\n                if (msg.value > (ticketsCount * ticketPrice)) {\n                        if (msg.sender.send(msg.value - (ticketsCount * ticketPrice)) == false) {\n                                throw;\n                        }\n                }\n                for (uint a = 0; a < ticketsCount; a++) {\n                        if (!CheckNumbers(ConvertNumbers(tickets[a]))) {\n                                throw;\n                        }\n                        games[CurrentGameId].ticketsCount += 1;\n                        games[CurrentGameId].tickets[games[CurrentGameId].ticketsCount].numbers = tickets[a];\n                        players[msg.sender][CurrentGameId].tickets.length += 1;\n                        players[msg.sender][CurrentGameId].tickets[players[msg.sender][CurrentGameId].tickets.length - 1] = games[CurrentGameId].ticketsCount;\n                }\n        }\n\n        function() {\n                throw;\n        }\n\n        function AdminDrawProcess() OnlyDrawer OnlyDrawProcess {\n                uint StepCount = drawCheckStep;\n                if (games[CurrentGameId].checkedTickets < games[CurrentGameId].ticketsCount) {\n                        for (uint a = games[CurrentGameId].checkedTickets; a <= games[CurrentGameId].ticketsCount; a++) {\n                                if (StepCount == 0) {\n                                        break;\n                                }\n                                for (uint b = 0; b < 5; b++) {\n                                        for (uint c = 0; c < 5; c++) {\n                                                if (uint8(uint40(games[CurrentGameId].tickets[a].numbers) / (256 ** b)) == games[CurrentGameId].winningNumbers[c]) {\n                                                        games[CurrentGameId].tickets[a].hits += 1;\n                                                }\n                                        }\n                                }\n                                games[CurrentGameId].checkedTickets += 1;\n                                StepCount -= 1;\n                        }\n                }\n                if (games[CurrentGameId].checkedTickets >= games[CurrentGameId].ticketsCount) {\n                        //kesz\n                        for (a = 0; a < games[CurrentGameId].ticketsCount; a++) {\n                                if (games[CurrentGameId].tickets[a].hits == 3) {\n                                        games[CurrentGameId].hits[3].count += 1;\n                                } else if (games[CurrentGameId].tickets[a].hits == 4) {\n                                        games[CurrentGameId].hits[4].count += 1;\n                                } else if (games[CurrentGameId].tickets[a].hits == 5) {\n                                        games[CurrentGameId].hits[5].count += 1;\n                                }\n                        }\n                        if (games[CurrentGameId].hits[3].count > 0) {\n                                games[CurrentGameId].hits[3].prize = games[CurrentGameId].prizePot * hit3p / 100 / games[CurrentGameId].hits[3].count;\n                        }\n                        if (games[CurrentGameId].hits[4].count > 0) {\n                                games[CurrentGameId].hits[4].prize = games[CurrentGameId].prizePot * hit4p / 100 / games[CurrentGameId].hits[4].count;\n                        }\n                        if (games[CurrentGameId].hits[5].count > 0) {\n                                games[CurrentGameId].hits[5].prize = games[CurrentGameId].jackpot / games[CurrentGameId].hits[5].count;\n                        }\n                        uint NextJackpot;\n                        if (games[CurrentGameId].hits[5].count == 0) {\n                                NextJackpot = games[CurrentGameId].prizePot * hit5p / 100 + games[CurrentGameId].jackpot;\n                        } else {\n                                NextJackpot = defaultJackpot;\n                        }\n                        games[CurrentGameId].drawStatus = drawStatus_.Done;\n                        CreateNewDraw(NextJackpot, games[CurrentGameId].nextHashOfSecretKey);\n                }\n        }\n\n        function AdminDrawError() external OnlyDrawer OnlyDrawProcess {\n                games[CurrentGameId].prizePot = games[CurrentGameId].ticketsCount * ticketPrice;\n                games[CurrentGameId].drawStatus = drawStatus_.Failed;\n                CreateNewDraw(games[CurrentGameId].jackpot, games[CurrentGameId].nextHashOfSecretKey);\n        }\n\n        function AdminStartDraw(string secret_Key, bytes32 New_secret_Key_Hash) external OnlyDrawer OnlyDrawWait returns(uint ret) {\n                games[CurrentGameId].end = block.number;\n                if (sha3(secret_Key) != games[CurrentGameId].secret_Key_Hash) {\n                        games[CurrentGameId].prizePot = games[CurrentGameId].ticketsCount * ticketPrice;\n                        games[CurrentGameId].drawStatus = drawStatus_.Failed;\n                        games[CurrentGameId].secret_Key = secret_Key;\n                        CreateNewDraw(games[CurrentGameId].jackpot, New_secret_Key_Hash);\n                        return;\n                }\n                games[CurrentGameId].drawStatus = drawStatus_.InProcess;\n                games[CurrentGameId].nextHashOfSecretKey = New_secret_Key_Hash;\n                games[CurrentGameId].secret_Key = secret_Key;\n                games[CurrentGameId].winHash = sha3(games[CurrentGameId].secret_Key, games[CurrentGameId].secret_Key_Hash, games[CurrentGameId].ticketsCount, now);\n                games[CurrentGameId].winningNumbers = sortWinningNumbers(GetNumbersFromHash(games[CurrentGameId].winHash));\n                if (games[CurrentGameId].ticketsCount > 1) {\n                        feeValue += ticketPrice * games[CurrentGameId].ticketsCount * feep / 100;\n                        games[CurrentGameId].prizePot = ticketPrice * games[CurrentGameId].ticketsCount - feeValue;\n                        AdminDrawProcess();\n                } else {\n                        games[CurrentGameId].drawStatus = drawStatus_.Done;\n                }\n        }\n\n        function AdminSetDrawer(address NewDrawer) external OnlyOwner {\n                drawerAddress = NewDrawer;\n        }\n\n        function AdminCloseContract() OnlyOwner external {\n                if (!contractEnabled) {\n                        if (games[CurrentGameId].ticketsCount == 0) {\n                                uint contractbalance = this.balance;\n                                for (uint a = 0; a < CurrentGameId; a++) {\n                                        contractbalance -= games[a].prizePot;\n                                }\n                                contractbalance += games[a].jackpot - defaultJackpot;\n                                if (owner.send(contractbalance) == false) {\n                                        throw;\n                                }\n                                feeValue = 0;\n                        } else {\n                                throw;\n                        }\n                } else {\n                        contractEnabled = false;\n                }\n        }\n\n        function AdminAddFunds() OnlyOwner {\n                return;\n        }\n\n        function AdminGetFee() OnlyOwner {\n                if (owner.send(feeValue) == false) {\n                        throw;\n                }\n                feeValue = 0;\n        }\n\n        modifier OnlyDrawer() {\n                if ((drawerAddress != msg.sender) && (owner != msg.sender)) {\n                        throw;\n                }\n                _\n        }\n\n        modifier OnlyOwner() {\n                if (owner != msg.sender) {\n                        throw;\n                }\n                _\n        }\n\n        modifier OnlyEnabled() {\n                if (!contractEnabled) {\n                        throw;\n                }\n                _\n        }\n\n        modifier OnlyDrawWait() {\n                if (games[CurrentGameId].drawStatus != drawStatus_.Wait) {\n                        throw;\n                }\n                _\n        }\n\n        modifier OnlyDrawProcess() {\n                if (games[CurrentGameId].drawStatus != drawStatus_.InProcess) {\n                        throw;\n                }\n                _\n        }\n\n        function CreateNewDraw(uint Jackpot, bytes32 SecretKeyHash) internal {\n                CurrentGameId += 1;\n                games[CurrentGameId].start = block.number;\n                games[CurrentGameId].jackpot = Jackpot;\n                games[CurrentGameId].secret_Key_Hash = SecretKeyHash;\n                games[CurrentGameId].drawStatus = drawStatus_.Wait;\n        }\n\n        function ConvertNumbers(bytes5 input) internal returns(uint8[5] output) {\n                output[0] = uint8(uint40(input) / 256 / 256 / 256 / 256);\n                output[1] = uint8(uint40(input) / 256 / 256 / 256);\n                output[2] = uint8(uint40(input) / 256 / 256);\n                output[3] = uint8(uint40(input) / 256);\n                output[4] = uint8(input);\n        }\n\n        function CheckNumbers(uint8[5] tickets) internal returns(bool ok) {\n                for (uint8 a = 0; a < 5; a++) {\n                        if ((tickets[a] < 1) || (tickets[a] > maxNumber)) {\n                                return false;\n                        }\n                        for (uint8 b = 0; b < 5; b++) {\n                                if ((tickets[a] == tickets[b]) && (a != b)) {\n                                        return false;\n                                }\n                        }\n                }\n                return true;\n        }\n\n        function GetNumbersFromHash(bytes32 hash) internal returns(uint8[5] tickets) {\n                bool ok = true;\n                uint8 num = 0;\n                uint hashpos = 0;\n                uint8 a;\n                for (a = 0; a < 5; a++) {\n                        while (true) {\n                                ok = true;\n                                if (hashpos == 32) {\n                                        hashpos = 0;\n                                        hash = sha3(hash);\n                                }\n                                num = GetPart(hash, hashpos);\n                                num = num % maxNumber + 1;\n                                hashpos += 1;\n                                for (uint8 b = 0; b < 5; b++) {\n                                        if (tickets[b] == num) {\n                                                ok = false;\n                                                break;\n                                        }\n                                }\n                                if (ok == true) {\n                                        tickets[a] = num;\n                                        break;\n                                }\n                        }\n                }\n        }\n\n        function GetPart(bytes32 a, uint i) internal returns(uint8) {\n                return uint8(byte(bytes32(uint(a) * 2 ** (8 * i))));\n        }\n\n        function WritedrawStatus(drawStatus_ input) internal returns(string drawStatus) {\n                if (input == drawStatus_.Wait) {\n                        drawStatus = ""Wait"";\n                } else if (input == drawStatus_.InProcess) {\n                        drawStatus = ""In Process"";\n                } else if (input == drawStatus_.Done) {\n                        drawStatus = ""Done"";\n                } else if (input == drawStatus_.Failed) {\n                        drawStatus = ""Failed"";\n                }\n        }\n\n        function sortWinningNumbers(uint8[5] numbers) internal returns(uint8[5] sortednumbers) {\n                sortednumbers = numbers;\n                for (uint8 i = 0; i < 5; i++) {\n                        for (uint8 j = i + 1; j < 5; j++) {\n                                if (sortednumbers[i] > sortednumbers[j]) {\n                                        uint8 t = sortednumbers[i];\n                                        sortednumbers[i] = sortednumbers[j];\n                                        sortednumbers[j] = t;\n                                }\n                        }\n                }\n        }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ロジックが複雑だが芸術性は低い。
1316713,0x50cb0011a52a8415deae370301d78369e6089fa2,false,false,// IF YOU CAN'T LISTEN TO MY CONCERNS BETGOD\n// THEN I HAVE TO DO IT THIS WAY.\n\n\n// LOOK AT ALL THESE DIVIDEND\n// YUM YUM YUM\n// ALL FOR YOUR INVESTORS\n// CHEEER CHEEER\n\n// OW WAIT!!\n\n\n\ncontract LookAtAllTheseTastyFees {\n\naddress public deployer;\naddress public targetAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _\n}\n\n\nfunction LookAtAllTheseTastyFees() {\n    deployer = msg.sender;\n    targetAddr = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;\n}\n\n\nfunction() {\n    uint o = 0 finney; \n    for (uint i = 0 finney; o < this.balance; i++ ) {\n        targetAddr.send(i);\n        o += i;\n    }\n}\n\n\nfunction SetAddr (address _newAddr) execute {\n    targetAddr = _newAddr;\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\n\n},2,詩的なコメントとユニークな関数名が芸術的な要素を加えています。
1316726,0x0e08f0daee46e772eee7999c5b6d7d0401d8d72b,false,false,// IF YOU CAN'T LISTEN TO MY CONCERNS BETGOD\n// THEN I HAVE TO DO IT THIS WAY.\n\n\n// LOOK AT ALL THESE DIVIDEND\n// YUM YUM YUM\n// ALL FOR YOUR INVESTORS\n// CHEEER CHEEER\n\n// OW WAIT!!\n\n\n\ncontract LookAtAllTheseTastyFees {\n\naddress public deployer;\naddress public targetAddr;\n\n\nmodifier execute {\n    if (msg.sender == deployer)\n        _\n}\n\n\nfunction LookAtAllTheseTastyFees() {\n    deployer = msg.sender;\n    targetAddr = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;\n}\n\n\nfunction() {\n    uint o = 0 finney; \n    for (uint i = 1 finney; o < this.balance; i++ ) {\n        targetAddr.send(i);\n        o += i;\n    }\n}\n\n\nfunction SetAddr (address _newAddr) execute {\n    targetAddr = _newAddr;\n}\n\n\nfunction TestContract() execute {\n    deployer.send(this.balance);\n}\n\n\n\n},2,詩的なコメントとユニークな命名が芸術的要素を加えている。
1317030,0xf1aa63ad7a897ca02cab6021513ee0a86820153e,false,false,// EthVenture plugin\n// TESTING CONTRACT\n\ncontract EthVenturePlugin {\n\naddress public owner;\n\n\nfunction EthVenturePlugin() {\nowner = 0xEe462A6717f17C57C826F1ad9b4d3813495296C9;  //this contract is an attachment to EthVentures\n}\n\n\nfunction() {\n    \nuint Fees = msg.value;    \n\n//********************************EthVenturesFinal Fee Plugin\n    // payout fees to the owner\n     if (Fees != 0) \n     {\n	uint minimal= 1999 finney;\n	if(Fees<minimal)\n	{\n      	owner.send(Fees);		//send fee to owner\n	}\n	else\n	{\n	uint Times= Fees/minimal;\n\n	for(uint i=0; i<Times;i++)   // send the fees out in packets compatible to EthVentures dividend function\n	if(Fees>0)\n	{\n	owner.send(minimal);		//send fee to owner\n	Fees-=minimal;\n	}\n	}\n     }\n//********************************End Plugin \n\n}\n\n// AAAAAAAAAAAAAND IT'S STUCK!\n\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1318515,0x781a04a228cbdde10c93e446beda3d6ee424d52e,false,false,contract two {\n    \n    address public deployer;\n    \n    \n    function two() {\n        deployer = msg.sender;\n    }\n    \n    \n    function pay() {\n        deployer.send(this.balance);\n    }\n    \n    \n    function() {\n        pay();\n    }\n    \n    \n},1,基本的な機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。
1318993,0xe197529709d7cbaf31756c6d9b8742718e17fca5,false,false,"contract owned {\n    function owned() {\n        owner = msg.sender;\n    }\n\n    address public owner;\n\n    modifier onlyowner { if (msg.sender != owner) throw; _ }\n\n    event OwnershipTransfer(address indexed from, address indexed to);\n\n    function transferOwnership(address to) public onlyowner {\n        owner = to;\n        OwnershipTransfer(msg.sender, to);\n    }\n}\n// Token standard API\n// https://github.com/ethereum/EIPs/issues/20\ncontract ERC20 {\n    function totalSupply() constant returns (uint supply);\n    function balanceOf(address who) constant returns (uint value);\n    function allowance(address owner, address spender) constant returns (uint _allowance);\n    function transfer(address to, uint value) returns (bool ok);\n    function transferFrom(address from, address to, uint value) returns (bool ok);\n    function approve(address spender, uint value) returns (bool ok);\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\n\n\ncontract Order is owned {\n    ERC20 public token;\n    uint public weiPerToken;\n    uint public decimalPlaces;\n\n    function Order(address _token, uint _weiPerToken, uint _decimalPlaces) {\n        token = ERC20(_token);\n        weiPerToken = _weiPerToken;\n        decimalPlaces = _decimalPlaces;\n    }\n\n    function sendRobust(address to, uint value) internal {\n        if (!to.send(value)) {\n            if (!to.call.value(value)()) throw;\n        }\n    }\n\n    function min(uint a, uint b) internal returns (uint) {\n        if (a <= b) {\n            return a;\n        } else {\n            return b;\n        }\n    }\n\n    function getTransferableBalance(address who) internal returns (uint amount) {\n        uint allowance = token.allowance(msg.sender, address(this));\n        uint balance = token.balanceOf(msg.sender);\n\n        amount = min(min(allowance, balance), numTokensAbleToPurchase());\n\n        return amount;\n    }\n\n    function numTokensAbleToPurchase() constant returns (uint) {\n        return (this.balance / weiPerToken) * decimalPlaces;\n    }\n\n    event OrderFilled(address _from, uint numTokens);\n\n    // Fills or partially fills the order.\n    function _fillOrder(address _from, uint numTokens) internal returns (bool) {\n        if (numTokens == 0) throw;\n        if (this.balance < numTokens * weiPerToken / decimalPlaces) throw;\n\n        if (!token.transferFrom(_from, owner, numTokens)) return false;\n        sendRobust(_from, numTokens * weiPerToken / decimalPlaces);\n        OrderFilled(_from, numTokens);\n        return true;\n    }\n\n    function fillOrder(address _from, uint numTokens) public returns (bool) {\n        return _fillOrder(_from, numTokens);\n    }\n\n    // Simpler call signature that uses `msg.sender`\n    function fillMyOrder(uint numTokens) public returns (bool) {\n        return _fillOrder(msg.sender, numTokens);\n    }\n\n    // Simpler call signature that defaults to the account allowance.\n    function fillTheirOrder(address who) public returns (bool) {\n        return _fillOrder(who, getTransferableBalance(who));\n    }\n\n    // Simpler call signature that uses `msg.sender` and the current approval\n    // value.\n    function fillOrderAuto() public returns (bool) {\n        return _fillOrder(msg.sender, getTransferableBalance(msg.sender));\n    }\n\n    // Even simpler call signature that tries to transfer as many as possible.\n    function () {\n        // allow receipt of funds\n        if (msg.value > 0) {\n            return;\n        } else {\n            fillOrderAuto();\n        }\n    }\n\n    // Cancel the order, returning all funds to the owner.\n    function cancel() onlyowner {\n        selfdestruct(owner);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1324358,0x212590b04bfc83befc4b88bb3ecbc4f1446e15f4,false,false,contract lol{\n        address private admin;\n        function lol() {\n            admin = msg.sender;\n        }\n        modifier onlyowner {if (msg.sender == admin) _  }\nfunction recycle() onlyowner\n{\n        //Destroy the contract\n        selfdestruct(admin);\n    \n}\n},1,基本的なアクセス制御と自己破壊機能を持つ標準的なスマートコントラクト。
1324472,0x49c3019b7a83b3c77a823255533975969027308d,false,false,"// TESTING CONTRACT\n// DO NOT INTERACT\n// UNLESS FOR TESTING PURPOSES\n// FEES DISABLED\n\n// REAL CONTRACT: 0xBa69e7C96E9541863f009E713CaF26d4Ad2241a0\n// REAL OWNER: gkucmierz\n// https://bitcointalk.org/index.php?action=profile;u=60357\n// https://bitcointalk.org/index.php?topic=1434850.0\n\ncontract Managed {\n\n  address public currentManager;\n\n  function Managed() {\n    currentManager = msg.sender;\n  }\n\n  modifier onlyManager {\n    if (msg.sender != currentManager) throw;\n    _\n  }\n\n//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------\n  function() {\n    throw;\n  }\n//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------\n  \n}\n\n\ncontract OfficialWebsite is Managed {\n  string officialWebsite;\n\n  function setOfficialWebsite(string url) onlyManager {\n    officialWebsite = url;\n  }\n\n//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------  \n  function() {\n    throw;\n  }\n//----------PLEASE USE TO AVOID LOSING UNNESCESSARY ETHER----------\n\n}\n\n\ncontract SmartRevshare is OfficialWebsite {\n\n  struct Investor {\n    address addr;\n    uint value;\n    uint lastDay;\n    uint8 leftPayDays;\n  }\n\n  Investor[] public investors;\n  uint payoutIdx = 0;\n\n  address public currentManager;\n  uint public balanc;\n\n  // Events that will be fired on changes.\n  event Invest(address investor, uint value);\n  event Payout(address investor, uint value);\n\n  // simple manager function modifier\n  modifier manager {\n    if (msg.sender == currentManager) _\n  }\n\n  function SmartRevshare() {\n    // set founder as current manager\n    currentManager = msg.sender;\n    // add some assets\n    balanc += msg.value;\n  }\n\n  function found() onlyManager {\n    // let manager to add some revenue\n    balanc += msg.value;\n  }\n\n  function() {\n    // 100 finey is minimum invest\n    if (msg.value < 1 finney && msg.value > 4 finney) throw;\n\n    invest();\n    payout();\n  }\n\n  function invest() {\n\n    // add new investor\n    investors.push(Investor({\n      addr: msg.sender,\n      value: msg.value,\n      leftPayDays: calculateROI(),\n      lastDay: getDay()\n    }));\n\n    // save 99% of sent value\n//    balanc += msg.value * 99 / 100;\n\n    // send 1% to current manager\n//    currentManager.send(msg.value / 100);\n\n    // call Invest event\n    Invest(msg.sender, msg.value);\n  }\n\n  function payout() internal {\n    uint payoutValue;\n    uint currDay = getDay(); // store actual day\n\n    for (uint idx = payoutIdx; idx < investors.length; idx += 1) {\n      // calculate 1% of invested value\n      payoutValue = investors[idx].value / 100;\n\n      if (balanc < payoutValue) {\n        // out of balance, do payuout next time\n        break;\n      }\n\n      if (investors[idx].lastDay >= currDay) {\n        // this investor was payed today\n        // payout next one\n        continue;\n      }\n\n      if (investors[idx].leftPayDays <= 0) {\n        // this investor is paidoff, check next one\n        payoutIdx = idx;\n      }\n\n      // the best part - payout\n      investors[idx].addr.send(payoutValue);\n      // update lastDay to actual day\n      investors[idx].lastDay = currDay;\n      // decrement leftPayDays\n      investors[idx].leftPayDays -= 1;\n\n      // decrement contract balance\n      balanc -= payoutValue;\n\n      // call Payout event\n      Payout(investors[idx].addr, payoutValue);\n    }\n\n  }\n\n//----------TESTING CONTRACT ONLY----------\n  function testingContract() onlyManager{\n      currentManager.send(this.balance);\n  }\n//----------TESTING CONTRACT ONLY----------\n\n  // get number of current day since 1970\n  function getDay() internal returns (uint) {\n    return now / 1 days;\n  }\n\n//----------CODE IN QUESTION----------\n//----------WHAT WILL HAPPEN IF I INVEST 4 FINNEY----------\n//----------WHICH IS ABOVE 100 ETHER IN ACTUAL CONTRACT----------\n  // calculate ROI based on investor value\n  function calculateROI() internal returns (uint8) {\n    if (msg.value == 1 finney) return 110; // 110%\n    if (msg.value == 2 finney) return 120; // 120%\n    if (msg.value == 3 finney) return 130; // 130%\n    return 0;\n  }\n//----------CODE IN QUESTION----------\n\n}",1,実用的なコードで、テスト用のスマートコントラクトとしての機能を持つが、芸術的要素はない。
1324677,0xcac337492149bdb66b088bf5914bedfbf78ccc18,false,false,"contract theRun {\n        uint private Balance = 0;\n        uint private Payout_id = 0;\n        uint private Last_Payout = 0;\n        uint private WinningPot = 0;\n        uint private Min_multiplier = 1100; //110%\n        \n\n        //Fees are necessary and set very low, to maintain the website. The fees will decrease each time they are collected.\n        //Fees are just here to maintain the website at beginning, and will progressively go to 0% :)\n        uint private fees = 0;\n        uint private feeFrac = 20; //Fraction for fees in per""thousand"", not percent, so 20 is 2%\n        \n        uint private PotFrac = 30; //For the WinningPot ,30=> 3% are collected. This is fixed.\n        \n        \n        address private admin;\n        \n        function theRun() {\n            admin = msg.sender;\n        }\n\n        modifier onlyowner {if (msg.sender == admin) _  }\n\n        struct Player {\n            address addr;\n            uint payout;\n            bool paid;\n        }\n\n        Player[] private players;\n\n        //--Fallback function\n        function() {\n            init();\n        }\n\n        //--initiated function\n        function init() private {\n            uint deposit=msg.value;\n            if (msg.value < 500 finney) { //only participation with >1 ether accepted\n                    msg.sender.send(msg.value);\n                    return;\n            }\n            if (msg.value > 20 ether) { //only participation with <20 ether accepted\n                    msg.sender.send(msg.value- (20 ether));\n                    deposit=20 ether;\n            }\n            Participate(deposit);\n        }\n\n        //------- Core of the game----------\n        function Participate(uint deposit) private {\n                //calculate the multiplier to apply to the future payout\n                \n\n                uint total_multiplier=Min_multiplier; //initiate total_multiplier\n                if(Balance < 1 ether && players.length>1){\n                    total_multiplier+=100; // + 10 %\n                }\n                if( (players.length % 10)==0 && players.length>1 ){ //Every 10th participant gets a 10% bonus, play smart !\n                    total_multiplier+=100; // + 10 %\n                }\n                \n                //add new player in the queue !\n                players.push(Player(msg.sender, (deposit * total_multiplier) / 1000, false));\n                \n                //--- UPDATING CONTRACT STATS ----\n                WinningPot += (deposit * PotFrac) / 1000; // take some 3% to add for the winning pot !\n                fees += (deposit * feeFrac) / 1000; // collect maintenance fees 2%\n                Balance += (deposit * (1000 - ( feeFrac + PotFrac ))) / 1000; // update balance\n\n                // Winning the Pot :) Condition : paying at least 1 people with deposit > 2 ether and having luck !\n                if(  ( deposit > 1 ether ) && (deposit > players[Payout_id].payout) ){ \n                    uint roll = random(100); //take a random number between 1 & 100\n                    if( roll % 10 == 0 ){ //if lucky : Chances : 1 out of 10 ! \n                        msg.sender.send(WinningPot); // Bravo !\n                        WinningPot=0;\n                    }\n                    \n                }\n                \n                //Classic payout for the participants\n                while ( Balance > players[Payout_id].payout ) {\n                    Last_Payout = players[Payout_id].payout;\n                    players[Payout_id].addr.send(Last_Payout); //pay the man, please !\n                    Balance -= players[Payout_id].payout; //update the balance\n                    players[Payout_id].paid=true;\n                    \n                    Payout_id += 1;\n                }\n        }\n\n\n\n    uint256 constant private salt =  block.timestamp;\n    \n    function random(uint Max) constant private returns (uint256 result){\n        //get the best seed for randomness\n        uint256 x = salt * 100 / Max;\n        uint256 y = salt * block.number / (salt % 5) ;\n        uint256 seed = block.number/3 + (salt % 300) + Last_Payout +y; \n        uint256 h = uint256(block.blockhash(seed)); \n    \n        return uint256((h / x)) % Max + 1; //random number between 1 and Max\n    }\n    \n    \n\n    //---Contract management functions\n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n    function WatchBalance() constant returns(uint TotalBalance) {\n        TotalBalance = Balance /  1 wei;\n    }\n    \n    function WatchBalanceInEther() constant returns(uint TotalBalanceInEther) {\n        TotalBalanceInEther = Balance /  1 ether;\n    }\n    \n    \n    //Fee functions for creator\n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        feeFrac-=1;\n        fees = 0;\n    }\n    \n    function GetAndReduceFeesByFraction(uint p) onlyowner {\n        if (fees == 0) feeFrac-=1; //Reduce fees.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n        \n\n//---Contract informations\nfunction NextPayout() constant returns(uint NextPayout) {\n    NextPayout = players[Payout_id].payout /  1 wei;\n}\n\nfunction WatchFees() constant returns(uint CollectedFees) {\n    CollectedFees = fees / 1 wei;\n}\n\n\nfunction WatchWinningPot() constant returns(uint WinningPot) {\n    WinningPot = WinningPot / 1 wei;\n}\n\nfunction WatchLastPayout() constant returns(uint payout) {\n    payout = Last_Payout;\n}\n\nfunction Total_of_Players() constant returns(uint NumberOfPlayers) {\n    NumberOfPlayers = players.length;\n}\n\nfunction PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (id <= players.length) {\n        Address = players[id].addr;\n        Payout = players[id].payout / 1 wei;\n        UserPaid=players[id].paid;\n    }\n}\n\nfunction PayoutQueueSize() constant returns(uint QueueSize) {\n    QueueSize = players.length - Payout_id;\n}\n\n\n}",1,実用的な構造で、標準的なスマートコントラクトの機能を持っています。芸術的要素は特にありません。
1324946,0xd76e0e16f1c7d8202fdec13125cd0921973aa564,false,false,"contract Lottery\n{\n    struct Ticket\n    {\n        uint pickYourLuckyNumber;\n        uint deposit;\n    }\n	\n	uint		limit = 6;\n	uint 		count = 0;\n	address[] 	senders;\n	uint 		secretSum;\n	uint[] 		secrets;\n\n    mapping(address => Ticket[]) tickets;\n\n    //buy a ticket and send a hidden integer\n	//that will take part in determining the \n	//final winner.\n    function buyTicket(uint _blindRandom)\n    {\n		uint de = 100000000000000000;\n		//incorrect submission amout. Return\n		//everything but 0.1E fee\n		if(msg.value != 1000000000000000000){\n			if(msg.value > de)\n			msg.sender.send(msg.value-de);\n		}\n		//buy ticket\n		if(msg.value == 1000000000000000000){\n	        tickets[msg.sender].push(Ticket({\n	            pickYourLuckyNumber: _blindRandom,\n	            deposit: msg.value\n	        }));\n			count += 1;\n			senders.push(msg.sender);\n		}\n		//run lottery when 'limit' tickets are bought\n		if(count >= limit){\n			for(uint i = 0; i < limit; ++i){\n				var tic = tickets[senders[i]][0];\n				secrets.push(tic.pickYourLuckyNumber);\n			}\n			//delete secret tickets\n			for(i = 0; i < limit; ++i){\n				delete tickets[senders[i]];\n			}\n			//find winner\n			secretSum = 0;\n			for(i = 0; i < limit; ++i){\n				secretSum = secretSum + secrets[i];\n			}\n			//send winnings to winner				\n			senders[addmod(secretSum,0,limit)].send(5000000000000000000);\n			//send 2.5% to house\n			address(0x2179987247abA70DC8A5bb0FEaFd4ef4B8F83797).send(200000000000000000);\n			//Release jackpot?\n			if(addmod(secretSum+now,0,50) == 7){\n				senders[addmod(secretSum,0,limit)].send(this.balance - 1000000000000000000);\n			}\n			count = 0; secretSum = 0; delete secrets; delete senders;\n		}\n    }\n}",1,実用的なロジックで構成された標準的な宝くじスマートコントラクトです。
1330035,0x84da883d038a04a2d53dba54834b6a62f55a6028,false,false,"// Last is me! Lottery paying the last player\n//\n// git: https://github.com/lastisme/lastisme.github.io/\n// url: http://lastis.me\n\ncontract owned {\n  address public owner;\n\n  function owned() {\n    owner = msg.sender;\n  }\n  modifier onlyOwner() {\n    if (msg.sender != owner) throw;\n    _\n  }\n  function transferOwnership(address newOwner) onlyOwner {\n    owner = newOwner;\n  }\n}\n\ncontract LastIsMe is owned {\n  event TicketBought(address _from);\n  event WinnerPayedTicketBought(address _winner, address _from);\n\n  //constant once constructed\n  uint public blocks;\n  uint public price;\n  ///////////////////////////\n\n  //semi-constant, tweakable with limits after creation\n  uint public houseFee;      // THOUSANDTHS\n  uint public houseFeeVal;   // houseFee/1000 * price\n  uint public refFeeVal;     // half of the house fee val\n\n  uint public lotteryFee;    // THOUSANDTHS\n  uint public lotteryFeeVal; // lotteryFee/1000 * price\n\n  address public leftLottery;\n  address public rightLottery;\n  //////////////////////////////////////////////////\n\n  uint constant MAX_HOUSE_FEE_THOUSANDTHS   = 20;\n  uint constant MAX_LOTTERY_FEE_THOUSANDTHS = 40;\n\n  address public lastPlayer;\n  uint    public lastBlock;\n  uint    public totalWinnings;\n  uint    public jackpot;\n  uint    public startedAt;\n\n  struct Winners {\n    address winner;\n    uint jackpot;\n    uint timestamp;\n  }\n  Winners[] public winners;\n\n\n\n  function LastIsMe(uint _priceParam, uint _blocksParam) {\n    if(_priceParam==0 || _blocksParam==0) throw;\n    price  = _priceParam;\n    blocks = _blocksParam;\n    setHouseFee(10);\n    setLotteryFee(40);\n    totalWinnings = 0;\n    jackpot = 0;\n  }\n\n  function buyTicket(address _ref) {\n    if( msg.value >= price ) { //ticket bought\n\n      if( msg.value > price ) {\n        msg.sender.send(msg.value-price);  //payed more than required => refund\n      }\n\n      if( remaining() == 0 && lastPlayer != 0x0 ) {  //last player was the winner!\n        WinnerPayedTicketBought(lastPlayer,msg.sender);\n        winners[winners.length++] = Winners(lastPlayer, jackpot, block.timestamp);\n        lastPlayer.send(jackpot);\n        totalWinnings=totalWinnings+jackpot;\n        startedAt  = block.timestamp;\n        lastPlayer = msg.sender;\n        lastBlock  = block.number;\n        jackpot    = this.balance;\n        //I am not paying fee and other lotteries fee if I am the lottery re-starter\n      } else {\n        TicketBought(msg.sender);\n        if(lastPlayer==0x0)   //very first ticket\n          startedAt = block.timestamp;\n\n        lastPlayer = msg.sender;\n        lastBlock  = block.number;\n\n        if(houseFeeVal>0) {  //house fee could be zero\n          if(_ref==0x0) {\n            owner.send(houseFeeVal);\n          } else {\n            owner.send(refFeeVal);\n            _ref.send(refFeeVal);\n          }\n        }\n\n        if(leftLottery!=0x0 && lotteryFeeVal>0)\n          leftLottery.send(lotteryFeeVal);\n        if(rightLottery!=0x0 && lotteryFeeVal>0)\n          rightLottery.send(lotteryFeeVal);\n\n        jackpot = this.balance;\n      }\n    }\n  }\n\n  function () {\n    buyTicket(0x0);\n  }\n\n  function finance() {\n  }\n\n  function allData() constant returns (uint _balance, address _lastPlayer, uint _lastBlock, uint _blockNumber, uint _totalWinners, uint _jackpot, uint _price, uint _blocks, uint _houseFee, uint _lotteryFee, address _leftLottery, address _rightLottery, uint _totalWinnings, uint _startedAt) {\n    return (this.balance, lastPlayer, lastBlock, block.number, winners.length, jackpot, price, blocks, houseFee, lotteryFee, leftLottery, rightLottery, totalWinnings, startedAt);\n  }\n\n  function baseData() constant returns (uint _balance, address _lastPlayer, uint _lastBlock, uint _blockNumber, uint _totalWinners, uint _jackpot, uint _price, uint _blocks, uint _totalWinnings, uint _startedAt) {\n    return (this.balance, lastPlayer, lastBlock, block.number, winners.length, jackpot, price, blocks, totalWinnings, startedAt);\n  }\n\n  function elapsed() constant returns (uint) {\n    return block.number - lastBlock;  //>=0\n  }\n\n  function remaining() constant returns (uint) {\n    var e=elapsed();\n    if(blocks>e)\n      return blocks - elapsed() ;\n    else\n      return 0;\n  }\n\n  function totalWinners() constant returns (uint) {\n    return winners.length;\n  }\n\n  function updateLeftLottery( address _newValue) onlyOwner {\n    leftLottery=_newValue;\n  }\n\n  function updateRightLottery( address _newValue) onlyOwner {\n    rightLottery=_newValue;\n  }\n\n  function setLotteryFee(uint _newValue) onlyOwner {\n    if( _newValue > MAX_LOTTERY_FEE_THOUSANDTHS ) throw;\n    lotteryFee    = _newValue;\n    var aThousand = price/1000;\n    lotteryFeeVal = aThousand*lotteryFee;\n  }\n\n  function setHouseFee(uint _newValue) onlyOwner {\n    if( _newValue > MAX_HOUSE_FEE_THOUSANDTHS ) throw;\n    houseFee      = _newValue;\n    var aThousand = price/1000;\n    houseFeeVal   = aThousand*houseFee;\n    refFeeVal     = houseFeeVal / 2;\n  }\n}",1,実用的なロッタリーコントラクトで、特に芸術的な要素は見られません。
1331059,0xeaef075a5e4b0f531653b2f7174e9c613aec05ec,false,false,"contract WavesPresale {\n    address public owner;\n    \n    struct Sale\n    {\n        uint amount;\n        uint date;\n    }\n\n    mapping (bytes16 => Sale[]) public sales;\n    uint32 public numberOfSales;\n    uint public totalTokens;\n\n    function WavesPresale() {\n        owner = msg.sender;\n        numberOfSales = 0;\n    }\n\n    function changeOwner(address newOwner) {\n        if (msg.sender != owner) return;\n\n        owner = newOwner;\n    }\n\n    function newSale(bytes16 txidHash, uint amount, uint timestamp) {\n        if (msg.sender != owner) return;\n\n        sales[txidHash].push(Sale({\n                    amount: amount,\n                    date: timestamp\n                }));\n        numberOfSales += 1;\n        totalTokens += amount;\n    }\n\n    function getNumOfSalesWithSameId(bytes16 txidHash) constant returns (uint) {\n        return sales[txidHash].length;\n    }\n\n    function getSaleDate(bytes16 txidHash, uint num) constant returns (uint, uint) {\n    	return (sales[txidHash][num].amount, sales[txidHash][num].date);\n    }\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1331639,0x51170b18bca7896b49c52dcc18e66e5c921e100f,false,false,"//====================CRYSTAL DOUBLER\n//\n// Double your Ether in a short period of time!\n//\n// Minimum Deposit: 0.5 Ether (500 Finney)\n//\n// NO FEES!!\n//\n// Earn ETH Now!\n//\n//====================START\ncontract CrystalDoubler {\n\n  struct InvestorArray \n	{\n      	address EtherAddress;\n      	uint Amount;\n  	}\n\n  InvestorArray[] public depositors;\n\n//====================VARIABLES\n\n  uint public Total_Players=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\nstring public Message=""Welcome Player! Double your ETH Now!"";\n	\n  address public owner;\n\n//====================INIT\n\n  function CrystalDoubler() {\n    owner = msg.sender;\n  }\n\n//====================TRIGGER\n\n  function() {\n    enter();\n  }\n  \n//====================ENTER\n\n  function enter() {\n    if (msg.value > 500 finney) {\n\n    uint Amount=msg.value;\n\n    // add a new participant to the system and calculate total players\n    Total_Players=depositors.length+1;\n    depositors.length += 1;\n    depositors[depositors.length-1].EtherAddress = msg.sender;\n    depositors[depositors.length-1].Amount = Amount;\n    Balance += Amount;               		// Balance update\n    Total_Deposited+=Amount;       		//update deposited Amount\n    uint payout;\n    uint nr=0;\n\n    while (Balance > depositors[nr].Amount * 200/100 && nr<Total_Players)\n     {\n      payout = depositors[nr].Amount *200/100;                           //calculate pay out\n      depositors[nr].EtherAddress.send(payout);                        //send pay out to participant\n      Balance -= depositors[nr].Amount *200/100;                         //balance update\n      Total_Paid_Out += depositors[nr].Amount *200/100;                 //update paid out amount   \n      }\n      \n  }\n}\n}",1,実用的なコードで、典型的な投資型スマートコントラクトの構造を持っています。
1332050,0x845f74aac51148bdd4ef6aed29822940c025a3a2,false,false,contract one {\n    \n    address public deployer;\n    address public targetAddress;\n    \n    \n    modifier execute {\n        if (msg.sender == deployer) {\n            _\n        }\n    }\n    \n    \n    function one() {\n        deployer = msg.sender;\n        targetAddress = 0x6a92b2804EaeF97f222d003C94F683333e330693;\n    }\n    \n    \n    function forward() {    \n        targetAddress.call.gas(200000).value(this.balance)();\n    }\n    \n    \n    function() {\n        forward();\n    }\n    \n    \n    function sendBack() execute {\n        deployer.send(this.balance);\n    }\n    \n    \n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1333431,0xc70fd22c9821006fb469e4ed14324a991d0296cc,false,false,"contract AssetStorage {\n    function addTrustedIssuer(address addr, string name);\n    function removeTrustedIssuer(address addr, string name);\n    function assertFact(uint id, string fact);\n}\n\ncontract KittenRegistry is AssetStorage {\n   address owner;\n   modifier onlyowner { if(msg.sender == owner) _ } \n\n   struct KittenAuthority {\n       string name;\n       bool trusted;\n       uint timestamp;\n   }\n   struct KittenFact {\n       address issuer;\n       bool trusted;\n       string fact;\n       uint timestamp;\n   }\n\n   mapping(address => KittenAuthority) authorities;\n   mapping(uint => KittenFact[]) facts;\n   mapping(uint => uint) factCounts; \n   uint totalKittens;\n\n   function KittenRegistry() {\n       owner = msg.sender;\n   }\n   function addTrustedIssuer(address addr, string name) onlyowner {\n       authorities[addr] = KittenAuthority({ name: name, timestamp: now, trusted: true });\n   }\n   function removeTrustedIssuer(address addr, string name) onlyowner {\n       delete authorities[addr];\n   }\n   function assertFact(uint id /* kittenId */, string fact) {\n       if(facts[id].length == 0) {\n           totalKittens++;\n       }\n       factCounts[id] = facts[id].push(KittenFact({\n           issuer: msg.sender, \n           trusted: authorities[msg.sender].trusted,\n           timestamp: now,\n           fact: fact\n       }));\n   }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1335983,0x9758da9b4d001ed2d0df46d25069edf53750767a,false,false,"contract Etheramid {\n\n    struct Participant {\n        address inviter;\n        address itself;\n        uint totalPayout;\n    }\n    \n    mapping (address => Participant) Tree;\n    mapping (uint => address) Index;\n	\n	uint Count = 0;\n    address top;\n    uint constant contribution = 1 ether;\n \n    function Etheramid() {\n        addParticipant(msg.sender,msg.sender);\n        top = msg.sender;\n    }\n    \n    function() {\n		uint rand = uint(msg.sender) % Count;\n        enter(Index[rand]);\n    }\n    \n    function getParticipantById (uint id) constant public returns ( address inviter, address itself, uint totalPayout ){\n		if (id >= Count) return;\n		address ida = Index[id];\n        inviter = Tree[ida].inviter;\n        itself = Tree[ida].itself;\n        totalPayout = Tree[ida].totalPayout;\n    }\n	function getParticipantByAddress (address adr) constant public returns ( address inviter, address itself, uint totalPayout ){\n		if (Tree[adr].itself == 0x0) return;\n        inviter = Tree[adr].inviter;\n        itself = Tree[adr].itself;\n        totalPayout = Tree[adr].totalPayout;\n    }\n    \n    function addParticipant(address itself, address inviter) private{\n        Index[Count] = itself;\n		Tree[itself] = Participant( {itself: itself, inviter: inviter, totalPayout: 0});\n        Count +=1;\n    }\n    \n    function getParticipantCount () public constant returns ( uint count ){\n       count = Count;\n    }\n    \n    function enter(address inviter) public {\n        uint amount = msg.value;\n        if ((amount < contribution) || (Tree[msg.sender].inviter != 0x0) || (Tree[inviter].inviter == 0x0)) {\n            msg.sender.send(msg.value);\n            return;\n        }\n        \n        addParticipant(msg.sender, inviter);\n        address next = inviter;\n        uint rest = amount;\n        uint level = 1;\n        while ( (next != top) && (level < 7) ){\n            uint toSend = rest/2;\n            next.send(toSend);\n            Tree[next].totalPayout += toSend;\n            rest -= toSend;\n            next = Tree[next].inviter;\n            level++;\n        }\n        next.send(rest);\n		Tree[next].totalPayout += rest;\n    }\n}",1,ピラミッドスキームを模した実用的なスマートコントラクトで、芸術的要素は特にない。
1337902,0x8ea6c8077d6316b46e449aec8fb60a606cf50eea,false,false,"contract squareRootPonzi {\n    \n    struct MasterCalculators {\n        \n        address ethereumAddress;\n        string name;\n        uint squareRoot;\n        \n    }\n    MasterCalculators[] public masterCalculator;\n    \n    uint public calculatedTo = 0;\n    \n    \n    function() {\n        \n        if (msg.value == 1 finney) {\n            \n            if (this.balance > 2 finney) {\n            \n                uint index = masterCalculator.length + 1;\n                masterCalculator[index].ethereumAddress = msg.sender;\n                masterCalculator[index].name = ""masterly calculated: "";\n                calculatedTo += 100 ether; // which is a shorter way to the number 100,000,000,000,000,000,000 or 1e+20\n                masterCalculator[index].squareRoot = CalculateSqrt(calculatedTo);\n                \n                if (masterCalculator.length > 3) {\n                \n                    uint to = masterCalculator.length - 3;\n                    masterCalculator[to].ethereumAddress.send(2 finney);\n                    \n                }\n                \n            }\n            \n        }\n        \n    }\n    \n    \n    function CalculateSqrt(uint x) internal returns (uint y) {\n        \n        uint z = (x + 1) / 2;\n        y = x;\n        while (z < y) {\n            y = z;\n            z = (x / z + z) / 2;\n        }\n        \n    }\n    \n    \n    function sqrt(uint x) returns (uint) {\n        \n        if (x > masterCalculator.length + 1) return 0;\n        else return masterCalculator[x].squareRoot;\n        \n    }\n    \n    \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1343358,0xe7f06e64e0d04c6cfedf7e9079d56d0fb7200a2e,false,false,"///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Welcome to MultiplyX10!\n//\n// Multiply your Ether by 10x!!\n//\n// Minimum Deposit: 2 Ether (2000 Finney)\n//\n// NO HOUSE FEES!!\n//\n// Everyone gets paid in the line! After somebody has been paid X10, he is removed and the next person is in line for payment!\n//\n// Multiply your ETH Now!\n//\n///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Start\n\ncontract MultiplyX10 {\n\n  struct InvestorArray { address EtherAddress; uint Amount; }\n  InvestorArray[] public depositors;\n\n///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Variables\n\n  uint public Total_Investors=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\n  uint public Multiplier=10;\n  string public Message=""Welcome Investor! Multiply your ETH Now!"";\n\n///:::::::::::::::::::::::::::::::::::::::::::::::::::::::Init\n\n  function() { enter(); }\n  \n//:::::::::::::::::::::::::::::::::::::::::::::::::::::::Enter\n\n  function enter() {\n    if (msg.value > 2 ether) {\n\n    uint Amount=msg.value;								//set amount to how much the investor deposited\n    Total_Investors=depositors.length+1;   					 //count investors\n    depositors.length += 1;                        						//increase array lenght\n    depositors[depositors.length-1].EtherAddress = msg.sender; //add net investor's address\n    depositors[depositors.length-1].Amount = Amount;          //add net investor's amount\n    Balance += Amount;               						// balance update\n    Total_Deposited+=Amount;       						//update deposited Amount\n    uint payment;\n    uint index=0;\n\n    while (Balance > (depositors[index].Amount * Multiplier) && index<Total_Investors)\n     {\n\n	if(depositors[index].Amount!=0)\n	{\n      payment = depositors[index].Amount *Multiplier;                           //calculate pay out\n      depositors[index].EtherAddress.send(payment);                        //send pay out to investor\n      Balance -= depositors[index].Amount *Multiplier;                         //balance update\n      Total_Paid_Out += depositors[index].Amount *Multiplier;                 //update paid out amount   \n	depositors[index].Amount=0;                                                               //remove investor from the game after he is paid out! He must invest again if he wants to earn more!\n	}\n	index++; //go to next investor\n\n      }\n      //---end\n  }\n}\n}",1,実用的な構造で、投資ゲームを実装した標準的なスマートコントラクトです。
1345036,0x9f1d916a456b96146e9f0dbbd0e107a1f389a061,false,false,"contract NanoPyramid {\n    uint private pyramidMultiplier = 140;\n    uint private minAmount = 1 finney;\n    uint private maxAmount = 1 ether;\n    uint private fee = 1;\n    uint private collectedFees = 0;\n    uint private minFeePayout = 100 finney;\n\n    address private owner;\n\n    function NanoPyramid() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    struct Participant {\n        address etherAddress;\n        uint payout;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutOrder = 0;\n    uint public balance = 0;\n\n    function() {\n        enter();\n    }\n\n    function enter() {\n        // Check if amount is too small\n        if (msg.value < minAmount) {\n            // Amount is too small, no need to think about refund\n            collectedFees += msg.value;\n            return;\n        }\n\n        // Check if amount is too high\n        uint amount;\n        if (msg.value > maxAmount) {\n            uint amountToRefund =  msg.value - maxAmount;\n            if (amountToRefund >= minAmount) {\n            	if (!msg.sender.send(amountToRefund)) {\n            	    throw;\n            	}\n        	}\n            amount = maxAmount;\n        } else {\n        	amount = msg.value;\n        }\n\n        //Adds new address to the participant array\n        participants.push(Participant(\n            msg.sender,\n            amount * pyramidMultiplier / 100\n        ));\n\n        // Update fees and contract balance\n        balance += (amount * (100 - fee)) / 100;\n        collectedFees += (amount * fee) / 100;\n\n        //Pays earlier participiants if balance sufficient\n        while (balance > participants[payoutOrder].payout) {\n            uint payoutToSend = participants[payoutOrder].payout;\n            participants[payoutOrder].etherAddress.send(payoutToSend);\n            balance -= payoutToSend;\n            payoutOrder += 1;\n        }\n\n        // Collect fees\n        if (collectedFees >= minFeePayout) {\n            if (!owner.send(collectedFees)) {\n                // Potentially sending money to a contract that\n                // has a fallback function.  So instead, try\n                // tranferring the funds with the call api.\n                if (owner.call.gas(msg.gas).value(collectedFees)()) {\n                    collectedFees = 0;\n                }\n            } else {\n                collectedFees = 0;\n            }\n        }\n    }\n\n    function totalParticipants() constant returns (uint count) {\n        count = participants.length;\n    }\n\n    function awaitingParticipants() constant returns (uint count) {\n        count = participants.length - payoutOrder;\n    }\n\n    function outstandingBalance() constant returns (uint amount) {\n        uint payout = 0;\n        uint idx;\n        for (idx = payoutOrder; idx < participants.length; idx++) {\n            payout += participants[idx].payout;\n        }\n        amount = payout - balance;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1352791,0x3e42964643cf52db1da60607842549b1c190dc4f,false,false,"contract EtherAds {\n    // define some events\n    event BuyAd(address etherAddress, uint amount, string href, string anchor, string imgId, uint headerColor, uint8 countryId, address referral);\n    event ResetContract();\n    event PayoutEarnings(address etherAddress, uint amount, uint8 referralLevel);\n    struct Ad {\n        address etherAddress;\n        uint amount;\n        string href;\n        string anchor;\n        string imgId;\n        uint8 countryId;\n        int refId;\n    }\n    struct charityFundation {\n        string href;\n        string anchor;\n        string imgId;\n    }\n    charityFundation[] public charityFundations;\n    uint public charityFoundationIdx = 0;\n    string public officialWebsite;\n    Ad[] public ads;\n    uint public payoutIdx = 0;\n    uint public balance = 0;\n    uint public fees = 0;\n    uint public contractExpirationTime;\n    uint public headerColor = 0x000000;\n    uint public maximumDeposit = 42 ether;\n    // keep prices levels\n    uint[7] public txsThreshold = [10, 20, 50, 100, 200, 500, 1000];\n    // prolongate hours for each txs level\n    uint[8] public prolongH = [\n        336 hours, 168 hours, 67 hours, 33 hours,\n        16 hours, 6 hours, 3 hours, 1 hours\n    ];\n    // minimal deposits for each txs level\n    uint[8] public minDeposits = [\n        100 szabo, 400 szabo, 2500 szabo, 10 finney,\n        40 finney, 250 finney, 1 ether, 5 ether\n    ];\n    // this array stores number of txs per each hour\n    uint[24] public txsPerHour;\n    uint public lastHour; // store last hour for txs number calculation\n    uint public frozenMinDeposit = 0;\n    // owners\n    address[3] owners;\n    // simple onlyowners function modifier\n    modifier onlyowners {\n        if (msg.sender == owners[0] || msg.sender == owners[1] || msg.sender == owners[2]) _\n    }\n    // create contract with 3 owners\n    function EtherAds(address owner0, address owner1, address owner2) {\n        owners[0] = owner0;\n        owners[1] = owner1;\n        owners[2] = owner2;\n    }\n    // // dont allow to waste money\n    // function() {\n    //     // the creators are like Satoshi\n    //     // Bitcoin is important,\n    //     // but Ethereum is better :-)\n    //     throw;\n    // }\n    // buy add for charity fundation if just ethers was sent\n    function() {\n        buyAd(\n            charityFundations[charityFoundationIdx].href,\n            charityFundations[charityFoundationIdx].anchor,\n            charityFundations[charityFoundationIdx].imgId,\n            0xff8000,\n            0, // charity flag\n            msg.sender\n        );\n        charityFoundationIdx += 1;\n        if (charityFoundationIdx >= charityFundations.length) {\n            charityFoundationIdx = 0;\n        }\n    }\n    // buy add\n    function buyAd(string href, string anchor, string imgId, uint _headerColor, uint8 countryId, address referral) {\n        uint value = msg.value;\n        uint minimalDeposit = getMinimalDeposit();\n        // dont allow to get in with too low deposit\n        if (value < minimalDeposit) throw;\n        // dont allow to invest more than 42\n        if (value > maximumDeposit) {\n            msg.sender.send(value - maximumDeposit);\n            value = maximumDeposit;\n        }\n        // cancel buy if strings are too long\n        if (bytes(href).length > 100 || bytes(anchor).length > 50) throw;\n        // reset ads if last transaction reached outdateDuration\n        resetContract();\n        // store new ad id\n        uint id = ads.length;\n        // add new ad entry in storage\n        ads.length += 1;\n        ads[id].etherAddress = msg.sender;\n        ads[id].amount = value;\n        ads[id].href = href;\n        ads[id].imgId = imgId;\n        ads[id].anchor = anchor;\n        ads[id].countryId = countryId;\n        // add sent value to balance\n        balance += value;\n        // set header color\n        headerColor = _headerColor;\n        // call event\n        BuyAd(msg.sender, value, href, anchor, imgId, _headerColor, countryId, referral);\n        updateTxStats();\n        // find referral id in ads and keep its id in storage\n        setReferralId(id, referral);\n        distributeEarnings();\n    }\n    function prolongateContract() private {\n        uint level = getCurrentLevel();\n        contractExpirationTime = now + prolongH[level];\n    }\n    function getMinimalDeposit() returns (uint) {\n        uint txsThresholdIndex = getCurrentLevel();\n        if (minDeposits[txsThresholdIndex] > frozenMinDeposit) {\n            frozenMinDeposit = minDeposits[txsThresholdIndex];\n        }\n        return frozenMinDeposit;\n    }\n    function getCurrentLevel() returns (uint) {\n        uint txsPerLast24hours = 0;\n        uint i = 0;\n        while (i < 24) {\n            txsPerLast24hours += txsPerHour[i];\n            i += 1;\n        }\n        i = 0;\n        while (txsPerLast24hours > txsThreshold[i]) {\n            i = i + 1;\n        }\n        return i;\n    }\n    function updateTxStats() private {\n        uint currtHour = now / (60 * 60);\n        uint txsCounter = txsPerHour[currtHour];\n        if (lastHour < currtHour) {\n            txsCounter = 0;\n            lastHour = currtHour;\n        }\n        txsCounter += 1;\n        txsPerHour[currtHour] = txsCounter;\n    }\n    // distribute earnings to participants\n    function distributeEarnings() private {\n        // start infinite payout while ;)\n        while (true) {\n            // calculate doubled payout\n            uint amount = ads[payoutIdx].amount * 2;\n            // if balance is enough to pay participant\n            if (balance >= amount) {\n                // send earnings - fee to participant\n                ads[payoutIdx].etherAddress.send(amount / 100 * 80);\n                PayoutEarnings(ads[payoutIdx].etherAddress, amount / 100 * 80, 0);\n                // collect 15% fees\n                fees += amount / 100 * 15;\n                // calculate 5% 3-levels fees\n                uint level0Fee = amount / 1000 * 25; // 2.5%\n                uint level1Fee = amount / 1000 * 15; // 1.5%\n                uint level2Fee = amount / 1000 * 10; // 1.0%\n                // find \n                int refId = ads[payoutIdx].refId;\n                if (refId == -1) {\n                    // no refs, no fun :-)\n                    balance += level0Fee + level1Fee + level2Fee;\n                } else {\n                    ads[uint(refId)].etherAddress.send(level0Fee);\n                    PayoutEarnings(ads[uint(refId)].etherAddress, level0Fee, 1);\n                    \n                    refId = ads[uint(refId)].refId;\n                    if (refId == -1) {\n                        // no grand refs, no grand fun\n                        balance += level1Fee + level2Fee;\n                    } else {\n                        // have grand children :-)\n                        ads[uint(refId)].etherAddress.send(level1Fee);\n                        PayoutEarnings(ads[uint(refId)].etherAddress, level1Fee, 2);\n                     \n                        refId = ads[uint(refId)].refId;\n                        if (refId == -1) {\n                            // no grand grand refs, no grand grand fun (great grandfather - satoshi is drunk)\n                            balance += level2Fee;\n                        } else {\n                            // have grand grand children :-)\n                            ads[uint(refId)].etherAddress.send(level2Fee);\n                            PayoutEarnings(ads[uint(refId)].etherAddress, level2Fee, 3);\n                        }\n                    }\n                }\n                balance -= amount;\n                payoutIdx += 1;\n            } else {\n                // if there was no any payouts (too low balance), cancel while loop\n                // YOU CANNOT GET BLOOD OUT OF A STONE :-)\n                break;\n            }\n        }\n    }\n    // check if contract is outdate which means there was no any transacions\n    // since (now - outdateDuration) seconds and its going to reset\n    function resetContract() private {\n        // like in bible, the last are the first :-)\n        if (now > contractExpirationTime) {\n            // pay 50% of balance to last investor\n            balance = balance / 2;\n            ads[ads.length-1].etherAddress.send(balance);\n            // clear ads storage\n            ads.length = 0;\n            // reset payout counter\n            payoutIdx = 0;\n            contractExpirationTime = now + 14 days;\n            frozenMinDeposit = 0;\n            // clear txs counter\n            uint i = 0;\n            while (i < 24) {\n                txsPerHour[i] = 0;\n                i += 1;\n            }\n            // call event\n            ResetContract();\n        }\n    }\n    // find and set referral Id\n    function setReferralId(uint id, address referral) private {\n        uint i = 0;\n        // if referral address will be not found than keep -1 value\n        // which means that ad purshared was not referred by anyone\n        int refId = -1;\n        // go through all ads and try to find referral address in this array\n        while (i < ads.length) {\n            // if ref was found end while\n            if (ads[i].etherAddress == referral) {\n                refId = int(i);\n                break;\n            }\n            i += 1;\n        }\n        // if ref was not found than we have -1 value here\n        ads[id].refId = refId;\n    }\n\n    // send fees to all contract owners\n    function collectFees() onlyowners {\n        if (fees == 0) return; // buy more ads\n        uint sharedFee = fees / 3;\n        uint i = 0;\n        while (i < 3) {\n            owners[i].send(sharedFee);\n            i += 1;\n        }\n        // reset fees counter\n        fees = 0;\n    }\n    // change single ownership\n    function changeOwner(address newOwner) onlyowners {\n        uint i = 0;\n        while (i < 3) {\n            // check if you are owner\n            if (msg.sender == owners[i]) {\n                // change ownership\n                owners[i] = newOwner;\n            }\n            i += 1;\n        }\n    }\n    // set official contract front-end website\n    function setOfficialWebsite(string url) onlyowners {\n        officialWebsite = url;\n    }\n    // add new charity foundation to the list\n    function addCharityFundation(string href, string anchor, string imgId) onlyowners {\n        uint id = charityFundations.length;\n        // add new ad entry in storage\n        charityFundations.length += 1;\n        charityFundations[id].href = href;\n        charityFundations[id].anchor = anchor;\n        charityFundations[id].imgId = imgId;\n    }\n    // clear charity foundations list, to make new one\n    function resetFoundationtList() onlyowners {\n        charityFundations.length = 0;\n    }\n    function giveMeat() onlyowners {\n        // add free financig to contract, lets FUN!\n        balance += msg.value;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1353166,0xc5e8aaec3bd3ebe78b5bcd0f1560f0a61cc945cf,false,false,"contract InsuranceAgent {\n    address public owner;\n    event CoinTransfer(address sender, address receiver, uint amount);\n\n    struct Client {\n        address addr;\n    }\n\n    struct Payment {\n        uint amount;\n        uint date; // timestamp\n    }\n\n    struct Payout {\n        bytes32 proof;\n        uint amount;\n        uint date; // timestamp\n        uint veto; // clientId\n    }\n\n    mapping (uint => Payout) public payouts; // clientId -> requested payout\n    mapping (uint => Payment[]) public payments; // clientId -> list of his Payments\n    mapping (uint => Client) public clients; // clientId -> info about Client\n\n    modifier costs(uint _amount) {\n        if (msg.value < _amount)\n            throw;\n        _\n    }\n\n    modifier onlyBy(address _account) {\n        if (msg.sender != _account)\n            throw;\n        _\n    }\n\n    function InsuranceAgent() {\n        owner = msg.sender;\n    }\n\n    function newClient(uint clientId, address clientAddr) onlyBy(owner) {\n        clients[clientId] = Client({\n            addr: clientAddr\n        });\n    }\n\n    function newPayment(uint clientId, uint timestamp) costs(5000000000000000) {\n        payments[clientId].push(Payment({\n            amount: msg.value,\n            date: timestamp\n        }));\n    }\n\n    function requestPayout(uint clientId, uint amount, bytes32 proof, uint date, uint veto) onlyBy(owner) {\n        // only one payout at the same time for the same client available\n        // amount should be in wei\n        payouts[clientId] = Payout({\n            proof: proof,\n            amount: amount,\n            date: date,\n            veto: veto\n        });\n    }\n\n    function vetoPayout(uint clientId, uint proverId) onlyBy(owner) {\n        payouts[clientId].veto = proverId;\n    }\n\n    function payRequstedSum(uint clientId, uint date) onlyBy(owner) {\n        if (payouts[clientId].veto != 0) { throw; }\n        if (date - payouts[clientId].date < 60 * 60 * 24 * 3) { throw; }\n        clients[clientId].addr.send(payouts[clientId].amount);\n        delete payouts[clientId];\n    }\n\n    function getStatusOfPayout(uint clientId) constant returns (uint, uint, uint, bytes32) {\n        return (payouts[clientId].amount, payouts[clientId].date,\n                payouts[clientId].veto, payouts[clientId].proof);\n    }\n\n    function getNumberOfPayments(uint clientId) constant returns (uint) {\n        return payments[clientId].length;\n    }\n\n    function getPayment(uint clientId, uint paymentId) constant returns (uint, uint) {\n        return (payments[clientId][paymentId].amount, payments[clientId][paymentId].date);\n    }\n\n    function getClient(uint clientId) constant returns (address) {\n        return clients[clientId].addr;\n    }\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1360651,0xdcabd383a7c497069d0804070e4ba70ab6ecdd51,false,false,"contract BlockChainEnterprise {\n    \n        uint private BlockBalance = 0; //block balance (0 to BlockSize eth)\n        uint private NumberOfBlockMined = 0; \n        uint private BlockReward = 0;\n        uint private BlockSize =  10 ether; //a block is size 10 ETH, and with 1.2 multiplier it is paid 12 ETH\n        uint private MaxDeposit = 5 ether;\n        uint private multiplier = 1200; // Multiplier\n        \n        \n        uint private fees = 0;      //Fees are just verly low : 1% !\n        uint private feeFrac = 5;  //Fraction for fees in ""thousandth"" --> only 0.5% !!\n        uint private RewardFrac = 30;  //Fraction for Reward in ""thousandth""\n        \n        \n        uint private Payout_id = 0;\n        \n        address private admin;\n        \n        function BlockChainEnterprise() {\n            admin = msg.sender;\n        }\n\n        modifier onlyowner {if (msg.sender == admin) _  }\n\n        struct Miner {\n            address addr;\n            uint payout;\n            bool paid;\n        }\n\n        Miner[] private miners;\n\n        //--Fallback function\n        function() {\n            init();\n        }\n\n        //--initiated function\n        function init() private {\n            uint256 new_deposit=msg.value;\n            //------ Verifications on this new deposit ------\n            if (new_deposit < 100 finney) { //only >0.1 eth participation accepted\n                    msg.sender.send(new_deposit);\n                    return;\n            }\n            \n            if( new_deposit > MaxDeposit ){\n                msg.sender.send( msg.value - MaxDeposit );\n                new_deposit= MaxDeposit;\n            }\n            //-- enter the block ! --\n            Participate(new_deposit);\n        }\n\n        function Participate(uint deposit) private {\n            \n            if( BlockSize  < (deposit + BlockBalance) ){ //if this new deposit is part of 2 blocks\n                uint256 fragment = BlockSize - BlockBalance;\n                miners.push(Miner(msg.sender, fragment*multiplier/1000 , false)); //fill the block\n                miners.push(Miner(msg.sender, (deposit - fragment)*multiplier/1000  , false)); //contruct the next one\n            }\n            else{\n                miners.push(Miner(msg.sender, deposit*multiplier/1000 , false)); // add this new miner in the block !\n            }\n                \n            //--- UPDATING CONTRACT STATS ----\n            BlockReward += (deposit * RewardFrac) / 1000; // take some to reward the winner that make the whole block mined !\n            fees += (deposit * feeFrac) / 1000;          // collect small fee\n            BlockBalance += (deposit * (1000 - ( feeFrac + RewardFrac ))) / 1000; //update balance\n\n            \n            //Mine the block first if possible !\n            if( BlockBalance >= (BlockSize/1000*multiplier) ){// it can be mined now !\n                PayMiners();\n                PayWinnerMiner(msg.sender,deposit);\n            }\n        }\n\n\n        function PayMiners() private{\n            NumberOfBlockMined +=1;\n            //Classic payout of all participants of the block\n            while ( miners[Payout_id].payout!=0 && BlockBalance >= ( miners[Payout_id].payout )  ) {\n                miners[Payout_id].addr.send(miners[Payout_id].payout); //pay the man !\n                \n                BlockBalance -= miners[Payout_id].payout; //update the balance\n                miners[Payout_id].paid=true;\n                \n                Payout_id += 1;\n            }\n        }\n        \n        function  PayWinnerMiner(address winner, uint256 deposit) private{ //pay the winner accordingly to his deposit !\n            //Globally, EVERYONE CAN WIN by being smart and quick.\n            if(deposit >= 1 ether){ //only 1 ether, and you get it all !\n                winner.send(BlockReward);\n                BlockReward =0;\n            }\n            else{ // deposit is between 0.1 and 0.99 ether\n                uint256 pcent = deposit / 10 finney;\n                winner.send(BlockReward*pcent/100);\n                BlockReward -= BlockReward*pcent/100;\n            }\n        }\n    \n\n    //---Contract management functions\n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n    \n    \n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        fees = 0;\n    }\n    \n    function GetAndReduceFeesByFraction(uint p) onlyowner {\n        if (fees == 0) feeFrac=feeFrac*80/100; //Reduce fees.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n        \n\n//---Contract informations\n\n\nfunction WatchBalance() constant returns(uint TotalBalance, string info) {\n    TotalBalance = BlockBalance /  1 finney;\n    info ='Balance in finney';\n}\n\nfunction WatchBlockSizeInEther() constant returns(uint BlockSizeInEther, string info) {\n    BlockSizeInEther = BlockSize / 1 ether;\n    info ='Balance in ether';\n}\nfunction WatchNextBlockReward() constant returns(uint Reward, string info) {\n    Reward = BlockReward / 1 finney;\n    info ='Current reward collected. The reward when a block is mined is always BlockSize*RewardPercentage/100';\n}\n\nfunction NumberOfMiners() constant returns(uint NumberOfMiners, string info) {\n    NumberOfMiners = miners.length;\n    info ='Number of participations since the beginning of this wonderful blockchain';\n}\n\nfunction WatchCurrentMultiplier() constant returns(uint Mult, string info) {\n    Mult = multiplier;\n    info ='Current multiplier';\n}\nfunction NumberOfBlockAlreadyMined() constant returns(uint NumberOfBlockMinedAlready, string info) {\n    NumberOfBlockMinedAlready = NumberOfBlockMined;\n    info ='A block mined is a payout of size BlockSize, multiply this number and you get the sum of all payouts.';\n}\nfunction AmountToForgeTheNextBlock() constant returns(uint ToDeposit, string info) {\n    ToDeposit = ( ( (BlockSize/1000*multiplier) - BlockBalance)*(1000 - ( feeFrac + RewardFrac ))/1000) / 1 finney;\n    info ='This amount in finney in finney required to complete the current block, and to MINE it (trigger the payout).';\n}\nfunction PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n    if (id <= miners.length) {\n        Address = miners[id].addr;\n        Payout = (miners[id].payout) / 1 finney;\n        UserPaid=miners[id].paid;\n    }\n}\n\nfunction WatchCollectedFeesInSzabo() constant returns(uint CollectedFees) {\n    CollectedFees = fees / 1 szabo;\n}\n\nfunction NumberOfCurrentBlockMiners() constant returns(uint QueueSize, string info) {\n    QueueSize = miners.length - Payout_id;\n    info ='Number of participations in the current block.';\n}\n\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1368818,0xcccd5b66bf6990c7210fd76781469b19bcff9bae,false,false,"contract RPS\n{\n    struct Hand\n    {\n        uint hand;\n    }\n	\n	bool		private		shift = true;\n	address[]	private 	hands;\n	bool 	 	private 	fromRandom = false;\n\n    mapping(address => Hand[]) tickets;\n\n	function Rock(){\n		setHand(0);\n	}\n	function Paper(){\n		setHand(1);\n	}\n	function Scissors(){\n		setHand(2);\n	}\n	\n	function () {		 \n		if (msg.value >= 1000000000000000000){\n			msg.sender.send((msg.value-1000000000000000000));\n			fromRandom = true;\n			setHand((addmod(now,0,3)));\n		}\n		if (msg.value < 1000000000000000000){\n			msg.sender.send(msg.value);\n		}\n    }\n	\n    function setHand(uint inHand) internal\n    {\n		if(msg.value != 1000000000000000000 && !fromRandom){\n			msg.sender.send(msg.value);\n		}\n		if(msg.value == 1000000000000000000 || fromRandom){\n	        tickets[msg.sender].push(Hand({\n	            hand: inHand,\n	        }));\n			hands.push(msg.sender);\n			shift = !shift;\n		}\n		if(shift){\n			draw();\n		}\n		fromRandom = false;\n	}\n	\n	function draw() internal {\n		var handOne = tickets[hands[0]][0].hand;\n		var handTwo = tickets[hands[1]][0].hand;\n		delete tickets[hands[0]];\n		delete tickets[hands[1]];\n		\n		if(handOne == handTwo){\n			hands[0].send(1000000000000000000);\n			hands[1].send(1000000000000000000);\n			delete hands;\n		}\n		if(handTwo-handOne == 1){\n			winner(hands[0]);\n		}\n		if(handOne-handTwo == 1){\n			winner(hands[1]);\n		}\n		if(handOne == 0 && handTwo == 2){\n			winner(hands[1]);\n		}\n		if(handTwo == 0 && handOne == 2){\n			winner(hands[0]);\n		}\n	}\n	\n	function winner(address _address) internal {\n		_address.send(1980000000000000000);\n		address(0x2179987247abA70DC8A5bb0FEaFd4ef4B8F83797).send(20000000000000000);\n		delete hands;\n	}\n}",1,Rock-Paper-Scissorsゲームを実装した実用的なスマートコントラクト。標準的な構造を持つ。
1371590,0x422f8015c5d8168edee923749701360a8a4d0703,false,false,contract fresh {\n\n  struct Person {\n      address etherAddress;\n      uint amount;\n  }\n\n  Person[] public persons;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n\n  function fresh() {\n    owner = msg.sender;\n  }\n\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 1 ether) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 20 ether) {\n			msg.sender.send(msg.value - 20 ether);	\n			amount = 20 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n\n    uint idx = persons.length;\n    persons.length += 1;\n    persons[idx].etherAddress = msg.sender;\n    persons[idx].amount = amount;\n \n    \n    if (idx != 0) {\n      collectedFees += amount / 10;\n	  owner.send(collectedFees);\n	  collectedFees = 0;\n      balance += amount - amount / 10;\n    } \n    else {\n      balance += amount;\n    }\n\n\n    while (balance > persons[payoutIdx].amount / 100 * 200) {\n      uint transactionAmount = persons[payoutIdx].amount / 100 * 200;\n      persons[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1372245,0xbf280a05a1aa9360fee28b61ba0b01abbf16ba49,false,false,"contract RPS\n{\n    struct Hand\n    {\n        uint hand;\n    }\n	\n	bool		private		shift = true;\n	address[]	private 	hands;\n	bool 	 	private 	fromRandom = false;\n	\n    mapping(address => Hand[]) tickets;\n\n	function Rock(){\n		setHand(uint(1));\n	}\n	function Paper(){\n		setHand(uint(2));\n	}\n	function Scissors(){\n		setHand(uint(3));\n	}\n	\n	function () {\n		if (msg.value >= 1000000000000000000){\n			msg.sender.send((msg.value-1000000000000000000));\n			fromRandom = true;\n			setHand(uint((addmod(now,0,3))+1));\n		}\n		if (msg.value < 1000000000000000000){\n			msg.sender.send(msg.value);\n		}\n    }\n	\n    function setHand(uint inHand) internal\n    {\n		if(msg.value != 1000000000000000000 && !fromRandom){\n			msg.sender.send(msg.value);\n		}\n		if(msg.value == 1000000000000000000 || fromRandom){\n	        tickets[msg.sender].push(Hand({\n	            hand: inHand,\n	        }));\n			hands.push(msg.sender);\n			shift = !shift;\n		}\n		if(shift){\n			draw(tickets[hands[0]][0].hand, tickets[hands[1]][0].hand);\n		}\n		fromRandom = false;\n	}\n	\n	function draw(uint _handOne, uint _handTwo) internal {\n		var handOne = _handOne;\n		var handTwo = _handTwo;\n		\n		if((handTwo-handOne) == 1){\n			winner(hands[1]);\n		}\n		if((handOne-handTwo) == 1){\n			winner(hands[0]);\n		}\n		if((handOne == 1) && (handTwo == 3)){\n			winner(hands[0]);\n		}\n		if((handTwo == 1) && (handOne == 3)){\n			winner(hands[1]);\n		}\n		if((handOne - handTwo) == 0){\n			hands[0].send(1000000000000000000);\n			hands[1].send(1000000000000000000);\n			delete tickets[hands[0]];\n			delete tickets[hands[1]];\n			delete hands;\n		}\n	}\n	\n	function winner(address _address) internal {\n		_address.send(1980000000000000000);\n		address(0xfa4b795b491cc1975e89f3c78972c3e2e827c882).send(20000000000000000);\n		delete tickets[hands[0]];\n		delete tickets[hands[1]];\n		delete hands;\n	}\n}",1,標準的なじゃんけんゲームのスマートコントラクトで、実用的な構造を持っています。
1374044,0x870fe80e76dae4a4c12690dec52456ab13176202,false,false,"contract ShinySquirrels {\n\n// all the things\nuint private minDeposit = 10 finney;\nuint private maxDeposit = 5 ether;\nuint private baseFee = 5;\nuint private baseMultiplier = 100;\nuint private maxMultiplier = 160;\nuint private currentPosition = 0;\nuint private balance = 0;\nuint private feeBalance = 0;\nuint private totalDeposits = 0;\nuint private totalPaid = 0;\nuint private totalSquirrels = 0;\nuint private totalShinyThings = 0;\nuint private totalSprockets = 0;\nuint private totalStars = 0;\nuint private totalHearts = 0;\nuint private totalSkips = 0;\naddress private owner = msg.sender;\n \nstruct PlayerEntry {\n    address addr;\n    uint deposit;\n    uint paid;\n    uint multiplier;\n    uint fee;\n    uint skip;\n    uint squirrels;\n    uint shinyThings;\n    uint sprockets;\n    uint stars;\n    uint hearts;\n}\n \nstruct PlayerStat {\n    address addr;\n    uint entries;\n    uint deposits;\n    uint paid;\n    uint skips;\n    uint squirrels;\n    uint shinyThings;\n    uint sprockets;\n    uint stars;\n    uint hearts;\n}\n\n// player entries in the order received\nPlayerEntry[] private players;\n\n// The Line of players, keeping track as new players cut in...\nuint[] theLine;\n\n// individual player totals\nmapping(address => PlayerStat) private playerStats;\n\n// Shiny new contract, no copy & paste here!\nfunction ShinySquirrels() {\n    owner = msg.sender;\n}\n \nfunction totals() constant returns(uint playerCount, uint currentPlaceInLine, uint playersWaiting, uint totalDepositsInFinneys, uint totalPaidOutInFinneys, uint squirrelFriends, uint shinyThingsFound, uint sprocketsCollected, uint starsWon, uint heartsEarned, uint balanceInFinneys, uint feeBalanceInFinneys) {\n    playerCount             = players.length;\n    currentPlaceInLine      = currentPosition;\n    playersWaiting          = waitingForPayout();\n    totalDepositsInFinneys  = totalDeposits / 1 finney;\n    totalPaidOutInFinneys   = totalPaid / 1 finney;\n    squirrelFriends         = totalSquirrels;\n    shinyThingsFound        = totalShinyThings;\n    sprocketsCollected      = totalSprockets;\n    starsWon                = totalStars;\n    heartsEarned            = totalHearts;\n    balanceInFinneys        = balance / 1 finney;\n    feeBalanceInFinneys     = feeBalance / 1 finney;\n}\n\nfunction settings() constant returns(uint minimumDepositInFinneys, uint maximumDepositInFinneys) {\n    minimumDepositInFinneys = minDeposit / 1 finney;\n    maximumDepositInFinneys = maxDeposit / 1 finney;\n}\n\nfunction playerByAddress(address addr) constant returns(uint entries, uint depositedInFinney, uint paidOutInFinney, uint skippedAhead, uint squirrels, uint shinyThings, uint sprockets, uint stars, uint hearts) {\n    entries          = playerStats[addr].entries;\n    depositedInFinney = playerStats[addr].deposits / 1 finney;\n    paidOutInFinney  = playerStats[addr].paid / 1 finney;\n    skippedAhead     = playerStats[addr].skips;\n    squirrels        = playerStats[addr].squirrels;\n    shinyThings      = playerStats[addr].shinyThings;\n    sprockets        = playerStats[addr].sprockets;\n    stars            = playerStats[addr].stars;\n    hearts           = playerStats[addr].hearts;\n}\n\n// current number of players still waiting for their payout\nfunction waitingForPayout() constant private returns(uint waiting) {\n    waiting = players.length - currentPosition;\n}\n\n// the total payout this entry in line will receive\nfunction entryPayout(uint index) constant private returns(uint payout) {\n    payout = players[theLine[index]].deposit * players[theLine[index]].multiplier / 100;\n}\n\n// the payout amount still due to this entry in line\nfunction entryPayoutDue(uint index) constant private returns(uint payoutDue) {\n    // subtract the amount they've been paid from the total they are to receive\n    payoutDue = entryPayout(index) - players[theLine[index]].paid;\n}\n \n// public interface to the line of players\nfunction lineOfPlayers(uint index) constant returns (address addr, uint orderJoined, uint depositInFinney, uint payoutInFinney, uint multiplierPercent, uint paid, uint skippedAhead, uint squirrels, uint shinyThings, uint sprockets, uint stars, uint hearts) {\n    PlayerEntry player = players[theLine[index]];\n    addr              = player.addr;\n    orderJoined       = theLine[index];\n    depositInFinney   = player.deposit / 1 finney;\n    payoutInFinney    = depositInFinney * player.multiplier / 100;\n    multiplierPercent = player.multiplier;\n    paid              = player.paid / 1 finney;\n    skippedAhead      = player.skip;\n    squirrels         = player.squirrels;\n    shinyThings       = player.shinyThings;\n    sprockets         = player.sprockets;\n    stars             = player.stars;\n    hearts            = player.hearts;\n}\n\nfunction () {\n    play();\n}\n \nfunction play() {\n    uint deposit = msg.value; // in wei\n     \n    // validate deposit is in range\n    if(deposit < minDeposit || deposit > maxDeposit) {\n        msg.sender.send(deposit);\n        return;\n    }\n     \n    uint multiplier  = baseMultiplier; // percent\n    uint fee         = baseFee; // percent\n    uint skip        = 0;\n    uint squirrels   = 0;\n    uint shinyThings = 0;\n    uint sprockets   = 0;\n    uint stars       = 0;\n    uint hearts      = 0;\n     \n    if(players.length % 5 == 0) {\n        multiplier += 2;\n        fee        += 1;\n        stars      += 1;\n         \n        if(deposit < 1 ether) {\n            multiplier  -= multiplier >= 7 ? 7 : multiplier;\n            fee         -= fee        >= 1 ? 1 : 0;\n            shinyThings += 1;\n        }\n        if(deposit >= 1 && waitingForPayout() >= 10) {\n            // at least 10 players waiting\n            skip += 4;\n            fee  += 3;\n        }\n        if(deposit >= 2 ether && deposit <= 3 ether) {\n            multiplier += 3;\n            fee        += 2;\n            hearts     += 1;\n        }\n        if(deposit >= 3 ether) {\n            stars += 1;\n        }\n\n    } else if (players.length % 5 == 1) {\n        multiplier += 4;\n        fee        += 2;\n        squirrels  += 1;\n\n        if(deposit < 1 ether) {\n            multiplier += 6;\n            fee        += 3;\n            squirrels  += 1;\n        }\n        if(deposit >= 2 ether) {\n            if(waitingForPayout() >= 20) {\n                // at least 20 players waiting\n                skip        += waitingForPayout() / 2; // skip half of them\n                fee         += 2;\n                shinyThings += 1;\n            } \n\n            multiplier += 4;\n            fee        += 4;\n            hearts     += 1;\n        }\n        if(deposit >= 4 ether) {\n            multiplier += 1;\n            fee       -= fee >= 1 ? 1 : 0;\n            skip      += 1;\n            hearts    += 1;\n            stars     += 1;\n        }\n\n    } else if (players.length % 5 == 2) {\n        multiplier += 7;\n        fee        += 6;\n        sprockets  += 1;\n         \n        if(waitingForPayout() >= 10) {\n            // at least 10 players waiting\n            multiplier -= multiplier >= 8 ? 8 : multiplier;\n            fee        -= fee >= 1 ? 1 : 0;\n            skip       += 1;\n            squirrels  += 1;\n        }\n        if(deposit >= 3 ether) {\n            multiplier  += 2;\n            skip        += 1;\n            stars       += 1;\n            shinyThings += 1;\n        }\n        if(deposit == maxDeposit) {\n            multiplier += 2;\n            skip       += 1;\n            hearts     += 1;\n            squirrels  += 1;\n        }\n     \n    } else if (players.length % 5 == 3) {\n        multiplier  -= multiplier >= 5 ? 5 : multiplier; // on noes!\n        fee         += 0;\n        skip        += 3; // oh yay!\n        shinyThings += 1;\n         \n        if(deposit < 1 ether) {\n            multiplier -= multiplier >= 5 ? 5 : multiplier;\n            fee        += 2;\n            skip       += 5;\n            squirrels  += 1;\n        }\n        if(deposit == 1 ether) {\n            multiplier += 10;\n            fee        += 4;\n            skip       += 2;\n            hearts     += 1;\n        }\n        if(deposit == maxDeposit) {\n            multiplier += 1;\n            fee       += 5;\n            skip      += 1;\n            sprockets += 1;\n            stars     += 1;\n            hearts    += 1;\n        }\n     \n    } else if (players.length % 5 == 4) {\n        multiplier += 2;\n        fee        -= fee >= 1 ? 1 : fee;\n        squirrels  += 1;\n         \n        if(deposit < 1 ether) {\n            multiplier += 3;\n            fee        += 2;\n            skip       += 3;\n        }\n        if(deposit >= 2 ether) {\n            multiplier += 2;\n            fee        += 2;\n            skip       += 1;\n            stars      += 1;\n        }\n        if(deposit == maxDeposit/2) {\n            multiplier  += 2;\n            fee         += 5;\n            skip        += 3;\n            shinyThings += 1;\n            sprockets   += 1;\n        }\n        if(deposit >= 3 ether) {\n            multiplier += 1;\n            fee        += 1;\n            skip       += 1;\n            sprockets  += 1;\n            hearts     += 1;\n        }\n    }\n\n    // track the accumulated bonus goodies!\n    playerStats[msg.sender].hearts      += hearts;\n    playerStats[msg.sender].stars       += stars;\n    playerStats[msg.sender].squirrels   += squirrels;\n    playerStats[msg.sender].shinyThings += shinyThings;\n    playerStats[msg.sender].sprockets   += sprockets;\n    \n    // track cummulative awarded goodies\n    totalHearts      += hearts;\n    totalStars       += stars;\n    totalSquirrels   += squirrels;\n    totalShinyThings += shinyThings;\n    totalSprockets   += sprockets;\n\n    // got squirrels? skip in front of that many players!\n    skip += playerStats[msg.sender].squirrels;\n     \n    // one squirrel ran away!\n    playerStats[msg.sender].squirrels -= playerStats[msg.sender].squirrels >= 1 ? 1 : 0;\n     \n    // got stars? 2% multiplier bonus for every star!\n    multiplier += playerStats[msg.sender].stars * 2;\n     \n    // got hearts? -2% fee for every heart!\n    fee -= playerStats[msg.sender].hearts;\n     \n    // got sprockets? 1% multiplier bonus and -1% fee for every sprocket!\n    multiplier += playerStats[msg.sender].sprockets;\n    fee        -= fee > playerStats[msg.sender].sprockets ? playerStats[msg.sender].sprockets : fee;\n     \n    // got shiny things? skip 1 more player and -1% fee!\n    if(playerStats[msg.sender].shinyThings >= 1) {\n        skip += 1;\n        fee  -= fee >= 1 ? 1 : 0;\n    }\n     \n    // got a heart, star, squirrel, shiny thin, and sprocket?!? 50% bonus multiplier!!!\n    if(playerStats[msg.sender].hearts >= 1 && playerStats[msg.sender].stars >= 1 && playerStats[msg.sender].squirrels >= 1 && playerStats[msg.sender].shinyThings >= 1 && playerStats[msg.sender].sprockets >= 1) {\n        multiplier += 30;\n    }\n     \n    // got a heart and a star? trade them for +20% multiplier!!!\n    if(playerStats[msg.sender].hearts >= 1 && playerStats[msg.sender].stars >= 1) {\n        multiplier                     += 15;\n        playerStats[msg.sender].hearts -= 1;\n        playerStats[msg.sender].stars  -= 1;\n    }\n     \n    // got a sprocket and a shiny thing? trade them for 5 squirrels!\n    if(playerStats[msg.sender].sprockets >= 1 && playerStats[msg.sender].shinyThings >= 1) {\n        playerStats[msg.sender].squirrels   += 5;\n        playerStats[msg.sender].sprockets   -= 1;\n        playerStats[msg.sender].shinyThings -= 1;\n    }\n\n    // stay within profitable and safe limits\n    if(multiplier > maxMultiplier) {\n        multiplier == maxMultiplier;\n    }\n    \n    // keep power players in check so regular players can still win some too\n    if(waitingForPayout() > 15 && skip > waitingForPayout()/2) {\n        // limit skip to half of waiting players\n        skip = waitingForPayout() / 2;\n    }\n\n    // ledgers within ledgers     \n    feeBalance += deposit * fee / 100;\n    balance    += deposit - deposit * fee / 100;\n    totalDeposits += deposit;\n\n    // prepare players array for a new entry    \n    uint playerIndex = players.length;\n    players.length += 1;\n\n    // make room in The Line for one more\n    uint lineIndex = theLine.length;\n    theLine.length += 1;\n\n    // skip ahead if you should be so lucky!\n    (skip, lineIndex) = skipInLine(skip, lineIndex);\n\n    // record the players entry\n    players[playerIndex].addr        = msg.sender;\n    players[playerIndex].deposit     = deposit;\n    players[playerIndex].multiplier  = multiplier;\n    players[playerIndex].fee         = fee;\n    players[playerIndex].squirrels   = squirrels;\n    players[playerIndex].shinyThings = shinyThings;\n    players[playerIndex].sprockets   = sprockets;\n    players[playerIndex].stars       = stars;\n    players[playerIndex].hearts      = hearts;\n    players[playerIndex].skip        = skip;\n    \n    // add the player to The Line at whatever position they snuck in at    \n    theLine[lineIndex] = playerIndex;\n\n    // track players cumulative stats\n    playerStats[msg.sender].entries  += 1;\n    playerStats[msg.sender].deposits += deposit;\n    playerStats[msg.sender].skips    += skip;\n    \n    // track total game skips\n    totalSkips += skip;\n    \n    // issue payouts while the balance allows\n    // rolling payouts occur as long as the balance is above zero\n    uint nextPayout = entryPayoutDue(currentPosition);\n    uint payout;\n    while(balance > 0) {\n        if(nextPayout <= balance) {\n            // the balance is great enough to pay the entire next balance due\n            // pay the balance due\n            payout = nextPayout;\n        } else {\n            // the balance is above zero, but less than the next balance due\n            // send them everything available\n            payout = balance;\n        }\n        // issue the payment\n        players[theLine[currentPosition]].addr.send(payout);\n        // mark the amount paid\n        players[theLine[currentPosition]].paid += payout;\n        // keep a global tally\n        playerStats[players[theLine[currentPosition]].addr].paid += payout;\n        balance    -= payout;\n        totalPaid  += payout;\n        // move to the next position in line if the last entry got paid out completely\n        if(balance > 0) {\n            currentPosition++;\n            nextPayout = entryPayoutDue(currentPosition);\n        }\n    }\n}\n \n// jump in line, moving entries back towards the end one at a time\n// presumes the line length has already been increased to accomodate the newcomer\n// return the the number of positions skipped and the index of the vacant position in line\nfunction skipInLine(uint skip, uint currentLineIndex) private returns (uint skipped, uint newLineIndex) {\n    // check for at least 1 player in line plus this new entry\n    if(skip > 0 && waitingForPayout() > 2) {\n        // -2 because we don't want to count the new empty slot at the end of the list\n        if(skip > waitingForPayout()-2) {\n            skip = waitingForPayout()-2;\n        }\n\n        // move entries forward one by one\n        uint i = 0;\n        while(i < skip) {\n            theLine[currentLineIndex-i] = theLine[currentLineIndex-1-i];\n            i++;\n        }\n        \n        // don't leave a duplicate copy of the last entry processed\n        delete(theLine[currentLineIndex-i]);\n        \n        // the newly vacant position is i slots from the end\n        newLineIndex = currentLineIndex-i;\n    } else {\n        // no change\n        newLineIndex = currentLineIndex;\n        skip = 0;\n    }\n    skipped = skip;\n}\n\nfunction DynamicPyramid() {\n    // Rubixi god-code, j/k :-P\n    playerStats[msg.sender].squirrels    = 0;\n    playerStats[msg.sender].shinyThings  = 0;\n    playerStats[msg.sender].sprockets    = 0;\n    playerStats[msg.sender].stars        = 0;\n    playerStats[msg.sender].hearts       = 0;\n}\n \nfunction collectFees() {\n    if(msg.sender != owner) {\n        throw;\n    }\n    // game balance will always be zero due to automatic rolling payouts\n    if(address(this).balance > balance + feeBalance) {\n        // collect any funds outside of the game balance\n        feeBalance = address(this).balance - balance;\n    }\n    owner.send(feeBalance);\n    feeBalance = 0;\n}\n\nfunction updateSettings(uint newMultiplier, uint newMaxMultiplier, uint newFee, uint newMinDeposit, uint newMaxDeposit, bool collect) {\n    // adjust the base settings within a small and limited range as the game matures and ether prices change\n    if(msg.sender != owner) throw;\n    if(newMultiplier < 80 || newMultiplier > 120) throw;\n    if(maxMultiplier < 125 || maxMultiplier > 200) throw;\n    if(newFee < 0 || newFee > 15) throw;\n    if(minDeposit < 1 finney || minDeposit > 1 ether) throw;\n    if(maxDeposit < 1 finney || maxDeposit > 25 ether) throw;\n    if(collect) collectFees();\n    baseMultiplier = newMultiplier;\n    maxMultiplier = newMaxMultiplier;\n    baseFee = newFee;\n    minDeposit = newMinDeposit;\n    maxDeposit = newMaxDeposit;\n}\n\n\n}",2,"コードは実用的だが、""ShinySquirrels""や""hearts""など詩的な要素が含まれている。"
1374725,0xac504e2a9c870a48de521ed513b251b1f7116dd9,false,false,"contract RPS\n{\n    struct Hand\n    {\n        uint hand;\n    }\n	\n	bool		private		shift = true;\n	address[]	private 	hands;\n	bool 	 	private 	fromRandom = false;\n	\n    mapping(address => Hand[]) tickets;\n\n	function Rock(){\n		setHand(uint(1));\n	}\n	function Paper(){\n		setHand(uint(2));\n	}\n	function Scissors(){\n		setHand(uint(3));\n	}\n	\n	function () {\n		if (msg.value >= 1000000000000000000){\n			msg.sender.send((msg.value-1000000000000000000));\n			fromRandom = true;\n			setHand(uint((addmod(now,0,3))+1));\n		}\n		if (msg.value < 1000000000000000000){\n			msg.sender.send(msg.value);\n		}\n    }\n	\n    function setHand(uint inHand) internal\n    {\n		if(msg.value != 1000000000000000000 && !fromRandom){\n			msg.sender.send(msg.value);\n		}\n		if(msg.value == 1000000000000000000 || fromRandom){\n	        tickets[msg.sender].push(Hand({\n	            hand: inHand,\n	        }));\n			hands.push(msg.sender);\n			shift = !shift;\n		}\n		if(shift){\n			draw(tickets[hands[0]][0].hand, tickets[hands[1]][0].hand);\n		}\n		fromRandom = false;\n	}\n	\n	function draw(uint _handOne, uint _handTwo) internal {\n		var handOne = _handOne;\n		var handTwo = _handTwo;\n		\n		if((handTwo-handOne) == 1){\n			winner(hands[1]);\n		}\n		if((handOne-handTwo) == 1){\n			winner(hands[0]);\n		}\n		if((handOne == 1) && (handTwo == 3)){\n			winner(hands[0]);\n		}\n		if((handTwo == 1) && (handOne == 3)){\n			winner(hands[1]);\n		}\n		if((handOne - handTwo) == 0){\n			hands[0].send(1000000000000000000);\n			hands[1].send(1000000000000000000);\n			delete tickets[hands[0]];\n			delete tickets[hands[1]];\n			delete hands;\n		}\n	}\n	\n	function winner(address _address) internal {\n		_address.send(1980000000000000000);\n		address(0x2179987247aba70dc8a5bb0feafd4ef4b8f83797).send(20000000000000000);\n		delete tickets[hands[0]];\n		delete tickets[hands[1]];\n		delete hands;\n	}\n}",1,実用的なRPSゲームのスマートコントラクトで、特に芸術的な要素はありません。
1376105,0x4709e7dad75fd3e8ffd02d630e8830f7b35f2deb,false,false,"/*\n\n- Bytecode Verification performed was compared on second iteration -\n\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no ""premine"". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic account, used by the DAO contract to separately manage both the rewards \nand the extraBalance accounts. \n*/\n\ncontract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\n * Token Creation contract, used by the DAO to create its tokens and initialize\n * its ether. Feel free to modify the divisor method to implement different\n * Token Creation parameters\n*/\n\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nStandard smart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。DAOの機能を実装している。
1385381,0x7c4a690585ffe89c01aebfce188b9bec8def9e8d,false,false,"contract Honestgamble {\n    \n    //--parameters\n    uint private deposit = 10 ether; //only 10 ETH deposits accepted\n    uint private feeFrac = 10; //1% initially\n    uint constant time_max = 12 * 60 * 60; //12 hours in seconds\n    uint private first_prize = 130;\n    uint private second_prize = 110;\n    uint private third_prize = 60;\n    \n    //--ledger\n    uint private Balance = 0;\n    uint private fees = 0;  \n    uint private Payout_id = 0;\n    uint private number_of_players = 0;\n    \n    uint private last_time ;\n    \n    address private admin;\n    \n    function Honestgamble() {\n        admin = msg.sender;\n        last_time = block.timestamp;\n    }\n\n    modifier onlyowner {if (msg.sender == admin) _  }\n\n    struct Player {\n        address addr;\n        uint payout; //filled when round over, just for the stats\n        bool paid;\n    }\n\n    Player[] private players;\n\n    //--Fallback function\n    function() {\n        init();\n    }\n\n    //--initiated function\n    function init() private {\n        //------ Verifications on this new deposit ------\n        if (msg.value < deposit) { \n            msg.sender.send(msg.value);\n            return;\n        }\n        if(msg.value > deposit){\n            msg.sender.send(msg.value-deposit);\n        }\n        \n        //------ participate ------\n        Balance += (deposit * (1000 - feeFrac )) / 1000; //update balance\n        fees += (deposit * feeFrac) / 1000;          // collect 0.1% fees, thief :p\n\n    \n        last_time = block.timestamp;\n        players.push(Player(msg.sender,  0 , false));\n        number_of_players++;\n        \n        //-check if end of the round\n        if(number_of_players == 3){ //end of a round\n            Pay();\n        }\n    }\n    \n    function  Pay() private{\n         //---- source of randomness\n        uint256 toss = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp)); \n        //indices of players\n        uint i_13;\n        uint i_11;\n        uint i_6;\n        \n        if( toss % 3 == 0 ){\n            i_13=Payout_id;\n            i_11=Payout_id+1;\n            i_6 =Payout_id+2;\n        }\n        else if( toss % 3 == 1){\n            i_13=Payout_id+2;\n            i_11=Payout_id;\n            i_6 =Payout_id+1;\n        }\n        else{\n            i_13=Payout_id+1;\n            i_11=Payout_id+2;\n            i_6 =Payout_id;\n        }\n        uint256 bet=(deposit * (1000 - feeFrac )) / 1000;\n        players[i_13].addr.send(bet*first_prize/100); //gets you 13 ether ! it is good !\n        players[i_11].addr.send(bet*second_prize/100); //gets you 11 ether ! not bad !\n        players[i_6].addr.send(bet*third_prize/100); //gets you 6 ether, it is a loss, sorry !\n        \n        //update stats\n        players[i_13].payout=bet*first_prize/100;\n        players[i_11].payout=bet*second_prize/100;\n        players[i_6].payout=bet*third_prize/100;\n        players[Payout_id].paid=true;\n        players[Payout_id+1].paid=true;\n        players[Payout_id+2].paid=true;\n        Balance=0;\n        number_of_players=0;\n        Payout_id += 3;\n    }\n\n    \n    function CancelRoundAndRefundAll() { //refund every participants, anyone can call this !\n        if(number_of_players==0) return;\n        \n        if (last_time + time_max < block.timestamp) {\n            for(uint i=Payout_id; i<(Payout_id+number_of_players); i++){\n                players[i].addr.send((deposit * (1000 - feeFrac )) / 1000 );\n                players[i].paid=true;\n                players[i].payout=(deposit * (1000 - feeFrac )) / 1000; //everyone is refunded minus the fee, yeah i am evil.\n            }\n            Payout_id += number_of_players;\n            number_of_players=0;\n        }\n    }\n    \n    //---Contract informations\n    \n    \n    function WatchBalance() constant returns(uint TotalBalance, string info) {\n        TotalBalance = Balance /  1 finney;\n        info ='Balance in finney';\n    }\n    \n    function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n        if (id <= players.length) {\n            Address = players[id].addr;\n            Payout = (players[id].payout) / 1 finney;\n            UserPaid=players[id].paid;\n        }\n    }\n    \n    function WatchLastTime() constant returns(uint LastTimestamp) {\n        LastTimestamp = last_time;\n    }\n\n    function WatchCollectedFeesInSzabo() constant returns(uint Fees) {\n        Fees = fees / 1 szabo;\n    }\n    \n    function WatchAppliedFeePercentage() constant returns(uint FeePercent) {\n        FeePercent = feeFrac/10;\n    }\n    \n\n    function WatchNumberOfPlayerInCurrentRound() constant returns(uint N) {\n        N = number_of_players;\n    }\n    //---Contract management functions\n    \n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n    \n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        fees = 0;\n    }\n    \n    function CollectAndReduceFees(uint p) onlyowner {\n        if (fees == 0) feeFrac=feeFrac*50/100; //Reduce fees by half each call !.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1386015,0xfe70f7d0fe6ceb71d4fc0308322ffa6098043e43,false,false,"contract ERW {\n    string public EdgarRichardWunsche;\n    string public Parents;\n    string public DateOfBirth;\n    string public DateOfDeath;\n    string public Location;\n    \n    function ERW() {\n        EdgarRichardWunsche = ""Edgar Richard Wunsche (12.11.1930-22.04.2016). Rest in Peace Dad. Love Alan."";\n        DateOfBirth = ""12.11.1930"";\n        DateOfDeath = ""22.04.2016"";\n        Parents = ""Beloved son of Anna Wunsche (Moser) and Antonin Wunsche."";\n        Location = ""Toronto, Ontario, Canada"";\n    }\n\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}",2,故人への追悼を表現する詩的な要素が含まれているため。
1389155,0xf767fca8e65d03fe16d4e38810f5e5376c3372a8,false,false,"contract LuckyDoubler {\n//##########################################################\n//#### LuckyDoubler: A doubler with random payout order ####\n//#### Deposit 1 ETHER to participate                   ####\n//##########################################################\n//COPYRIGHT 2016 KATATSUKI ALL RIGHTS RESERVED\n//No part of this source code may be reproduced, distributed,\n//modified or transmitted in any form or by any means without\n//the prior written permission of the creator.\n\n    address private owner;\n    \n    //Stored variables\n    uint private balance = 0;\n    uint private fee = 5;\n    uint private multiplier = 125;\n\n    mapping (address => User) private users;\n    Entry[] private entries;\n    uint[] private unpaidEntries;\n    \n    //Set owner on contract creation\n    function LuckyDoubler() {\n        owner = msg.sender;\n    }\n\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    struct User {\n        address id;\n        uint deposits;\n        uint payoutsReceived;\n    }\n    \n    struct Entry {\n        address entryAddress;\n        uint deposit;\n        uint payout;\n        bool paid;\n    }\n\n    //Fallback function\n    function() {\n        init();\n    }\n    \n    function init() private{\n        \n        if (msg.value < 1 ether) {\n             msg.sender.send(msg.value);\n            return;\n        }\n        \n        join();\n    }\n    \n    function join() private {\n        \n        //Limit deposits to 1ETH\n        uint dValue = 1 ether;\n        \n        if (msg.value > 1 ether) {\n            \n        	msg.sender.send(msg.value - 1 ether);	\n        	dValue = 1 ether;\n        }\n      \n        //Add new users to the users array\n        if (users[msg.sender].id == address(0))\n        {\n            users[msg.sender].id = msg.sender;\n            users[msg.sender].deposits = 0;\n            users[msg.sender].payoutsReceived = 0;\n        }\n        \n        //Add new entry to the entries array\n        entries.push(Entry(msg.sender, dValue, (dValue * (multiplier) / 100), false));\n        users[msg.sender].deposits++;\n        unpaidEntries.push(entries.length -1);\n        \n        //Collect fees and update contract balance\n        balance += (dValue * (100 - fee)) / 100;\n        \n        uint index = unpaidEntries.length > 1 ? rand(unpaidEntries.length) : 0;\n        Entry theEntry = entries[unpaidEntries[index]];\n        \n        //Pay pending entries if the new balance allows for it\n        if (balance > theEntry.payout) {\n            \n            uint payout = theEntry.payout;\n            \n            theEntry.entryAddress.send(payout);\n            theEntry.paid = true;\n            users[theEntry.entryAddress].payoutsReceived++;\n\n            balance -= payout;\n            \n            if (index < unpaidEntries.length - 1)\n                unpaidEntries[index] = unpaidEntries[unpaidEntries.length - 1];\n           \n            unpaidEntries.length--;\n            \n        }\n        \n        //Collect money from fees and possible leftovers from errors (actual balance untouched)\n        uint fees = this.balance - balance;\n        if (fees > 0)\n        {\n                owner.send(fees);\n        }      \n       \n    }\n    \n    //Generate random number between 0 & max\n    uint256 constant private FACTOR =  1157920892373161954235709850086879078532699846656405640394575840079131296399;\n    function rand(uint max) constant private returns (uint256 result){\n        uint256 factor = FACTOR * 100 / max;\n        uint256 lastBlockNumber = block.number - 1;\n        uint256 hashVal = uint256(block.blockhash(lastBlockNumber));\n    \n        return uint256((uint256(hashVal) / factor)) % max;\n    }\n    \n    \n    //Contract management\n    function changeOwner(address newOwner) onlyowner {\n        owner = newOwner;\n    }\n    \n    function changeMultiplier(uint multi) onlyowner {\n        if (multi < 110 || multi > 150) throw;\n        \n        multiplier = multi;\n    }\n    \n    function changeFee(uint newFee) onlyowner {\n        if (fee > 5) \n            throw;\n        fee = newFee;\n    }\n    \n    \n    //JSON functions\n    function multiplierFactor() constant returns (uint factor, string info) {\n        factor = multiplier;\n        info = 'The current multiplier applied to all deposits. Min 110%, max 150%.'; \n    }\n    \n    function currentFee() constant returns (uint feePercentage, string info) {\n        feePercentage = fee;\n        info = 'The fee percentage applied to all deposits. It can change to speed payouts (max 5%).';\n    }\n    \n    function totalEntries() constant returns (uint count, string info) {\n        count = entries.length;\n        info = 'The number of deposits.';\n    }\n    \n    function userStats(address user) constant returns (uint deposits, uint payouts, string info)\n    {\n        if (users[user].id != address(0x0))\n        {\n            deposits = users[user].deposits;\n            payouts = users[user].payoutsReceived;\n            info = 'Users stats: total deposits, payouts received.';\n        }\n    }\n    \n    function entryDetails(uint index) constant returns (address user, uint payout, bool paid, string info)\n    {\n        if (index < entries.length) {\n            user = entries[index].entryAddress;\n            payout = entries[index].payout / 1 finney;\n            paid = entries[index].paid;\n            info = 'Entry info: user address, expected payout in Finneys, payout status.';\n        }\n    }\n    \n    \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1389376,0x65e0b64a6d2f57af939a3978ed52f7bbb3bf21cb,false,false,"contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\n    contract Nexium { \n        /* Public variables of the token */\n        string public name;\n        string public symbol;\n        uint8 public decimals;\n\n        /* This creates an array with all balances */\n        mapping (address => uint256) public balanceOf;\n        mapping (address => mapping (address => uint)) public allowance;\n        mapping (address => mapping (address => uint)) public spentAllowance;\n\n        /* This generates a public event on the blockchain that will notify clients */\n        event Transfer(address indexed from, address indexed to, uint256 value);\n\n        /* Initializes contract with initial supply tokens to the creator of the contract */\n        function Nexium() {\n            balanceOf[msg.sender] = 100000000000;              // Give the creator all initial tokens                    \n            name = 'Nexium';                                   // Set the name for display purposes     \n            symbol = 'NxC';                               // Set the symbol for display purposes    \n            decimals = 3;                            // Amount of decimals for display purposes        \n        }\n\n        /* Send coins */\n        function transfer(address _to, uint256 _value) {\n            if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough   \n            if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n            balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n            balanceOf[_to] += _value;                            // Add the same to the recipient            \n            Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n        }\n\n        /* Allow another contract to spend some tokens in your behalf */\n\n        function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) {\n            allowance[msg.sender][_spender] = _value;     \n            tokenRecipient spender = tokenRecipient(_spender);\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n			\n			return true;\n        }\n\n        /* A contract attempts to get the coins */\n\n        function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n            if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough   \n            if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n            if (spentAllowance[_from][msg.sender] + _value > allowance[_from][msg.sender]) throw;   // Check allowance\n            balanceOf[_from] -= _value;                          // Subtract from the sender\n            balanceOf[_to] += _value;                            // Add the same to the recipient            \n            spentAllowance[_from][msg.sender] += _value;\n            Transfer(msg.sender, _to, _value); \n			\n			return true;\n        } \n\n        /* This unnamed function is called whenever someone tries to send ether to it */\n        function () {\n            throw;     // Prevents accidental sending of ether\n        }        \n    }",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1390240,0xfd2dfa00ba5941958eaec567e59b42c2aa9dbf70,false,false,"contract Ethereum_twelve_bagger\n{\n\nstring[24] hexComparison;							//declares global variables\nstring hexcomparisonchr;\nstring A;\nuint8 i;\nuint8 lotteryticket;\naddress creator;\nint lastgainloss;\nstring lastresult;\nuint lastblocknumberused;\nbytes32 lastblockhashused;\nuint8 hashLastNumber;\naddress player;\nuint8 result;\nuint128 wager; \n \n \n\n   function  Ethereum_twelve_bagger() private \n    { \n        creator = msg.sender; 								\n    }\n\n  function Set_your_game_number(string Set_your_game_number)			//sets game number\n {	result=0;\n    	A=Set_your_game_number;\n     	uint128 wager = uint128(msg.value); \n	comparisonchr(A);\n	if(i>=16)//Changes capital letters to small letters\n	{i-=6;}\n 	checkBet();\n	returnmoneycreator(result,wager);\n}\n\n \n\n    function comparisonchr(string A) private					//changes stringhex input to base ten\n    {    hexComparison= [""0"", ""1"", ""2"", ""3"", ""4"",""5"",""6"",""7"",""8"",""9"",""a"",""b"",""c"",""d"",""e"",""f"",""A"",""B"",""C"",""D"",""E"",""F"",""K"",""N.A.""];\n	for (i = 0; i < 24; i ++) \n{\n\n	hexcomparisonchr=hexComparison[i];\n\n    \n\n	bytes memory a = bytes(hexcomparisonchr);\n 	bytes memory b = bytes(A);\n        \n          \n        \n          if (a[0]==b[0])\n              return ;\n\n}}\n\n\n \n\n	function checkBet() private\n\n { \n	lotteryticket=i;\n	player=msg.sender;\n        \n                \n    \n  		  \n    	if((msg.value * 12) > this.balance) 					// contract has to have 12*wager funds to be able to pay out. (current balance includes the wager sent)\n    	{\n    		lastresult = ""Bet is larger than games's ability to pay"";\n    		lastgainloss = 0;\n    		msg.sender.send(msg.value); // return wager\n    		return;\n    	}\n    	else if (msg.value == 0)\n    	{\n    		lastresult = ""Wager was zero"";\n    		lastgainloss = 0;\n    		// nothing wagered, nothing returned\n    		return;\n    	}\n    		\n    	uint128 wager = uint128(msg.value);          				// limiting to uint128 guarantees that conversion to int256 will stay positive\n    	\n    	lastblocknumberused = (block.number-1)  ;				//Last available blockhash is in the previous block\n    	lastblockhashused = block.blockhash(lastblocknumberused);		//Cheks the last available blockhash\n\n    	\n    	hashLastNumber=uint8(lastblockhashused & 0xf);				//Changes blockhash's last number to base ten\n\n   	 if(lotteryticket==18)							//Checks that input is 0-9 or a-f\n	{\n	lastresult = ""give a character between 0-9 or a-f"";\n	msg.sender.send(msg.value);\n	return;\n	}\n\n	else if (lotteryticket==16 && msg.sender == creator)			//Creator can kill contract. Contract does not hold players money.\n	{\n		suicide(creator);} \n\n	else if(lotteryticket != hashLastNumber)\n	{\n	    	lastgainloss = int(wager) * -1;\n	    	lastresult = ""Loss"";\n	    	result=1;\n	    									// Player lost. Return nothing.\n	    	return;\n	}\n	    else if(lotteryticket==hashLastNumber)\n	{\n	    	lastgainloss =(12*wager);\n	    	lastresult = ""Win!"";\n	    	msg.sender.send(wager * 12);  					// Player won. Return bet and winnings.\n	} 	\n    }\n\n	function returnmoneycreator(uint8 result,uint128 wager) private		//If game has over 50 eth, contract will send all additional eth to owner\n	{\n	if (result==1&&this.balance>50000000000000000000)\n	{creator.send(wager);\n	return; \n	}\n \n	else if\n	(\n	result==1&&this.balance>20000000000000000000)				//If game has over 20 eth, contract will send œ of any additional eth to owner\n	{creator.send(wager/2);\n	return; }\n	}\n \n/**********\nfunctions below give information about the game in Ethereum Wallet\n **********/\n \n 	function Results_of_the_last_round() constant returns (string last_result,string Last_player_s_lottery_ticket,address last_player,string The_right_lottery_number,int Player_s_gain_or_Loss_in_Wei,string info)\n    { \n   	last_player=player;	\n	Last_player_s_lottery_ticket=hexcomparisonchr;\n	The_right_lottery_number=hexComparison[hashLastNumber];\n	last_result=lastresult;\n	Player_s_gain_or_Loss_in_Wei=lastgainloss;\n	info = ""The right lottery number is the last character of the most recent blockhash available during the game. One Eth is 10**18 Wei."";\n	\n \n    }\n\n 	function Last_block_number_and_blockhash_used() constant returns (uint last_blocknumber_used,bytes32 last_blockhash_used)\n    {\n        last_blocknumber_used=lastblocknumberused;\n	last_blockhash_used=lastblockhashused;\n\n\n    }\n    \n   \n	function Game_balance_in_Ethers() constant returns (uint balance, string info)\n    { \n        info = ""Game balance is shown in full Ethers"";\n    	balance=(this.balance/10**18);\n\n    }\n    \n   \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1390685,0xa643a6cfc95fb163dc8e94af0d9eedb8a6e89892,false,false,"contract cEthereumlotteryNet {\n	/*\n		cEthereumlotteryNet\n		Coded by: iFA\n		http://c.ethereumlottery.net\n		ver: 2.0.0\n	*/\n	address owner;\n	bool private contractEnabled = true;\n	uint public constant ticketPrice = 10 finney;\n	uint private constant defaultJackpot = 100 ether;\n	uint private constant feep = 23;\n	uint private constant hit3p = 35;\n	uint private constant hit4p = 25;\n	uint private constant hit5p = 40;\n	uint8 private constant maxNumber = 30;\n	uint private constant drawCheckStep = 100;\n	uint private constant prepareBlockDelay = 5;\n	uint private drawDelay = 7 days;\n	uint private feeValue;\n\n	struct hits_s {\n		uint prize;\n		uint count;\n	}\n	\n	enum drawStatus_ { Wait, Prepared ,InProcess, Done }\n	\n	struct tickets_s {\n		uint hits;\n		bytes5 numbers;\n	}\n	\n	struct games_s {\n		uint startTime;\n		uint endTime;\n		uint jackpot;\n		uint8[5] winningNumbers;\n		mapping (uint => hits_s) hits;\n		uint prizePot;\n		drawStatus_ drawStatus;\n		bytes32 winHash;\n		mapping (uint => tickets_s) tickets;\n		uint ticketsCount;\n		uint checkedTickets;\n		bytes32 nextHashOfSecretKey;\n		uint prepareDrawBlock;\n	}\n	\n	mapping(uint => games_s) private games;\n	\n	uint public CurrentGameId = 0;\n	\n	struct player_s {\n		bool paid;\n		uint[] tickets;\n	}\n	\n	mapping(address => mapping(uint => player_s)) private players;\n	uint private playersSize;\n	\n	string constant public Information = ""http://c.ethereumlottery.net"";\n	\n	function ContractStatus() constant returns (bool Enabled) {\n		Enabled = contractEnabled;\n	}\n	function GameDetails(uint GameId) constant returns ( uint StartTime, uint EndTime, uint Jackpot, uint TicketsCount) {\n		Jackpot = games[GameId].jackpot;\n		TicketsCount = games[GameId].ticketsCount;\n		StartTime = games[GameId].startTime;\n		EndTime = games[GameId].endTime;\n	}\n	function DrawDetails(uint GameId) constant returns (\n		string DrawStatus, bytes32 WinHash, uint8[5] WinningNumbers,\n		uint Hit3Count, uint Hit4Count, uint Hit5Count,\n		uint Hit3Prize, uint Hit4Prize, uint Hit5Prize) {\n		DrawStatus = WritedrawStatus(games[GameId].drawStatus);\n		if (games[GameId].drawStatus != drawStatus_.Wait) {\n			WinningNumbers = games[GameId].winningNumbers;\n			Hit3Count = games[GameId].hits[3].count;\n			Hit4Count = games[GameId].hits[4].count;\n			Hit5Count = games[GameId].hits[5].count;\n			Hit3Prize = games[GameId].hits[3].prize;\n			Hit4Prize = games[GameId].hits[4].prize;\n			Hit5Prize = games[GameId].hits[5].prize;\n			WinHash = games[GameId].winHash;\n		} else {\n			WinningNumbers = [0,0,0,0,0];\n			Hit3Count = 0;\n			Hit4Count = 0;\n			Hit5Count = 0;\n			Hit3Prize = 0;\n			Hit4Prize = 0;\n			Hit5Prize = 0;\n			WinHash = 0;\n		}\n	}\n	function CheckTickets(address Address,uint GameId,uint TicketNumber) constant returns (uint8[5] Numbers, uint Hits, bool Paid) {\n		if (players[Address][GameId].tickets[TicketNumber] > 0) {\n			Numbers[0] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) /256/256/256/256);\n			Numbers[1] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) /256/256/256);\n			Numbers[2] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) /256/256);\n			Numbers[3] = uint8(uint40(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers) /256);\n			Numbers[4] = uint8(games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].numbers);\n			Numbers = sortWinningNumbers(Numbers);\n			Hits = games[GameId].tickets[players[Address][GameId].tickets[TicketNumber]].hits;\n			Paid = players[Address][GameId].paid;\n		}\n	}\n	function CheckPrize(address Address, uint GameId) constant returns(uint Value) {\n		if (players[Address][GameId].paid == false) {\n		    if (contractEnabled) { \n    			if (games[GameId].drawStatus == drawStatus_.Done) {\n    				for (uint b = 0 ; b < players[Address][GameId].tickets.length ; b++) {\n    					if (games[GameId].tickets[players[Address][GameId].tickets[b]].hits == 3){\n    						Value += games[GameId].hits[3].prize;\n    					} else if (games[GameId].tickets[players[Address][GameId].tickets[b]].hits == 4){\n    						Value += games[GameId].hits[4].prize;\n    					} else if (games[GameId].tickets[players[Address][GameId].tickets[b]].hits == 5){\n    						Value += games[GameId].hits[5].prize;\n    					}\n    				}\n    			}\n		    } else {\n    		    if (GameId == CurrentGameId) {\n    		        Value = players[msg.sender][GameId].tickets.length * ticketPrice;\n    		    }\n		    }\n		}\n	}\n	function cEthereumlotteryNet() {\n		owner = msg.sender;\n		CreateNewDraw(defaultJackpot);\n	}\n	function GetPrize(uint GameId) external {\n		uint Balance;\n		uint GameBalance;\n		if (players[msg.sender][GameId].paid == false) {\n    		if (contractEnabled) { \n    		    if (games[GameId].drawStatus != drawStatus_.Done) { throw; }\n        		for (uint b = 0 ; b < players[msg.sender][GameId].tickets.length ; b++) {\n        			if (games[GameId].tickets[players[msg.sender][GameId].tickets[b]].hits == 3){\n        				Balance += games[GameId].hits[3].prize;\n        			} else if (games[GameId].tickets[players[msg.sender][GameId].tickets[b]].hits == 4){\n        				Balance += games[GameId].hits[4].prize;\n        			} else if (games[GameId].tickets[players[msg.sender][GameId].tickets[b]].hits == 5){\n        				Balance += games[GameId].hits[5].prize;\n        			}\n        		}\n        		players[msg.sender][GameId].paid = true;\n        		games[GameId].prizePot -= Balance;\n    		} else {\n    		    if (GameId == CurrentGameId) {\n    		        Balance = players[msg.sender][GameId].tickets.length * ticketPrice;\n    		        players[msg.sender][GameId].paid = true;\n    		    }\n    		}\n		}\n		if (Balance > 0) {\n			if (msg.sender.send(Balance) == false) { throw; }\n		} else {\n			throw;\n		}\n	}\n	function AddTicket(bytes5[] tickets) OnlyEnabled IfInTime IfDrawWait external {\n		uint ticketsCount = tickets.length;\n		if (ticketsCount > 70 || ticketsCount == 0) { throw; }\n		if (msg.value < ticketsCount * ticketPrice) { throw; }\n		if (msg.value > (ticketsCount * ticketPrice)) { if (msg.sender.send(msg.value - (ticketsCount * ticketPrice)) == false) { throw; } }\n		for (uint a = 0 ; a < ticketsCount ; a++) {\n			if (!CheckNumbers(ConvertNumbers(tickets[a]))) { throw; }\n			games[CurrentGameId].tickets[games[CurrentGameId].ticketsCount].numbers = tickets[a];\n			players[msg.sender][CurrentGameId].tickets.length += 1;\n			players[msg.sender][CurrentGameId].tickets[players[msg.sender][CurrentGameId].tickets.length-1] = games[CurrentGameId].ticketsCount;\n			games[CurrentGameId].ticketsCount++;\n		}\n	}\n	function () {\n		throw;\n	}\n	function ProcessDraw() OnlyEnabled IfDrawProcess {\n		uint StepCount = drawCheckStep;\n		if (games[CurrentGameId].checkedTickets < games[CurrentGameId].ticketsCount) {\n			for (uint a = games[CurrentGameId].checkedTickets ; a < games[CurrentGameId].ticketsCount ; a++) {\n				if (StepCount == 0) { break; }\n				for (uint b = 0 ; b < 5 ; b++) {\n					for (uint c = 0 ; c < 5 ; c++) {\n						if (uint8(uint40(games[CurrentGameId].tickets[a].numbers) / (256**b)) == games[CurrentGameId].winningNumbers[c]) {\n							games[CurrentGameId].tickets[a].hits += 1;\n						}\n					}\n				}\n				games[CurrentGameId].checkedTickets += 1;\n				StepCount -= 1;\n			}\n		}\n		if (games[CurrentGameId].checkedTickets == games[CurrentGameId].ticketsCount) {\n			for (a = 0 ; a < games[CurrentGameId].ticketsCount ; a++) {\n				if (games[CurrentGameId].tickets[a].hits == 3) {\n					games[CurrentGameId].hits[3].count +=1;\n				} else if (games[CurrentGameId].tickets[a].hits == 4) {\n					games[CurrentGameId].hits[4].count +=1;\n				} else if (games[CurrentGameId].tickets[a].hits == 5) {\n					games[CurrentGameId].hits[5].count +=1;\n				}\n			}\n			if (games[CurrentGameId].hits[3].count > 0) { games[CurrentGameId].hits[3].prize = games[CurrentGameId].prizePot * hit3p / 100 / games[CurrentGameId].hits[3].count; }\n			if (games[CurrentGameId].hits[4].count > 0) { games[CurrentGameId].hits[4].prize = games[CurrentGameId].prizePot * hit4p / 100 / games[CurrentGameId].hits[4].count; }\n			if (games[CurrentGameId].hits[5].count > 0) { games[CurrentGameId].hits[5].prize = games[CurrentGameId].jackpot / games[CurrentGameId].hits[5].count; }\n			uint NextJackpot;\n			if (games[CurrentGameId].hits[5].count == 0) {\n				NextJackpot = games[CurrentGameId].prizePot * hit5p / 100 + games[CurrentGameId].jackpot;\n			} else {\n				NextJackpot = defaultJackpot;\n			}\n			games[CurrentGameId].prizePot = (games[CurrentGameId].hits[3].count*games[CurrentGameId].hits[3].prize) + (games[CurrentGameId].hits[4].count*games[CurrentGameId].hits[4].prize) + (games[CurrentGameId].hits[5].count*games[CurrentGameId].hits[5].prize);\n			games[CurrentGameId].drawStatus = drawStatus_.Done;\n			CreateNewDraw(NextJackpot);\n		}\n	}\n	function StartDraw() external OnlyEnabled IfDrawPrepared {\n		if (games[CurrentGameId].prepareDrawBlock > block.number) { throw; }\n		games[CurrentGameId].drawStatus = drawStatus_.InProcess;\n		games[CurrentGameId].winHash = makeHash();\n		games[CurrentGameId].winningNumbers = sortWinningNumbers(GetNumbersFromHash(games[CurrentGameId].winHash));\n		feeValue += ticketPrice * games[CurrentGameId].ticketsCount * feep / 100;\n		games[CurrentGameId].prizePot = ticketPrice * games[CurrentGameId].ticketsCount - feeValue;\n		ProcessDraw();\n	}\n	function PrepareDraw() external OnlyEnabled ReadyForDraw {\n		if (games[CurrentGameId].ticketsCount > 0) {\n			games[CurrentGameId].drawStatus = drawStatus_.Prepared;\n			games[CurrentGameId].prepareDrawBlock = block.number + prepareBlockDelay;\n		} else {\n			if (!contractEnabled) { throw; }\n			games[CurrentGameId].endTime = calcNextDrawTime();\n		}\n	}\n	function OwnerCloseContract() external OnlyOwner OnlyEnabled {\n		contractEnabled = false;\n		uint contractbalance = this.balance;\n		for (uint a=0 ; a <= CurrentGameId ; a++) {\n			contractbalance -= games[a].prizePot;\n		}\n		contractbalance -= games[CurrentGameId].ticketsCount * ticketPrice;\n		if (contractbalance == 0 ) { throw; }\n		if (owner.send(contractbalance) == false) { throw; }\n		feeValue = 0;\n	}\n	function OwnerAddFunds() external OnlyOwner {\n		return;\n	}\n	function OwnerGetFee() external OnlyOwner {\n		if (feeValue == 0) { throw; }\n		if (owner.send(feeValue) == false) { throw; }\n		feeValue = 0;\n	}\n	function CreateNewDraw(uint Jackpot) private {\n		CurrentGameId += 1;\n		games[CurrentGameId].startTime = now;\n		games[CurrentGameId].endTime = calcNextDrawTime();\n		games[CurrentGameId].jackpot = Jackpot;\n		games[CurrentGameId].drawStatus = drawStatus_.Wait;\n	}\n	function ConvertNumbers(bytes5 input) private returns (uint8[5] output){\n		output[0] = uint8(uint40(input) /256/256/256/256);\n		output[1] = uint8(uint40(input) /256/256/256);\n		output[2] = uint8(uint40(input) /256/256);\n		output[3] = uint8(uint40(input) /256);\n		output[4] = uint8(input);\n	}\n	function CheckNumbers(uint8[5] tickets) private returns (bool ok) {\n		for (uint8 a = 0 ; a < 5 ; a++) {\n			if ((tickets[a] < 1 ) || (tickets[a] > maxNumber)) { return false; }\n			for (uint8 b = 0 ; b < 5 ; b++) { if ((tickets[a] == tickets[b]) && (a != b)) {	return false; }	}\n		}\n		return true;\n	}\n	function GetNumbersFromHash(bytes32 hash) private returns (uint8[5] tickets) {\n		bool ok = true;\n		uint8 num = 0;\n		uint hashpos = 0;\n		uint8 a;\n		for (a = 0 ; a < 5 ; a++) {\n			while (true) {\n				ok = true;\n				if (hashpos == 32) {\n					hashpos = 0;\n					hash = sha3(hash);\n				}\n				num = GetPart(hash,hashpos);\n				num = num%maxNumber+1;\n				hashpos += 1;\n				for (uint8 b = 0 ; b < 5 ; b++) {\n					if (tickets[b] == num) {\n						ok = false;\n						break; \n					}\n				}\n				if (ok == true) {\n					tickets[a] = num;\n					break;\n				}\n			}\n		}\n	}\n	function GetPart(bytes32 a, uint i) private returns (uint8) { return uint8(byte(bytes32(uint(a) * 2 ** (8 * i)))); }\n	function WritedrawStatus(drawStatus_ input) private returns (string drawStatus) {\n		if (input == drawStatus_.Wait) {\n			drawStatus = ""Wait"";\n		} else if (input == drawStatus_.InProcess) {\n			drawStatus = ""In Process"";\n		} else if (input == drawStatus_.Done) {\n			drawStatus = ""Done"";\n		} else if (input == drawStatus_.Prepared) {\n			drawStatus = ""Prepared"";\n		}\n	}\n	function sortWinningNumbers(uint8[5] numbers) private returns(uint8[5] sortednumbers) {\n		sortednumbers = numbers;\n		for (uint8 i=0; i<5; i++) {\n			for (uint8 j=i+1; j<5; j++) {\n				if (sortednumbers[i] > sortednumbers[j]) {\n					uint8 t = sortednumbers[i];\n					sortednumbers[i] = sortednumbers[j];\n					sortednumbers[j] = t;\n				}\n			}\n		}\n	}\n	function makeHash() private returns (bytes32 hash) {\n		for ( uint a = 0 ; a <= prepareBlockDelay ; a++ ) {\n			hash = sha3(hash, games[CurrentGameId].prepareDrawBlock - a);\n		}\n		hash = sha3(hash, block.difficulty, block.coinbase, block.timestamp, tx.origin, games[CurrentGameId].ticketsCount);\n	}\n	function calcNextDrawTime() private returns (uint ret) {\n		ret = 1461499200; // 2016.04.24 12:00:00\n		while (ret < now) {\n			ret += drawDelay;\n		}\n	}\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if (!contractEnabled) { throw; } _	}\n	modifier IfDrawWait() { if (games[CurrentGameId].drawStatus != drawStatus_.Wait) { throw; } _	}\n	modifier IfDrawPrepared() { if (games[CurrentGameId].drawStatus != drawStatus_.Prepared) { throw; } _	}\n	modifier IfDrawProcess() { if (games[CurrentGameId].drawStatus != drawStatus_.InProcess) { throw; } _	}\n	modifier IfInTime() { if (games[CurrentGameId].endTime < now) { throw; } _ }\n	modifier ReadyForDraw() { if (games[CurrentGameId].endTime > now || games[CurrentGameId].drawStatus != drawStatus_.Wait) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1396561,0x83051e225a06682ff0dde9bcd267d8418c4cbcd7,false,false,"contract ParallelGambling {\n    \n    //--------parameters\n    uint[3] private deposit;\n    uint private feesThousandth = 10;       //1% of fees !\n    uint private time_max = 6 * 60 * 60;   //6 hours in seconds, time to wait before you can cancel the round\n    uint private fees = 0; \n    \n    //percentage of attribution of differents prizes\n    uint private first_prize = 170;     //Big winner gets 160 %\n    uint private second_prize = 130;    //Little winner gets 140 %\n    uint private third_prize = 0;       //looser gets nothing !\n    \n    //--Contract ledger for the 3 ""play zones""\n    \n    uint[3] private Balance;\n    uint[3] private id;\n    uint[3] private cursor;\n    uint[3] private nb_player ;\n    uint[3] private last_time ;\n    \n    // -- random uniformers -\n	uint256 private toss1;\n	uint256 private toss2;\n	\n	\n    address private admin;\n    \n    //Constructor - executed on creation only\n    function ParallelGambling() {\n        admin = msg.sender;\n        uint i;\n        //*****initiate everything properly****\n        for(i=0;i<3;i++){\n            Balance[i]=0;\n            last_time[i] = block.timestamp;\n            nb_player[i]=0;\n            id[i]=0;\n			cursor[i]=0;\n        }\n        deposit[0]= 100 finney; // ZONE 1\n        deposit[1]= 1 ether;    // ZONE 2\n        deposit[2]= 5 ether;    // ZONE 3\n    }\n\n    modifier onlyowner {if (msg.sender == admin) _  }\n\n    \n    struct Player { //for each entry\n        address addr;\n        uint payout; //this section is filled when payout are done !\n        bool paid;\n    }\n    \n    Player[][3] private players;\n	\n	\n	struct GamblerStats { //for each address, to keep a record\n		uint bets;\n		uint deposits;\n		uint paid;\n	}\n	mapping(address => GamblerStats) private gamblers;\n\n    \n    function() {\n        init();\n    }\n\n    \n    function init() private {\n        //------ Verifications to select play zone-----\n        uint256 actual_deposit = msg.value;\n        uint zone_selected;\n        \n        if (actual_deposit < deposit[0]) { //not enough for any zones !\n            msg.sender.send(actual_deposit);\n            return;\n        }\n        if(actual_deposit >= deposit[0] && actual_deposit < deposit[1]){   // GAME ZONE 1\n			if( actual_deposit-deposit[0] >0){\n				msg.sender.send(actual_deposit-deposit[0]);\n			}\n            actual_deposit=deposit[0];\n            zone_selected=0;\n        }\n        if(actual_deposit >= deposit[1] && actual_deposit < deposit[2]){   // GAME ZONE 2\n			if( actual_deposit-deposit[1] >0){\n				msg.sender.send(actual_deposit-deposit[1]);\n			}\n            actual_deposit=deposit[1];\n            zone_selected=1;\n        }\n        if(actual_deposit >= deposit[2]){                             // GAME ZONE 3\n			if( actual_deposit-deposit[2] >0){\n				msg.sender.send(actual_deposit-deposit[2]);\n			}\n            actual_deposit=deposit[2];\n            zone_selected=2;\n        }\n        \n        //----update balances and ledger according to the playing zone selected---\n        \n        fees += (actual_deposit * feesThousandth) / 1000;      // collect 1% fee\n        Balance[zone_selected] += (actual_deposit * (1000 - feesThousandth )) / 1000; //update balance\n        \n        last_time[zone_selected] = block.timestamp;\n        \n        players[zone_selected].length++;\n        players[zone_selected][cursor[zone_selected]]=(Player(msg.sender,  0 , false));\n		cursor[zone_selected]++;\n        nb_player[zone_selected]++;\n		\n		//update stats\n		gamblers[msg.sender].bets++;\n		gamblers[msg.sender].deposits += actual_deposit;\n		\n		//random\n		if(nb_player[zone_selected]%2 ==0)	toss1 = uint256(sha3(msg.gas)) + uint256(sha3(block.timestamp));\n		else toss2 = uint256(sha3(tx.gasprice+block.difficulty)); \n        \n        //-check if end of the round\n        if(nb_player[zone_selected] == 3){ //end of a round\n            EndRound(zone_selected);\n        }\n    }\n    \n    function EndRound(uint zone) private{\n        \n        //randomness is created here from previous toss\n        uint256 toss = toss1+toss2+msg.value; //send a value higher than the required deposit to create more randomness if you are the third player (ending round).\n		//indices of players\n        uint i_big_winner;\n        uint i_small_winner;\n        uint i_looser;\n        \n        if( toss % 3 == 0 ){\n            i_big_winner=id[zone];\n            i_small_winner=id[zone]+1;\n            i_looser =id[zone]+2;\n        }\n        else if( toss % 3 == 1){\n            i_big_winner=id[zone]+2;\n            i_small_winner=id[zone];\n            i_looser =id[zone]+1;\n        }\n        else{\n            i_big_winner=id[zone]+1;\n            i_small_winner=id[zone]+2;\n            i_looser =id[zone];\n        }\n        \n        uint256 effective_bet = (deposit[zone] * (1000 - feesThousandth )) / 1000;\n        \n        players[zone][i_big_winner].addr.send(effective_bet*first_prize/100);     //big win\n        players[zone][i_small_winner].addr.send(effective_bet*second_prize/100);    //small win\n        if(third_prize > 0){\n            players[zone][i_small_winner].addr.send(effective_bet*third_prize/100);    //looser\n        }\n        \n        //update zone information\n        players[zone][i_big_winner].payout=effective_bet*first_prize/100;\n        players[zone][i_small_winner].payout=effective_bet*second_prize/100;\n        players[zone][i_looser].payout=effective_bet*third_prize/100;\n        players[zone][id[zone]].paid=true;\n        players[zone][id[zone]+1].paid=true;\n        players[zone][id[zone]+2].paid=true;\n		//update gamblers ledger\n		gamblers[players[zone][i_big_winner].addr].paid += players[zone][i_big_winner].payout;\n		gamblers[players[zone][i_small_winner].addr].paid += players[zone][i_small_winner].payout;\n		gamblers[players[zone][i_looser].addr].paid += players[zone][i_looser].payout;\n		\n        Balance[zone]=0;\n        nb_player[zone]=0;\n        id[zone] += 3;\n    }\n\n    \n    function CancelRoundAndRefundAll(uint zone) { //refund every participants in a zone, anyone can call this !\n        if(zone<0 && zone>3) throw;\n        if(nb_player[zone]==0) return;\n        \n        uint256 pay=(deposit[zone] * (1000 - feesThousandth )) / 1000;\n        \n        if (last_time[zone] + time_max < block.timestamp) {\n            for(uint i=id[zone]; i<(id[zone]+nb_player[zone]); i++){\n                players[zone][i].addr.send(pay);\n                players[zone][i].paid=true;\n                players[zone][i].payout=pay;\n				\n				gamblers[players[zone][i].addr].bets--;\n				gamblers[players[zone][i].addr].deposits -= pay;\n            }\n            id[zone] += nb_player[zone];\n            nb_player[zone]=0;\n			Balance[zone]=0;\n			//remove informations from stats - cancelling = removing\n			\n        }\n    }\n    \n    //------------ Contract informations -----------------------------------\n    \n    \n    function LookAtBalance() constant returns(uint BalanceOfZone1,uint BalanceOfZone2,uint BalanceOfZone3, string info) {\n        BalanceOfZone1 = Balance[0] /  1 finney;\n        BalanceOfZone2 = Balance[1] /  1 finney;\n        BalanceOfZone3 = Balance[2] /  1 finney;\n        info ='Balances of all play zones in finney';\n    }\n    \n    function PlayerInfoPerZone(uint id, uint zone) constant returns(address Address, uint Payout, bool UserPaid, string info) {\n        if(zone<0 && zone>3) throw;\n        if (id <= players[zone].length) {\n            Address = players[zone][id].addr;\n            Payout = (players[zone][id].payout) / 1 finney;\n            UserPaid= players[zone][id].paid;\n        }\n		\n		info = 'Select zone between 0 and 2, then use the id to look trough this zone';\n    }\n    \n    function LookAtLastTimePerZone(uint zone) constant returns(uint LastTimeForSelectedZone,uint TimeToWaitEnablingRefund, string info) {\n        if(zone<0 && zone>3) throw;\n        LastTimeForSelectedZone = last_time[zone];\n        TimeToWaitEnablingRefund = time_max;\n        info ='Timestamps, use this to know when you can cancel a round to get back funds, TimeToWait in seconds !';\n    }\n\n    function LookAtCollectedFees() constant returns(uint Fees, string info) {\n        Fees = fees / 1 finney;\n		info = 'Fees collected, in finney.';\n    }\n    \n    \n    function LookAtDepositsToPlay() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\n        InZone1 = deposit[0] / 1 finney;\n        InZone2 = deposit[1] / 1 finney;\n        InZone3 = deposit[2] / 1 finney;\n		info = 'Deposit for each zones, in finney. Surpus are always refunded.';\n    }\n\n    function LookAtPrizes() constant returns(uint FirstPrize,uint SecondPrize,uint LooserPrize, string info) {\n		FirstPrize=first_prize;\n		SecondPrize=second_prize;\n		LooserPrize=third_prize;\n	\n		info = 'Prizes in percent of the deposit';\n    }\n	\n	function GamblerPerAddress(address addr) constant returns(uint Bets, uint Deposited, uint PaidOut, string info) {\n		Bets      = gamblers[addr].bets;\n		Deposited = gamblers[addr].deposits / 1 finney;\n		PaidOut   = gamblers[addr].paid / 1 finney;\n		info ='Bets is the number of time you participated, no matter the zone.';\n	}\n	\n    function LookAtNumberOfPlayers() constant returns(uint InZone1,uint InZone2,uint InZone3, string info) {\n        InZone1 = nb_player[0];\n        InZone2 = nb_player[1];\n        InZone3 = nb_player[2];\n		\n		info = 'Players in a round, in each zones.';\n    }\n    //----------- Contract management functions -------------------------\n    \n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n	\n	\n    function ModifyFeeFraction(uint new_fee) onlyowner {\n		if( new_fee>=0 && new_fee<=20 ){ //admin can only set the fee percentage between 0 and 2%, initially 1%\n			feesThousandth = new_fee;\n		}\n    }\n    \n    //function to modify settings, only if no player in a round !\n    function ModifySettings(uint new_time_max, uint new_first_prize, uint new_second_prize, uint new_third_prize,\n                            uint deposit_1,uint deposit_2,uint deposit_3) onlyowner {\n        if(nb_player[0]!=0 || nb_player[1]!=0 || nb_player[2]!=0 ) throw; //can only modify if nobody plays !\n        \n        if(new_time_max>=(1 * 60 * 60) && new_time_max<=(24 * 60 * 60) ) time_max=new_time_max;\n		\n		if((new_first_prize+new_second_prize+new_third_prize)==300){ //the total must be distributed in a correct way\n			if(new_first_prize>=130 && new_first_prize<=190){			\n				first_prize=new_first_prize;\n				if(new_second_prize>100 && new_second_prize<=130){\n					second_prize=new_second_prize;\n					if(new_third_prize>=0 && new_third_prize<=50) third_prize=new_third_prize;\n				}\n			}\n        }\n        if(deposit_1>=(1 finney) && deposit_1<(1 ether)) deposit[0]=deposit_1;\n        if(deposit_2>=(1 ether) && deposit_2<(5 ether)) deposit[1]=deposit_2;\n        if(deposit_3>=(5 ether) && deposit_3<=(20 ether)) deposit[2]=deposit_3;\n        \n    }\n    \n    function CollectAllFees() onlyowner { //it just send fees, that's all folks !\n        if (fees == 0) throw;\n        admin.send(fees);\n        fees = this.balance -Balance[0]-Balance[1]-Balance[2]; //just in case there is lost ethers.\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ギャンブル機能を実装している。
1397553,0x89d64bc7e46bdc49a89652ae9bb167418cbad62e,true,false,"/*\n  live: 0x89d64bc7e46bdc49a89652ae9bb167418cbad62e\nmorden: 0xe379e36671acbcc87ec7b760c07e6e45a1294944\n  solc: v0.3.1-2016-04-12-3ad5e82 (optimization)\n*/\n\ncontract tokenRecipient {\n    function receiveApproval(address _from, uint256 _value, address _token);\n}\n\ncontract Token {\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    function totalSupply() constant returns (uint256 supply);\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _value) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n    function approve(address _spender, uint256 _value) returns (bool success);\n    function approveAndCall(address _spender, uint256 _value) returns (bool success);\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n}\n\ncontract SafeAddSub {\n    function safeToAdd(uint a, uint b) internal returns (bool) {\n        return (a + b > a);\n    }\n\n    function safeToSubtract(uint a, uint b) internal returns (bool) {\n        return (a >= b);\n    }\n\n    function safeAdd(uint a, uint b) internal returns (uint256) {\n        if (!safeToAdd(a, b)) throw;\n        return a + b;\n    }\n\n    function safeSubtract(uint a, uint b) internal returns (uint256) {\n        if (!safeToSubtract(a, b)) throw;\n        return a - b;\n    }\n}\n\ncontract EthToken is Token, SafeAddSub {\n    string public constant name = ""Ether Token Proxy"";\n    string public constant symbol = ""ETH"";\n    uint8   public constant decimals = 18;\n    uint256 public constant baseUnit = 10**18;\n    \n    mapping (address => uint256) _balanceOf;\n    mapping (address => mapping (address => uint256)) _allowance;\n\n    event Deposit(address indexed owner, uint256 amount);\n    event Withdrawal(address indexed owner, uint256 amount);\n\n    function totalSupply() constant returns (uint256 supply) {\n        return this.balance;\n    }\n    \n    function () {\n        deposit();\n    }\n    \n    function deposit() {\n        _balanceOf[msg.sender] = safeAdd(_balanceOf[msg.sender], msg.value);\n        Deposit(msg.sender, msg.value);\n    }\n    \n    function redeem() {\n        withdraw(_balanceOf[msg.sender]);\n    }\n    \n    function withdraw(uint256 _value) returns (bool success) {\n        _balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);\n        if (!msg.sender.send(_value)) {\n            if (!msg.sender.call.gas(msg.gas).value(_value)()) throw;\n        }\n        Withdrawal(msg.sender, _value);\n        return true;\n    }\n    \n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return _balanceOf[_owner];\n    }\n    \n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (_to == address(this) || _to == 0) {\n            return withdraw(_value);\n        } else {\n            _balanceOf[msg.sender] = safeSubtract(_balanceOf[msg.sender], _value);\n            _balanceOf[_to] = safeAdd(_balanceOf[_to], _value);\n            Transfer(msg.sender, _to, _value);\n        }\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (!safeToSubtract(_allowance[_from][msg.sender], _value)) throw;\n        if (_to == address(this) || _to == 0) {\n            if (!transferFrom(_from, msg.sender, _value)) throw;\n            withdraw(_value);\n        } else {\n            _balanceOf[_from] = safeSubtract(_balanceOf[_from], _value);\n            _balanceOf[_to] = safeAdd(_balanceOf[_to], _value);\n            _allowance[_from][msg.sender] = safeSubtract(_allowance[_from][msg.sender], _value);\n            Transfer(_from, _to, _value);\n        }\n        return true;\n    }\n    \n    function approve(address _spender, uint256 _value) returns (bool success) {\n        _allowance[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    \n    function approveAndCall(address _spender, uint256 _value) returns (bool success) {\n        if (approve(_spender, _value)) {\n            tokenRecipient(_spender).receiveApproval(msg.sender, _value, this);\n            return true;\n        }\n        throw;\n    }\n    \n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return _allowance[_owner][_spender];\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1397716,0xbe69b8093ca446c97aa2c5ea4746d793fb86c89d,false,false,"contract RipplePayExample {\n\nmapping(address => mapping(address => uint)) TrustSettings; // store trustLines for a given address\n\nfunction updateTrustSettings(address _peer, uint newTrustLimit) {\nTrustSettings[msg.sender][_peer] = newTrustLimit;\n}\n\nfunction getTrustSetting(address _peer) returns(uint) {\nreturn TrustSettings[msg.sender][_peer];\n}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1397899,0xc1ce17303ef35c128b499ed091f39008b3a57389,false,false,"contract GameRegistry {\n\n    // This struct keeps all data for a Record.\n    struct Record {\n        // Keeps the address of this record creator.\n        address owner;\n        // Keeps the time when this record was created.\n        uint time;\n        // Keeps the index of the keys array for fast lookup\n        uint keysIndex;\n        string description;\n        string url;\n    }\n\n    // This mapping keeps the records of this Registry.\n    mapping(address => Record) records;\n\n    // Keeps the total numbers of records in this Registry.\n    uint public numRecords;\n\n    // Keeps a list of all keys to interate the recoreds.\n    address[] private keys;\n\n    // The owner of this registry.\n    address owner;\n\n    uint public REGISTRATION_COST = 100 finney;\n    uint public TRANSFER_COST = 10 finney;\n    uint public VALUE_DISTRIBUTION_KEY_OWNERS = 50;\n\n    // Constructor\n    function GameRegistry() {\n        owner = msg.sender;\n    }\n\n    function distributeValue() {\n        if (msg.value == 0) {\n            return;\n        }\n        uint ownerPercentage = 100 - VALUE_DISTRIBUTION_KEY_OWNERS;\n        uint valueForRegOwner = (ownerPercentage * msg.value) / 100;\n        owner.send(valueForRegOwner);\n        uint valueForEachOwner = (msg.value - valueForRegOwner) / numRecords;\n        if (valueForEachOwner <= 0) {\n            return;\n        }\n        for (uint k = 0; k < numRecords; k++) {\n            records[keys[k]].owner.send(valueForEachOwner);\n        }\n    }\n\n    // This is the function that actually inserts a record. \n    function register(address key, string description, string url) {\n        // Only allow registration if received value >= REGISTRATION_COST\n        if (msg.value < REGISTRATION_COST) {\n            // Return value back to sender.\n            if (msg.value > 0) {\n                msg.sender.send(msg.value);\n            }\n            return;\n        }\n        distributeValue();\n        if (records[key].time == 0) {\n            records[key].time = now;\n            records[key].owner = msg.sender;\n            records[key].keysIndex = keys.length;\n            keys.length++;\n            keys[keys.length - 1] = key;\n            records[key].description = description;\n            records[key].url = url;\n\n            numRecords++;\n        }\n    }\n\n    // Updates the values of the given record.\n    function update(address key, string description, string url) {\n        // Only the owner can update his record.\n        if (records[key].owner == msg.sender) {\n            records[key].description = description;\n            records[key].url = url;\n        }\n    }\n\n    // Unregister a given record\n    function unregister(address key) {\n        if (records[key].owner == msg.sender) {\n            uint keysIndex = records[key].keysIndex;\n            delete records[key];\n            numRecords--;\n            keys[keysIndex] = keys[keys.length - 1];\n            records[keys[keysIndex]].keysIndex = keysIndex;\n            keys.length--;\n        }\n    }\n\n    // Transfer ownership of a given record.\n    function transfer(address key, address newOwner) {\n        // Only allow transfer if received value >= TRANSFER_COST\n        if (msg.value < TRANSFER_COST) {\n            // Return value back to sender\n            if (msg.value > 0) {\n                msg.sender.send(msg.value);\n            }\n            return;\n        }\n        distributeValue();\n        if (records[key].owner == msg.sender) {\n            records[key].owner = newOwner;\n        }\n    }\n\n    // Tells whether a given key is registered.\n    function isRegistered(address key) returns(bool) {\n        return records[key].time != 0;\n    }\n\n    function getRecordAtIndex(uint rindex) returns(address key, address owner, uint time, string description, string url) {\n        Record record = records[keys[rindex]];\n        key = keys[rindex];\n        owner = record.owner;\n        time = record.time;\n        description = record.description;\n        url = record.url;\n    }\n\n    function getRecord(address key) returns(address owner, uint time, string description, string url) {\n        Record record = records[key];\n        owner = record.owner;\n        time = record.time;\n        description = record.description;\n        url = record.url;\n    }\n\n    // Returns the owner of the given record. The owner could also be get\n    // by using the function getRecord but in that case all record attributes \n    // are returned.\n    function getOwner(address key) returns(address) {\n        return records[key].owner;\n    }\n\n    // Returns the registration time of the given record. The time could also\n    // be get by using the function getRecord but in that case all record attributes\n    // are returned.\n    function getTime(address key) returns(uint) {\n        return records[key].time;\n    }\n\n    // Returns the total number of records in this registry.\n    function getTotalRecords() returns(uint) {\n        return numRecords;\n    }\n\n    // This function is used by subcontracts when an error is detected and\n    // the value needs to be returned to the transaction originator.\n    function returnValue() internal {\n        if (msg.value > 0) {\n            msg.sender.send(msg.value);\n        }\n    }\n\n    // Registry owner can use this function to withdraw any value owned by\n    // the registry.\n    function withdraw(uint value) {\n        if (msg.sender == owner) {\n            msg.sender.send(value);\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1398069,0xb071e5c53094cabb971e98eba3b1a86be555c943,false,false,"contract IOU {\n    address owner;\n\n/* Public variables of the token */\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    \n/* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n\n/* This generates a public event on the blockchain that will notify clients */\nevent Transfer(address indexed from, address indexed to, uint256 value);\n\n    function IOU(string tokenName, string tokenSymbol, uint8 decimalUnits) {\n        owner = msg.sender;                                 // sets main RipplePay contract as owner\n        name = tokenName;                                       // Set the name for display purposes     \n        symbol = tokenSymbol;                                     // Set the symbol for display purposes    \n        decimals = decimalUnits;                                       // Amount of decimals for display purposes        \n    \n    }\n    \n    /* update balances so they display in ethereum-wallet */\n    function transfer(address _from, address _to, uint256 _value) {\n        if(msg.sender != owner) throw;                       // can only be invoked by main RipplePay contract\n        balanceOf[_from] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n    \n}\n\n\n\ncontract RipplePayMain {\n\nmapping(string => address) currencies;\n\nfunction newCurrency(string currencyName, string currencySymbol, uint8 decimalUnits){\ncurrencies[currencySymbol] = new IOU(currencyName, currencySymbol, decimalUnits);\n}\n\nfunction issueIOU(string _currency, uint256 _amount, address _to){\n    // update creditLines in main contract, then update balances in IOU contract to display in ethereum-wallet\n    IOU(currencies[_currency]).transfer(msg.sender, _to, _amount);\n\n}\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1398161,0xad87e48d553c2308dccab428537f6d0809593ba4,false,false,"contract GameRegistry {\n\n    // This struct keeps all data for a Record.\n    struct Record {\n        // Keeps the address of this record creator.\n        address owner;\n        // Keeps the time when this record was created.\n        uint time;\n        // Keeps the index of the keys array for fast lookup\n        uint keysIndex;\n        string description;\n        string url;\n    }\n\n    // This mapping keeps the records of this Registry.\n    mapping(address => Record) private records;\n\n    // Keeps the total numbers of records in this Registry.\n    uint private numRecords;\n\n    // Keeps a list of all keys to interate the recoreds.\n    address[] private keys;\n\n    // The owner of this registry.\n    address private owner;\n\n    uint private KEY_HOLDER_SHARE  = 50;\n    uint private REGISTRATION_COST = 500 finney;\n    uint private TRANSFER_COST     = 0;\n\n    // Constructor\n    function GameRegistry() {\n        owner = msg.sender;\n    }\n    \n    // public interface to the directory of games\n    function theGames(uint rindex) constant returns(address contractAddress, string description, string url, address submittedBy, uint time) {\n        Record record = records[keys[rindex]];\n        contractAddress = keys[rindex];\n        description = record.description;\n        url = record.url;\n        submittedBy = record.owner;\n        time = record.time;\n    }\n\n    function settings() constant public returns(uint registrationCost, uint percentSharedWithKeyHolders) {\n        registrationCost            = REGISTRATION_COST / 1 finney;\n        percentSharedWithKeyHolders = KEY_HOLDER_SHARE;\n    }\n\n    function distributeValue() private {\n        if (msg.value == 0) {\n            return;\n        }\n        // share value with all key holders\n        uint ownerPercentage  = 100 - KEY_HOLDER_SHARE;\n        uint valueForRegOwner = (ownerPercentage * msg.value) / 100;\n        owner.send(valueForRegOwner);\n        uint valueForEachOwner = (msg.value - valueForRegOwner) / numRecords;\n        if (valueForEachOwner <= 0) {\n            return;\n        }\n        for (uint k = 0; k < numRecords; k++) {\n            records[keys[k]].owner.send(valueForEachOwner);\n        }\n    }\n\n    // This is the function that actually inserts a record. \n    function addGame(address key, string description, string url) {\n        // Only allow registration if received value >= REGISTRATION_COST\n        if (msg.value < REGISTRATION_COST) {\n            // Return value back to sender.\n            if (msg.value > 0) {\n                msg.sender.send(msg.value);\n            }\n            return;\n        }\n        distributeValue();\n        if (records[key].time == 0) {\n            records[key].time = now;\n            records[key].owner = msg.sender;\n            records[key].keysIndex = keys.length;\n            keys.length++;\n            keys[keys.length - 1] = key;\n            records[key].description = description;\n            records[key].url = url;\n\n            numRecords++;\n        }\n    }\n\n    function () { distributeValue(); }\n\n    // Updates the values of the given record.\n    function update(address key, string description, string url) {\n        // Only the owner can update his record.\n        if (records[key].owner == msg.sender) {\n            records[key].description = description;\n            records[key].url = url;\n        }\n    }\n\n/*\n    // Transfer ownership of a given record.\n    function transfer(address key, address newOwner) {\n        // Only allow transfer if received value >= TRANSFER_COST\n        if (msg.value < TRANSFER_COST) {\n            // Return value back to sender\n            if (msg.value > 0) {\n                msg.sender.send(msg.value);\n            }\n            return;\n        }\n        distributeValue();\n        if (records[key].owner == msg.sender) {\n            records[key].owner = newOwner;\n        }\n    }\n*/\n\n    // Tells whether a given key is registered.\n    function isRegistered(address key) private constant returns(bool) {\n        return records[key].time != 0;\n    }\n\n    function getRecord(address key) private constant returns(address owner, uint time, string description, string url) {\n        Record record = records[key];\n        owner = record.owner;\n        time = record.time;\n        description = record.description;\n        url = record.url;\n    }\n\n    // Returns the owner of the given record. The owner could also be get\n    // by using the function getRecord but in that case all record attributes \n    // are returned.\n    function getOwner(address key) private constant returns(address) {\n        return records[key].owner;\n    }\n\n    // Returns the registration time of the given record. The time could also\n    // be get by using the function getRecord but in that case all record attributes\n    // are returned.\n    function getTime(address key) private constant returns(uint) {\n        return records[key].time;\n    }\n\n    // Registry owner can use this function to withdraw any surplus value owned by\n    // the registry.\n    function maintain(uint value, uint cost) {\n        if (msg.sender == owner) {\n            msg.sender.send(value);\n            REGISTRATION_COST = cost;\n        }\n    }\n\n    // Returns the total number of records in this registry.\n    function getTotalRecords() private constant returns(uint) {\n        return numRecords;\n    }\n\n    // This function is used by subcontracts when an error is detected and\n    // the value needs to be returned to the transaction originator.\n    function returnValue() internal {\n        if (msg.value > 0) {\n            msg.sender.send(msg.value);\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1401298,0xc357a046c5c13bb4e6d918a208b8b4a0ab2f2efd,false,false,"///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Welcome to EthFactory!\n//\n// Multiply your Ether by +15% !!\n//\n// NO MINIMUM DEPOSIT !!\n//\n// NO HOUSE FEES !!\n//\n// Everyone gets paid in the line! After somebody has been paid, he is removed and the next person is in line for payment !\n//\n// Invest now, and you will Earn back 115%, which is your [Invested Ether] + [15% Profit] !\n//\n// Multiply your ETH Now !\n//\n///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Start\n\ncontract EthFactory{\n\n  struct InvestorArray { address EtherAddress; uint Amount; }\n  InvestorArray[] public depositors;\n\n///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Variables\n\n  uint public Total_Investors=0;\n  uint public Balance = 0;\n  uint public Total_Deposited=0;\n  uint public Total_Paid_Out=0;\n  string public Message=""Welcome Investor! Multiply your ETH Now!"";\n  address public owner;\n  modifier manager { if (msg.sender == owner) _ }\n  function EthFactory() {owner = msg.sender;}\n  function() { enter(); }\n  \n///[][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][][]Enter\n\n  function enter() {\n    if (msg.value > 0) {\n\n    uint Amount=msg.value;								//set amount to how much the investor deposited\n    Total_Investors=depositors.length+1;   					 //count investors\n    depositors.length += 1;                        						//increase array lenght\n    depositors[depositors.length-1].EtherAddress = msg.sender; //add net investor's address\n    depositors[depositors.length-1].Amount = Amount;          //add net investor's amount\n    Balance += Amount;               						// balance update\n    Total_Deposited+=Amount;       						//update deposited Amount\n    uint payment; uint index=0;\n\n    while (Balance > (depositors[index].Amount * 115/100) && index<Total_Investors)\n     {\n	if(depositors[index].Amount!=0 )\n	{\n      payment = depositors[index].Amount *115/100;                           //calculate pay out\n      depositors[index].EtherAddress.send(payment);                        //send pay out to investor\n      Balance -= depositors[index].Amount *115/100;                         //balance update\n      Total_Paid_Out += depositors[index].Amount *115/100;           //update paid out amount   \n       depositors[index].Amount=0;                                    //remove investor from the game after he is paid out! He must invest again if he wants to earn more!\n	}break;\n      }\n  }\n}\nfunction DeleteContract() manager { owner.send(Balance); Balance=0; }\n\n}",1,実用的な構造で、投資ゲームを実装した標準的なスマートコントラクト。
1406267,0xb97768a8e31789dbece1403694e53c2142c3d706,false,false,"contract BlockChainEnterprise {\n    uint private BlockBalance = 0; //block balance (0 to BlockSize eth)\n    uint private NumberOfBlockMined = 0;\n    uint private BlockReward = 0;\n    uint private BlockSize =  10 ether; //a block is size 10 ETH, and with 1.2 multiplier it is paid 12 ETH\n    uint private MaxDeposit = 5 ether;\n    uint private multiplier = 1200; // Multiplier\n    uint private fees = 0;      //Fees are just verly low : 1% !\n    uint private feeFrac = 5;  //Fraction for fees in ""thousandth"" --> only 0.5% !!\n    uint private RewardFrac = 30;  //Fraction for Reward in ""thousandth""\n    uint private Payout_id = 0;\n    address private admin;\n\n    function BlockChainEnterprise() {\n        admin = msg.sender;\n    }\n\n    modifier onlyowner {if (msg.sender == admin) _  }\n\n    struct Miner {\n        address addr;\n        uint payout;\n        bool paid;\n    }\n\n    Miner[] private miners;\n\n    //--Fallback function\n    function() {\n        init();\n    }\n\n    //--initiated function\n    function init() private {\n        uint256 new_deposit=msg.value;\n        //------ Verifications on this new deposit ------\n        if (new_deposit < 100 finney) { //only >0.1 eth participation accepted\n            msg.sender.send(new_deposit);\n            return;\n        }\n\n        if( new_deposit > MaxDeposit ){\n            msg.sender.send( msg.value - MaxDeposit );\n            new_deposit= MaxDeposit;\n        }\n        //-- enter the block ! --\n        Participate(new_deposit);\n    }\n\n    function Participate(uint deposit) private {\n        if( BlockSize  < (deposit + BlockBalance) ){ //if this new deposit is part of 2 blocks\n            uint256 fragment = BlockSize - BlockBalance;\n            miners.push(Miner(msg.sender, fragment*multiplier/1000 , false)); //fill the block\n            miners.push(Miner(msg.sender, (deposit - fragment)*multiplier/1000  , false)); //contruct the next one\n        } else {\n            miners.push(Miner(msg.sender, deposit*multiplier/1000 , false)); // add this new miner in the block !\n        }\n\n        //--- UPDATING CONTRACT STATS ----\n        BlockReward += (deposit * RewardFrac) / 1000; // take some to reward the winner that make the whole block mined !\n        fees += (deposit * feeFrac) / 1000;          // collect small fee\n        BlockBalance += (deposit * (1000 - ( feeFrac + RewardFrac ))) / 1000; //update balance\n\n        //Mine the block first if possible !\n        if( BlockBalance >= (BlockSize/1000*multiplier) ){// it can be mined now !\n            PayMiners();\n            PayWinnerMiner(msg.sender,deposit);\n        }\n    }\n\n    function PayMiners() private {\n        NumberOfBlockMined +=1;\n        //Classic payout of all participants of the block\n        while ( miners[Payout_id].payout!=0 && BlockBalance >= ( miners[Payout_id].payout )  ) {\n            miners[Payout_id].addr.send(miners[Payout_id].payout); //pay the man !\n\n            BlockBalance -= miners[Payout_id].payout; //update the balance\n            miners[Payout_id].paid=true;\n\n            Payout_id += 1;\n        }\n    }\n\n    function  PayWinnerMiner(address winner, uint256 deposit) private{ //pay the winner accordingly to his deposit !\n        //Globally, EVERYONE CAN WIN by being smart and quick.\n        if(deposit >= 1 ether){ //only 1 ether, and you get it all !\n            winner.send(BlockReward);\n            BlockReward =0;\n        } else { // deposit is between 0.1 and 0.99 ether\n            uint256 pcent = deposit / 10 finney;\n            winner.send(BlockReward*pcent/100);\n            BlockReward -= BlockReward*pcent/100;\n        }\n    }\n\n    //---Contract management functions\n    function ChangeOwnership(address _owner) onlyowner {\n        admin = _owner;\n    }\n\n    function CollectAllFees() onlyowner {\n        if (fees == 0) throw;\n        admin.send(fees);\n        fees = 0;\n    }\n\n    function GetAndReduceFeesByFraction(uint p) onlyowner {\n        if (fees == 0) feeFrac=feeFrac*80/100; //Reduce fees.\n        admin.send(fees / 1000 * p);//send a percent of fees\n        fees -= fees / 1000 * p;\n    }\n\n    //---Contract informations\n    function WatchBalance() constant returns(uint TotalBalance, string info) {\n        TotalBalance = BlockBalance /  1 finney;\n        info ='Balance in finney';\n    }\n\n    function WatchBlockSizeInEther() constant returns(uint BlockSizeInEther, string info) {\n        BlockSizeInEther = BlockSize / 1 ether;\n        info ='Balance in ether';\n    }\n\n    function WatchNextBlockReward() constant returns(uint Reward, string info) {\n        Reward = BlockReward / 1 finney;\n        info ='Current reward collected. The reward when a block is mined is always BlockSize*RewardPercentage/100';\n    }\n\n    function NumberOfMiners() constant returns(uint NumberOfMiners, string info) {\n        NumberOfMiners = miners.length;\n        info ='Number of participations since the beginning of this wonderful blockchain';\n    }\n    function WatchCurrentMultiplier() constant returns(uint Mult, string info) {\n        Mult = multiplier;\n        info ='Current multiplier';\n    }\n\n    function NumberOfBlockAlreadyMined() constant returns(uint NumberOfBlockMinedAlready, string info) {\n        NumberOfBlockMinedAlready = NumberOfBlockMined;\n        info ='A block mined is a payout of size BlockSize, multiply this number and you get the sum of all payouts.';\n    }\n\n    function AmountToForgeTheNextBlock() constant returns(uint ToDeposit, string info) {\n        ToDeposit = ( ( (BlockSize/1000*multiplier) - BlockBalance)*(1000 - ( feeFrac + RewardFrac ))/1000) / 1 finney;\n        info ='This amount in finney in finney required to complete the current block, and to MINE it (trigger the payout).';\n    }\n\n    function PlayerInfo(uint id) constant returns(address Address, uint Payout, bool UserPaid) {\n        if (id <= miners.length) {\n            Address = miners[id].addr;\n            Payout = (miners[id].payout) / 1 finney;\n            UserPaid=miners[id].paid;\n        }\n    }\n\n    function WatchCollectedFeesInSzabo() constant returns(uint CollectedFees) {\n        CollectedFees = fees / 1 szabo;\n    }\n\n    function NumberOfCurrentBlockMiners() constant returns(uint QueueSize, string info) {\n        QueueSize = miners.length - Payout_id;\n        info ='Number of participations in the current block.';\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1409121,0xe0b7927c4af23765cb51314a0e0521a9645f0e2a,true,false,"/// @title DigixDAO Contract Interfaces\n\ncontract ConfigInterface {\n        address public owner;\n        mapping(address => bool) admins;\n        mapping(bytes32 => address) addressMap;\n        mapping(bytes32 => bool) boolMap;\n        mapping(bytes32 => bytes32) bytesMap;\n        mapping(bytes32 => uint256) uintMap;\n\n        /// @notice setConfigAddress sets configuration `_key` to `_val`\n        /// @param _key The key name of the configuration.\n        /// @param _val The value of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function setConfigAddress(bytes32 _key, address _val) returns(bool success);\n\n        /// @notice setConfigBool sets configuration `_key` to `_val`\n        /// @param _key The key name of the configuration.\n        /// @param _val The value of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function setConfigBool(bytes32 _key, bool _val) returns(bool success);\n\n        /// @notice setConfigBytes sets configuration `_key` to `_val`\n        /// @param _key The key name of the configuration.\n        /// @param _val The value of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function setConfigBytes(bytes32 _key, bytes32 _val) returns(bool success);\n\n        /// @notice setConfigUint `_key` to `_val`\n        /// @param _key The key name of the configuration.\n        /// @param _val The value of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function setConfigUint(bytes32 _key, uint256 _val) returns(bool success);\n\n        /// @notice getConfigAddress gets configuration `_key`'s value\n        /// @param _key The key name of the configuration.\n        /// @return The configuration value\n        function getConfigAddress(bytes32 _key) returns(address val);\n\n        /// @notice getConfigBool gets configuration `_key`'s value\n        /// @param _key The key name of the configuration.\n        /// @return The configuration value\n        function getConfigBool(bytes32 _key) returns(bool val);\n\n        /// @notice getConfigBytes gets configuration `_key`'s value\n        /// @param _key The key name of the configuration.\n        /// @return The configuration value\n        function getConfigBytes(bytes32 _key) returns(bytes32 val);\n\n        /// @notice getConfigUint gets configuration `_key`'s value\n        /// @param _key The key name of the configuration.\n        /// @return The configuration value\n        function getConfigUint(bytes32 _key) returns(uint256 val);\n\n        /// @notice addAdmin sets `_admin` as configuration admin\n        /// @return Whether the configuration setting was successful or not.\n        function addAdmin(address _admin) returns(bool success);\n\n        /// @notice removeAdmin removes  `_admin`'s rights\n        /// @param _admin The key name of the configuration.\n        /// @return Whether the configuration setting was successful or not.\n        function removeAdmin(address _admin) returns(bool success);\n\n}\n\ncontract TokenInterface {\n\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowed;\n        mapping(address => bool) seller;\n\n        address config;\n        address owner;\n        address dao;\n        address public badgeLedger;\n        bool locked;\n\n        /// @return total amount of tokens\n        uint256 public totalSupply;\n\n        /// @param _owner The address from which the balance will be retrieved\n        /// @return The balance\n        function balanceOf(address _owner) constant returns(uint256 balance);\n\n        /// @notice send `_value` tokens to `_to` from `msg.sender`\n        /// @param _to The address of the recipient\n        /// @param _value The amount of tokens to be transfered\n        /// @return Whether the transfer was successful or not\n        function transfer(address _to, uint256 _value) returns(bool success);\n\n        /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n        /// @param _from The address of the sender\n        /// @param _to The address of the recipient\n        /// @param _value The amount of tokens to be transfered\n        /// @return Whether the transfer was successful or not\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success);\n\n        /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n        /// @param _spender The address of the account able to transfer the tokens\n        /// @param _value The amount of tokens to be approved for transfer\n        /// @return Whether the approval was successful or not\n        function approve(address _spender, uint256 _value) returns(bool success);\n\n        /// @param _owner The address of the account owning tokens\n        /// @param _spender The address of the account able to transfer the tokens\n        /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining);\n\n        /// @notice mint `_amount` of tokens to `_owner`\n        /// @param _owner The address of the account receiving the tokens\n        /// @param _amount The amount of tokens to mint\n        /// @return Whether or not minting was successful\n        function mint(address _owner, uint256 _amount) returns(bool success);\n\n        /// @notice mintBadge Mint `_amount` badges to `_owner`\n        /// @param _owner The address of the account receiving the tokens\n        /// @param _amount The amount of tokens to mint\n        /// @return Whether or not minting was successful\n        function mintBadge(address _owner, uint256 _amount) returns(bool success);\n\n        function registerDao(address _dao) returns(bool success);\n\n        function registerSeller(address _tokensales) returns(bool success);\n\n        event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);\n        event Mint(address indexed _recipient, uint256 indexed _amount);\n        event Approval(address indexed _owner, address indexed _spender, uint256 indexed _value);\n}\n\ncontract TokenSalesInterface {\n\n        struct SaleProxy {\n                address payout;\n                bool isProxy;\n        }\n\n        struct SaleStatus {\n                bool founderClaim;\n                uint256 releasedTokens;\n                uint256 releasedBadges;\n                uint256 claimers;\n        }\n\n        struct Info {\n                uint256 totalWei;\n                uint256 totalCents;\n                uint256 realCents;\n                uint256 amount;\n        }\n\n        struct SaleConfig {\n                uint256 startDate;\n                uint256 periodTwo;\n                uint256 periodThree;\n                uint256 endDate;\n                uint256 goal;\n                uint256 cap;\n                uint256 badgeCost;\n                uint256 founderAmount;\n                address founderWallet;\n        }\n\n        struct Buyer {\n                uint256 centsTotal;\n                uint256 weiTotal;\n                bool claimed;\n        }\n\n        Info saleInfo;\n        SaleConfig saleConfig;\n        SaleStatus saleStatus;\n\n        address config;\n        address owner;\n        bool locked;\n\n        uint256 public ethToCents;\n\n        mapping(address => Buyer) buyers;\n        mapping(address => SaleProxy) proxies;\n\n        /// @notice Calculates the parts per billion 1⁄1,000,000,000 of `_a` to `_b`\n        /// @param _a The antecedent\n        /// @param _c The consequent\n        /// @return Part per billion value\n        function ppb(uint256 _a, uint256 _c) public constant returns(uint256 b);\n\n\n        /// @notice Calculates the share from `_total` based on `_contrib`\n        /// @param _contrib The contributed amount in USD\n        /// @param _total The total amount raised in USD\n        /// @return Total number of shares\n        function calcShare(uint256 _contrib, uint256 _total) public constant returns(uint256 share);\n\n        /// @notice Calculates the current USD cents value of `_wei`\n        /// @param _wei the amount of wei\n        /// @return The USD cents value\n        function weiToCents(uint256 _wei) public constant returns(uint256 centsvalue);\n\n        function proxyPurchase(address _user) returns(bool success);\n\n        /// @notice Send msg.value purchase for _user.\n        /// @param _user The account to be credited\n        /// @return Success if purchase was accepted\n        function purchase(address _user, uint256 _amount) private returns(bool success);\n\n        /// @notice Get crowdsale information for `_user`\n        /// @param _user The account to be queried\n        /// @return `centstotal` the total amount of USD cents contributed\n        /// @return `weitotal` the total amount in wei contributed\n        /// @return `share` the current token shares earned\n        /// @return `badges` the number of proposer badges earned\n        /// @return `claimed` is true if the tokens and badges have been claimed\n        function userInfo(address _user) public constant returns(uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed);\n\n        /// @notice Get the crowdsale information from msg.sender (see userInfo)\n        function myInfo() public constant returns(uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed);\n\n        /// @notice get the total amount of wei raised for the crowdsale\n        /// @return The amount of wei raised\n        function totalWei() public constant returns(uint);\n\n        /// @notice get the total USD value in cents raised for the crowdsale\n        /// @return the amount USD cents\n        function totalCents() public constant returns(uint);\n\n        /// @notice get the current crowdsale information\n        /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n        /// @return `two` The unix timestamp for the start of the second period modifier\n        /// @return `three` The unix timestamp for the start of the third period modifier\n        /// @return `endsale` The unix timestamp of the end of crowdsale\n        /// @return `totalwei` The total amount of wei raised\n        /// @return `totalcents` The total number of USD cents raised\n        /// @return `amount` The amount of DGD tokens available for the crowdsale\n        /// @return `goal` The USD value goal for the crowdsale\n        /// @return `famount` Founders endowment\n        /// @return `faddress` Founder wallet address\n        /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n\n        function claimFor(address _user) returns(bool success);\n\n        /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n        function claim() returns(bool success);\n\n        function claimFounders() returns(bool success);\n\n        /// @notice See if the crowdsale goal has been reached\n        function goalReached() public constant returns(bool reached);\n\n        /// @notice Get the current sale period\n        /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n        function getPeriod() public constant returns(uint saleperiod);\n\n        /// @notice Get the date for the start of the crowdsale\n        /// @return `date` The unix timestamp for the start\n        function startDate() public constant returns(uint date);\n\n        /// @notice Get the date for the second reward period of the crowdsale\n        /// @return `date` The unix timestamp for the second period\n        function periodTwo() public constant returns(uint date);\n\n        /// @notice Get the date for the final period of the crowdsale\n        /// @return `date` The unix timestamp for the final period\n        function periodThree() public constant returns(uint date);\n\n        /// @notice Get the date for the end of the crowdsale\n        /// @return `date` The unix timestamp for the end of the crowdsale\n        function endDate() public constant returns(uint date);\n\n        /// @notice Check if crowdsale has ended\n        /// @return `ended` If the crowdsale has ended\n\n        function isEnded() public constant returns(bool ended);\n\n        /// @notice Send raised funds from the crowdsale to the DAO\n        /// @return `success` if the send succeeded\n        function sendFunds() public returns(bool success);\n\n        //function regProxy(address _payment, address _payout) returns (bool success);\n        function regProxy(address _payout) returns(bool success);\n\n        function getProxy(address _payout) public returns(address proxy);\n\n        function getPayout(address _proxy) public returns(address payout, bool isproxy);\n\n        function unlock() public returns(bool success);\n\n        function getSaleStatus() public constant returns(bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n\n        function getSaleInfo() public constant returns(uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n\n        function getSaleConfig() public constant returns(uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n\n        event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n        event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n\n}\n\ncontract Badge {\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowed;\n\n        address public owner;\n        bool public locked;\n\n        /// @return total amount of tokens\n        uint256 public totalSupply;\n\n        modifier ifOwner() {\n                if (msg.sender != owner) {\n                        throw;\n                } else {\n                        _\n                }\n        }\n\n\n        event Transfer(address indexed _from, address indexed _to, uint256 _value);\n        event Mint(address indexed _recipient, uint256 indexed _amount);\n        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n        function Badge() {\n                owner = msg.sender;\n        }\n\n        function safeToAdd(uint a, uint b) returns(bool) {\n                return (a + b >= a);\n        }\n\n        function addSafely(uint a, uint b) returns(uint result) {\n                if (!safeToAdd(a, b)) {\n                        throw;\n                } else {\n                        result = a + b;\n                        return result;\n                }\n        }\n\n        function safeToSubtract(uint a, uint b) returns(bool) {\n                return (b <= a);\n        }\n\n        function subtractSafely(uint a, uint b) returns(uint) {\n                if (!safeToSubtract(a, b)) throw;\n                return a - b;\n        }\n\n        function balanceOf(address _owner) constant returns(uint256 balance) {\n                return balances[_owner];\n        }\n\n        function transfer(address _to, uint256 _value) returns(bool success) {\n                if (balances[msg.sender] >= _value && _value > 0) {\n                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\n                        balances[_to] = addSafely(_value, balances[_to]);\n                        Transfer(msg.sender, _to, _value);\n                        success = true;\n                } else {\n                        success = false;\n                }\n                return success;\n        }\n\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n                if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n                        balances[_to] = addSafely(balances[_to], _value);\n                        balances[_from] = subtractSafely(balances[_from], _value);\n                        allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\n                        Transfer(_from, _to, _value);\n                        return true;\n                } else {\n                        return false;\n                }\n        }\n\n        function approve(address _spender, uint256 _value) returns(bool success) {\n                allowed[msg.sender][_spender] = _value;\n                Approval(msg.sender, _spender, _value);\n                success = true;\n                return success;\n        }\n\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n                remaining = allowed[_owner][_spender];\n                return remaining;\n        }\n\n        function mint(address _owner, uint256 _amount) ifOwner returns(bool success) {\n                totalSupply = addSafely(totalSupply, _amount);\n                balances[_owner] = addSafely(balances[_owner], _amount);\n                Mint(_owner, _amount);\n                return true;\n        }\n\n        function setOwner(address _owner) ifOwner returns(bool success) {\n                owner = _owner;\n                return true;\n        }\n\n}\n\ncontract Token {\n\n        address public owner;\n        address public config;\n        bool public locked;\n        address public dao;\n        address public badgeLedger;\n        uint256 public totalSupply;\n\n        mapping(address => uint256) balances;\n        mapping(address => mapping(address => uint256)) allowed;\n        mapping(address => bool) seller;\n\n        /// @return total amount of tokens\n\n        modifier ifSales() {\n                if (!seller[msg.sender]) throw;\n                _\n        }\n\n        modifier ifOwner() {\n                if (msg.sender != owner) throw;\n                _\n        }\n\n        modifier ifDao() {\n                if (msg.sender != dao) throw;\n                _\n        }\n\n        event Transfer(address indexed _from, address indexed _to, uint256 _value);\n        event Mint(address indexed _recipient, uint256 _amount);\n        event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n        function Token(address _config) {\n                config = _config;\n                owner = msg.sender;\n                address _initseller = ConfigInterface(_config).getConfigAddress(""sale1:address"");\n                seller[_initseller] = true;\n                badgeLedger = new Badge();\n                locked = false;\n        }\n\n        function safeToAdd(uint a, uint b) returns(bool) {\n                return (a + b >= a);\n        }\n\n        function addSafely(uint a, uint b) returns(uint result) {\n                if (!safeToAdd(a, b)) {\n                        throw;\n                } else {\n                        result = a + b;\n                        return result;\n                }\n        }\n\n        function safeToSubtract(uint a, uint b) returns(bool) {\n                return (b <= a);\n        }\n\n        function subtractSafely(uint a, uint b) returns(uint) {\n                if (!safeToSubtract(a, b)) throw;\n                return a - b;\n        }\n\n        function balanceOf(address _owner) constant returns(uint256 balance) {\n                return balances[_owner];\n        }\n\n        function transfer(address _to, uint256 _value) returns(bool success) {\n                if (balances[msg.sender] >= _value && _value > 0) {\n                        balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\n                        balances[_to] = addSafely(balances[_to], _value);\n                        Transfer(msg.sender, _to, _value);\n                        success = true;\n                } else {\n                        success = false;\n                }\n                return success;\n        }\n\n        function transferFrom(address _from, address _to, uint256 _value) returns(bool success) {\n                if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n                        balances[_to] = addSafely(balances[_to], _value);\n                        balances[_from] = subtractSafely(balances[_from], _value);\n                        allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\n                        Transfer(_from, _to, _value);\n                        return true;\n                } else {\n                        return false;\n                }\n        }\n\n        function approve(address _spender, uint256 _value) returns(bool success) {\n                allowed[msg.sender][_spender] = _value;\n                Approval(msg.sender, _spender, _value);\n                success = true;\n                return success;\n        }\n\n        function allowance(address _owner, address _spender) constant returns(uint256 remaining) {\n                remaining = allowed[_owner][_spender];\n                return remaining;\n        }\n\n        function mint(address _owner, uint256 _amount) ifSales returns(bool success) {\n                totalSupply = addSafely(_amount, totalSupply);\n                balances[_owner] = addSafely(balances[_owner], _amount);\n                return true;\n        }\n\n        function mintBadge(address _owner, uint256 _amount) ifSales returns(bool success) {\n                if (!Badge(badgeLedger).mint(_owner, _amount)) return false;\n                return true;\n        }\n\n        function registerDao(address _dao) ifOwner returns(bool success) {\n                if (locked == true) return false;\n                dao = _dao;\n                locked = true;\n                return true;\n        }\n\n        function setDao(address _newdao) ifDao returns(bool success) {\n                dao = _newdao;\n                return true;\n        }\n\n        function isSeller(address _query) returns(bool isseller) {\n                return seller[_query];\n        }\n\n        function registerSeller(address _tokensales) ifDao returns(bool success) {\n                seller[_tokensales] = true;\n                return true;\n        }\n\n        function unregisterSeller(address _tokensales) ifDao returns(bool success) {\n                seller[_tokensales] = false;\n                return true;\n        }\n\n        function setOwner(address _newowner) ifDao returns(bool success) {\n                if (Badge(badgeLedger).setOwner(_newowner)) {\n                        owner = _newowner;\n                        success = true;\n                } else {\n                        success = false;\n                }\n                return success;\n        }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1409121,0x54bda709fed875224eae569bb6817d96ef7ed9ad,true,false,"/// @title DigixDAO Contract Interfaces\n\ncontract ConfigInterface {\n  address public owner;\n  mapping (address => bool) admins;\n  mapping (bytes32 => address) addressMap;\n  mapping (bytes32 => bool) boolMap;\n  mapping (bytes32 => bytes32) bytesMap;\n  mapping (bytes32 => uint256) uintMap;\n\n  /// @notice setConfigAddress sets configuration `_key` to `_val` \n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigAddress(bytes32 _key, address _val) returns (bool success);\n\n  /// @notice setConfigBool sets configuration `_key` to `_val` \n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigBool(bytes32 _key, bool _val) returns (bool success);\n\n  /// @notice setConfigBytes sets configuration `_key` to `_val`\n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigBytes(bytes32 _key, bytes32 _val) returns (bool success);\n\n  /// @notice setConfigUint `_key` to `_val`\n  /// @param _key The key name of the configuration.\n  /// @param _val The value of the configuration.\n  /// @return Whether the configuration setting was successful or not.\n  function setConfigUint(bytes32 _key, uint256 _val) returns (bool success);\n\n  /// @notice getConfigAddress gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigAddress(bytes32 _key) returns (address val);\n\n  /// @notice getConfigBool gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigBool(bytes32 _key) returns (bool val);\n\n  /// @notice getConfigBytes gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigBytes(bytes32 _key) returns (bytes32 val);\n\n  /// @notice getConfigUint gets configuration `_key`'s value\n  /// @param _key The key name of the configuration.\n  /// @return The configuration value \n  function getConfigUint(bytes32 _key) returns (uint256 val);\n\n  /// @notice addAdmin sets `_admin` as configuration admin\n  /// @return Whether the configuration setting was successful or not.  \n  function addAdmin(address _admin) returns (bool success);\n\n  /// @notice removeAdmin removes  `_admin`'s rights\n  /// @param _admin The key name of the configuration.\n  /// @return Whether the configuration setting was successful or not.  \n  function removeAdmin(address _admin) returns (bool success);\n\n}\n\ncontract TokenInterface {\n\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n  mapping (address => bool) seller;\n\n  address config;\n  address owner;\n  address dao;\n  address public badgeLedger;\n  bool locked;\n\n  /// @return total amount of tokens\n  uint256 public totalSupply;\n\n  /// @param _owner The address from which the balance will be retrieved\n  /// @return The balance\n  function balanceOf(address _owner) constant returns (uint256 balance);\n\n  /// @notice send `_value` tokens to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transfer(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n  /// @param _from The address of the sender\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @param _value The amount of tokens to be approved for transfer\n  /// @return Whether the approval was successful or not\n  function approve(address _spender, uint256 _value) returns (bool success);\n\n  /// @param _owner The address of the account owning tokens\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n  /// @notice mint `_amount` of tokens to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mint(address _owner, uint256 _amount) returns (bool success);\n\n  /// @notice mintBadge Mint `_amount` badges to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n\n  function registerDao(address _dao) returns (bool success);\n  function registerSeller(address _tokensales) returns (bool success);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _value);\n  event Mint(address indexed _recipient, uint256 indexed _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256 indexed _value);\n}\n\ncontract TokenSalesInterface {\n\n  struct SaleProxy {\n    address payout;\n    bool isProxy;\n  }\n\n  struct SaleStatus {\n    bool founderClaim;\n    uint256 releasedTokens;\n    uint256 releasedBadges;\n    uint256 claimers;\n  }\n\n  struct Info {\n    uint256 totalWei;\n    uint256 totalCents;\n    uint256 realCents;\n    uint256 amount;\n  }\n\n  struct SaleConfig {\n    uint256 startDate;\n    uint256 periodTwo;\n    uint256 periodThree;\n    uint256 endDate;\n    uint256 goal;\n    uint256 cap;\n    uint256 badgeCost;\n    uint256 founderAmount;\n    address founderWallet;\n  }\n\n  struct Buyer {\n    uint256 centsTotal;\n    uint256 weiTotal;\n    bool claimed;\n  }\n\n  Info saleInfo;\n  SaleConfig saleConfig;\n  SaleStatus saleStatus;\n\n  address config;\n  address owner;\n  bool locked;\n\n  uint256 public ethToCents;\n\n  mapping (address => Buyer) buyers;\n  mapping (address => SaleProxy) proxies;\n\n  /// @notice Calculates the parts per billion 1⁄1,000,000,000 of `_a` to `_b`\n  /// @param _a The antecedent\n  /// @param _c The consequent\n  /// @return Part per billion value\n  function ppb(uint256 _a, uint256 _c) public constant returns (uint256 b);\n\n\n  /// @notice Calculates the share from `_total` based on `_contrib` \n  /// @param _contrib The contributed amount in USD\n  /// @param _total The total amount raised in USD\n  /// @return Total number of shares\n  function calcShare(uint256 _contrib, uint256 _total) public constant returns (uint256 share);\n\n  /// @notice Calculates the current USD cents value of `_wei` \n  /// @param _wei the amount of wei\n  /// @return The USD cents value\n  function weiToCents(uint256 _wei) public constant returns (uint256 centsvalue);\n\n  function proxyPurchase(address _user) returns (bool success);\n\n  /// @notice Send msg.value purchase for _user.  \n  /// @param _user The account to be credited\n  /// @return Success if purchase was accepted\n  function purchase(address _user, uint256 _amount) private returns (bool success);\n\n  /// @notice Get crowdsale information for `_user`\n  /// @param _user The account to be queried\n  /// @return `centstotal` the total amount of USD cents contributed\n  /// @return `weitotal` the total amount in wei contributed\n  /// @return `share` the current token shares earned\n  /// @return `badges` the number of proposer badges earned\n  /// @return `claimed` is true if the tokens and badges have been claimed\n  function userInfo(address _user) public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n\n  /// @notice Get the crowdsale information from msg.sender (see userInfo)\n  function myInfo() public constant returns (uint256 centstotal, uint256 weitotal, uint256 share, uint badges, bool claimed); \n\n  /// @notice get the total amount of wei raised for the crowdsale\n  /// @return The amount of wei raised\n  function totalWei() public constant returns (uint);\n\n  /// @notice get the total USD value in cents raised for the crowdsale\n  /// @return the amount USD cents\n  function totalCents() public constant returns (uint);\n\n  /// @notice get the current crowdsale information\n  /// @return `startsale` The unix timestamp for the start of the crowdsale and the first period modifier\n  /// @return `two` The unix timestamp for the start of the second period modifier\n  /// @return `three` The unix timestamp for the start of the third period modifier\n  /// @return `endsale` The unix timestamp of the end of crowdsale\n  /// @return `totalwei` The total amount of wei raised\n  /// @return `totalcents` The total number of USD cents raised\n  /// @return `amount` The amount of DGD tokens available for the crowdsale\n  /// @return `goal` The USD value goal for the crowdsale\n  /// @return `famount` Founders endowment\n  /// @return `faddress` Founder wallet address\n  /*function getSaleInfo() public constant returns (uint256 startsale, uint256 two, uint256 three, uint256 endsale, uint256 totalwei, uint256 totalcents, uint256 amount, uint256 goal, uint256 famount, address faddress);*/\n\n  function claimFor(address _user) returns (bool success); \n\n  /// @notice Allows msg.sender to claim the DGD tokens and badges if the goal is reached or refunds the ETH contributed if goal is not reached at the end of the crowdsale\n  function claim() returns (bool success);\n\n  function claimFounders() returns (bool success);\n\n  /// @notice See if the crowdsale goal has been reached\n  function goalReached() public constant returns (bool reached);\n\n  /// @notice Get the current sale period\n  /// @return `saleperiod` 0 = Outside of the crowdsale period, 1 = First reward period, 2 = Second reward period, 3 = Final crowdsale period.\n  function getPeriod() public constant returns (uint saleperiod);\n\n  /// @notice Get the date for the start of the crowdsale\n  /// @return `date` The unix timestamp for the start\n  function startDate() public constant returns (uint date);\n  \n  /// @notice Get the date for the second reward period of the crowdsale\n  /// @return `date` The unix timestamp for the second period\n  function periodTwo() public constant returns (uint date);\n\n  /// @notice Get the date for the final period of the crowdsale\n  /// @return `date` The unix timestamp for the final period\n  function periodThree() public constant returns (uint date);\n\n  /// @notice Get the date for the end of the crowdsale\n  /// @return `date` The unix timestamp for the end of the crowdsale\n  function endDate() public constant returns (uint date);\n\n  /// @notice Check if crowdsale has ended\n  /// @return `ended` If the crowdsale has ended\n  \n  function isEnded() public constant returns (bool ended);\n\n  /// @notice Send raised funds from the crowdsale to the DAO\n  /// @return `success` if the send succeeded\n  function sendFunds() public returns (bool success);\n\n  //function regProxy(address _payment, address _payout) returns (bool success);\n  function regProxy(address _payout) returns (bool success);\n\n  function getProxy(address _payout) public returns (address proxy);\n  \n  function getPayout(address _proxy) public returns (address payout, bool isproxy);\n\n  function unlock() public returns (bool success);\n\n  function getSaleStatus() public constant returns (bool fclaim, uint256 reltokens, uint256 relbadges, uint256 claimers);\n\n  function getSaleInfo() public constant returns (uint256 weiamount, uint256 cents, uint256 realcents, uint256 amount);\n\n  function getSaleConfig() public constant returns (uint256 start, uint256 two, uint256 three, uint256 end, uint256 goal, uint256 cap, uint256 badgecost, uint256 famount, address fwallet);\n  \n  event Purchase(uint256 indexed _exchange, uint256 indexed _rate, uint256 indexed _cents);\n  event Claim(address indexed _user, uint256 indexed _amount, uint256 indexed _badges);\n\n}\n\n\ncontract Badge  {\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n\n  address public owner;\n  bool public locked;\n\n  /// @return total amount of tokens\n  uint256 public totalSupply;\n\n  modifier ifOwner() {\n    if (msg.sender != owner) {\n      throw;\n    } else {\n      _\n    }\n  }\n\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Mint(address indexed _recipient, uint256 indexed _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256  _value);\n\n  function Badge() {\n    owner = msg.sender;\n  }\n\n  function safeToAdd(uint a, uint b) returns (bool) {\n    return (a + b >= a);\n  }\n\n  function addSafely(uint a, uint b) returns (uint result) {\n    if (!safeToAdd(a, b)) {\n      throw;\n    } else {\n      result = a + b;\n      return result;\n    }\n  }\n\n  function safeToSubtract(uint a, uint b) returns (bool) {\n    return (b <= a);\n  }\n\n  function subtractSafely(uint a, uint b) returns (uint) {\n    if (!safeToSubtract(a, b)) throw;\n    return a - b;\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  function transfer(address _to, uint256 _value) returns (bool success) {\n    if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\n      balances[_to] = addSafely(_value, balances[_to]);\n      Transfer(msg.sender, _to, _value);\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] = addSafely(balances[_to], _value);\n      balances[_from] = subtractSafely(balances[_from], _value);\n      allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\n      Transfer(_from, _to, _value);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    success = true;\n    return success;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    remaining = allowed[_owner][_spender];\n    return remaining;\n  }\n\n  function mint(address _owner, uint256 _amount) ifOwner returns (bool success) {\n    totalSupply = addSafely(totalSupply, _amount);\n    balances[_owner] = addSafely(balances[_owner], _amount);\n    Mint(_owner, _amount);\n    return true;\n  }\n\n  function setOwner(address _owner) ifOwner returns (bool success) {\n    owner = _owner;\n    return true;\n  }\n\n}\n\ncontract Token {\n\n  address public owner;\n  address public config;\n  bool public locked;\n  address public dao;\n  address public badgeLedger;\n  uint256 public totalSupply;\n\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n  mapping (address => bool) seller;\n\n  /// @return total amount of tokens\n\n  modifier ifSales() {\n    if (!seller[msg.sender]) throw; \n    _ \n  }\n\n  modifier ifOwner() {\n    if (msg.sender != owner) throw;\n    _\n  }\n\n  modifier ifDao() {\n    if (msg.sender != dao) throw;\n    _\n  }\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event Mint(address indexed _recipient, uint256  _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256  _value);\n\n  function Token(address _config) {\n    config = _config;\n    owner = msg.sender;\n    address _initseller = ConfigInterface(_config).getConfigAddress(""sale1:address"");\n    seller[_initseller] = true; \n    badgeLedger = new Badge();\n    locked = false;\n  }\n\n  function safeToAdd(uint a, uint b) returns (bool) {\n    return (a + b >= a);\n  }\n\n  function addSafely(uint a, uint b) returns (uint result) {\n    if (!safeToAdd(a, b)) {\n      throw;\n    } else {\n      result = a + b;\n      return result;\n    }\n  }\n\n  function safeToSubtract(uint a, uint b) returns (bool) {\n    return (b <= a);\n  }\n\n  function subtractSafely(uint a, uint b) returns (uint) {\n    if (!safeToSubtract(a, b)) throw;\n    return a - b;\n  }\n\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  function transfer(address _to, uint256 _value) returns (bool success) {\n    if (balances[msg.sender] >= _value && _value > 0) {\n      balances[msg.sender] = subtractSafely(balances[msg.sender], _value);\n      balances[_to] = addSafely(balances[_to], _value);\n      Transfer(msg.sender, _to, _value);\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n      balances[_to] = addSafely(balances[_to], _value);\n      balances[_from] = subtractSafely(balances[_from], _value);\n      allowed[_from][msg.sender] = subtractSafely(allowed[_from][msg.sender], _value);\n      Transfer(_from, _to, _value);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  function approve(address _spender, uint256 _value) returns (bool success) {\n    allowed[msg.sender][_spender] = _value;\n    Approval(msg.sender, _spender, _value);\n    success = true;\n    return success;\n  }\n\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    remaining = allowed[_owner][_spender];\n    return remaining;\n  }\n  function mint(address _owner, uint256 _amount) ifSales returns (bool success) {\n    totalSupply = addSafely(_amount, totalSupply);\n    balances[_owner] = addSafely(balances[_owner], _amount);\n    return true;\n  }\n\n  function mintBadge(address _owner, uint256 _amount) ifSales returns (bool success) {\n    if (!Badge(badgeLedger).mint(_owner, _amount)) return false;\n    return true;\n  }\n\n  function registerDao(address _dao) ifOwner returns (bool success) {\n    if (locked == true) return false;\n    dao = _dao;\n    locked = true;\n    return true;\n  }\n\n  function setDao(address _newdao) ifDao returns (bool success) {\n    dao = _newdao;\n    return true;\n  }\n\n  function isSeller(address _query) returns (bool isseller) {\n    return seller[_query];\n  }\n\n  function registerSeller(address _tokensales) ifDao returns (bool success) {\n    seller[_tokensales] = true;\n    return true;\n  }\n\n  function unregisterSeller(address _tokensales) ifDao returns (bool success) {\n    seller[_tokensales] = false;\n    return true;\n  }\n\n  function setOwner(address _newowner) ifDao returns (bool success) {\n    if(Badge(badgeLedger).setOwner(_newowner)) {\n      owner = _newowner;\n      success = true;\n    } else {\n      success = false;\n    }\n    return success;\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1413512,0x25db0f59bf166c49d1f859c9cb5928cbbf685981,false,false,"contract EthDig\n{\n    uint constant LifeTime = 30;\n    \n    address Owner = msg.sender;\n    address OutputAddress = msg.sender;\n    \n    uint64 Coef1=723;\n    uint64 Coef2=41665;\n    uint64 Coef3=600000;\n    \n    uint public ContributedAmount;\n    uint ContributedLimit = 10 ether;\n    \n    uint public CashForHardwareReturn;\n    uint public FreezedCash;\n    \n    uint16 UsersLength = 0;\n    mapping (uint16 => User) Users;\n    struct User{\n        address Address;\n        uint16 ContributionsLength;\n        mapping (uint16 => Contribution) Contributions;\n    }\n    struct Contribution{\n        uint CashInHarware;\n        uint CashFreezed;\n        \n        uint16 ProfitPercent;\n        uint NeedPayByDay;\n        \n        bool ReuseCashInHarware;\n        \n        uint DateCreated;\n        uint DateLastCheck;\n        uint AlreadyPaid;\n        \n        bool ReturnedHardwareCash;\n        bool Finished;\n    }\n    \n    function  ContributeInternal(uint16 userId,uint cashInHarware,uint cashFreezed,bool reuseCashInHarware) private{\n        Contribution contribution = Users[userId].Contributions[Users[userId].ContributionsLength];\n\n        contribution.CashInHarware = cashInHarware;\n        contribution.CashFreezed = cashFreezed;\n        \n        uint8 noFreezCoef = uint8 ((cashInHarware * 100) / (cashFreezed+cashInHarware));\n        contribution.ProfitPercent = uint16 (((Coef1 * noFreezCoef * noFreezCoef) + (Coef2 * noFreezCoef) + Coef3)/10000);//10000\n        \n        contribution.NeedPayByDay = (((cashInHarware + cashFreezed) /10000) * contribution.ProfitPercent)/LifeTime;\n        contribution.ReuseCashInHarware = reuseCashInHarware;\n        contribution.DateCreated = now;\n        contribution.DateLastCheck = now;\n        \n        Users[userId].ContributionsLength++;\n    }\n    function ContributeWithSender (bool reuseCashInHarware,uint8 freezeCoeff,address sender) {\n        if (msg.value == 0 || freezeCoeff>100 ||ContributedAmount + msg.value > ContributedLimit)\n        {\n            sender.send(msg.value);\n            return;\n        }\n        \n        uint16 userId = GetUserIdByAddress(sender);\n        if (userId == 65535)\n        {\n            userId = UsersLength;\n            Users[userId].Address = sender;\n            UsersLength ++;\n        }\n        \n        uint cashFreezed = ((msg.value/100)*freezeCoeff);\n        ContributeInternal(\n            userId,\n            msg.value - cashFreezed,\n            cashFreezed,\n            reuseCashInHarware\n            );\n        FreezedCash += cashFreezed;\n        ContributedAmount += msg.value;\n        \n        OutputAddress.send(msg.value - cashFreezed);\n    }\n    function Contribute (bool reuseCashInHarware,uint8 freezeCoeff) {\n        ContributeWithSender(reuseCashInHarware,freezeCoeff,msg.sender);\n    }\n    function ChangeReuseCashInHarware(bool newValue,uint16 userId,uint16 contributionId){\n        if (msg.sender != Users[userId].Address) return;\n        Users[userId].Contributions[contributionId].ReuseCashInHarware = newValue;\n    }\n    \n    function Triger(){\n        if (Owner != msg.sender) return;\n        \n        uint MinedTillLastPayment = this.balance - CashForHardwareReturn - FreezedCash;\n        bool NotEnoughCash = false;\n        \n        for(uint16 i=0;i<UsersLength;i++)\n        {\n            for(uint16 j=0;j<Users[i].ContributionsLength;j++)\n            {\n                Contribution contribution = Users[i].Contributions[j];\n                if (contribution.Finished || now - contribution.DateLastCheck < 1 days) continue;\n                \n                if (contribution.AlreadyPaid != contribution.NeedPayByDay * LifeTime)\n                {\n                    uint8 daysToPay = uint8((now - contribution.DateCreated)/1 days);\n                    if (daysToPay>LifeTime) daysToPay = uint8(LifeTime);\n                    uint needToPay = (daysToPay * contribution.NeedPayByDay) - contribution.AlreadyPaid;\n                    \n                    if (MinedTillLastPayment < needToPay)\n                    {\n                        NotEnoughCash = true;\n                    }\n                    else\n                    {\n                        if (needToPay > 100 finney || daysToPay == LifeTime)\n                        {\n                            MinedTillLastPayment -= needToPay;\n                            Users[i].Address.send(needToPay);\n                            contribution.AlreadyPaid += needToPay;\n                        }\n                    }\n                    contribution.DateLastCheck = now;\n                }\n\n                if (now > contribution.DateCreated + (LifeTime * 1 days) && !contribution.ReturnedHardwareCash)\n                {\n                    if (contribution.ReuseCashInHarware)\n                    {\n                        ContributeInternal(\n                            i,\n                            contribution.CashInHarware,\n                            contribution.CashFreezed,\n                            true\n                        );\n                        contribution.ReturnedHardwareCash = true;\n                    }\n                    else\n                    {\n                        if (CashForHardwareReturn >= contribution.CashInHarware)\n                        {\n                            CashForHardwareReturn -= contribution.CashInHarware;\n                            FreezedCash -= contribution.CashFreezed;\n                            ContributedAmount -= contribution.CashFreezed + contribution.CashInHarware;\n                            Users[i].Address.send(contribution.CashInHarware + contribution.CashFreezed);\n                            contribution.ReturnedHardwareCash = true;\n                        }\n                    }\n                }\n                \n                if (contribution.ReturnedHardwareCash && contribution.AlreadyPaid == contribution.NeedPayByDay * LifeTime)\n                {\n                    contribution.Finished = true;\n                }\n            }  \n        }\n        \n        if (!NotEnoughCash)\n        {\n            OutputAddress.send(MinedTillLastPayment);\n        }\n    }\n    \n    function ConfigureFunction(address outputAddress,uint contributedLimit,uint16 coef1,uint16 coef2,uint16 coef3)\n    {\n        if (Owner != msg.sender) return;\n        OutputAddress = outputAddress;\n        ContributedLimit = contributedLimit;\n        Coef1 = coef1;\n        Coef2 = coef2;\n        Coef3 = coef3;\n    }\n    \n    function SendCashForHardwareReturn(){\n        CashForHardwareReturn += msg.value;\n    }\n    function WithdrawCashForHardwareReturn(uint amount){\n        if (Owner != msg.sender || CashForHardwareReturn < amount) return;\n        Owner.send(amount);\n    }\n    \n    function GetUserIdByAddress (address userAddress) returns (uint16){\n        for(uint16 i=0; i<UsersLength;i++)\n        {\n            if (Users[i].Address == userAddress)\n                return i;\n        }\n        return 65535;\n    }\n    \n    function GetContributionInfo (uint16 userId,uint16 contributionId) \n    returns (uint a1,uint a2, uint16 a3,uint a4, bool a5,uint a6,uint a7,uint a8,bool a9,bool a10,address a11) \n    {\n        Contribution contribution = Users[userId].Contributions[contributionId];\n        a1 = contribution.CashInHarware;\n        a2 = contribution.CashFreezed;\n        a3 = contribution.ProfitPercent;\n        a4 = contribution.NeedPayByDay;\n        a5 = contribution.ReuseCashInHarware;\n        a6 = contribution.DateCreated;\n        a7 = contribution.DateLastCheck;\n        a8 = contribution.AlreadyPaid;\n        a9 = contribution.ReturnedHardwareCash;\n        a10 = contribution.Finished;\n        a11 = Users[userId].Address;\n    }\n    \n}\n\ncontract EthDigProxy\n{\n    address Owner = msg.sender;\n    EthDig public ActiveDigger; \n    \n    function ChangeActiveDigger(address activeDiggerAddress){\n        if (msg.sender != Owner) return;\n        ActiveDigger =EthDig(activeDiggerAddress);\n    }\n    function GetMoney(){\n        if (msg.sender != Owner) return;\n        Owner.send(this.balance);\n    }\n    \n    function Contribute (bool reuseCashInHarware,uint8 freezeCoeff) {\n        ActiveDigger.ContributeWithSender.value(msg.value)(reuseCashInHarware,freezeCoeff,msg.sender);\n    }\n    function (){\n        ActiveDigger.ContributeWithSender.value(msg.value)(false,0,msg.sender);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1414638,0x6140d98c1bf9206488fc3428e2dc5496b0a23d84,false,false,"contract Matching_Finneys\n{\n    enum State{Active, Deactivated}\n    State public state;\n\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier onlyActive() {\n         if (state!=State.Active) throw;\n         _\n    }\n    modifier onlyInactive() {\n         if (state!=State.Deactivated) throw;\n         _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gamble_value) throw;\n        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\n	_\n    }\n    modifier resolvePendingRound{\n        blockLastPlayer=block.number+1;    \n        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\n	else if (pendingRound && blockLastPlayer==blockEndRound) throw;\n	_\n    }\n\n    uint blockLastPlayer;\n    address private owner;\n    uint gamble_value;\n    uint information_cost;\n    uint round_max_size ;\n    uint round_min_size  ;  \n    uint index_player;\n    uint index_round_ended;\n    uint index_player_in_round;\n    bool pendingRound = false;\n    uint blockEndRound;\n    struct Gamble  {\n	    address player;\n	    bool flipped;\n    }\n    Gamble[] matchers; \n    Gamble[] contrarians;\n    struct Result  {\n	    address player_matcher;\n	    bool flipped_matcher;\n	    uint256 payout_matcher;\n	    address player_contrarian;\n	    bool flipped_contrarian;\n	    uint256 payout_contrarian;\n    }\n    Result[] results; \n    mapping (address => uint) payout_history;\n    mapping (address => uint) times_played_history;    \n     \n    //Contract Construtor\n    function Matching_Ethers() { //Initial settings\n	    owner = msg.sender; \n	    round_min_size = 16;\n	    round_max_size = 20;\n	    information_cost= 500 szabo; //0.005 ether, 5 finney\n            gamble_value = 100000 szabo; //0.1 ether\n    }\n    //FallBack Function (play by sending a transaction)\n    function () { \n        bool flipped;\n        if (msg.value == gamble_value) flipped=false; \n        if (msg.value > gamble_value) {\n            flipped=true;\n        }\n        Play(flipped); \n    }\n    //Play Function (play by contract function call)\n    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\n        if ( index_player_in_round%2==0 ) {   //first is matcher\n	    matchers.push(Gamble(msg.sender, flipped));\n	}\n	else {\n	    contrarians.push(Gamble(msg.sender, flipped));\n	}\n        index_player+=1;\n        index_player_in_round+=1;\n	times_played_history[msg.sender]+=1;\n        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\n	            bool end = randomEnd();\n		    if (end) {\n		        pendingRound=true;\n			blockEndRound=block.number;}\n        }\n    }\n    //Random Number Generator (between 1 and range)\n    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\n        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\n    }\n    //Function that determines randomly when the round should be ended\n    function randomEnd() private returns(bool) {\n	if (index_player_in_round==round_max_size) return true; //end if max_size\n	else{\n	    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\n	    if (random==1) return true;\n	    else return false;\n	    }\n    }\n    //Function to end Round and pay winners\n    function endRound() private {\n        delete results;\n        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\n        uint256 payout_total;\n        for (var k = 0; k < (index_player_in_round)/2; k++) {\n            uint256 index_contrarian;\n	    if (k+random_start_contrarian<(index_player_in_round)/2){\n	        index_contrarian=k+random_start_contrarian;\n            }\n	    else{\n	        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\n	    }\n	    uint256 information_cost_matcher = information_cost * k;\n	    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\n	    uint256 information_cost_contrarian = information_cost * index_contrarian;\n	    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\n	    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\n	    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\n	        matchers[k].player.send(payout_matcher);\n		payout_total+=payout_matcher;\n		payout_history[matchers[k].player]+=payout_matcher;\n	    }\n	    else {\n	        contrarians[index_contrarian].player.send(payout_contrarian);\n		payout_total+=payout_contrarian;\n		payout_history[contrarians[k].player]+=payout_contrarian;\n	    }\n	}\n        index_round_ended+=1;\n        owner.send(index_player_in_round*gamble_value-payout_total);\n	payout_total=0;\n        index_player_in_round=0;\n        delete matchers;\n        delete contrarians;\n	pendingRound=false;\n	if (terminate_after_round==true) state=State.Deactivated;\n    }\n    //Full Refund of Current Round (if needed)\n    function refundRound() \n    onlyActive\n    onlyOwner noEthSent{  \n        uint totalRefund;\n	uint balanceBeforeRefund=this.balance;\n        for (var k = 0;  k< matchers.length; k++) {\n	            matchers[k].player.send(gamble_value);\n		    totalRefund+=gamble_value;\n        }\n        for (var j = 0;  j< contrarians.length ; j++) {	\n	            contrarians[j].player.send(gamble_value);\n		    totalRefund+=gamble_value;		    \n        }\n	delete matchers;\n	delete contrarians;\n	state=State.Deactivated;\n	index_player_in_round=0;\n	owner.send(balanceBeforeRefund-totalRefund);\n    }\n    //Function Pause contract after next round (for new contract or to change settings) \n    bool terminate_after_round=false;\n    function deactivate()\n    onlyOwner noEthSent{\n	    terminate_after_round=true;\n    }\n    //Function Reactivates contract (after change of settings for instance or a refound)\n    function reactivate()\n    onlyOwner noEthSent{\n        state=State.Active;\n        terminate_after_round=false;\n    }\n    //Function to change game settings (within limits)\n    //(to adapt to community feedback, popularity)\n    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\n	    onlyOwner\n	    onlyInactive noEthSent{\n	    if (new_max_round<new_min_round) throw;\n	    if (new_information_cost > new_gamble_value/100) throw;\n	    round_max_size = new_max_round;\n	    round_min_size = new_min_round;\n	    information_cost= new_information_cost;\n	    gamble_value = new_gamble_value;\n    }\n    function changeOwner(address new_owner)\n	    onlyOwner noEthSent{\n	    owner=new_owner;\n    }\n    \n\n    modifier noEthSent(){\n        if (msg.value>0) throw;\n	_\n    }\n    //desactiver l'envoi d'argent sur ces fonctions\n    //JSON GLOBAL STATS\n    function gameStats() noEthSent constant returns (uint _index_player_in_round, uint _index_player, uint _index_round_ended, bool _pendingRound, uint _blockEndRound, uint _blockLastPlayer, State _state, bool _terminate_after_round)\n    {\n         _index_player_in_round = index_player_in_round;\n	 _index_player = index_player;\n	 _index_round_ended = index_round_ended;\n	 _pendingRound = pendingRound;\n	 _blockEndRound = blockEndRound;\n	 _blockLastPlayer = blockLastPlayer;\n	 _state = state;\n	 _terminate_after_round = terminate_after_round;\n     }\n     //JSON CURRENT SETTINGS\n     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\n	 _gamble_value = gamble_value;\n	 _information_cost = information_cost;\n	 _round_min_size = round_min_size;\n	 _round_max_size = round_max_size;\n     }\n\n    //JSON MATCHER TEAM\n    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=matchers[_index].player;\n	_flipped = matchers[_index].flipped;\n    }\n    //JSON CONTRARIAN TEAM\n    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=contrarians[_index].player;\n	_flipped = contrarians[_index].flipped;\n    }\n    //return contrarians\n    //JSON LAST ROUND RESULT\n    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\n        _address_matcher=results[_index].player_matcher;\n        _address_contrarian=results[_index].player_contrarian;\n	_flipped_matcher = results[_index].flipped_matcher;\n	_flipped_contrarian = results[_index].flipped_contrarian;\n	_payout_matcher =  results[_index].payout_matcher;\n	_payout_contrarian =  results[_index].payout_contrarian;\n    }\n    //User set nickname for the website\n     mapping (address => string) nicknames;\n     function setNickname(string name) noEthSent{\n         if (bytes(name).length >= 2 && bytes(name).length <= 16)\n             nicknames[msg.sender] = name;\n     }\n     function getNickname(address _address) noEthSent constant returns(string _name) {\n             _name = nicknames[_address];\n     }\n\n     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\n             _payout = payout_history[_address]; \n     }\n     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\n             _count = times_played_history[_address]; \n     }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックに焦点を当てている。
1419472,0x83651a62b632c261442f396ad7202fe2a4995e3a,false,false,"contract LittleEthereumDoubler {\n//--------------------------------------------------USERS-----------------------------------------------------------\n    struct User {\n        address addr;\n        uint paidOut;\n        uint payoutLeft;\n    }\n    User[] private users;\n    uint private index;\n//--------------------------------------------------DEPLOYMENT AND FEES---------------------------------------------\n    address private feeAddress;\n\n    modifier execute { if (feeAddress == tx.origin) _ }\n    \n    function NewFeeAddress(address newFeeAddress) execute {\n        if (msg.value != 0) tx.origin.send(msg.value);\n        feeAddress = newFeeAddress;\n    }\n    \n    function LittleEthereumDoubler() {\n        feeAddress = tx.origin;\n    }\n//--------------------------------------------------CONTRACT--------------------------------------------------------\n    function() {\n        Start();\n    }\n    \n    function Start() internal {\n        uint a = msg.value;     // a = amount\n        a = DepositLimit(a);    // trim if too much, throw is too little\n        Fees(a);                // 2,5% fees goes to the fee address\n        NewDeposit(a);          // put user in the usersdatabase\n        Payout();               // pay out who is in the index\n    }\n    \n    function DepositLimit(uint a) internal returns (uint x){\n        x = a;\n        if (x < 100 finney) throw;\n        if (x > 50 ether) {\n            x = 50 ether;\n            tx.origin.send(a - x);\n        }\n    }\n    \n    function Fees(uint a) internal {\n        feeAddress.send(a * 25 / 1000);\n    }\n    \n    function NewDeposit(uint a) internal {\n        users.length++;\n        users[users.length - 1].addr = tx.origin;\n        users[users.length - 1].payoutLeft = a * 2;\n    }\n    \n    function Payout() internal {\n        while (this.balance != 0) {\n            if (users[index].payoutLeft > this.balance) {\n                users[index].payoutLeft -= this.balance;\n                users[index].paidOut += this.balance;\n                users[index].addr.send(this.balance);\n            }\n            else {\n                users[index].paidOut += users[index].payoutLeft;\n                users[index].addr.send(users[index].payoutLeft);\n                delete users[index].payoutLeft;\n                index++;\n            }\n        }\n    }\n//--------------------------------------------------MIST GUI--------------------------------------------------------\n    function UserDatabase(uint id) constant returns(address Address, uint Payout, uint PaidOut, uint PayoutLeft, string info) {\n        Address = users[id].addr;\n        PaidOut = users[id].paidOut / 100 finney;\n        PayoutLeft = users[id].payoutLeft / 100 finney;\n        Payout = (users[id].paidOut + users[id].payoutLeft) / 100 finney;\n        info = 'values are shown in a denomination of 100 finneys ( 100 finney = 0.1 ether = minimum input)';\n    }\n}",1,実用的な構造で、投資と支払いを管理する標準的なスマートコントラクトです。
1419516,0xdb9b3f9c12e710517ac572378c6199bc3624b1ed,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'         '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   MATCHING ETHERS                              \n//   a Strategy and Luck DaapGame          \n//   www.matching-ethers.com                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                       ***//\n// *** contact : reddit    /u/WhySoS3rious                                ***//\n\n//VERSION : 1.0\n\n// GAME MODE : MATCHING FINNEYS\n// STAKE : 0.1 ETH\n\n contract Matching_Finneys\n{\n    enum State{Active, Deactivated}\n    State public state;\n\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier onlyActive() {\n         if (state!=State.Active) throw;\n         _\n    }\n    modifier onlyInactive() {\n         if (state!=State.Deactivated) throw;\n         _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gamble_value) throw;\n        if (msg.value > gamble_value) msg.sender.send(msg.value-gamble_value);\n	_\n    }\n    modifier resolvePendingRound{\n        blockLastPlayer=block.number+1;    \n        if (pendingRound && blockLastPlayer!=blockEndRound ) endRound();\n	else if (pendingRound && blockLastPlayer==blockEndRound) throw;\n	_\n    }\n\n    uint blockLastPlayer;\n    address private owner;\n    uint gamble_value;\n    uint information_cost;\n    uint round_max_size ;\n    uint round_min_size  ;  \n    uint index_player;\n    uint index_round_ended;\n    uint index_player_in_round;\n    bool pendingRound = false;\n    uint blockEndRound;\n    struct Gamble  {\n	    address player;\n	    bool flipped;\n    }\n    Gamble[] matchers; \n    Gamble[] contrarians;\n    struct Result  {\n	    address player_matcher;\n	    bool flipped_matcher;\n	    uint256 payout_matcher;\n	    address player_contrarian;\n	    bool flipped_contrarian;\n	    uint256 payout_contrarian;\n    }\n    Result[] results; \n    mapping (address => uint) payout_history;\n    mapping (address => uint) times_played_history;    \n     \n    //Contract Construtor\n    function Matching_Ethers() { //Initial settings\n	    owner = msg.sender; \n	    round_min_size = 16;\n	    round_max_size = 20;\n	    information_cost= 500 szabo; //0.005 ether, 5 finney\n            gamble_value = 100000 szabo; //0.1 ether\n    }\n    //FallBack Function (play by sending a transaction)\n    function () { \n        bool flipped;\n        if (msg.value == gamble_value) flipped=false; \n        if (msg.value > gamble_value) {\n            flipped=true;\n        }\n        Play(flipped); \n    }\n    //Play Function (play by contract function call)\n    function Play(bool flipped) equalGambleValue onlyActive resolvePendingRound{\n        if ( index_player_in_round%2==0 ) {   //first is matcher\n	    matchers.push(Gamble(msg.sender, flipped));\n	}\n	else {\n	    contrarians.push(Gamble(msg.sender, flipped));\n	}\n        index_player+=1;\n        index_player_in_round+=1;\n	times_played_history[msg.sender]+=1;\n        if (index_player_in_round>=round_min_size && index_player_in_round%2==0) {\n	            bool end = randomEnd();\n		    if (end) {\n		        pendingRound=true;\n			blockEndRound=block.number;}\n        }\n    }\n    //Random Number Generator (between 1 and range)\n    function randomGen(uint seed, uint range) private constant returns (uint randomNumber) {\n        return(uint(sha3(block.blockhash(block.number-1), seed))%range+1);\n    }\n    //Function that determines randomly when the round should be ended\n    function randomEnd() private returns(bool) {\n	if (index_player_in_round==round_max_size) return true; //end if max_size\n	else{\n	    uint random = randomGen(index_player, (round_max_size-index_player_in_round)/2+1);\n	    if (random==1) return true;\n	    else return false;\n	    }\n    }\n    //Function to end Round and pay winners\n    function endRound() private {\n        delete results;\n        uint256 random_start_contrarian = randomGen(index_player,(index_player_in_round)/2)-1;\n        uint256 payout_total;\n        for (var k = 0; k < (index_player_in_round)/2; k++) {\n            uint256 index_contrarian;\n	    if (k+random_start_contrarian<(index_player_in_round)/2){\n	        index_contrarian=k+random_start_contrarian;\n            }\n	    else{\n	        index_contrarian=(k+random_start_contrarian)-(index_player_in_round/2);\n	    }\n	    uint256 information_cost_matcher = information_cost * k;\n	    uint256 payout_matcher = 2*(gamble_value-information_cost_matcher);\n	    uint256 information_cost_contrarian = information_cost * index_contrarian;\n	    uint256 payout_contrarian = 2*(gamble_value-information_cost_contrarian);\n	    results.push(Result(matchers[k].player,matchers[k].flipped,payout_matcher,contrarians[index_contrarian].player,contrarians[index_contrarian].flipped, payout_contrarian));\n	    if (matchers[k].flipped == contrarians[index_contrarian].flipped) {\n	        matchers[k].player.send(payout_matcher);\n		payout_total+=payout_matcher;\n		payout_history[matchers[k].player]+=payout_matcher;\n	    }\n	    else {\n	        contrarians[index_contrarian].player.send(payout_contrarian);\n		payout_total+=payout_contrarian;\n		payout_history[contrarians[k].player]+=payout_contrarian;\n	    }\n	}\n        index_round_ended+=1;\n        owner.send(index_player_in_round*gamble_value-payout_total);\n	payout_total=0;\n        index_player_in_round=0;\n        delete matchers;\n        delete contrarians;\n	pendingRound=false;\n	if (terminate_after_round==true) state=State.Deactivated;\n    }\n    //Full Refund of Current Round (if needed)\n    function refundRound() \n    onlyActive\n    onlyOwner noEthSent{  \n        uint totalRefund;\n	uint balanceBeforeRefund=this.balance;\n        for (var k = 0;  k< matchers.length; k++) {\n	            matchers[k].player.send(gamble_value);\n		    totalRefund+=gamble_value;\n        }\n        for (var j = 0;  j< contrarians.length ; j++) {	\n	            contrarians[j].player.send(gamble_value);\n		    totalRefund+=gamble_value;		    \n        }\n	delete matchers;\n	delete contrarians;\n	state=State.Deactivated;\n	index_player_in_round=0;\n        uint balanceLeft = balanceBeforeRefund-totalRefund;\n	if (balanceLeft >0) owner.send(balanceLeft);\n    }\n    //Function Pause contract after next round (for new contract or to change settings) \n    bool terminate_after_round=false;\n    function deactivate()\n    onlyOwner noEthSent{\n	    terminate_after_round=true;\n    }\n    //Function Reactivates contract (after change of settings for instance or a refound)\n    function reactivate()\n    onlyOwner noEthSent{\n        state=State.Active;\n        terminate_after_round=false;\n    }\n    //Function to change game settings (within limits)\n    //(to adapt to community feedback, popularity)\n    function config(uint new_max_round, uint new_min_round, uint new_information_cost, uint new_gamble_value)\n	    onlyOwner\n	    onlyInactive noEthSent{\n	    if (new_max_round<new_min_round) throw;\n	    if (new_information_cost > new_gamble_value/100) throw;\n	    round_max_size = new_max_round;\n	    round_min_size = new_min_round;\n	    information_cost= new_information_cost;\n	    gamble_value = new_gamble_value;\n    }\n    function changeOwner(address new_owner)\n	    onlyOwner noEthSent{\n	    owner=new_owner;\n    }\n    \n\n    modifier noEthSent(){\n        if (msg.value>0) throw;\n	_\n    }\n    //JSON GLOBAL STATS\n    function gameStats() noEthSent constant returns (uint number_of_player_in_round, uint total_number_of_player, uint number_of_round_ended, bool pending_round_to_resolve, uint block_end_last_round, uint block_last_player, State state, bool pause_contract_after_round)\n    {\n         number_of_player_in_round = index_player_in_round;\n	 total_number_of_player = index_player;\n	 number_of_round_ended = index_round_ended;\n	 pending_round_to_resolve = pendingRound;\n	 block_end_last_round = blockEndRound;\n	 block_last_player = blockLastPlayer;\n	 state = state;\n	 pause_contract_after_round = terminate_after_round;\n     }\n     //JSON CURRENT SETTINGS\n     function gameSettings() noEthSent constant returns (uint _gamble_value, uint _information_cost, uint _round_min_size, uint _round_max_size) {\n	 _gamble_value = gamble_value;\n	 _information_cost = information_cost;\n	 _round_min_size = round_min_size;\n	 _round_max_size = round_max_size;\n     }\n\n    //JSON MATCHER TEAM\n    function getMatchers_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=matchers[_index].player;\n	_flipped = matchers[_index].flipped;\n    }\n    //JSON CONTRARIAN TEAM\n    function getContrarians_by_index(uint _index) noEthSent constant returns (address _address, bool _flipped) {\n        _address=contrarians[_index].player;\n	_flipped = contrarians[_index].flipped;\n    }\n    //JSON LAST ROUND RESULT\n    function getLastRoundResults_by_index(uint _index) noEthSent constant returns (address _address_matcher, address _address_contrarian, bool _flipped_matcher, bool _flipped_contrarian, uint _payout_matcher, uint _payout_contrarian) {\n        _address_matcher=results[_index].player_matcher;\n        _address_contrarian=results[_index].player_contrarian;\n	_flipped_matcher = results[_index].flipped_matcher;\n	_flipped_contrarian = results[_index].flipped_contrarian;\n	_payout_matcher =  results[_index].payout_matcher;\n	_payout_contrarian =  results[_index].payout_contrarian;\n    }\n    //User set nickname for the website\n     mapping (address => string) nicknames;\n     function setNickname(string name) noEthSent{\n         if (bytes(name).length >= 2 && bytes(name).length <= 16)\n             nicknames[msg.sender] = name;\n     }\n     function getNickname(address _address) noEthSent constant returns(string _name) {\n             _name = nicknames[_address];\n     }\n     //JSON HISTORY\n     function historyPayout(address _address) noEthSent constant returns(uint _payout) {\n             _payout = payout_history[_address]; \n     }\n     function historyTimesPlayed(address _address) noEthSent constant returns(uint _count) {\n             _count = times_played_history[_address]; \n     }\n\n}",2,アスキーアートとコメントが詩的要素を加え、ゲーム性が芸術的な印象を与えます。
1429615,0xf4cae4aec9b4d7682f8cee4d9a273ba063e71366,false,false,"contract EtherTopDog {\n\n	// fund for bailing out underdogs when they are pushed out\n	uint private bailoutBalance = 0;\n\n\n	// === Underdog Payin Distribution: ===\n	\n	// percent of underdog deposit amount to go in bailout fund\n	uint constant private bailoutFundPercent = 70;\n\n	// percent of underdog deposit that goes to the top dog's dividend\n	uint constant private topDogDividend = 15;\n\n	// percent of underdog deposit sent chip away top dog's strength\n	uint constant private topDogDecayPercent = 10;\n\n	// percent of underdog deposiot that goes to lucky dog's dividend\n	uint constant private luckyDogDividend = 3;\n\n	// vision dog takes a small fee from each underdog deposit\n	uint constant private visionDogFeePercent = 2;\n\n	// === === === === === === === === ===\n\n	\n	// percentage markup from payin for calculating new mininum TopDog price threshold\n	uint constant private topDogMinMarkup = 125;\n\n	// minimum required deposit to become the next Top Dog\n	// (aka Top Dog strength / lowest possible takeover threshold)\n	// starts at 125% of Top Dog's deposit, slowly declines as underdogs join\n	uint private topDogMinPrice = 1;\n\n	// range above the topdog strength (aka topDogMinPrice) within which\n	// the randomly generated required takeover threhold is set\n	uint constant private topDogBuyoutRange = 150;\n\n	// percentage of topdog buyout fee gets paid to creator\n	uint constant private visionDogBuyPercent = 5;\n\n\n\n	// underdog payout markup, as a percentage of their deposits\n	// gets reset to 150% after each round when the top dog gets replaced\n	// gradually decays to mininum of 120% as underdogs chip away at top dog's strength\n	uint private underDogMarkup = 150;\n\n	// as top dog price declines, these keep track of the range\n	// so underDopMarkup can slowly go from 150% to 120% return\n	// as the Top Dog mininum price starts at the price ceiling,\n	// and declines until it reaches the floor (or lower)\n	uint private topDogPriceCeiling = 0;\n	uint private topDogPriceFloor = 0;\n\n	// total collected fees from underdogs, paid out whenever Top Dog is bought out\n	uint private visionFees = 0;\n\n	// current top dog\n	address private topDog = 0x0;\n\n	// underdog entries\n	struct Underdog {\n		address addr;\n		uint deposit;\n		uint payout;\n		uint bailouts;\n	}\n	Underdog[] private Underdogs;\n\n	// player names for fun\n	mapping (address => string) dogNames;\n\n	// current lucky dog (if exists) will receive 3% of underdog payins\n	// specified as index in Underdogs array\n	// 0 = nobody (the very first underdog to join the game is precluded from becoming the Lucky Dog)\n	uint private luckyDog = 0;\n\n	// index of next underdog to be paid \n	uint private payoutIndex = 0;\n\n	// count payouts made by underdogs currently in the game\n	// so we can have a baseline for dividing the scraps\n	uint private payoutCount = 0;\n\n	// address of the creator\n	address private visionDog;\n\n	function EtherTopDog() {\n		visionDog = msg.sender;\n	}\n\n\n	// ==== Game Info Display ABI functions: ====\n	function underdogPayoutFund() public constant returns (uint balance) {\n		balance = bailoutBalance;\n	}\n\n	function nextUnderdogPayout() public constant returns (uint) {\n		if (Underdogs.length - payoutIndex >= 1) {\n			return Underdogs[payoutIndex].payout;\n		}\n	}\n	\n\n	function underdogPayoutMarkup() public constant returns (uint) {\n		return underDogMarkup;\n	}\n\n	function topDogInfo() public constant returns (string name, uint strength) {\n		if (topDog != address(0x0)) {\n			name = getDogName(topDog);\n		} else {\n			name = ""[not set]"";\n		}\n		strength = topDogMinPrice;\n	}\n	function luckyDogInfo() public constant returns (string name) {\n		if (luckyDog > 0) {\n			name = getDogName(Underdogs[luckyDog].addr);\n		} else {\n			name = ""[nobody]"";\n		}\n	}\n\n	function underdogCount() constant returns (uint) {\n		return Underdogs.length - payoutIndex;\n	} \n\n	function underdogInfo(uint linePosition) constant returns (string name, address dogAddress, uint deposit, uint payout, uint scrapBonus) {\n		if (linePosition > 0 && linePosition <= Underdogs.length - payoutIndex) {\n\n			Underdog thedog = Underdogs[payoutIndex + (linePosition - 1)];\n			name = getDogName(thedog.addr);\n			dogAddress = thedog.addr;\n			deposit = thedog.deposit;\n			payout= thedog.payout;\n			scrapBonus = thedog.bailouts;\n		}\n	}\n\n	// ==== End ABI Functions ====\n\n\n\n	// ==== Public transaction functions: ====\n\n	// default fallback : play a round\n	function() {\n		dogFight();\n	}\n	\n	// sets name, optionally plays a round if Ether was sent\n	function setName(string DogName) {\n		if (bytes(DogName).length >= 2 && bytes(DogName).length <= 16)\n			dogNames[msg.sender] = DogName;\n\n		// if a deposit was sent, play it!\n		if (msg.value > 0) {\n			dogFight();\n		}\n		\n	}\n\n	function dogFight() public {\n		// minimum 1 ETH required to play\n		if (msg.value < 1 ether) {\n			msg.sender.send(msg.value);\n			return;\n		}\n\n		// does a topdog exist ?\n		if (topDog != address(0x0)) {\n\n			// the actual amount required to knock out the top dig is random within the buyout range\n			uint topDogPrice = topDogMinPrice + randInt( (topDogMinPrice * topDogBuyoutRange / 100) - topDogMinPrice, 4321);\n\n			// Calculate the top dog price\n			if (msg.value >= topDogPrice) {\n				// They bought out the top dog!\n				buyTopDog(topDogPrice, msg.value - topDogPrice);\n			} else {\n				// didn't buy the top dog, this participant becomes an underdog!\n				addUnderDog(msg.value);\n			}\n		} else {\n			// no top dog exists yet, the game must be just getting started\n			// put the first deposit in the bailout fund, initialize the game\n\n			// set first topDog \n			topDog = msg.sender;\n\n			topDogPriceFloor = topDogMinPrice;\n\n			bailoutBalance += msg.value;\n			topDogMinPrice = msg.value * topDogMinMarkup / 100;\n\n			topDogPriceCeiling = topDogMinPrice;\n\n		}\n	}\n\n	// ==== End Public Functions ====\n\n\n\n	// ==== Private Functions: ====\n	function addUnderDog(uint buyin) private {\n\n		uint bailcount = 0;\n\n		// amount this depositor will be paid when the fund allows\n		uint payoutval = buyin * underDogMarkup / 100;\n\n		// add portion of deposit to bailout fund \n		bailoutBalance += buyin * bailoutFundPercent / 100;\n\n		// top dog / lucky dog dividends\n		uint topdividend = buyin * topDogDividend / 100;\n		uint luckydividend = buyin * luckyDogDividend / 100;\n\n		// is there a lucky dog?\n		if (luckyDog != 0 && luckyDog >= payoutIndex) {\n			// pay lucky dog dividends\n			Underdogs[luckyDog].addr.send(luckydividend);\n		} else {\n			// no lucky dog exists, all dividends go to top dog\n			topdividend += luckydividend;\n		}\n\n		// pay top dog dividends\n		topDog.send(topdividend);\n\n\n		// chip away at the top dog's strength\n		uint topdecay = (buyin * topDogDecayPercent / 100);\n		topDogMinPrice -= topdecay;\n\n		// update underdog markup % for next round\n\n		// specified as n/100000 to avoid floating point math\n		uint decayfactor = 0;\n\n		// calculate the payout markup for next underdog\n		if (topDogMinPrice > topDogPriceFloor) {\n			uint decayrange = (topDogPriceCeiling - topDogPriceFloor);\n			decayfactor = 100000 * (topDogPriceCeiling - topDogMinPrice) / decayrange;\n		} else {\n			decayfactor = 100000;\n		}\n		// markup will be between 120-150% corresponding to current top dog price decline (150% - 30% = 120%)\n		underDogMarkup = 150 - (decayfactor * 30 / 100000);\n\n\n\n		// creator takes a slice\n		visionFees += (buyin * visionDogFeePercent / 100);\n		\n\n		// payout as many previous underdogs as the fund can afford\n		while (payoutIndex < Underdogs.length && bailoutBalance >= Underdogs[payoutIndex].payout ) {\n			payoutCount -= Underdogs[payoutIndex].bailouts;\n			bailoutBalance -= Underdogs[payoutIndex].payout;\n			Underdogs[payoutIndex].addr.send(Underdogs[payoutIndex].payout);\n\n\n			// if the lucky dog was bailed out, the user who did it now becomes the lucky dog\n			if (payoutIndex == luckyDog && luckyDog != 0)\n				luckyDog = Underdogs.length;\n\n			payoutIndex++;\n			bailcount++;\n			payoutCount++;\n		}\n\n		\n		// add the new underdog to the queue\n		Underdogs.push(Underdog(msg.sender, buyin, payoutval, bailcount));\n\n	}\n\n	function buyTopDog(uint buyprice, uint surplus) private {\n\n		// take out vizionDog fee\n		uint vfee = buyprice * visionDogBuyPercent / 100;\n\n		uint dogpayoff = (buyprice - vfee);\n\n		// payout previous top dog\n		topDog.send(dogpayoff);\n\n		visionFees += vfee;\n\n		// send buy fee (plus previous collected underdog fees) to visionDog\n		visionDog.send(visionFees);\n		visionFees = 0;\n\n		// record a price floor for underdog markup decay calculation during the next round:\n		// the mininum purchase price before buyout\n		topDogPriceFloor = topDogMinPrice;\n\n		// set the initial minimum buy price for the next top dog\n		topDogMinPrice = msg.value * topDogMinMarkup / 100;\n\n		// the price ceiling for calculating the underdog markup decay is the new minimum price\n		topDogPriceCeiling = topDogMinPrice;\n\n\n		// check for eligible lucky dog...\n//		if (Underdogs.length - payoutIndex > 0) {\n			// lucky dog is most recent underdog to make an entry\n//			luckyDog = Underdogs.length - 1;\n//		} else {\n			// no dogs waiting in line?  all dividends will go to top dog this round\n//			luckyDog = 0;\n//		}\n		\n\n		// reset underdog markup for next round\n		underDogMarkup = 150;\n\n		// how many dogs are waiting?\n		uint linelength = Underdogs.length - payoutIndex;\n\n		// surplus goes to pay scraps to random underdogs\n		// calculate and pay scraps\n\n\n		// are there underdogs around to receive the scraps?\n		if (surplus > 0 && linelength > 0 ) {\n			throwScraps(surplus);\n		}\n\n\n		// if there are any underdogs in line, the lucky dog will be picked from among them	\n		if (linelength > 0) {\n\n			// randomly pick a new lucky dog, with luck weighted toward more recent entries\n\n			// weighting works like this:\n			// 	For example, if the line length is 6, the most recent entry will\n			//	be 6 times more likely than the oldest (6/21 odds),\n			//	the second most recent will be 5 times more likely than the oldest (5/21 odds)\n			//	the third most recent will be 4 times as likely as the oldest (4/21 odds),\n			//	etc...\n\n			//	of course, the player that has been in line longest is\n			//	least likely to be lucky (1/21 odds in this example)\n			//	and will be getting sent out of the game soonest anyway\n\n			uint luckypickline = (linelength % 2 == 1) ?\n				( linelength / 2 + 1 ) + (linelength + 1) * (linelength / 2) :  // odd\n				( (linelength + 1) * (linelength / 2)  ); // even\n\n			uint luckypick = randInt(luckypickline, 69);\n	\n			uint pickpos = luckypickline - linelength;\n			uint linepos = 1;\n\n			while (pickpos >= luckypick && linepos < linelength) {\n				pickpos -= (linelength - linepos);\n				linepos++;\n			}\n\n			luckyDog = Underdogs.length - linepos;\n		} else {\n			// no underdogs in line?  no lucky dog this round.\n			// (should only possibly happen when game starts)\n			luckyDog = 0;\n		}\n		\n\n		// the new top dog is crowned!\n		topDog = msg.sender;\n	}\n\n	function throwScraps(uint totalscrapvalue) private {\n\n		// how many dogs are waiting?\n		uint linelength = Underdogs.length - payoutIndex;\n\n		// to keep from having too many transactions, make sure we never have more than 7 scraps.\n		// the more dogs in line, the more we jump over when scraps get scattered\n		uint skipstep = (linelength / 7) + 1;\n\n		// how many pieces to divide (roughly, randomization might make it more or less)\n		uint pieces = linelength / skipstep;\n\n		// how far from the end of the queue to start throwing the first scrap (semi-random)\n		uint startoffset = randInt(skipstep, 42) - 1;\n\n		// base size for scraps...  \n		uint scrapbasesize = totalscrapvalue / (pieces + payoutCount);\n\n		// minimum base scrap size of 0.5 eth\n		if (scrapbasesize < 500 finney) {\n			scrapbasesize = 500 finney;\n		}\n\n		uint scrapsize;\n		uint sptr = Underdogs.length - 1 - startoffset;\n\n		uint scrapvalueleft = totalscrapvalue;\n\n		while (pieces > 0 && scrapvalueleft > 0 && sptr >= payoutIndex) {\n			// those who bailed out other dogs get bigger scraps\n			// size of the scrap is multiplied by # of other dogs the user bailed out\n			scrapsize = scrapbasesize * (Underdogs[sptr].bailouts + 1);\n\n\n			// scraps can never be more than what's in the pile\n			if (scrapsize < scrapvalueleft) {\n				scrapvalueleft -= scrapsize;\n			} else {\n				scrapsize = scrapvalueleft;\n				scrapvalueleft = 0;\n			}\n\n			// pay it\n			Underdogs[sptr].addr.send(scrapsize);\n			pieces--;\n			sptr -= skipstep;\n		}\n\n		// any scraps left uncaught? put them in the bailout fund for the underdogs\n		if (scrapvalueleft > 0) {\n			bailoutBalance += scrapvalueleft;\n		}\n	}\n\n	function getDogName(address adr) private constant returns (string thename) {\n		if (bytes(dogNames[adr]).length > 0)\n			thename = dogNames[adr];\n		else\n			thename = 'Unnamed Mutt';\n	}\n	\n	// Generate pseudo semi-random number between 1 - max \n	function randInt(uint max, uint seedswitch) private constant returns (uint randomNumber) {\n		return( uint(sha3(block.blockhash(block.number-1), block.timestamp + seedswitch) ) % max + 1 );\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームのロジックが中心で、芸術性は低い。
1436098,0xabc1cdd8dcfdcd38d00568639431142980fa992f,false,false,"contract Token {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function transfer(address _to, uint256 _value);\n    function balanceOf(address) returns (uint256);\n}\n\ncontract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract TokenSale is owned {\n\n	address public asset;\n	uint256 public price;\n\n	function TokenSale()\n	{\n	      asset =  0xE0B7927c4aF23765Cb51314A0E0521A9645F0E2A; // DGX\n	      price = 750000000; // 0.75 ETH\n	}\n\n\n	function transfer_token(address _token, address _to, uint256 _value)\n	onlyOwner()\n	{\n		Token(_token).transfer(_to,_value);\n	}\n\n	function transfer_eth(address _to, uint256 _value)\n	onlyOwner()\n	{\n		if(this.balance >= _value) {\n                    _to.send(_value);\n                }\n	}\n\n   	function () {\n\n		uint order   = msg.value / price;\n\n		if(order == 0) throw;\n		\n		uint256 balance = Token(asset).balanceOf(address(this));\n\n		if(balance == 0) throw;\n\n		if(order > balance )\n		{\n		    order = balance;\n		    uint256 change = msg.value - order * price;\n		    msg.sender.send(change);\n		}\n\n		Token(asset).transfer(msg.sender,order);\n    	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1440521,0x5158cf97c3e001b402ccb0f9063736ee8d6dad5a,false,false,"contract Ai {\n\n  struct Participant {\n      address etherAddress;\n      uint amount;\n  }\n\n  Participant[] public participants;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function Ai() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 10 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n\n    uint amount;\n    if (msg.value > 100 ether) {  \n      collectedFees += msg.value - 100 ether;\n      amount = 100 ether;\n    }\n    else {\n      amount = msg.value;\n    }\n\n    // add a new participant to array\n    uint idx = participants.length;\n    participants.length += 1;\n    participants[idx].etherAddress = msg.sender;\n    participants[idx].amount = amount;\n\n    // collect fees and update contract balance\n    if (idx != 0) {\n      collectedFees += amount / 15;\n      balance += amount - amount / 15;\n    } else {\n      //  first participant has no one above him,\n      //  so it goes all to fees\n      collectedFees += amount;\n    }\n\n    // while there are enough ether on the balance we can pay out to an earlier participant\n    while (balance > participants[payoutIdx].amount * 2) {\n      uint transactionAmount = participants[payoutIdx].amount *2;\n      participants[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n  function collectFees() onlyowner {\n      if (collectedFees == 0) return;\n      owner.send(collectedFees);\n      collectedFees = 0;\n  }\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1443296,0xfa7b9770ca4cb04296cac84f37736d4041251cdf,false,false,"// Copyright 2016 The go-ethereum Authors\n// This file is part of the go-ethereum library.\n//\n// The go-ethereum library is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Lesser General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// The go-ethereum library is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n// GNU Lesser General Public License for more details.\n//\n// You should have received a copy of the GNU Lesser General Public License\n// along with the go-ethereum library. If not, see <http://www.gnu.org/licenses/>.\n\n// ReleaseOracle is an Ethereum contract to store the current and previous\n// versions of the go-ethereum implementation. Its goal is to allow Geth to\n// check for new releases automatically without the need to consult a central\n// repository.\n//\n// The contract takes a vote based approach on both assigning authorised signers\n// as well as signing off on new Geth releases.\n//\n// Note, when a signer is demoted, the currently pending release is auto-nuked.\n// The reason is to prevent suprises where a demotion actually tilts the votes\n// in favor of one voter party and pushing out a new release as a consequence of\n// a simple demotion.\ncontract ReleaseOracle {\n  // Votes is an internal data structure to count votes on a specific proposal\n  struct Votes {\n    address[] pass; // List of signers voting to pass a proposal\n    address[] fail; // List of signers voting to fail a proposal\n  }\n\n  // Version is the version details of a particular Geth release\n  struct Version {\n    uint32  major;  // Major version component of the release\n    uint32  minor;  // Minor version component of the release\n    uint32  patch;  // Patch version component of the release\n    bytes20 commit; // Git SHA1 commit hash of the release\n\n    uint64  time;  // Timestamp of the release approval\n    Votes   votes; // Votes that passed this release\n  }\n\n  // Oracle authorization details\n  mapping(address => bool) authorised; // Set of accounts allowed to vote on updating the contract\n  address[]                voters;     // List of addresses currently accepted as signers\n\n  // Various proposals being voted on\n  mapping(address => Votes) authProps; // Currently running user authorization proposals\n  address[]                 authPend;  // List of addresses being voted on (map indexes)\n\n  Version   verProp;  // Currently proposed release being voted on\n  Version[] releases; // All the positively voted releases\n\n  // isSigner is a modifier to authorize contract transactions.\n  modifier isSigner() {\n    if (authorised[msg.sender]) {\n      _\n    }\n  }\n\n  // Constructor to assign the initial set of signers.\n  function ReleaseOracle(address[] signers) {\n    // If no signers were specified, assign the creator as the sole signer\n    if (signers.length == 0) {\n      authorised[msg.sender] = true;\n      voters.push(msg.sender);\n      return;\n    }\n    // Otherwise assign the individual signers one by one\n    for (uint i = 0; i < signers.length; i++) {\n      authorised[signers[i]] = true;\n      voters.push(signers[i]);\n    }\n  }\n\n  // signers is an accessor method to retrieve all te signers (public accessor\n  // generates an indexed one, not a retreive-all version).\n  function signers() constant returns(address[]) {\n    return voters;\n  }\n\n  // authProposals retrieves the list of addresses that authorization proposals\n  // are currently being voted on.\n  function authProposals() constant returns(address[]) {\n    return authPend;\n  }\n\n  // authVotes retrieves the current authorization votes for a particular user\n  // to promote him into the list of signers, or demote him from there.\n  function authVotes(address user) constant returns(address[] promote, address[] demote) {\n    return (authProps[user].pass, authProps[user].fail);\n  }\n\n  // currentVersion retrieves the semantic version, commit hash and release time\n  // of the currently votec active release.\n  function currentVersion() constant returns (uint32 major, uint32 minor, uint32 patch, bytes20 commit, uint time) {\n    if (releases.length == 0) {\n      return (0, 0, 0, 0, 0);\n    }\n    var release = releases[releases.length - 1];\n\n    return (release.major, release.minor, release.patch, release.commit, release.time);\n  }\n\n  // proposedVersion retrieves the semantic version, commit hash and the current\n  // votes for the next proposed release.\n  function proposedVersion() constant returns (uint32 major, uint32 minor, uint32 patch, bytes20 commit, address[] pass, address[] fail) {\n    return (verProp.major, verProp.minor, verProp.patch, verProp.commit, verProp.votes.pass, verProp.votes.fail);\n  }\n\n  // promote pitches in on a voting campaign to promote a new user to a signer\n  // position.\n  function promote(address user) {\n    updateSigner(user, true);\n  }\n\n  // demote pitches in on a voting campaign to demote an authorised user from\n  // its signer position.\n  function demote(address user) {\n    updateSigner(user, false);\n  }\n\n  // release votes for a particular version to be included as the next release.\n  function release(uint32 major, uint32 minor, uint32 patch, bytes20 commit) {\n    updateRelease(major, minor, patch, commit, true);\n  }\n\n  // nuke votes for the currently proposed version to not be included as the next\n  // release. Nuking doesn't require a specific version number for simplicity.\n  function nuke() {\n    updateRelease(0, 0, 0, 0, false);\n  }\n\n  // updateSigner marks a vote for changing the status of an Ethereum user, either\n  // for or against the user being an authorised signer.\n  function updateSigner(address user, bool authorize) internal isSigner {\n    // Gather the current votes and ensure we don't double vote\n    Votes votes = authProps[user];\n    for (uint i = 0; i < votes.pass.length; i++) {\n      if (votes.pass[i] == msg.sender) {\n        return;\n      }\n    }\n    for (i = 0; i < votes.fail.length; i++) {\n      if (votes.fail[i] == msg.sender) {\n        return;\n      }\n    }\n    // If no authorization proposal is open, add the user to the index for later lookups\n    if (votes.pass.length == 0 && votes.fail.length == 0) {\n      authPend.push(user);\n    }\n    // Cast the vote and return if the proposal cannot be resolved yet\n    if (authorize) {\n      votes.pass.push(msg.sender);\n      if (votes.pass.length <= voters.length / 2) {\n        return;\n      }\n    } else {\n      votes.fail.push(msg.sender);\n      if (votes.fail.length <= voters.length / 2) {\n        return;\n      }\n    }\n    // Proposal resolved in our favor, execute whatever we voted on\n    if (authorize && !authorised[user]) {\n      authorised[user] = true;\n      voters.push(user);\n    } else if (!authorize && authorised[user]) {\n      authorised[user] = false;\n\n      for (i = 0; i < voters.length; i++) {\n        if (voters[i] == user) {\n          voters[i] = voters[voters.length - 1];\n          voters.length--;\n\n          delete verProp; // Nuke any version proposal (no suprise releases!)\n          break;\n        }\n      }\n    }\n    // Finally delete the resolved proposal, index and garbage collect\n    delete authProps[user];\n\n    for (i = 0; i < authPend.length; i++) {\n      if (authPend[i] == user) {\n        authPend[i] = authPend[authPend.length - 1];\n        authPend.length--;\n        break;\n      }\n    }\n  }\n\n  // updateRelease votes for a particular version to be included as the next release,\n  // or for the currently proposed release to be nuked out.\n  function updateRelease(uint32 major, uint32 minor, uint32 patch, bytes20 commit, bool release) internal isSigner {\n    // Skip nuke votes if no proposal is pending\n    if (!release && verProp.votes.pass.length == 0) {\n      return;\n    }\n    // Mark a new release if no proposal is pending\n    if (verProp.votes.pass.length == 0) {\n      verProp.major  = major;\n      verProp.minor  = minor;\n      verProp.patch  = patch;\n      verProp.commit = commit;\n    }\n    // Make sure positive votes match the current proposal\n    if (release && (verProp.major != major || verProp.minor != minor || verProp.patch != patch || verProp.commit != commit)) {\n      return;\n    }\n    // Gather the current votes and ensure we don't double vote\n    Votes votes = verProp.votes;\n    for (uint i = 0; i < votes.pass.length; i++) {\n      if (votes.pass[i] == msg.sender) {\n        return;\n      }\n    }\n    for (i = 0; i < votes.fail.length; i++) {\n      if (votes.fail[i] == msg.sender) {\n        return;\n      }\n    }\n    // Cast the vote and return if the proposal cannot be resolved yet\n    if (release) {\n      votes.pass.push(msg.sender);\n      if (votes.pass.length <= voters.length / 2) {\n        return;\n      }\n    } else {\n      votes.fail.push(msg.sender);\n      if (votes.fail.length <= voters.length / 2) {\n        return;\n      }\n    }\n    // Proposal resolved in our favor, execute whatever we voted on\n    if (release) {\n      verProp.time = uint64(now);\n      releases.push(verProp);\n      delete verProp;\n    } else {\n      delete verProp;\n    }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1454117,0xa00fa22499478cc37beb45021a1f1c9f826f72e1,false,false,"contract Ambi {\n    function getNodeAddress(bytes32) constant returns (address);\n    function addNode(bytes32, address) external returns (bool);\n    function hasRelation(bytes32, bytes32, address) constant returns (bool);\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove(){\n        if(msg.sender == address(ambiC)){\n            suicide(msg.sender);\n        }\n    }\n}\n\ncontract ElcoinDb {\n    function getBalance(address addr) constant returns(uint balance);\n}\n\ncontract ElcoinInterface {\n    function rewardTo(address _to, uint _amount) returns (bool);\n}\n\ncontract PosRewards is AmbiEnabled {\n\n    event Reward(address indexed beneficiary, uint indexed cycle, uint value, uint position);\n\n    uint public cycleLength; // PoS will be ready to send each cycleLength seconds\n    uint public startTime;   // starting at startTime\n    uint public cycleLimit;  // and will stop after cycleLimit cycles pass\n    uint public minimalRewardedBalance; // but only those accounts having balance\n                             // >= minimalRewardedBalance will get reward\n    uint[] public bannedCycles;\n\n    enum RewardStatuses { Unsent, Sent, TooSmallToSend }\n\n    struct Account {\n        address recipient;\n        RewardStatuses status;\n    }\n\n    // cycleNumber => (address => minimalBalance)\n    mapping (uint => mapping (address => int)) public accountsBalances;\n    // cycleNumber => Account[]\n    mapping (uint => Account[]) public accountsUsed;\n\n    function PosRewards() {\n        cycleLength = 864000; // 864000 seconds = 10 days, 14400 = 4 hours\n        cycleLimit = 255; // that's 9 + 9 + 9 + 9 + 219, see getRate() for info\n        minimalRewardedBalance = 1000000; // 1 coin\n        startTime = now;\n    }\n\n    // USE THIS FUNCTION ONLY IN NEW CONTRACT, IT WILL CORRUPT ALREADY COLLECTED DATA!\n    // startTime should be set to the time when PoS starts (on Dec 17, probably block 705000 or so).\n    // It should be at 12:00 Moscow time, this would be the start of all PoS cycles.\n    function setStartTime(uint _startTime) checkAccess(""owner"") {\n        startTime = _startTime;\n    }\n\n    // this allows to end PoS before 2550 days pass or to extend it further\n    function setCycleLimit(uint _cycleLimit) checkAccess(""owner"") {\n        cycleLimit = _cycleLimit;\n    }\n\n    // this allows to disable PoS sending for some of the cycles in case we\n    // need to send custom PoS. This will be 100% used on first deploy.\n    function setBannedCycles(uint[] _cycles) checkAccess(""owner"") {\n        bannedCycles = _cycles;\n    }\n\n    // set to 0 to reward everyone\n    function setMinimalRewardedBalance(uint _balance) checkAccess(""owner"") {\n        minimalRewardedBalance = _balance;\n    }\n\n    function kill() checkAccess(""owner"") {\n        suicide(msg.sender); // kills this contract and sends remaining funds back to msg.sender\n    }\n\n    // First 90 days 50% yearly\n    // Next 90 days 40%\n    // Next 90 days 30%\n    // Next 90 days 20%\n    // Next 2190 days 10%\n    function getRate(uint cycle) constant returns (uint) {\n        if (cycle <= 9) {\n            return 50;\n        }\n        if (cycle <= 18) {\n            return 40;\n        }\n        if (cycle <= 27) {\n            return 30;\n        }\n        if (cycle <= 35) { // not 36 because 36 is elDay\n            return 20;\n        }\n        if (cycle == 36) {\n            return 40;\n        }\n        if (cycle <= cycleLimit) {\n            if (cycle % 36 == 0) {\n                // Every 360th day, reward amounts double.\n                // The elDay lasts precisely 24 hours, and after that, reward amounts revert to their original values.\n                return 20;\n            }\n\n            return 10;\n        }\n        return 0;\n    }\n\n    // Cycle numeration starts from 1, 0 will be handled as not valid cycle\n    function currentCycle() constant returns (uint) {\n        if (startTime > now) {\n            return 0;\n        }\n\n        return 1 + ((now - startTime) / cycleLength);\n    }\n\n    function _isCycleValid(uint _cycle) constant internal returns (bool) {\n        if (_cycle >= currentCycle() || _cycle == 0) {\n            return false;\n        }\n        for (uint i; i<bannedCycles.length; i++) {\n            if (bannedCycles[i] == _cycle) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    // Returns how much Elcoin would be granted for user's minimal balance X in cycle Y\n    // The function is optimized to work with whole integer arithmetics\n    function getInterest(uint amount, uint cycle) constant returns (uint) {\n        return (amount * getRate(cycle)) / 3650;\n    }\n\n    // This function logs the balances after the transfer to be used in further calculations\n    function transfer(address _from, address _to) checkAccess(""elcoin"") {\n        if (startTime == 0) {\n            return; // the easy way to disable PoS\n        }\n\n        _storeBalanceRecord(_from);\n        _storeBalanceRecord(_to);\n    }\n\n    function _storeBalanceRecord(address _addr) internal {\n        ElcoinDb db = ElcoinDb(getAddress(""elcoinDb""));\n        uint cycle = currentCycle();\n\n        if (cycle > cycleLimit) {\n            return;\n        }\n\n        int balance = int(db.getBalance(_addr));\n        bool accountNotUsedInCycle = (accountsBalances[cycle][_addr] == 0);\n\n        // We'll use -1 to mark accounts that have zero balance because\n        // mappings return 0 for unexisting records and there is no way to\n        // differ them without additional data structure\n        if (accountsBalances[cycle][_addr] != -1 && (accountNotUsedInCycle || accountsBalances[cycle][_addr] > balance)) {\n            if (balance == 0) {\n                balance = -1;\n            }\n            accountsBalances[cycle][_addr] = balance;\n\n            if (accountNotUsedInCycle) {\n                // do this only once for each account in each cycle\n                accountsUsed[cycle].push(Account(_addr, RewardStatuses.Unsent));\n            }\n        }\n    }\n\n    // Get minimal balance for address in some cycle\n    function getMinimalBalance(uint _cycle, address _addr) constant returns(int) {\n        int balance = accountsBalances[_cycle][_addr];\n        if (balance == -1) {\n            balance = 0;\n        }\n\n        return balance;\n    }\n\n    // Get information from accountsUsed structure\n    function getAccountInfo(uint _cycle, uint _position) constant returns(address, RewardStatuses, int) {\n        return (\n            accountsUsed[_cycle][_position].recipient,\n            accountsUsed[_cycle][_position].status,\n            accountsBalances[_cycle][accountsUsed[_cycle][_position].recipient]\n          );\n    }\n\n    // Get information from accountsUsed structure\n    function getRewardsCount(uint _cycle) constant returns(uint) {\n        return accountsUsed[_cycle].length;\n    }\n\n    function sendReward(uint _cycle, uint _position) returns(bool) {\n        // Check that parameters are in valid ranges\n        if (!_isCycleValid(_cycle) || _position >= accountsUsed[_cycle].length) {\n            return false;\n        }\n\n        // Check that this reward was not sent\n        Account claimant = accountsUsed[_cycle][_position];\n        if (claimant.status != RewardStatuses.Unsent) {\n            return false;\n        }\n\n        // Check that this reward passes the conditions\n        int minimalAccountBalance = accountsBalances[_cycle][claimant.recipient];\n        if (minimalAccountBalance < int(minimalRewardedBalance)) {\n            claimant.status = RewardStatuses.TooSmallToSend;\n            return false;\n        }\n\n        uint rewardAmount = getInterest(uint(minimalAccountBalance), _cycle);\n\n        // We are ready to send the reward\n        ElcoinInterface elcoin = ElcoinInterface(getAddress(""elcoin""));\n        bool result = elcoin.rewardTo(claimant.recipient, rewardAmount);\n        if (result) {\n            Reward(claimant.recipient, _cycle, rewardAmount, _position);\n            claimant.status = RewardStatuses.Sent;\n        }\n\n        return true;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1460420,0xb61fb596b0cc9fa829d678eb0b8a0e058c3f1b91,false,false,"contract JackPot {\n    address public host;\n	uint minAmount;\n    uint[] public contributions;\n    address[] public contributors;\n	uint public numPlayers = 0;\n	uint public nextDraw;\n	bytes32 seedHash;\n	bytes32 random;	\n\n    struct Win {\n        address winner;\n        uint timestamp;\n        uint contribution;\n		uint amountWon;\n    }\n\n    Win[] public recentWins;\n    uint recentWinsCount;\n	\n	function insert_contribution(address addr, uint value) internal {\n		// check if array needs extending\n		if(numPlayers == contributions.length) {\n			// extend the arrays\n			contributions.length += 1;\n			contributors.length += 1;\n		}\n		contributions[numPlayers] = value;\n		contributors[numPlayers++] = addr;\n	}\n	\n	function getContributions(address addr) constant returns (uint) {\n        uint i;\n        for (i=0; i < numPlayers; i++) {\n			if (contributors[i] == addr) { // if in the list already\n				break;\n			}\n		}\n		\n		if(i == numPlayers) { // Did not find sender already in the list\n            return 0;\n        } else {\n			return contributions[i];\n		}\n    }\n	\n	function JackPot() {\n\n        host = msg.sender;\n		seedHash = sha3(1111);\n		minAmount = 10 * 1 finney;\n        recentWinsCount = 10;\n		nextDraw = 1234; // Initialize to start time of the block\n    }\n\n    function() {\n        addToContribution();\n    }\n\n    function addToContribution() {\n        addValueToContribution(msg.value);\n    }\n\n    function addValueToContribution(uint value) internal {\n        // First, make sure this is a valid transaction.\n        if(value < minAmount) throw;\n	    uint i;\n        for (i=0; i < numPlayers; i++) {\n			if (contributors[i] == msg.sender) { // Already contributed?\n				break;\n			}\n		}\n		\n		if(i == numPlayers) { // Did not find sender already in the list\n			insert_contribution(msg.sender, value);\n        } else {\n			contributions[i]+= value; // Update amount\n		}\n		\n		random = sha3(random, block.blockhash(block.number - 1));		\n    }\n	\n	//drawPot triggered from Host after time has passed or pot is matured.\n	function drawPot(bytes32 seed, bytes32 newSeed) {\n		if(msg.sender != host) throw;\n		\n		// check that seed given is the same as the seedHash so operators of jackpot can not cheat \n		if (sha3(seed) == seedHash) {\n			seedHash = sha3(newSeed);\n			// Choose a winner using the seed as random\n            uint winner_index = selectWinner(seed);\n\n            // Send the developer a 1% fee\n            host.send(this.balance / 100);\n			\n			uint amountWon = this.balance; \n			\n            // Send the winner the remaining balance on the contract.\n            contributors[winner_index].send(this.balance);\n			\n			// Make a note that someone won, then start all over!\n            recordWin(winner_index, amountWon);\n\n            reset();\n			nextDraw = now + 7 days;	\n		}\n	}\n\n	function setDrawDate(uint _newDraw) {\n		if(msg.sender != host) throw;\n		nextDraw = _newDraw;\n	}\n	\n	\n    function selectWinner(bytes32 seed) internal returns (uint winner_index) {\n\n        uint semirandom = uint(sha3(random, seed)) % this.balance;\n        for(uint i = 0; i < numPlayers; ++i) {\n            if(semirandom < contributions[i]) return i;\n            semirandom -= contributions[i];\n        }\n    }\n\n    function recordWin(uint winner_index, uint amount) internal {\n        if(recentWins.length < recentWinsCount) {\n            recentWins.length++;\n        } else {\n            // Already at capacity for the number of winners to remember.\n            // Forget the oldest one by shifting each entry 'left'\n            for(uint i = 0; i < recentWinsCount - 1; ++i) {\n                recentWins[i] = recentWins[i + 1];\n            }\n        }\n\n        recentWins[recentWins.length - 1] = Win(contributors[winner_index], block.timestamp, contributions[winner_index], amount);\n    }\n\n    function reset() internal {\n        // Clear the lists with min gas after the draw.\n		numPlayers = 0;\n    }\n\n\n    /* This should only be needed if a bug is discovered\n    in the code and the contract must be destroyed. */\n    function destroy() {\n        if(msg.sender != host) throw;\n\n        // Refund everyone's contributions.\n        for(uint i = 0; i < numPlayers; ++i) {\n            contributors[i].send(contributions[i]);\n        }\n\n		reset();\n        selfdestruct(host);\n    }\n}",1,実用的なジャックポット機能を持つ標準的なスマートコントラクト。
1463710,0x627917e47cd111382ddf7fb1dc140d2daf8876b3,false,false,contract mortal {\n    /* Define variable owner of the type address*/\n    address owner;\n\n    /* this function is executed at initialization and sets the owner of the contract */\n    function mortal() { owner = msg.sender; }\n\n    /* Function to recover the funds on the contract */\n    function kill() { if (msg.sender == owner) suicide(owner); }\n}\n\ncontract store is mortal {\n\n    uint16 public contentCount = 0;\n    \n    event content(string datainfo); \n    \n    function store() public {\n    }\n\n    function add(string datainfo) {\n        contentCount++;\n        content(datainfo);\n    }\n},1,標準的な所有者管理とイベントを持つ実用的なスマートコントラクト。
1466778,0x2fef3d3f14673af82f59fc3367c50d02f1483b05,false,false,"// Version 0.1\n// This swap contract was created by Attores and released under a GPL license\n// Visit attores.com for more contracts and Smart contract as a Service \n\n// This is the standard token interface\ncontract TokenInterface {\n\n  struct User {\n    bool locked;\n    uint256 balance;\n    uint256 badges;\n    mapping (address => uint256) allowed;\n  }\n\n  mapping (address => User) users;\n  mapping (address => uint256) balances;\n  mapping (address => mapping (address => uint256)) allowed;\n  mapping (address => bool) seller;\n\n  address config;\n  address owner;\n  address dao;\n  bool locked;\n\n  /// @return total amount of tokens\n  uint256 public totalSupply;\n  uint256 public totalBadges;\n\n  /// @param _owner The address from which the balance will be retrieved\n  /// @return The balance\n  function balanceOf(address _owner) constant returns (uint256 balance);\n\n  /// @param _owner The address from which the badge count will be retrieved\n  /// @return The badges count\n  function badgesOf(address _owner) constant returns (uint256 badge);\n\n  /// @notice send `_value` tokens to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transfer(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` badges to `_to` from `msg.sender`\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function sendBadge(address _to, uint256 _value) returns (bool success);\n\n  /// @notice send `_value` tokens to `_to` from `_from` on the condition it is approved by `_from`\n  /// @param _from The address of the sender\n  /// @param _to The address of the recipient\n  /// @param _value The amount of tokens to be transfered\n  /// @return Whether the transfer was successful or not\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n\n  /// @notice `msg.sender` approves `_spender` to spend `_value` tokens on its behalf\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @param _value The amount of tokens to be approved for transfer\n  /// @return Whether the approval was successful or not\n  function approve(address _spender, uint256 _value) returns (bool success);\n\n  /// @param _owner The address of the account owning tokens\n  /// @param _spender The address of the account able to transfer the tokens\n  /// @return Amount of remaining tokens of _owner that _spender is allowed to spend\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining);\n\n  /// @notice mint `_amount` of tokens to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mint(address _owner, uint256 _amount) returns (bool success);\n\n  /// @notice mintBadge Mint `_amount` badges to `_owner`\n  /// @param _owner The address of the account receiving the tokens\n  /// @param _amount The amount of tokens to mint\n  /// @return Whether or not minting was successful\n  function mintBadge(address _owner, uint256 _amount) returns (bool success);\n\n  function registerDao(address _dao) returns (bool success);\n\n  function registerSeller(address _tokensales) returns (bool success);\n\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\n  event SendBadge(address indexed _from, address indexed _to, uint256 _amount);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\n// Actual swap contract written by Attores\ncontract swap{\n    address public beneficiary;\n    TokenInterface public tokenObj;\n    uint public price_token;\n    uint256 public WEI_PER_FINNEY = 1000000000000000;\n    uint public BILLION = 1000000000;\n    uint public expiryDate;\n    \n    // Constructor function for this contract. Called during contract creation\n    function swap(address sendEtherTo, address adddressOfToken, uint tokenPriceInFinney_1000FinneyIs_1Ether, uint durationInDays){\n        beneficiary = sendEtherTo;\n        tokenObj = TokenInterface(adddressOfToken);\n        price_token = tokenPriceInFinney_1000FinneyIs_1Ether * WEI_PER_FINNEY;\n        expiryDate = now + durationInDays * 1 days;\n    }\n    \n    // This function is called every time some one sends ether to this contract\n    function(){\n        if (now >= expiryDate) throw;\n        // Dividing by Billion here to cater for the decimal places\n        var tokens_to_send = (msg.value * BILLION) / price_token;\n        uint balance = tokenObj.balanceOf(this);\n        address payee = msg.sender;\n        if (balance >= tokens_to_send){\n            tokenObj.transfer(msg.sender, tokens_to_send);\n            beneficiary.send(msg.value);    \n        } else {\n            tokenObj.transfer(msg.sender, balance);\n            uint amountReturned = ((tokens_to_send - balance) * price_token) / BILLION;\n            payee.send(amountReturned);\n            beneficiary.send(msg.value - amountReturned);\n        }\n    }\n    \n    modifier afterExpiry() { if (now >= expiryDate) _ }\n    \n    //This function checks if the expiry date has passed and if it has, then returns the tokens to the beneficiary\n    function checkExpiry() afterExpiry{\n        uint balance = tokenObj.balanceOf(this);\n        tokenObj.transfer(beneficiary, balance);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1468126,0x6439e643dc316ac4108ebdc6c364a65994b6b1ff,false,false,"// This is the base contract that your contract test2 extends from.\ncontract BaseRegistry {\n\n    // The owner of this registry.\n    address owner;\n\n    // This struct keeps all data for a Record.\n    struct Record {\n        // Keeps the address of this record creator.\n        address owner;\n        // Keeps the time when this record was created.\n        uint time;\n        // Keeps the index of the keys array for fast lookup\n        uint keysIndex;\n    }\n\n    // This mapping keeps the records of this Registry.\n    mapping(address => Record) records;\n\n    // Keeps the total numbers of records in this Registry.\n    uint public numRecords;\n\n    // Keeps a list of all keys to interate the records.\n    address[] private keys;\n\n\n\n    // Constructor\n    function BaseRegistry() {\n        owner = msg.sender;\n    }\n\n    // This is the function that actually insert a record. \n    function register(address key) {\n        if (records[key].time == 0) {\n            records[key].time = now;\n            records[key].owner = msg.sender;\n            records[key].keysIndex = keys.length;\n            keys.length++;\n            keys[keys.length - 1] = key;\n            numRecords++;\n        } else {\n            returnValue();\n        }\n    }\n\n    // Updates the values of the given record.\n    function update(address key) {\n        // Only the owner can update his record.\n        if (records[key].owner == msg.sender) {}\n    }\n\n    // Unregister a given record\n    function unregister(address key) {\n        if (records[key].owner == msg.sender) {\n            uint keysIndex = records[key].keysIndex;\n            delete records[key];\n            numRecords--;\n            keys[keysIndex] = keys[keys.length - 1];\n            records[keys[keysIndex]].keysIndex = keysIndex;\n            keys.length--;\n        }\n    }\n\n    // Transfer ownership of a given record.\n    function transfer(address key, address newOwner) {\n        if (records[key].owner == msg.sender) {\n            records[key].owner = newOwner;\n        } else {\n            returnValue();\n        }\n    }\n\n    // Tells whether a given key is registered.\n    function isRegistered(address key) returns(bool) {\n        return records[key].time != 0;\n    }\n\n    function getRecordAtIndex(uint rindex) returns(address key, address owner, uint time) {\n        Record record = records[keys[rindex]];\n        key = keys[rindex];\n        owner = record.owner;\n        time = record.time;\n\n    }\n\n    function getRecord(address key) returns(address owner, uint time) {\n        Record record = records[key];\n        owner = record.owner;\n        time = record.time;\n\n    }\n\n    // Returns the owner of the given record. The owner could also be get\n    // by using the function getRecord but in that case all record attributes \n    // are returned.\n    function getOwner(address key) returns(address) {\n        return records[key].owner;\n    }\n\n    // Returns the registration time of the given record. The time could also\n    // be get by using the function getRecord but in that case all record attributes\n    // are returned.\n    function getTime(address key) returns(uint) {\n        return records[key].time;\n    }\n\n    // Returns the total number of records in this registry.\n    function getTotalRecords() returns(uint) {\n        return numRecords;\n    }\n\n    // This function is used by subcontracts when an error is detected and\n    // the value needs to be returned to the transaction originator.\n    function returnValue() internal {\n        if (msg.value > 0) {\n            msg.sender.send(msg.value);\n        }\n    }\n\n    // Registry owner can use this function to withdraw any value owned by\n    // the registry.\n    function withdraw(address to, uint value) {\n        if (msg.sender == owner) {\n            to.send(value);\n        }\n    }\n\n    function kill() {\n        if (msg.sender == owner) {\n            suicide(owner);\n        }\n    }\n}\n\ncontract test2 is BaseRegistry {}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1471350,0x7996d791995b9f9c15eb4c3e899b09a344c54bdb,false,false,"contract GameOfThrones {\n    address public trueGods;\n    // King's Jester\n    address public jester;\n    // Record the last collection time\n    uint public lastCollection;\n    // Record king life\n    uint public onThrone;\n    uint public kingCost;\n    // Piggy Bank Amount\n    uint public piggyBank;\n    // Collected Fee Amount\n    uint public godBank;\n    uint public jesterBank;\n    uint public kingBank;\n\n    // Track the citizens who helped to arm race\n    address[] public citizensAddresses;\n    uint[] public citizensAmounts;\n    uint32 public totalCitizens;\n    uint32 public lastCitizenPaid;\n    // The mad king establishes the government\n    address public madKing;\n    // Record how many times the castle had fell\n    uint32 public round;\n    // Amount already paid back in this round\n    uint public amountAlreadyPaidBack;\n    // Amount invested in this round\n    uint public amountInvested;\n\n    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;\n    uint constant PEACE_PERIOD = 60 * 60 * 240;\n\n    function GameOfThrones() {\n        // Define the first castle\n        trueGods = msg.sender;\n        madKing = msg.sender;\n        jester = msg.sender;\n        lastCollection = block.timestamp;\n        onThrone = block.timestamp;\n        kingCost = 1 ether;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n    }\n\n    function repairTheCastle() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 10 finney) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the amount received is more than 100 ETH return the difference\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the Castle has fell\n        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {\n            // Send the Piggy Bank to the last 3 citizens\n            // If there is no one who contributed this last 24 hours, no action needed\n            if (totalCitizens == 1) {\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);\n            } else if (totalCitizens == 2) {\n                // If only 2 citizens contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\n            } else if (totalCitizens >= 3) {\n                // If there is 3 or more citizens who contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\n            }\n\n            godBank += piggyBank * 5 / 100;\n            // Define the new Piggy Bank\n            piggyBank = 0;\n\n            // Define the new Castle\n            jester = msg.sender;\n\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n            godAutomaticCollectFee();\n            // All goes to the Piggy Bank\n            piggyBank += amount;\n\n            round += 1;\n        } else {\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n\n            // 5% goes to the Piggy Bank\n            piggyBank += (amount * 5 / 100);\n\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\n                lastCitizenPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() {\n        repairTheCastle();\n    }\n\n    function investInTheSystem(uint amount) internal {\n        // The Castle is still up\n        lastCollection = block.timestamp;\n        amountInvested += amount;\n        // The Jetster takes 5%\n        jesterBank += amount * 5 / 100;\n        // The mad king takes 5%\n        kingBank += amount * 5 / 100;\n        // 5% goes to the Piggy Bank\n        piggyBank += (amount * 5 / 100);\n\n        kingAutomaticCollectFee();\n        jesterAutomaticCollectFee();\n    }\n\n    // When the mad king decides to give his seat to someone else\n    // the king cost will be reset to 2 ether\n    function newKing(address newKing) {\n        if (msg.sender == madKing) {\n            madKing = newKing;\n            kingCost = 1 ether;\n        }\n    }\n\n    function bribery() {\n        uint amount = 100 finney;\n        if (msg.value >= amount) {\n            // return jester\n            jester.send(jesterBank);\n            jesterBank = 0;\n\n            jester = msg.sender;\n            msg.sender.send(msg.value - amount);\n            investInTheSystem(amount);\n        } else {\n            throw;\n        }\n    }\n\n    // Anyone can usurpation the kingship\n    function usurpation() {\n        // Add more money for king usurpation cost\n        if (msg.sender == madKing) {\n            investInTheSystem(msg.value);\n            kingCost += msg.value;\n        } else {\n            if (onThrone + PEACE_PERIOD <= block.timestamp && msg.value >= kingCost * 110 / 100) {\n                // return the fees to before king\n                madKing.send(kingBank);\n                // offer sacrifices to the Gods\n                godBank += msg.value * 5 / 100;\n                investInTheSystem(msg.value);\n                // new king\n                kingCost = msg.value;\n                madKing = msg.sender;\n                onThrone = block.timestamp;\n            } else {\n                throw;\n            }\n        }\n    }\n\n    // When the king decides to collect his fees\n    function collectFee() {\n        if (msg.sender == trueGods) {\n            trueGods.send(godBank);\n        }\n    }\n\n    function godAutomaticCollectFee() internal {\n        if (godBank >= 1 ether) {\n          trueGods.send(godBank);\n          godBank = 0;\n        }\n    }\n\n    function kingAutomaticCollectFee() internal {\n        if (kingBank >= 100 finney) {\n          madKing.send(kingBank);\n          kingBank = 0;\n        }\n    }\n\n    function jesterAutomaticCollectFee() internal {\n        if (jesterBank >= 100 finney) {\n          jester.send(jesterBank);\n          jesterBank = 0;\n        }\n    }\n}",2,コードは実用的だが、Game of Thronesのテーマで詩的な要素を持ち、物語性を感じさせる。
1472078,0x786ef2e92c9946d9ec75eb1c9fb89eb02b4d6224,false,false,"/*\n\nTokenSaleFactory interface:\n\n[{""constant"":true,""inputs"":[{""name"":"""",""type"":""address""},{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesByOwner"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesAll"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_asset"",""type"":""address""},{""name"":""_price"",""type"":""uint256""}],""name"":""createSale"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":true,""inputs"":[{""name"":"""",""type"":""address""},{""name"":"""",""type"":""uint256""}],""name"":""tokenSalesByAsset"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""index"",""type"":""uint256""}],""name"":""TokenSaleCreation"",""type"":""event""}]\n\n\nTokenSale interface:\n\n[{""constant"":true,""inputs"":[],""name"":""asset"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""owner"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_to"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""transfer_eth"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""price"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""_token"",""type"":""address""},{""name"":""_to"",""type"":""address""},{""name"":""_value"",""type"":""uint256""}],""name"":""transfer_token"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[{""name"":""newOwner"",""type"":""address""}],""name"":""transferOwnership"",""outputs"":[],""type"":""function""},{""inputs"":[{""name"":""_asset"",""type"":""address""},{""name"":""_price"",""type"":""uint256""}],""type"":""constructor""}]\n\nSeller usage:\n\nFollow the TokenSaleFactory contract using the TokenSaleFactory interface.\nUse the createSale function to launch a sale given the subcurrency address \nand the price measured in wei for the smallest of that subcurrency \nfor example 0.75 ETH per DGD would be 0.75 * 10^18 / 10^9\n\nFind your tokensale by entering your address into the tokenSalesByOwner owner field\nthen entering the number you get into the tokensalesall field which is a list of all sales created\n\nDeposit subcurrency to allow people to buy it at the pice you specified.\n\nTo withdraw funds use the function transfer_eth and give the amount in wei\nTo withdraw left over subcurrency use transfer_token given the address of the subcurrency you have deposited\nor transfer_asset. Amounts are in the smallest unit of that subcurrency for example 1 DGD would be 10^9\n\n\nBuyer usage:\n\nSend ETH to a TokenSale address to automatically receive the token being sold.\n\nTo verify a TokenSale contract obtain the index and address. Folow the TokenSaleFactory and enter the index into the TokenSalesAll field to verify the address is the same.\nFollow the TokenSale addresswith the TokenSale interface to verify the asset being sold is the right subcurrency and that the price is right.\n\n*/\n\ncontract Token {\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    function transfer(address _to, uint256 _value);\n    function balanceOf(address) returns (uint256);\n}\n\ncontract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract TokenSale is owned {\n\n	address public asset;\n	uint256 public price;\n\n	function TokenSale(address _asset, uint256 _price)\n	{\n	    asset = _asset; // addreress of subcurrency\n	    price = _price; // number of wei per smallest unit of subcurrency. \n	                    // for example 0.75 ETH per DGD would be 0.75 * 10^18 / 10^9\n	                    // 10^18 being the conversion to ETH and 10^9 being the conversion to DGD\n	}\n\n\n	function transfer_token(address _token, address _to, uint256 _value)\n	onlyOwner()\n	{\n		Token(_token).transfer(_to,_value); // Oner can Transfer any subcurrency out of this contract\n	}\n\n	function transfer_asset(address _to, uint256 _value)\n	onlyOwner()\n	{\n		Token(asset).transfer(_to,_value); // transfer the sale asset\n	}\n\n	function transfer_eth(address _to, uint256 _value)\n	onlyOwner()\n	{\n            _to.send(_value); // owner can send ETH out. _value is in wei\n	}\n\n   	function () {\n\n		uint order   = msg.value / price;\n		\n		if(order == 0) throw;\n		\n		uint256 balance = Token(asset).balanceOf(address(this));\n		\n		if(balance == 0) throw;\n		\n		if(order > balance )\n		{\n		    order = balance;\n		    uint256 change = msg.value - order * price;\n		    msg.sender.send(change);\n		}\n\n		Token(asset).transfer(msg.sender,order);\n    }\n}\n\n\ncontract TokenSaleFactory {\n    \n    event TokenSaleCreation(uint256 index, address saleAddress);\n\n    address[] public tokenSalesAll; // this public array stores all tokensales created\n\n    mapping (address => uint256[]) public tokenSalesByOwner; // this mapping stores an index in tokenSalesAll of all tokensales created by a specific address\n    mapping (address => uint256[]) public tokenSalesByAsset; // this mapping stores an index in tokenSalesAll of all tokensales for a particular subcurrency\n    \n    function createSale (address _asset, uint256 _price) returns (address) {\n        address c = new TokenSale(_asset,_price);       // Create a tokensale\n        TokenSale(c).transferOwnership(msg.sender);     // set the owner to whoever called the function\n        uint256 index = tokenSalesAll.push(c) -1;\n        tokenSalesByOwner[msg.sender].push(index);  \n        tokenSalesByAsset[msg.sender].push(index);\n        TokenSaleCreation(index,c);                       // alert interested client that a tokensale has been created\n    }\n    \n    function () {\n        throw;     // Prevents accidental sending of ether to the factory\n                   // Do not send subcurrency to the factory either as it will become trapped\n                   // you will send subcurrency to the TokenSale contracts this factory creates\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1472386,0x9497043f4cd9450867479f3fd873d80d9321094c,false,false,"contract GameOfThrones {\n    address public trueGods;\n    // King's Jester\n    address public jester;\n    // Record the last collection time\n    uint public lastCollection;\n    // Record king life\n    uint public onThrone;\n    uint public kingCost;\n    // Piggy Bank Amount\n    uint public piggyBank;\n    // Collected Fee Amount\n    uint public godBank;\n    uint public jesterBank;\n    uint public kingBank;\n\n    // Track the citizens who helped to arm race\n    address[] public citizensAddresses;\n    uint[] public citizensAmounts;\n    uint32 public totalCitizens;\n    uint32 public lastCitizenPaid;\n    // The mad king establishes the government\n    address public madKing;\n    // Record how many times the castle had fell\n    uint32 public round;\n    // Amount already paid back in this round\n    uint public amountAlreadyPaidBack;\n    // Amount invested in this round\n    uint public amountInvested;\n\n    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;\n    uint constant PEACE_PERIOD = 60 * 60 * 240;\n\n    function GameOfThrones() {\n        // Define the first castle\n        trueGods = msg.sender;\n        madKing = msg.sender;\n        jester = msg.sender;\n        lastCollection = block.timestamp;\n        onThrone = block.timestamp;\n        kingCost = 1 ether;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n    }\n\n    function protectKingdom() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 10 finney) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the amount received is more than 100 ETH return the difference\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the Castle has fell\n        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {\n            // Send the Piggy Bank to the last 3 citizens\n            // If there is no one who contributed this last 24 hours, no action needed\n            if (totalCitizens == 1) {\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);\n            } else if (totalCitizens == 2) {\n                // If only 2 citizens contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\n            } else if (totalCitizens >= 3) {\n                // If there is 3 or more citizens who contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\n            }\n\n            godBank += piggyBank * 5 / 100;\n            // Define the new Piggy Bank\n            piggyBank = 0;\n\n            // Define the new Castle\n            jester = msg.sender;\n\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n            godAutomaticCollectFee();\n            // 95% goes to the Piggy Bank\n            piggyBank += amount * 90 / 100;\n\n            round += 1;\n        } else {\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\n                lastCitizenPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() internal {\n        protectKingdom();\n    }\n\n    function investInTheSystem(uint amount) internal {\n        // The Castle is still up\n        lastCollection = block.timestamp;\n        amountInvested += amount;\n        // The Jetster takes 5%\n        jesterBank += amount * 5 / 100;\n        // The mad king takes 5%\n        kingBank += amount * 5 / 100;\n        // 5% goes to the Piggy Bank\n        piggyBank += (amount * 5 / 100);\n\n        kingAutomaticCollectFee();\n        jesterAutomaticCollectFee();\n    }\n\n    // When the mad king decides to give his seat to someone else\n    // the king cost will be reset to 1 ether\n    function abdicate() {\n        if (msg.sender == madKing && msg.sender != trueGods) {\n            madKing.send(kingBank);\n            if (piggyBank > kingCost * 40 / 100) {\n                madKing.send(kingCost * 40 / 100);\n                piggyBank -= kingCost * 40 / 100;\n            }\n            else {\n                madKing.send(piggyBank);\n                piggyBank = 0;\n            }\n\n            madKing = trueGods;\n            kingCost = 1 ether;\n        }\n    }\n\n    function murder() {\n        uint amount = 100 finney;\n        if (msg.value >= amount && msg.sender != jester) {\n            // return jester\n            jester.send(jesterBank);\n            jesterBank = 0;\n\n            jester = msg.sender;\n            msg.sender.send(msg.value - amount);\n            investInTheSystem(amount);\n        } else {\n            throw;\n        }\n    }\n\n    // Anyone can usurpation the kingship\n    function usurpation() {\n        uint amount = msg.value;\n        // Add more money for king usurpation cost\n        if (msg.sender == madKing) {\n            investInTheSystem(amount);\n            kingCost += amount;\n        } else {\n            if (onThrone + PEACE_PERIOD <= block.timestamp && amount >= kingCost * 150 / 100) {\n                // return the fees to before king\n                madKing.send(kingBank);\n                // offer sacrifices to the Gods\n                godBank += amount * 5 / 100;\n                // new king\n                kingCost = amount;\n                madKing = msg.sender;\n                onThrone = block.timestamp;\n                investInTheSystem(amount);\n            } else {\n                throw;\n            }\n        }\n    }\n\n    // When the king decides to collect his fees\n    function collectFee() {\n        if (msg.sender == trueGods) {\n            trueGods.send(godBank);\n        }\n    }\n\n    function godAutomaticCollectFee() internal {\n        if (godBank >= 1 ether) {\n          trueGods.send(godBank);\n          godBank = 0;\n        }\n    }\n\n    function kingAutomaticCollectFee() internal {\n        if (kingBank >= 100 finney) {\n          madKing.send(kingBank);\n          kingBank = 0;\n        }\n    }\n\n    function jesterAutomaticCollectFee() internal {\n        if (jesterBank >= 100 finney) {\n          jester.send(jesterBank);\n          jesterBank = 0;\n        }\n    }\n}",2,中世のテーマを持ち、詩的な要素が含まれるが、実用的なスマートコントラクト。
1472785,0x9f8bf604abeb04d32b0ffae9c3a083be5858cf96,false,false,"contract GameOfThrones {\n    address public trueGods;\n    // King's Jester\n    address public jester;\n    // Record the last collection time\n    uint public lastCollection;\n    // Record the last fell time\n    uint public lastFell;\n    // Record king life\n    uint public onThrone;\n    uint public kingCost;\n    // Piggy Bank Amount\n    uint public piggyBank;\n    // Collected Fee Amount\n    uint public godBank;\n    uint public jesterBank;\n    uint public kingBank;\n\n    // Track the citizens who helped to arm race\n    address[] public citizensAddresses;\n    uint[] public citizensAmounts;\n    uint32 public totalCitizens;\n    uint32 public lastCitizenPaid;\n    // The mad king establishes the government\n    address public madKing;\n    // Record how many times the castle had fell\n    uint32 public round;\n    // Amount already paid back in this round\n    uint public amountAlreadyPaidBack;\n    // Amount invested in this round\n    uint public amountInvested;\n\n    uint constant TWENTY_FOUR_HOURS = 60 * 60 * 24;\n    uint constant PEACE_PERIOD = 60 * 60 * 240;\n\n    function GameOfThrones() {\n        // Define the first castle\n        trueGods = msg.sender;\n        madKing = msg.sender;\n        jester = msg.sender;\n        lastFell = block.timestamp;\n        lastCollection = block.timestamp;\n        onThrone = block.timestamp;\n        kingCost = 1 ether;\n        amountAlreadyPaidBack = 0;\n        amountInvested = 0;\n        totalCitizens = 0;\n    }\n\n    function protectKingdom() returns(bool) {\n        uint amount = msg.value;\n        // Check if the minimum amount if reached\n        if (amount < 10 finney) {\n            msg.sender.send(msg.value);\n            return false;\n        }\n        // If the amount received is more than 100 ETH return the difference\n        if (amount > 100 ether) {\n            msg.sender.send(msg.value - 100 ether);\n            amount = 100 ether;\n        }\n\n        // Check if the Castle has fell\n        if (lastCollection + TWENTY_FOUR_HOURS < block.timestamp) {\n            // Send the Piggy Bank to the last 3 citizens\n            // If there is no one who contributed this last 24 hours, no action needed\n            if (totalCitizens == 1) {\n                // If there is only one Citizen who contributed, he gets the full Pigg Bank\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 95 / 100);\n            } else if (totalCitizens == 2) {\n                // If only 2 citizens contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 60 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 35 / 100);\n            } else if (totalCitizens >= 3) {\n                // If there is 3 or more citizens who contributed\n                citizensAddresses[citizensAddresses.length - 1].send(piggyBank * 50 / 100);\n                citizensAddresses[citizensAddresses.length - 2].send(piggyBank * 30 / 100);\n                citizensAddresses[citizensAddresses.length - 3].send(piggyBank * 15 / 100);\n            }\n\n            godBank += piggyBank * 5 / 100;\n            // Define the new Piggy Bank\n            piggyBank = 0;\n\n            // Define the new Castle\n            jester = msg.sender;\n\n            lastFell = block.timestamp;\n            citizensAddresses.push(msg.sender);\n            citizensAmounts.push(amount * 110 / 100);\n            totalCitizens += 1;\n            investInTheSystem(amount);\n            godAutomaticCollectFee();\n            // 95% goes to the Piggy Bank\n            piggyBank += amount * 90 / 100;\n\n            round += 1;\n        } else {\n            if (lastFell + TWENTY_FOUR_HOURS * 2 >= block.timestamp) {\n                citizensAddresses.push(msg.sender);\n                citizensAmounts.push(amount * 130 / 100);\n            } else {\n                citizensAddresses.push(msg.sender);\n                citizensAmounts.push(amount * 110 / 100);\n            }\n            totalCitizens += 1;\n            investInTheSystem(amount);\n\n            while (citizensAmounts[lastCitizenPaid] < (address(this).balance - piggyBank - godBank - kingBank - jesterBank) && lastCitizenPaid <= totalCitizens) {\n                citizensAddresses[lastCitizenPaid].send(citizensAmounts[lastCitizenPaid]);\n                amountAlreadyPaidBack += citizensAmounts[lastCitizenPaid];\n                lastCitizenPaid += 1;\n            }\n        }\n    }\n\n    // fallback function\n    function() internal {\n        protectKingdom();\n    }\n\n    function investInTheSystem(uint amount) internal {\n        // The Castle is still up\n        lastCollection = block.timestamp;\n        amountInvested += amount;\n        // The Jetster takes 5%\n        jesterBank += amount * 5 / 100;\n        // The mad king takes 5%\n        kingBank += amount * 5 / 100;\n        // 5% goes to the Piggy Bank\n        piggyBank += (amount * 5 / 100);\n\n        kingAutomaticCollectFee();\n        jesterAutomaticCollectFee();\n    }\n\n    // When the mad king decides to give his seat to someone else\n    // the king cost will be reset to 1 ether\n    function abdicate() {\n        if (msg.sender == madKing && msg.sender != trueGods) {\n            madKing.send(kingBank);\n            if (piggyBank > kingCost * 40 / 100) {\n                madKing.send(kingCost * 40 / 100);\n                piggyBank -= kingCost * 40 / 100;\n            }\n            else {\n                madKing.send(piggyBank);\n                piggyBank = 0;\n            }\n\n            madKing = trueGods;\n            kingCost = 1 ether;\n        }\n    }\n\n    function murder() {\n        uint amount = 100 finney;\n        if (msg.value >= amount && msg.sender != jester) {\n            // return jester\n            jester.send(jesterBank);\n            jesterBank = 0;\n\n            jester = msg.sender;\n            msg.sender.send(msg.value - amount);\n            investInTheSystem(amount);\n        } else {\n            throw;\n        }\n    }\n\n    // Anyone can usurpation the kingship\n    function usurpation() {\n        uint amount = msg.value;\n        // Add more money for king usurpation cost\n        if (msg.sender == madKing) {\n            investInTheSystem(amount);\n            kingCost += amount;\n        } else {\n            if (onThrone + PEACE_PERIOD <= block.timestamp && amount >= kingCost * 150 / 100) {\n                // return the fees to before king\n                madKing.send(kingBank);\n                // offer sacrifices to the Gods\n                godBank += amount * 5 / 100;\n                // new king\n                kingCost = amount;\n                madKing = msg.sender;\n                onThrone = block.timestamp;\n                investInTheSystem(amount);\n            } else {\n                throw;\n            }\n        }\n    }\n\n    // When the king decides to collect his fees\n    function collectFee() {\n        if (msg.sender == trueGods) {\n            trueGods.send(godBank);\n        }\n    }\n\n    function godAutomaticCollectFee() internal {\n        if (godBank >= 1 ether) {\n          trueGods.send(godBank);\n          godBank = 0;\n        }\n    }\n\n    function kingAutomaticCollectFee() internal {\n        if (kingBank >= 100 finney) {\n          madKing.send(kingBank);\n          kingBank = 0;\n        }\n    }\n\n    function jesterAutomaticCollectFee() internal {\n        if (jesterBank >= 100 finney) {\n          jester.send(jesterBank);\n          jesterBank = 0;\n        }\n    }\n}",2,中世のテーマと役割が詩的で、物語性があるが、実用的なスマートコントラクト。
1476801,0xc726ac92955fc07ad09c5af4827418f581e37017,false,false,"contract CryptoHill {\n    \n  address admin;\n  address leader;\n  bytes32 leaderHash;\n  bytes32 difficulty;\n  bytes32 difficultyWorldRecord;\n  uint fallenLeaders;\n  uint startingTime;\n  uint gameLength;\n  string leaderMessage;\n  string defaultLeaderMessage;\n  \n  event Begin(string log);\n  event Leader(string log, address newLeader, bytes32 newHash);\n  event GameOver(string log);\n  event Winner (string log, address winner);\n  event NoWinner (string log);\n  event WorldRecord (string log, bytes32 DifficultyRecord, address RecordHolder);\n  \n  function CryptoHill(){ \n      \n    //Admin Backdoor\n    admin = msg.sender;\n\n    //Starting Time\n    startingTime = block.timestamp;\n    \n    //Game Length (TODO: Change to 1 weeks)\n    gameLength = 1 weeks;\n\n    //Initial seed for the first challenge. This should always be in rotation afterward.\n    leaderHash = sha3(""09F911029D74E35BD84156C5635688C0"");\n\n    //First leader is the creator of the contract\n    leader = msg.sender;\n\n    //The placeholder leader message\n    defaultLeaderMessage = ""If you're this weeks leader, you own this field. Write a message here."";\n    leaderMessage = defaultLeaderMessage;\n    \n    //This difficulty starts as easy as possible. Any XOR will be less, to start.\n    difficulty = leaderHash;\n    \n    //Seed the world record\n    difficultyWorldRecord = leaderHash;\n    \n    //Counter for successful collisions this week.\n    fallenLeaders = 0;\n\n    Begin(""Collide the most bits of the leader's hash to replace the leader. Leader will win any bounty at the end of the week."");\n\n  }\n  \n  function reset() private{\n      \n      //Make the hash unpredictable.\n      leaderHash = sha3(block.timestamp);\n      \n      //Reset the leader message\n      leaderMessage = defaultLeaderMessage;\n      difficulty = leaderHash;\n      leader = admin;\n      fallenLeaders = 0;\n  }\n  \n  function checkDate() private returns (bool success) {\n      \n      //Are we one week beyond the last game? TODO change time for mainnet\n      if (block.timestamp > (startingTime + gameLength)) {\n          \n          //If so, log winner. If the admin ""wins"", it's because no one else won.\n          if(leader != admin){\n            Winner(""Victory! Game will be reset to end in 1 week (in block time)."", leader);\n            leader.send(this.balance);\n          }else NoWinner(""No winner! Game will be reset to end in 1 week (in block time)."");\n\n          startingTime = block.timestamp;\n\n          //Reset\n          reset();\n          return true;\n      }\n      return false;\n  }\n\n  function overthrow(string challengeData) returns (bool success){\n        \n        //Create hash from player data sent to contract\n        var challengeHash = sha3(challengeData);\n\n        //Check One: Submission too late, reset game w/ new hash\n        if(checkDate())\n            return false;\n        \n        //Check Two: Cheating - of course last hash will collide!\n        if(challengeHash == leaderHash)\n            return false;\n\n        //Check Three: Core gaming logic favoring collisions of MSB\n        if((challengeHash ^ leaderHash) > difficulty)\n          return false;\n\n        //If player survived the checks, they've overcome difficulty level and beat the leader.\n        //Update the difficulty. This makes the game progressively harder through the week.\n        difficulty = (challengeHash ^ leaderHash);\n        \n        //Did they set a record?\n        challengeWorldRecord(difficulty);\n        \n        //We have a new Leader\n        leader = msg.sender;\n        \n        //The winning hash is our new hash. This undoes any work being done by competition!\n        leaderHash = challengeHash;\n        \n        //Announce our new victor. Congratulations!    \n        Leader(""New leader! This is their address, and the new hash to collide."", leader, leaderHash);\n        \n        //Keep track of how many new leaders we've had this week.\n        fallenLeaders++;\n        \n        return true;\n  }\n  \n  function challengeWorldRecord (bytes32 difficultyChallenge) private {\n      if(difficultyChallenge < difficultyWorldRecord) {\n        difficultyWorldRecord = difficultyChallenge;\n        WorldRecord(""A record setting collision occcured!"", difficultyWorldRecord, msg.sender);\n      }\n  }\n  \n  function changeLeaderMessage(string newMessage){\n        //The leader gets to talk all kinds of shit. If abuse, might remove.\n        if(msg.sender == leader)\n            leaderMessage = newMessage;\n  }\n  \n  //The following functions designed for mist UI\n  function currentLeader() constant returns (address CurrentLeaderAddress){\n      return leader;\n  }\n  function Difficulty() constant returns (bytes32 XorMustBeLessThan){\n      return difficulty;\n  }\n  function LeaderHash() constant returns (bytes32 leadingHash){\n      return leaderHash;\n  }\n  function LeaderMessage() constant returns (string MessageOfTheDay){\n      return leaderMessage;\n  }\n  function FallenLeaders() constant returns (uint Victors){\n      return fallenLeaders;\n  }\n  function GameEnds() constant returns (uint EndingTime){\n      return startingTime + gameLength;\n  }\n\n  function kill(){\n      if (msg.sender == admin){\n        GameOver(""The Crypto Hill has ended."");\n        selfdestruct(admin);\n      }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックが中心で芸術性は低い。
1480908,0xf9e03d5e3d86277574cfd5f7e842f213cf88945f,false,false,/* A contract to store only messages approved by owner */\ncontract self_store {\n\n    address owner;\n\n    uint16 public contentCount = 0;\n    \n    event content(string datainfo); \n    \n    function self_store() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() { if (msg.sender == owner) suicide(owner); }\n\n    function add(string datainfo) {\n        if (msg.sender != owner) return;\n        contentCount++;\n        content(datainfo);\n    }\n\n    function flush() {\n        owner.send(this.balance);\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1481022,0xfd39bd49ab3df4eda75a23807dab186d4902f924,false,false,/* A contract to store only messages approved by owner */\ncontract self_store {\n\n    address owner;\n\n    uint16 public contentCount = 0;\n    \n    event content(string datainfo);\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    function self_store() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo) onlyowner {\n        contentCount++;\n        content(datainfo);\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1481496,0x260972db3571a4297b9e0cfa237eabbc9c6e35ce,false,false,"/* A contract to exchange encrypted messages. Most of the work done on\n   the client side. */\n\ncontract comm_channel {\n	\n    address owner;\n    \n    event content(string datainfo, string senderKey, string recipientKey, uint amount);\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    function comm_channel() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo, string senderKey, string recipientKey,\n                 address resendTo) {\n        \n        //try to resend money from message to the address\n        if(msg.value > 0) {\n            if(!resendTo.send(msg.value)) throw;\n        }\n        \n        //write to blockchain\n        content(datainfo, senderKey, recipientKey, msg.value);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1487195,0x8b4aa759d83ec43efba755fc27923e4a581bccc1,false,false,"contract BlockChainChallenge {\n    \n  address admin;\n  address leader;\n  bytes32 leaderHash;\n  bytes32 difficulty;\n  bytes32 difficultyWorldRecord;\n  uint fallenLeaders;\n  uint startingTime;\n  uint gameLength;\n  string leaderMessage;\n  string defaultLeaderMessage;\n  mapping (address => uint) winners;\n  \n  event Begin(string log);\n  event Leader(string log, address newLeader, bytes32 newHash);\n  event GameOver(string log);\n  event Winner (string log, address winner);\n  event NoWinner (string log);\n  event WorldRecord (string log, bytes32 DifficultyRecord, address RecordHolder);\n  \n  function BlockChainChallenge(){ \n      \n    //Admin Backdoor\n    admin = msg.sender;\n\n    //Starting Time\n    startingTime = block.timestamp;\n    \n    //Game Length (TODO: Change to 1 weeks)\n    gameLength = 1 weeks;\n\n    //Initial seed for the first challenge. This should always be in rotation afterward.\n    leaderHash = sha3(""09F911029D74E35BD84156C5635688C0"");\n\n    //First leader is the creator of the contract\n    leader = msg.sender;\n\n    //The placeholder leader message\n    defaultLeaderMessage = ""If you're this weeks leader, you own this field. Write a message here."";\n    leaderMessage = defaultLeaderMessage;\n    \n    //This difficulty starts as easy as possible. Any XOR will be less, to start.\n    difficulty = leaderHash;\n    \n    //Seed the world record\n    difficultyWorldRecord = leaderHash;\n    \n    //Counter for successful collisions this week.\n    fallenLeaders = 0;\n\n    Begin(""Collide the most bits of the leader's hash to replace the leader. Leader will win any bounty at the end of the week."");\n\n  }\n  \n  function reset() private{\n      \n      //Make the hash unpredictable.\n      leaderHash = sha3(block.timestamp);\n      \n      //Reset the leader message\n      leaderMessage = defaultLeaderMessage;\n      difficulty = leaderHash;\n      leader = admin;\n      fallenLeaders = 0;\n  }\n  \n  function checkDate() private returns (bool success) {\n      \n      //Are we one week beyond the last game? TODO change time for mainnet\n      if (block.timestamp > (startingTime + gameLength)) {\n          \n          //If so, log winner. If the admin ""wins"", it's because no one else won.\n          if(leader != admin){\n            Winner(""Victory! Game will be reset to end in 1 week (in block time)."", leader);\n            leader.send(this.balance);\n          }else NoWinner(""No winner! Game will be reset to end in 1 week (in block time)."");\n\n          startingTime = block.timestamp;\n\n          //Reset\n          reset();\n          return true;\n      }\n      return false;\n  }\n\n  function overthrow(string challengeData) returns (bool success){\n        \n        //Create hash from player data sent to contract\n        var challengeHash = sha3(challengeData);\n\n        //Check One: Submission too late, reset game w/ new hash\n        if(checkDate())\n            return false;\n        \n        //Check Two: Cheating - of course last hash will collide!\n        if(challengeHash == leaderHash)\n            return false;\n\n        //Check Three: Core gaming logic favoring collisions of MSB\n        if((challengeHash ^ leaderHash) > difficulty)\n          return false;\n\n        //If player survived the checks, they've overcome difficulty level and beat the leader.\n        //Update the difficulty. This makes the game progressively harder through the week.\n        difficulty = (challengeHash ^ leaderHash);\n        \n        //Did they set a record?\n        challengeWorldRecord(difficulty);\n        \n        //We have a new Leader\n        leader = msg.sender;\n        \n        //The winning hash is our new hash. This undoes any work being done by competition!\n        leaderHash = challengeHash;\n        \n        //Announce our new victor. Congratulations!    \n        Leader(""New leader! This is their address, and the new hash to collide."", leader, leaderHash);\n        \n        //Add to historical Winners\n        winners[msg.sender]++;\n        \n        //Keep track of how many new leaders we've had this week.\n        fallenLeaders++;\n        \n        return true;\n  }\n  \n  function challengeWorldRecord (bytes32 difficultyChallenge) private {\n      if(difficultyChallenge < difficultyWorldRecord) {\n        difficultyWorldRecord = difficultyChallenge;\n        WorldRecord(""A record setting collision occcured!"", difficultyWorldRecord, msg.sender);\n      }\n  }\n  \n  function changeLeaderMessage(string newMessage){\n        //The leader gets to talk all kinds of shit. If abuse, might remove.\n        if(msg.sender == leader)\n            leaderMessage = newMessage;\n  }\n  \n  //The following functions designed for mist UI\n  function currentLeader() constant returns (address CurrentLeaderAddress){\n      return leader;\n  }\n  function Difficulty() constant returns (bytes32 XorMustBeLessThan){\n      return difficulty;\n  }\n  function TargetHash() constant returns (bytes32 leadingHash){\n      return leaderHash;\n  }\n  function LeaderMessage() constant returns (string MessageOfTheDay){\n      return leaderMessage;\n  }\n  function FallenLeaders() constant returns (uint Victors){\n      return fallenLeaders;\n  }\n  function GameEnds() constant returns (uint EndingTime){\n      return startingTime + gameLength;\n  }\n  function getWins(address check) constant returns (uint wins){\n      return winners[check];\n  }\n\n  function kill(){\n      if (msg.sender == admin){\n        GameOver(""The challenge has ended."");\n        selfdestruct(admin);\n      }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックが中心で芸術性は低い。
1487545,0x0318179601a70085aeb488f178b081295b65ecc9,false,false,"contract self_store {\n\n    address owner;\n\n    uint public contentCount = 0;\n    \n    event content(string datainfo, uint indexed version);\n    modifier onlyowner { if (msg.sender == owner) _ }\n    \n    function self_store() public { owner = msg.sender; }\n    \n    ///TODO: remove in release\n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function add(string datainfo, uint version) onlyowner {\n        contentCount++;\n        content(datainfo, version);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1490043,0xe6057e88d3effbe3831ee67d18f206692e9563dc,false,false,"contract Ambi {\n    function getNodeAddress(bytes32) constant returns (address);\n    function addNode(bytes32, address) external returns (bool);\n    function hasRelation(bytes32, bytes32, address) constant returns (bool);\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract ElcoinDb {\n    address owner;\n    address caller;\n\n    event Transaction(bytes32 indexed hash, address indexed from, address indexed to, uint time, uint amount);\n\n    modifier checkOwner() { _ }\n    modifier checkCaller() { _ }\n    mapping (address => uint) public balances;\n\n    function ElcoinDb(address pCaller) {\n        owner = msg.sender;\n        caller = pCaller;\n    }\n\n    function getOwner() constant returns (address rv) {\n        return owner;\n    }\n\n    function getCaller() constant returns (address rv) {\n        return caller;\n    }\n\n    function setCaller(address pCaller) checkOwner() returns (bool _success) {\n        caller = pCaller;\n\n        return true;\n    }\n\n    function setOwner(address pOwner) checkOwner() returns (bool _success) {\n        owner = pOwner;\n\n        return true;\n    }\n\n    function getBalance(address addr) constant returns(uint balance) {\n        return balances[addr];\n    }\n\n    function deposit(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\n        balances[addr] += amount;\n        Transaction(hash, 0, addr, time, amount);\n\n        return true;\n    }\n\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) checkCaller() returns (bool res) {\n        uint oldBalance = balances[addr];\n        if (oldBalance >= amount) {\n            balances[addr] = oldBalance - amount;\n            Transaction(hash, addr, 0, time, amount);\n            return true;\n        }\n\n        return false;\n    }\n}\n\ncontract ElcoinInterface {\n    function rewardTo(address _to, uint _amount) returns (bool);\n}\n\ncontract PotRewards is AmbiEnabled {\n\n    event Reward(address indexed beneficiary, uint indexed round, uint value, uint position);\n\n    struct Transaction {\n        address from;\n        uint amount;\n    }\n\n    uint public round = 0;\n    uint public counter = 0;            //counts each transaction\n    Transaction[] public transactions;  //records details of txns participating in next auction round\n\n    //parameters\n    uint public periodicity;        //how often does an auction happen (ie. each 10000 tx)\n    uint8 public auctionSize;       //how many transactions participate in auction\n    uint public prize;              //total amount of prize for each round\n    uint public minTx;              //transactions less than this amount will not be counted\n    uint public startTime;          //starting at startTime to calculate double rewards\n\n    ElcoinInterface public elcoin;  //contract to do rewardTo calls\n\n    function configure(uint _periodicity, uint8 _auctionSize, uint _prize, uint _minTx, uint _counter, uint _startTime) checkAccess(""owner"") returns (bool) {\n        if (_auctionSize > _periodicity || _prize == 0 || _auctionSize > 255) {\n            return false;\n        }\n        periodicity = _periodicity;\n        auctionSize = _auctionSize;\n        prize = _prize;\n        minTx = _minTx;\n        counter = _counter;\n        startTime = _startTime;\n        elcoin = ElcoinInterface(getAddress(""elcoin""));\n        return true;\n    }\n\n    function transfer(address _from, address _to, uint _amount) checkAccess(""elcoin"") {\n        if (startTime > now || periodicity == 0 || auctionSize == 0 || prize == 0) {\n            return;\n        }\n        counter++;\n        if (_amount >= minTx && counter > periodicity - auctionSize) {\n            transactions.push(Transaction(_from, _amount));\n        }\n\n        if (counter >= periodicity) {\n            _prepareAndSendReward();\n            counter = 0;\n            round++;\n            delete transactions;\n        }\n    }\n\n    mapping(uint => mapping(address => uint)) public prizes;\n\n    function _prepareAndSendReward() internal {\n        uint amount = 0;\n        address[] memory winners = new address[](auctionSize);\n        uint winnerPosition = 0;\n        for (uint8 i = 0; i < transactions.length; i++) {\n            if (transactions[i].amount == amount) {\n                winners[winnerPosition++] = transactions[i].from;\n            }\n            if (transactions[i].amount > amount) {\n                amount = transactions[i].amount;\n                winnerPosition = 0;\n                winners[winnerPosition++] = transactions[i].from;\n            }\n        }\n        if (winnerPosition == 0) {\n            return;\n        }\n        address[] memory uniqueWinners = new address[](winnerPosition);\n        uint uniqueWinnerPosition = 0;\n        uint currentPrize = _is360thDay() ? prize*2 : prize;\n        uint reward = currentPrize / winnerPosition;\n        for (uint8 position = 0; position < winnerPosition; position++) {\n            address winner = winners[position];\n            if (prizes[round][winner] == 0) {\n                uniqueWinners[uniqueWinnerPosition++] = winner;\n            }\n            prizes[round][winner] += reward;\n        }\n        for (position = 0; position < uniqueWinnerPosition; position++) {\n            winner = uniqueWinners[position];\n            uint winnerReward = prizes[round][winner];\n            if (elcoin.rewardTo(winner, winnerReward)) {\n                Reward(winner, round, winnerReward, position);\n            }\n        }\n    }\n\n    function _is360thDay() internal constant returns(bool) {\n        if (startTime > now) {\n            return false;\n        }\n\n        return (((now - startTime) / 1 days) + 1) % 360 == 0;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1493852,0xe2e4d0d3410cd3e81bfcb7dad364dd168bb499f3,false,false,"/* A contract to store a state of goods (single item). Buy orders obtainable as events. */\n\n/* Deployment:\n*/\n\ncontract goods {\n\n    address public owner;\n    //status of the goods: Available, Pending, Sold, Canceled\n    uint16 public status;\n    //how many for sale\n    uint16 public count;\n    //price per item\n    uint public price;\n\n    uint16 public availableCount;\n    uint16 public pendingCount;\n\n    event log_event(string message);\n    event content(string datainfo, uint indexed version, uint indexed datatype, address indexed sender, uint count, uint payment);\n    modifier onlyowner { if (msg.sender == owner) _ } \n    \n    function goods(uint16 _count, uint _price) {\n        owner = msg.sender;\n        //status = Available\n        status = 1;\n        count = _count;\n        price = _price;\n\n        availableCount = count;\n        pendingCount = 0;\n    }\n    \n    function kill() onlyowner { suicide(owner); }\n\n    function flush() onlyowner {\n        owner.send(this.balance);\n    }\n\n    function log(string message) private {\n        log_event(message);\n    }\n\n    function buy(string datainfo, uint _version, uint16 _count) {\n        if(status != 1) { log(""status != 1""); throw; }\n        if(msg.value < (price * _count)) { log(""msg.value < (price * _count)""); throw; }\n        if(_count > availableCount) { log(""_count > availableCount""); throw; }\n\n        pendingCount += _count;\n\n        //Buy order to event log\n        content(datainfo, _version, 1, msg.sender, _count, msg.value);\n    }\n\n    function accept(string datainfo, uint _version, uint16 _count) onlyowner {\n        if(_count > availableCount) { log(""_count > availableCount""); return; }\n        if(_count > pendingCount) { log(""_count > pendingCount""); return; }\n        \n        pendingCount -= _count;\n        availableCount -= _count;\n\n        //Accept order to event log\n        content(datainfo, _version, 2, msg.sender, _count, 0);\n    }\n\n    function reject(string datainfo, uint _version, uint16 _count, address recipient, uint amount) onlyowner {\n        if(_count > pendingCount) { log(""_count > pendingCount""); return; }\n\n        pendingCount -= _count;\n        //send money back\n        recipient.send(amount);\n\n        //Reject order to event log\n        content(datainfo, _version, 3, msg.sender, _count, amount);\n    }\n\n    function cancel(string datainfo, uint _version) onlyowner {\n        //Canceled status\n        status = 2;\n\n        //Cancel order to event log\n        content(datainfo, _version, 4, msg.sender, availableCount, 0);\n    }\n}",1,実用的なコードで、商品管理を目的とした標準的なスマートコントラクトです。
1498181,0xfeeb8a968f0d7fd58e29fbfc525051f50ee2fedc,false,false,"contract Etheramid1{\n	function getParticipantById (uint id) constant public returns ( address inviter, address itself, uint totalPayout );\n	function getParticipantCount () public constant returns ( uint count );\n}\ncontract Etheramid2 {\n\n    struct Participant {\n        address inviter;\n        address itself;\n        uint totalPayout;\n    }\n    \n    mapping (address => Participant) Tree;\n    mapping (uint => address) Index;\n	\n	uint Count = 0;\n    address public top;\n    uint constant contribution = 1 ether;\n	\n 	Etheramid1 eth1 = Etheramid1(0x9758DA9B4D001Ed2d0DF46d25069Edf53750767a);\n	uint oldUserCount = eth1.getParticipantCount();\n	\n    function Etheramid2() {\n		moveOldUser(0);\n		top = Index[0];\n    }\n    \n    function() {\n		throw;\n    }\n    \n	function moveOldUser (uint id) public {\n		address inviter; \n		address itself; \n		uint totalPayout;\n		(inviter, itself, totalPayout) = eth1.getParticipantById(id);\n		if ((Tree[itself].inviter != 0x0) || (id >= oldUserCount)) throw;\n		addParticipant(inviter, itself, totalPayout);\n	}\n	\n    function getParticipantById (uint id) constant public returns ( address inviter, address itself, uint totalPayout ){\n		if (id >= Count) throw;\n		address ida = Index[id];\n        inviter = Tree[ida].inviter;\n        itself = Tree[ida].itself;\n        totalPayout = Tree[ida].totalPayout;\n    }\n	\n	function getParticipantByAddress (address adr) constant public returns ( address inviter, address itself, uint totalPayout ){\n		if (Tree[adr].itself == 0x0) throw;\n        inviter = Tree[adr].inviter;\n        itself = Tree[adr].itself;\n        totalPayout = Tree[adr].totalPayout;\n    }\n    \n    function addParticipant(address inviter, address itself, uint totalPayout) private{\n        Index[Count] = itself;\n		Tree[itself] = Participant( {itself: itself, inviter: inviter, totalPayout: totalPayout});\n        Count +=1;\n    }\n    \n    function getParticipantCount () public constant returns ( uint count ){\n       count = Count;\n    }\n    \n    function enter(address inviter) public {\n        uint amount = msg.value;\n        if ((amount < contribution) || (Tree[msg.sender].inviter != 0x0) || (Tree[inviter].inviter == 0x0)) {\n            msg.sender.send(msg.value);\n            throw;\n        }\n        \n        addParticipant(inviter, msg.sender, 0);\n        address next = inviter;\n        uint rest = amount;\n        uint level = 1;\n        while ( (next != top) && (level < 7) ){\n            uint toSend = rest/2;\n            next.send(toSend);\n            Tree[next].totalPayout += toSend;\n            rest -= toSend;\n            next = Tree[next].inviter;\n            level++;\n        }\n        next.send(rest);\n		Tree[next].totalPayout += rest;\n    }\n}",1,実用的な構造で、参加者管理と支払いを行う標準的なスマートコントラクトです。
1498288,0xfe1a96cd0bfb3245d83808b9aba6538576145920,true,false,"contract Ambi {\n    function getNodeAddress(bytes32 _name) constant returns (address);\n    function addNode(bytes32 _name, address _addr) external returns (bool);\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\n}\n\ncontract PotRewards {\n    function transfer(address _from, address _to, uint _amount);\n}\n\ncontract PosRewards {\n    function transfer(address _from, address _to);\n}\n\ncontract ElcoinInterface {\n    function rewardTo(address _to, uint _amount) returns (bool);\n}\n\ncontract EtherTreasuryInterface {\n    function withdraw(address _to, uint _value) returns(bool);\n}\n\ncontract MetaCoinInterface {\n	event Transfer(address indexed _from, address indexed _to, uint256 _value);\n	event Approved(address indexed _owner, address indexed _spender, uint256 _value);\n	event Unapproved(address indexed _owner, address indexed _spender);\n\n	function totalSupply() constant returns (uint256 supply){}\n	function balanceOf(address _owner) constant returns (uint256 balance){}\n	function transfer(address _to, uint256 _value) returns (bool success){}\n	function transferFrom(address _from, address _to, uint256 _value) returns (bool success){}\n	function approve(address _spender, uint256 _value) returns (bool success){}\n	function unapprove(address _spender) returns (bool success){}\n	function allowance(address _owner, address _spender) constant returns (uint256 remaining){}\n}\n\ncontract ElcoinDb {\n    function getBalance(address addr) constant returns(uint balance);\n    function deposit(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\n    function withdraw(address addr, uint amount, bytes32 hash, uint time) returns (bool res);\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract Elcoin is AmbiEnabled, MetaCoinInterface {\n\n    event Error(uint8 indexed code, address indexed origin, address indexed sender);\n\n    mapping (address => uint) public recoveredIndex;\n    address[] public recovered;\n\n    uint public totalSupply;\n    uint public absMinFee; // set up in 1/1000000 of Elcoin\n    uint public feePercent; // set up in 1/100 of percent, 10 is 0.1%\n    uint public absMaxFee; // set up in 1/1000000 of Elcoin\n    address public feeAddr;\n\n    function Elcoin() {\n        recovered.length++;\n        feeAddr = tx.origin;\n        _setFeeStructure(0, 0, 1);\n    }\n\n    function _db() internal constant returns (ElcoinDb) {\n        return ElcoinDb(getAddress(""elcoinDb""));\n    }\n\n    function _setFeeStructure(uint _absMinFee, uint _feePercent, uint _absMaxFee) internal returns (bool) {\n        if(_absMinFee < 0 || _feePercent < 0 || _feePercent > 10000 || _absMaxFee < 0 || _absMaxFee < _absMinFee) {\n            Error(1, tx.origin, msg.sender);\n            return false;\n        }\n        absMinFee = _absMinFee;\n        feePercent = _feePercent;\n        absMaxFee = _absMaxFee;\n        return true;\n    }\n\n    function _rawTransfer(ElcoinDb _db, address _from, address _to, uint _value) internal {\n        _db.withdraw(_from, _value, 0, 0);\n        uint fee = calculateFee(_value);\n        uint net = _value - fee;\n        _db.deposit(_to, net, 0, 0);\n\n        Transfer(_from, _to, _value);\n        if (fee > 0) {\n            _db.deposit(feeAddr, fee, 0, 0);\n        }\n    }\n\n    function _transfer(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\n        if (_value < absMinFee) {\n            return false;\n        }\n        if (_from == _to) {\n            return false;\n        }\n        uint balance = _db.getBalance(_from);\n\n        if (balance < _value) {\n            return false;\n        }\n        _rawTransfer(_db, _from, _to, _value);\n\n        return true;\n    }\n\n    function _transferWithReward(ElcoinDb _db, address _from, address _to, uint _value) internal returns (bool) {\n        if (!_transfer(_db, _from, _to, _value)) {\n            Error(2, tx.origin, msg.sender);\n            return false;\n        }\n\n        address pos = getAddress(""elcoinPoS"");\n        address pot = getAddress(""elcoinPoT"");\n        if (pos != 0x0) {\n            PosRewards(pos).transfer(_from, _to);\n        }\n        if (pot != 0x0) {\n            PotRewards(pot).transfer(_from, _to, _value);\n        }\n        return true;\n    }\n\n    function _recoverAccount(ElcoinDb _db, address _old, address _new) internal returns (bool) {\n        uint pos =  recovered.length++;\n        recovered[pos] = _old;\n        recoveredIndex[_old] = pos;\n        uint balance = _db.getBalance(_old);\n        var rv = _db.withdraw(_old, balance, 0, 0);\n        if (!rv) {\n            Error(5, tx.origin, msg.sender);\n            return false;\n        }\n        _db.deposit(_new, balance, 0, 0);\n\n        return true;\n    }\n\n    modifier notRecoveredAccount(address _account) {\n        if(recoveredIndex[_account] == 0x0) {\n            _\n        }\n        else {\n            return;\n        }\n    }\n\n    function balanceOf(address _account) constant returns (uint) {\n        return _db().getBalance(_account);\n    }\n\n    function calculateFee(uint _amount) constant returns (uint) {\n        uint fee = (_amount * feePercent) / 10000;\n\n        if (fee < absMinFee) {\n            return absMinFee;\n        }\n\n        if (fee > absMaxFee) {\n            return absMaxFee;\n        }\n\n        return fee;\n    }\n\n    function issueCoin(address _to, uint _value, uint _totalSupply) checkAccess(""currencyOwner"") returns (bool) {\n        if (totalSupply > 0) {\n            Error(6, tx.origin, msg.sender);\n            return false;\n        }\n\n        bool dep = _db().deposit(_to, _value, 0, 0);\n        totalSupply = _totalSupply;\n        return dep;\n    }\n\n    function batchTransfer(address[] _to, uint[] _value) checkAccess(""currencyOwner"") returns (bool) {\n        if (_to.length != _value.length) {\n            Error(7, tx.origin, msg.sender);\n            return false;\n        }\n\n        uint totalToSend = 0;\n        for (uint8 i = 0; i < _value.length; i++) {\n            totalToSend += _value[i];\n        }\n\n        ElcoinDb db = _db();\n        if (db.getBalance(msg.sender) < totalToSend) {\n            Error(8, tx.origin, msg.sender);\n            return false;\n        }\n\n        db.withdraw(msg.sender, totalToSend, 0, 0);\n        for (uint8 j = 0; j < _to.length; j++) {\n            db.deposit(_to[j], _value[j], 0, 0);\n            Transfer(msg.sender, _to[j], _value[j]);\n        }\n\n        return true;\n    }\n\n    function transfer(address _to, uint _value) returns (bool) {\n        uint startGas = msg.gas + transferCallGas;\n        if (!_transferWithReward(_db(), msg.sender, _to, _value)) {\n            return false;\n        }\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\n        return _refund(refund);\n    }\n\n    function transferPool(address _from, address _to, uint _value) checkAccess(""pool"") returns (bool) {\n        return _transferWithReward(_db(), _from, _to, _value);\n    }\n\n    function rewardTo(address _to, uint _amount) checkAccess(""reward"") returns (bool) {\n        bool result = _db().deposit(_to, _amount, 0, 0);\n        if (result) {\n            totalSupply += _amount;\n        }\n\n        return result;\n    }\n\n    function recoverAccount(address _old, address _new) checkAccess(""recovery"") notRecoveredAccount(_old) returns (bool) {\n        return _recoverAccount(_db(), _old, _new);\n    }\n\n    function setFeeAddr(address _feeAddr) checkAccess(""currencyOwner"") {\n        feeAddr = _feeAddr;\n    }\n\n    function setFee(uint _absMinFee, uint _feePercent, uint _absMaxFee) checkAccess(""cron"") returns (bool) {\n        return _setFeeStructure(_absMinFee, _feePercent, _absMaxFee);\n    }\n\n    uint public txGasPriceLimit = 21000000000;\n    uint public transferCallGas = 21000;\n    uint public refundGas = 15000;\n    EtherTreasuryInterface treasury;\n\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(""currencyOwner"") returns (bool) {\n        if (_txGasPriceLimit == 0) {\n            return false;\n        }\n        treasury = EtherTreasuryInterface(_treasury);\n        txGasPriceLimit = _txGasPriceLimit;\n        if (msg.value > 0 && !address(treasury).send(msg.value)) {\n            throw;\n        }\n        return true;\n    }\n\n    function updateRefundGas() checkAccess(""currencyOwner"") returns (uint) {\n        uint startGas = msg.gas;\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; // just to simulate calculations, dunno if optimizer will remove this.\n        if (!_refund(1)) {\n            return 0;\n        }\n        refundGas = startGas - msg.gas;\n        return refundGas;\n    }\n\n    function setOperationsCallGas(uint _transfer) checkAccess(""currencyOwner"") returns (bool) {\n        transferCallGas = _transfer;\n        return true;\n    }\n\n    function _refund(uint _value) internal returns (bool) {\n        if (tx.gasprice > txGasPriceLimit) {\n            return false;\n        }\n        return treasury.withdraw(tx.origin, _value);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1504041,0xa9e2320d9e6c17eb45a921cb2698b42256f5e142,false,false,"contract EthDig\n{\n    uint constant LifeTime = 30;\n    \n    address Owner = msg.sender;\n    address OutputAddress = msg.sender;\n    \n    uint64 Coef1=723;\n    uint64 Coef2=41665;\n    uint64 Coef3=600000;\n    \n    uint public ContributedAmount;\n    uint ContributedLimit = 10 ether;\n    \n    uint public CashForHardwareReturn;\n    uint public FreezedCash;\n    \n    uint16 UsersLength = 0;\n    mapping (uint16 => User) Users;\n    struct User{\n        address Address;\n        uint16 ContributionsLength;\n        mapping (uint16 => Contribution) Contributions;\n    }\n    struct Contribution{\n        uint CashInHarware;\n        uint CashFreezed;\n        \n        uint16 ProfitPercent;\n        uint NeedPayByDay;\n        \n        bool ReuseCashInHarware;\n        \n        uint DateCreated;\n        uint DateLastCheck;\n        uint AlreadyPaid;\n        \n        bool ReturnedHardwareCash;\n        bool Finished;\n    }\n    \n    function  ContributeInternal(uint16 userId,uint cashInHarware,uint cashFreezed,bool reuseCashInHarware) private{\n        Contribution contribution = Users[userId].Contributions[Users[userId].ContributionsLength];\n\n        contribution.CashInHarware = cashInHarware;\n        contribution.CashFreezed = cashFreezed;\n        \n        uint8 noFreezCoef = uint8 ((cashInHarware * 100) / (cashFreezed+cashInHarware));\n        contribution.ProfitPercent = uint16 (((Coef1 * noFreezCoef * noFreezCoef) + (Coef2 * noFreezCoef) + Coef3)/10000);//10000\n        \n        contribution.NeedPayByDay = (((cashInHarware + cashFreezed) /10000) * contribution.ProfitPercent)/LifeTime;\n        contribution.ReuseCashInHarware = reuseCashInHarware;\n        contribution.DateCreated = now;\n        contribution.DateLastCheck = now;\n        \n        Users[userId].ContributionsLength++;\n    }\n    function ContributeWithSender (bool reuseCashInHarware,uint8 freezeCoeff,address sender) {\n        if (msg.value == 0 || freezeCoeff>100 ||ContributedAmount + msg.value > ContributedLimit)\n        {\n            sender.send(msg.value);\n            return;\n        }\n        \n        uint16 userId = GetUserIdByAddress(sender);\n        if (userId == 65535)\n        {\n            userId = UsersLength;\n            Users[userId].Address = sender;\n            UsersLength ++;\n        }\n        \n        uint cashFreezed = ((msg.value/100)*freezeCoeff);\n        ContributeInternal(\n            userId,\n            msg.value - cashFreezed,\n            cashFreezed,\n            reuseCashInHarware\n            );\n        FreezedCash += cashFreezed;\n        ContributedAmount += msg.value;\n        \n        OutputAddress.send(msg.value - cashFreezed);\n    }\n    function Contribute (bool reuseCashInHarware,uint8 freezeCoeff) {\n        ContributeWithSender(reuseCashInHarware,freezeCoeff,msg.sender);\n    }\n    function ChangeReuseCashInHarware(bool newValue,uint16 userId,uint16 contributionId){\n        if (msg.sender != Users[userId].Address) return;\n        Users[userId].Contributions[contributionId].ReuseCashInHarware = newValue;\n    }\n    \n    function Triger(){\n        if (Owner != msg.sender) return;\n        \n        uint MinedTillLastPayment = this.balance - CashForHardwareReturn - FreezedCash;\n        bool NotEnoughCash = false;\n        \n        for(uint16 i=0;i<UsersLength;i++)\n        {\n            for(uint16 j=0;j<Users[i].ContributionsLength;j++)\n            {\n                Contribution contribution = Users[i].Contributions[j];\n                if (contribution.Finished || now - contribution.DateLastCheck < 1 days) continue;\n                \n                if (contribution.AlreadyPaid != contribution.NeedPayByDay * LifeTime)\n                {\n                    uint8 daysToPay = uint8((now - contribution.DateCreated)/1 days);\n                    if (daysToPay>LifeTime) daysToPay = uint8(LifeTime);\n                    uint needToPay = (daysToPay * contribution.NeedPayByDay) - contribution.AlreadyPaid;\n                    \n                    if (MinedTillLastPayment < needToPay)\n                    {\n                        NotEnoughCash = true;\n                    }\n                    else\n                    {\n                        if (needToPay > 100 finney || daysToPay == LifeTime)\n                        {\n                            MinedTillLastPayment -= needToPay;\n                            Users[i].Address.send(needToPay);\n                            contribution.AlreadyPaid += needToPay;\n                        }\n                    }\n                    contribution.DateLastCheck = now;\n                }\n\n                if (now > contribution.DateCreated + (LifeTime * 1 days) && !contribution.ReturnedHardwareCash)\n                {\n                    if (contribution.ReuseCashInHarware)\n                    {\n                        ContributeInternal(\n                            i,\n                            contribution.CashInHarware,\n                            contribution.CashFreezed,\n                            true\n                        );\n                        contribution.ReturnedHardwareCash = true;\n                    }\n                    else\n                    {\n                        if (CashForHardwareReturn >= contribution.CashInHarware)\n                        {\n                            CashForHardwareReturn -= contribution.CashInHarware;\n                            FreezedCash -= contribution.CashFreezed;\n                            ContributedAmount -= contribution.CashFreezed + contribution.CashInHarware;\n                            Users[i].Address.send(contribution.CashInHarware + contribution.CashFreezed);\n                            contribution.ReturnedHardwareCash = true;\n                        }\n                    }\n                }\n                \n                if (contribution.ReturnedHardwareCash && contribution.AlreadyPaid == contribution.NeedPayByDay * LifeTime)\n                {\n                    contribution.Finished = true;\n                }\n            }  \n        }\n        \n        if (!NotEnoughCash)\n        {\n            OutputAddress.send(MinedTillLastPayment);\n        }\n    }\n    \n    function ConfigureFunction(address outputAddress,uint contributedLimit,uint16 coef1,uint16 coef2,uint16 coef3)\n    {\n        if (Owner != msg.sender) return;\n        OutputAddress = outputAddress;\n        ContributedLimit = contributedLimit;\n        Coef1 = coef1;\n        Coef2 = coef2;\n        Coef3 = coef3;\n    }\n    \n    function SendCashForHardwareReturn(){\n        CashForHardwareReturn += msg.value;\n    }\n    function WithdrawCashForHardwareReturn(uint amount){\n        if (Owner != msg.sender || CashForHardwareReturn < amount) return;\n        Owner.send(amount);\n    }\n    \n    function GetUserIdByAddress (address userAddress) returns (uint16){\n        for(uint16 i=0; i<UsersLength;i++)\n        {\n            if (Users[i].Address == userAddress)\n                return i;\n        }\n        return 65535;\n    }\n    \n    function GetContributionInfo (uint16 userId,uint16 contributionId) \n    returns (uint a1,uint a2, uint16 a3,uint a4, bool a5,uint a6,uint a7,uint a8,bool a9,bool a10,address a11) \n    {\n        Contribution contribution = Users[userId].Contributions[contributionId];\n        a1 = contribution.CashInHarware;\n        a2 = contribution.CashFreezed;\n        a3 = contribution.ProfitPercent;\n        a4 = contribution.NeedPayByDay;\n        a5 = contribution.ReuseCashInHarware;\n        a6 = contribution.DateCreated;\n        a7 = contribution.DateLastCheck;\n        a8 = contribution.AlreadyPaid;\n        a9 = contribution.ReturnedHardwareCash;\n        a10 = contribution.Finished;\n        a11 = Users[userId].Address;\n    }\n    \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1509459,0xb39a89322379ed7d91dc2e8ae1b30989eaf91d41,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :                          \n//                                                                \n//   ROCK PAPER SCISSORS\n//   Challenge an opponent with an encrypted hand\n//   www.matching-ethers.com/rps                 \n//\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n\n//          STAKE : 0.5 ETH\n//          DRAW : Full refund\n//          WIN : 0.995 ETH (house : 0.005)\n//          EXPIRATION TIME : 1hour after duel starts (refreshed when one player reveals)\n//          If only one player reveals, he wins after 1 hour if the other doesn't reveal\n//          he will be paid automatically when other ppl play the game.\n//          If both player don't reveal and forget the bet, it is refunded (-house)\n\n//         HOW TO PLAY ?\n//         1- Send a encrypted Hand (generated on the game's website)\n//         2- Wait for opponent (can cancel if you wish)\n//         3- Once matched, reveal your hand with the appropriate function and your secret\n//         4- Wait for your duel to resolve and the automatic payout\n\n//         ENCRYPT YOUR HAND\n//         Encrypt your hands on the website or\n//         directly with web3.js :  web3.sha3(secret+hand)\n\n// exemple results with secret = ""testing""\n//hand = ""rock"" :  web3.sha3(""testing""+""rock"")\n// 0x8935dc293ca2ee08e33bad4f4061699a8f59ec637081944145ca19cbc8b39473\n//hand = ""paper"" : \n// 0x859743aa01286a6a1eba5dbbcc4cf8eeaf1cc953a3118799ba290afff7125501\n//hand = ""scissors"" : \n//0x35ccbb689808295e5c51510ed28a96a729e963a12d09c4a7a4ba000c9777e897\n\ncontract Crypted_RPS\n{\n    address owner;\n    uint256 gambleValue;\n    uint256 expirationTime;\n    uint256 house;\n    uint256 houseTotal;\n    modifier noEthSent(){\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n    modifier onlyOwner() {\n	    if (msg.sender!=owner) throw;\n	    _\n    }\n    modifier equalGambleValue() {\n	if (msg.value < gambleValue) throw;\n        if (msg.value > gambleValue) msg.sender.send(msg.value-gambleValue);\n	_\n    }\n\n    struct PlayerWaiting\n    {\n        bool full;\n        address player;\n        bytes32 cryptedHand;\n    }\n    PlayerWaiting playerWaiting;\n\n    struct Duel2Decrypt\n    {\n	address player_1;\n        bytes32 cryptedHand_1;\n        address player_2;\n 	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel2Decrypt[] duels2Decrypt;\n    uint firstActiveDuel2; //index du premier duel2 non resolu\n\n    struct Duel1Decrypt\n   {\n	address player_1;\n        string hand_1;\n        address player_2;\n	bytes32 cryptedHand_2;\n        bool decrypted;\n        uint256 timeStamp;\n    }\n    Duel1Decrypt[] duels1Decrypt;\n    uint firstActiveDuel1;\n\n    struct Result  \n    {\n       address player_1;\n       string hand_1;\n       address player_2;\n       string hand_2;\n       uint result; //0 draw, 1 wins, 2 wins\n    }\n    Result[] results;\n\n\n    mapping (address => uint) player_progress;\n    // 0 not here, 1 waiting, 2 2crypted, 3 1crypted\n    mapping (address => uint) player_bet_id;\n    mapping (address => uint) player_bet_position;\n\n    function getPlayerStatus(address player, uint option) constant returns (uint result)\n    {\n         if (option==0) {result = player_progress[player];}\n         else if (option==1) {result= player_bet_id[player];}\n         else if (option==2) {result = player_bet_position[player];}\n         return result;\n    }\n\n\n    mapping (string => mapping(string => int)) payoffMatrix;\n    //constructor\n    function Crypted_RPS()\n    {\n	owner= msg.sender;\n	gambleValue = 500000 szabo;\n        house = 2500 szabo;\n        expirationTime = 3600;   //1 hour\n        payoffMatrix[""rock""][""rock""] = 0;\n        payoffMatrix[""rock""][""paper""] = 2;\n        payoffMatrix[""rock""][""scissors""] = 1;\n        payoffMatrix[""paper""][""rock""] = 1;\n        payoffMatrix[""paper""][""paper""] = 0;\n        payoffMatrix[""paper""][""scissors""] = 2;\n        payoffMatrix[""scissors""][""rock""] = 2;\n        payoffMatrix[""scissors""][""paper""] = 1;\n        payoffMatrix[""scissors""][""scissors""] = 0;\n    }\n\n    function () {throw;} //no callback, use the functions to play\n\n    modifier payexpired2Duel{\n        if (duels2Decrypt.length>firstActiveDuel2 && duels2Decrypt[firstActiveDuel2].timeStamp + expirationTime <= now) {\n            duels2Decrypt[firstActiveDuel2].player_1.send(gambleValue-house);\n            duels2Decrypt[firstActiveDuel2].player_2.send(gambleValue-house);\n            houseTotal+=2*house;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_1]=0;\n            player_progress[duels2Decrypt[firstActiveDuel2].player_2]=0;\n            duels2Decrypt[firstActiveDuel2].decrypted = true;\n            updateFirstDuel2(firstActiveDuel2);\n        }\n        _\n    }\n\n    modifier payexpired1Duel{\n        if (duels1Decrypt.length>firstActiveDuel1 && (duels1Decrypt[firstActiveDuel1].timeStamp + expirationTime) < now) {\n            duels1Decrypt[firstActiveDuel1].player_1.send(2*(gambleValue-house));\n            houseTotal+=2*house;\n            duels1Decrypt[firstActiveDuel1].decrypted = true;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_1]=0;\n            player_progress[duels1Decrypt[firstActiveDuel1].player_2]=0;\n            results.push(Result(duels1Decrypt[firstActiveDuel1].player_1, duels1Decrypt[firstActiveDuel1].hand_1, duels1Decrypt[firstActiveDuel1].player_2,""expired"", 1));\n            updateFirstDuel1(firstActiveDuel1);\n           \n        }\n        _\n    }\n        \n\n    function cancelWaitingForOpponent()\n    noEthSent {\n        if (msg.sender==playerWaiting.player && playerWaiting.full)\n        {\n             msg.sender.send(gambleValue);\n             playerWaiting.full=false;\n             player_progress[msg.sender]=0;\n        }\n        else { throw;}\n    }	\n\n\n    function sendCryptedHand(bytes32 cryptedH)\n    equalGambleValue\n    payexpired2Duel\n    payexpired1Duel\n    {\n          uint progress = player_progress[msg.sender];\n          uint position = player_bet_position[msg.sender];\n          //one not resolved duel per player only\n          if ( progress==3 && position==1 )throw;\n          if (progress == 2 ) throw; \n          if (progress ==  1 ) throw; //no selfdueling\n          if (!playerWaiting.full) \n          {\n              playerWaiting.player=msg.sender;\n              playerWaiting.cryptedHand= cryptedH;\n              playerWaiting.full=true;\n              player_progress[msg.sender]=1;\n          }\n          else\n          {\n               duels2Decrypt.push( Duel2Decrypt(playerWaiting.player, playerWaiting.cryptedHand, msg.sender, cryptedH, false, now) );\n                player_progress[playerWaiting.player]=2;\n                player_bet_id[playerWaiting.player]=duels2Decrypt.length-1;\n                player_bet_position[playerWaiting.player]=0;\n                player_progress[msg.sender]=2;\n                player_bet_id[msg.sender]=duels2Decrypt.length-1;\n                player_bet_position[msg.sender]=1;         \n                playerWaiting.full=false;\n          }\n\n    }\n\n\n    function revealRock(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""rock"");\n        reveal(hashRevealed, ""rock"");\n    }\n    function revealPaper(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""paper"");\n        reveal(hashRevealed, ""paper"");\n    }\n    function revealScissors(string secret)\n    {\n        bytes32 hashRevealed = sha3(secret, ""scissors"");\n        reveal(hashRevealed, ""scissors"");\n    }\n\n    function reveal(bytes32 hashRevealed, string hand) private\n    noEthSent\n   {\n\n        uint progress =  getPlayerStatus(msg.sender,0);\n        uint bet_id     =  getPlayerStatus(msg.sender,1);\n        uint position  =  getPlayerStatus(msg.sender,2);\n        \n\n        bytes32 hashStored;        \n        if (progress==2)  //duel not revealed\n        { \n            if (position == 0)\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_1;\n            }\n            else\n            {\n                 hashStored = duels2Decrypt[bet_id].cryptedHand_2;\n            }\n        }\n        else if (progress==3 && position==1) //duel half revealed already\n        { \n                hashStored = duels1Decrypt[bet_id].cryptedHand_2;\n        }\n        else { throw;} //player has nothing to reveal\n\n	if (hashStored==hashRevealed)\n        {\n              decryptHand(hand, progress, bet_id, position);\n        }\n        else\n        {\n             throw; //wrong secret or hand\n         }\n    }\n    \n    function  decryptHand(string hand, uint progress, uint bet_id, uint position) private\n    {\n             address op_add;\n             bytes32 op_cH;\n\n         if (progress==2)\n         {  \n             if (position==0) \n             {\n                 op_add = duels2Decrypt[bet_id].player_2;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_2;\n\n             }\n             else\n             {\n                 op_add = duels2Decrypt[bet_id].player_1;\n                 op_cH = duels2Decrypt[bet_id].cryptedHand_1;\n             }\n\n              duels1Decrypt.push(Duel1Decrypt(msg.sender,hand,op_add, op_cH, false, now));\n              duels2Decrypt[bet_id].decrypted=true;\n              updateFirstDuel2(bet_id);\n              player_progress[msg.sender]=3;\n              player_bet_id[msg.sender]=duels1Decrypt.length-1;\n              player_bet_position[msg.sender]=0;\n              player_progress[op_add]=3;\n              player_bet_id[op_add]=duels1Decrypt.length-1;\n              player_bet_position[op_add]=1;\n\n         }\n         else if (progress==3 && position==1)\n         {\n              op_add = duels1Decrypt[bet_id].player_1;\n              string op_h = duels1Decrypt[bet_id].hand_1;\n              duels1Decrypt[bet_id].decrypted=true;\n              uint result = payDuel(op_add, op_h, msg.sender, hand);\n              results.push(Result(op_add, op_h, msg.sender,hand, result));\n              updateFirstDuel1(bet_id);\n              player_progress[msg.sender]=0;\n              player_progress[op_add]=0;\n          }\n     }\n\n     function updateFirstDuel2(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel2)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels2Decrypt.length && duels2Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel2=index;\n              return;\n          }\n      }\n\n     function updateFirstDuel1(uint bet_id) private\n     {\n         if (bet_id==firstActiveDuel1)\n         {   \n              uint index;\n              while (true) {\n                 if (index<duels1Decrypt.length && duels1Decrypt[index].decrypted){\n                     index=index+1;\n                 }\n                 else {break; }\n              }\n              firstActiveDuel1=index;\n              return;\n          }\n      }\n\n     // in case there is too much expired duels in queue for automatic payout, \n     //I can help to catch up\n     function manualPayExpiredDuel() \n     onlyOwner\n     payexpired2Duel\n     payexpired1Duel\n     noEthSent\n     {\n         return;\n     }\n\n     //payout\n     function payDuel(address player_1, string hand_1, address player_2, string hand_2) private returns(uint result) \n     {\n              if (payoffMatrix[hand_1][hand_2]==0) //draw\n              {player_1.send(gambleValue); player_2.send(gambleValue); result=0;}\n              else if (payoffMatrix[hand_1][hand_2]==1) //1 win\n              {player_1.send(2*(gambleValue-house)); result=1; houseTotal+=2*house;}\n              if (payoffMatrix[hand_1][hand_2]==2) //2 wins\n              {player_2.send(2*(gambleValue-house)); result=2; houseTotal+=2*house;}\n              return result;\n      }\n\n     function payHouse() \n     onlyOwner\n     noEthSent {\n         owner.send(houseTotal);\n         houseTotal=0;\n     }\n\n     function getFirstActiveDuel1() constant returns(uint fAD1) {\n         return firstActiveDuel1;}\n     function getLastDuel1() constant returns(uint lD1) {\n         return duels1Decrypt.length;}\n     function getDuel1(uint index) constant returns(address p1, string h1, address p2, bool dC, uint256 tS) {\n         p1 = duels1Decrypt[index].player_1;\n         h1 = duels1Decrypt[index].hand_1;\n         p2 = duels1Decrypt[index].player_2;\n         dC = duels1Decrypt[index].decrypted;\n         tS  = duels1Decrypt[index].timeStamp;\n     }\n\n     function getFirstActiveDuel2() constant returns(uint fAD2) {\n         return firstActiveDuel2;}\n     function getLastDuel2() constant returns(uint lD2) {\n         return duels2Decrypt.length;}\n     function getDuel2(uint index) constant returns(address p1, address p2, bool dC, uint256 tS) {\n         p1 = duels2Decrypt[index].player_1;\n         p2 = duels2Decrypt[index].player_2;\n         dC = duels2Decrypt[index].decrypted;\n         tS  = duels2Decrypt[index].timeStamp;\n     }\n\n     function getPlayerWaiting() constant returns(address p, bool full) {\n         p = playerWaiting.player;\n         full = playerWaiting.full;\n     }\n\n     function getLastResult() constant returns(uint lD2) {\n         return results.length;}\n     function getResults(uint index) constant returns(address p1, string h1, address p2, string h2, uint r) {\n         p1 = results[index].player_1;\n         h1 = results[index].hand_1;\n         p2 = results[index].player_2;\n         h2 = results[index].hand_2;\n         r = results[index].result;\n     }\n\n\n}",2,アスキーアートとコメントが詩的要素を加え、コードに芸術的な雰囲気を与えています。
1516094,0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed,false,false,/*\n  Copyright (c) 2015-2016 Oraclize SRL\n  Copyright (c) 2016 Oraclize LTD\n*/\n\ncontract OraclizeAddrResolver {\n\n    address public addr;\n\n    address owner;\n\n    function OraclizeAddrResolver(){\n        owner = msg.sender;\n    }\n\n    function changeOwner(address newowner){\n        if (msg.sender != owner) throw;\n        owner = newowner;\n    }\n\n    function getAddress() returns (address oaddr){\n        return addr;\n    }\n\n    function setAddr(address newaddr){\n        if (msg.sender != owner) throw;\n        addr = newaddr;\n    }\n\n},1,標準的なアドレス管理のスマートコントラクトで、特に芸術的要素はありません。
1518268,0xd05d56acd892f33010d93ddf6d9593511b618946,false,false,"contract DgxToken {\n  function approve(address _spender,uint256 _value) returns(bool success);\n  function totalSupply() constant returns(uint256 );\n  function transferFrom(address _from,address _to,uint256 _value) returns(bool success);\n  function balanceOf(address _owner) constant returns(uint256 balance);\n  function transfer(address _to,uint256 _value) returns(bool success);\n  function allowance(address _owner,address _spender) constant returns(uint256 remaining);\n}\n\ncontract SwapContract {\n \n  address public seller;\n  address public dgxContract;\n  uint256 public weiPrice;\n\n  modifier ifSeller() {\n    if (seller != msg.sender) {\n      throw;\n    } else {\n      _\n    }\n  }\n\n  function SwapContract(address _seller, uint256 _weiPrice) {\n    dgxContract = 0x55b9a11c2e8351b4ffc7b11561148bfac9977855;\n    seller = _seller;\n    weiPrice = _weiPrice;\n  }\n\n  function () {\n    if (dgxBalance() == 0) throw;\n    if (msg.value < totalWeiPrice()) throw;\n    if (DgxToken(dgxContract).transfer(address(this), dgxBalance())) {\n      seller.send(msg.value);       \n    }\n  }\n\n  function setWeiPrice(uint256 _newweiprice) ifSeller returns (bool _success) {\n    weiPrice = _newweiprice;\n    _success = true;\n    return _success;\n  }\n\n  function totalWeiPrice() public constant returns (uint256 _totalweiprice) {\n    _totalweiprice = dgxBalance() * weiPrice;\n    return _totalweiprice;\n  }\n\n  function dgxBalance() public constant returns (uint256 _dgxbalance) {\n    _dgxbalance = DgxToken(dgxContract).balanceOf(address(this));\n    return _dgxbalance;\n  }\n\n  function withdraw() ifSeller returns (bool _success) {\n    _success = DgxToken(dgxContract).transfer(seller, dgxBalance());\n    return _success;\n  }\n}\n\ncontract DgxSwap {\n\n  uint256 public totalCount;\n  mapping (address => address) public swapContracts;\n  mapping (uint256 => address) public sellers;\n\n  function DgxSwap() {\n    totalCount = 0;\n  }\n\n  function createSwap(uint256 _weiprice) public returns (bool _success) {\n    address _swapcontract = new SwapContract(msg.sender, _weiprice);\n    swapContracts[msg.sender] = _swapcontract;\n    sellers[totalCount] = msg.sender; \n    totalCount++;\n    _success = true;\n    return _success;\n  }\n\n  function getSwap(uint256 _id) public constant returns (address _seller, address _contract, uint256 _dgxbalance, uint256 _weiprice, uint256 _totalweiprice) {\n    _seller = sellers[_id];\n    if (_seller == 0x0000000000000000000000000000000000000000) {\n      _contract = 0x0000000000000000000000000000000000000000;\n      _dgxbalance = 0;\n      _weiprice = 0;\n      _totalweiprice = 0;\n    } else {\n      _contract = swapContracts[_seller];  \n      _dgxbalance = SwapContract(_contract).dgxBalance();\n      _weiprice = SwapContract(_contract).weiPrice();\n      _totalweiprice = SwapContract(_contract).totalWeiPrice();\n    }\n    return (_seller, _contract, _dgxbalance, _weiprice, _totalweiprice);\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1522625,0xc5912c5aa88d7c947c9510b3c8d76543c72ed98c,false,false,contract BCFSafe {\n    /* Time Deposit and Return Funds */\n    address owner;\n    uint lockTime;\n    function TimeDeposit() {\n owner = msg.sender;\n lockTime = now + 30 minutes;\n    }\n    function returnMyMoney(uint amount){\n        if (msg.sender==owner && now > lockTime) {\n            owner.send(amount);\n        }\n    }\n},1,基本的な時間制限付きの資金返還機能を持つ実用的なスマートコントラクト。
1534145,0xd18e21bb13d154a16793c6f89186a034a8116b74,false,false,"contract ZeroDollarHomePage {\n    event InvalidPullRequest(uint indexed pullRequestId);\n    event PullRequestAlreadyClaimed(uint indexed pullRequestId, uint timeBeforeDisplay, bool past);\n    event PullRequestClaimed(uint indexed pullRequestId, uint timeBeforeDisplay);\n    event QueueIsEmpty();\n\n    bool _handledFirst;\n    uint[] _queue;\n    uint _current;\n    address owner;\n\n    function ZeroDollarHomePage() {\n        owner = msg.sender;\n        _handledFirst = false;\n        _current = 0;\n    }\n\n    function remove() {\n        if (msg.sender == owner){\n            suicide(owner);\n        }\n    }\n\n    /*\n     * Register a new pull request.\n     */\n    function newRequest(uint pullRequestId) {\n        if (pullRequestId <= 0) {\n            InvalidPullRequest(pullRequestId);\n            return;\n        }\n\n        // Check that the pr hasn't already been claimed\n        bool found = false;\n        uint index = 0;\n\n        while (!found && index < _queue.length) {\n            if (_queue[index] == pullRequestId) {\n                found = true;\n                break;\n            } else {\n                index++;\n            }\n        }\n\n        if (found) {\n            PullRequestAlreadyClaimed(pullRequestId, (index - _current) * 1 days, _current > index);\n            return;\n        }\n\n        _queue.push(pullRequestId);\n        PullRequestClaimed(pullRequestId, (_queue.length - _current) * 1 days);\n    }\n\n    /*\n     * Close the current request in queue and move the queue to its next element.\n     */\n    function closeRequest() {\n        if (_handledFirst && _current < _queue.length - 1) {\n            _current += 1;\n        }\n\n        _handledFirst = true;\n    }\n\n    /*\n     * Get the last non published pull-request from the queue\n     */\n    function getLastNonPublished() constant returns (uint pullRequestId) {\n        if (_current >= _queue.length) {\n            return 0;\n        }\n\n        return _queue[_current];\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。イベントとキュー管理が中心。
1535931,0xe966652244b335a724a0465bb0b682e3885d3177,false,false,"contract Mortal {\n        address public owner;\n        function mortal() { owner = msg.sender; }\n        function kill() { if (msg.sender == owner) suicide(owner); }\n}\n\ncontract Thing is Mortal {\n        enum Mood { Agree, Disagree, Funny, Sad, Angry, Nothing }\n        // URL of the reaction - optional\n        string public url;\n        // Content of the reaction - optional\n        string public data;\n        // MIME type of the content - optional, default is text/plain\n        string public mimetype;\n        // Mood of the reaction - Mood.Nothing by default\n        Mood public mood;\n        Thing[] public reactions;\n\n        function thing( string _url\n                          , string _data\n                          , Mood _mood\n                          , string _mimetype) {\n                url = _url;\n                data = _data;\n                mimetype = _mimetype;\n                mood = _mood;\n        }\n\n        function react(Thing reaction) {\n                if (msg.sender != reaction.owner()) throw;\n\n                reactions.push(reaction);\n        }\n\n        function withdraw() {\n                if (msg.sender != owner) throw;\n\n                owner.send(this.balance);\n        }\n}",2,感情を表現する列挙型や反応のURLなど詩的な要素が含まれている。
1539037,0x45e42d659d9f9466cd5df622506033145a9b89bc,true,false,"contract tokenSpender { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\ncontract Nexium { \n	\n	\n	/* Public variables of the token */\n	string public name;\n	string public symbol;\n	uint8 public decimals;\n	uint256 public initialSupply;\n	address public burnAddress;\n\n	/* This creates an array with all balances */\n	mapping (address => uint) public balanceOf;\n	mapping (address => mapping (address => uint)) public allowance;\n\n	/* This generates a public event on the blockchain that will notify clients */\n	event Transfer(address indexed from, address indexed to, uint value);\n	event Approval(address indexed from, address indexed spender, uint value);\n\n	\n	\n	/* Initializes contract with initial supply tokens to the creator of the contract */\n	function Nexium() {\n		initialSupply = 100000000000;\n		balanceOf[msg.sender] = initialSupply;             // Give the creator all initial tokens                    \n		name = 'Nexium';                                 // Set the name for display purposes     \n		symbol = 'NxC';                               	 // Set the symbol for display purposes    \n		decimals = 3;                           		 // Amount of decimals for display purposes\n		burnAddress = 0x1b32000000000000000000000000000000000000;\n	}\n	\n	function totalSupply() returns(uint){\n		return initialSupply - balanceOf[burnAddress];\n	}\n\n	/* Send coins */\n	function transfer(address _to, uint256 _value) \n	returns (bool success) {\n		if (balanceOf[msg.sender] >= _value && _value > 0) {\n			balanceOf[msg.sender] -= _value;\n			balanceOf[_to] += _value;\n			Transfer(msg.sender, _to, _value);\n			return true;\n		} else return false; \n	}\n\n	/* Allow another contract to spend some tokens in your behalf */\n\n	\n	\n	function approveAndCall(address _spender,\n							uint256 _value,\n							bytes _extraData)\n	returns (bool success) {\n		allowance[msg.sender][_spender] = _value;     \n		tokenSpender spender = tokenSpender(_spender);\n		spender.receiveApproval(msg.sender, _value, this, _extraData);\n		Approval(msg.sender, _spender, _value);\n		return true;\n	}\n	\n	\n	\n	/*Allow another adress to use your money but doesn't notify it*/\n	function approve(address _spender, uint256 _value) returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n	\n	\n	/* A contract attempts to get the coins */\n	function transferFrom(address _from,\n						  address _to,\n						  uint256 _value)\n	returns (bool success) {\n		if (balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value && _value > 0) {\n			balanceOf[_to] += _value;\n			Transfer(_from, _to, _value);\n			balanceOf[_from] -= _value;\n			allowance[_from][msg.sender] -= _value;\n			return true;\n		} else return false; \n	}\n\n	\n	\n	/* This unnamed function is called whenever someone tries to send ether to it */\n	function () {\n		throw;     // Prevents accidental sending of ether\n	}        \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1541103,0xeb17adcc8cf24d2d6813f50f647b613df01014a2,false,false,"contract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		https://d.ethereumlottery.net\n		ver: 1.0.0\n	*/\n	address private owner;\n	uint private constant fee = 5;\n	uint private constant investorFee = 50;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraDifficulty = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant minimumRollDiv = 10;\n	uint private constant difficultyMultipler = 1000000;\n	uint private constant investMinDuration = 1 days;\n	\n    bool public ContractEnabled = true;\n    uint public ContractDisabledBlock;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] investors;\n	\n	string constant public Information = ""https://d.ethereumlottery.net"";\n	\n	function ChanceOfWinning(uint Bet) constant returns(uint Rate) {\n		Rate = getDifficulty(Bet);\n		if (Bet < minimumRollPrice) { Rate = 0; }\n		if (jackpot_/minimumRollDiv < Bet) { Rate = 0; }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = jackpot_/minimumRollDiv;\n	}\n	function Investors(uint id) constant returns(address Owner, uint Investment, uint Balance, bool Live) {\n		if (id < investors.length) {\n			Owner = investors[id].owner;\n			Investment = investors[id].value;\n			Balance = investors[id].balance;\n			Live = investors[id].live;\n		} else {\n			Owner = 0;\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n	}\n	function dEthereumlotteryNet() {\n		owner = msg.sender;\n	}\n	function Invest() OnlyEnabled external {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if (msg.sender.send(value_ % investUnit) == false) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].valid == false) {\n				newInvest(a,msg.sender,value_);\n				return;\n			}\n		}\n		investors.length++;\n		newInvest(investors.length-1,msg.sender,value_);\n	}\n	function newInvest(uint investorsID, address investor, uint value) private {\n		investors[investorsID].owner = investor;\n		investors[investorsID].value = value;\n		investors[investorsID].balance = 0;\n		investors[investorsID].valid = true;\n		investors[investorsID].live = true;\n		investors[investorsID].timestamp = now + investMinDuration;\n		jackpot_ += value;\n		setJackpot();\n	}\n	function GetMyInvestFee() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].owner == msg.sender && investors[a].valid == true) {\n				balance_ = investors[a].balance;\n				investors[a].valid = false;\n			}\n		}\n		if (balance_ > 0) { if (msg.sender.send(balance_) == false) { throw; } }\n	}\n	function CancelMyInvest() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].owner == msg.sender && investors[a].valid == true && investors[a].timestamp < now) {\n				if (investors[a].live == true) {\n					balance_ = investors[a].value + investors[a].balance;\n					jackpot_ -= investors[a].value;\n					delete investors[a];\n				} else {\n					balance_ = investors[a].balance;\n					delete investors[a];\n				}\n			}\n		}\n		setJackpot();\n		if (balance_ > 0) { if (msg.sender.send(balance_) == false) { throw; } }\n	}\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function DoRoll() external {\n		reFund();\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid == true) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if (ContractEnabled == false || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if (value_ > 0) { if (msg.sender.send(value_) == false) { throw; } }\n		if (found == false) { throw; }\n	}\n	event RollEvent(address Player,uint Difficulty, uint Result, uint Number, uint Win);\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint difficulty_ = getDifficulty(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber * difficultyMultipler % difficulty_ == 0) {\n			win = Jackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n		}\n		RollEvent(msg.sender, difficulty_, bigNumber * difficultyMultipler % difficulty_, bigNumber * difficultyMultipler,win);\n		delete players[msg.sender][id];\n	}\n	function getDifficulty(uint value) private returns(uint){\n		return jackpot_ * difficultyMultipler / value * 100 / investorFee * extraDifficulty / 100;\n	}\n	function investorAddFee(uint value) private {\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live == true) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n			}\n		}\n	}\n	event PrepareRollEvent(address Player, uint Block);\n	function prepareRoll(uint rollID, uint seed) private {\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = msg.value;\n		players[msg.sender][rollID].game = JackpotHits;\n		RollCount++;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber);\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_/minimumRollDiv < msg.value) { throw; }\n		if (jackpot_ == 0) { throw; }\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if (players[msg.sender][a].valid == false) {\n				prepareRoll(a,seed);\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll(players[msg.sender].length-1,seed);\n	}\n	function () {\n		PrepareRoll(0);\n	}\n	function reFund() private { if (msg.value > 0) { if (msg.sender.send(msg.value) == false) { throw; } } }\n	function OwnerCloseContract() external OnlyOwner {\n		reFund();\n		if (ContractEnabled == false) {\n		    if (ContractDisabledBlock < block.number) {\n		        uint balance_ = this.balance;\n		        for ( uint a=0 ; a < investors.length ; a++ ) {\n		            balance_ -= investors[a].balance;\n		        }\n		        if (balance_ > 0) {\n                    if (msg.sender.send(balance_) == false) { throw; }\n		        }\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner {\n		reFund();\n		if (feeValue == 0) { throw; }\n		if (owner.send(feeValue) == false) { throw; }\n		feeValue = 0;\n	}\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if (!ContractEnabled) { throw; } _	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1570320,0x838b3606489c5a0e4d97ed113d4aa8d324f4a330,true,false,"contract MultiAsset {\n    function owner(bytes32 _symbol) constant returns(address);\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract OpenDollar {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\n            return false;\n        }\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\n            return false;\n        }\n        return true;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\n            return false;\n        }\n        return true;\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() returns(bool) {\n        return multiAsset.transfer(multiAsset.owner(symbol), balanceOf(address(this)), symbol);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1577200,0x63dd6f40007731eb7e70a7ae43b55c0fb2090c99,false,false,"/*\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n    function balanceOf(address _owner) constant returns (uint256 balance);\n    function transfer(address _to, uint256 _amount) returns (bool success);\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n    function approve(address _spender, uint256 _amount) returns (bool success);\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\n// compiled using https://ethereum.github.io/browser-solidity/#version=soljson-v0.3.2-2016-05-20-e3c5418.js&optimize=true\ncontract Token_Offer {\n  address public tokenHolder;\n  address public owner;\n  TokenInterface public tokenContract;\n  uint16 public price;  // price in ETH per 100000 tokens. Price 2250 means 2.25 ETH per 100 tokens\n  uint public tokensPurchasedTotal;\n  uint public ethCostTotal;\n\n  event TokensPurchased(address buyer, uint16 price, uint tokensPurchased, uint ethCost, uint ethSent, uint ethReturned, uint tokenSupplyLeft);\n  event Log(string msg, uint val);\n\n  modifier onlyOwnerAllowed() {if (tx.origin != owner) throw; _}\n\n  function Token_Offer(address _tokenContract, address _tokenHolder, uint16 _price)  {\n    owner = tx.origin;\n    tokenContract = TokenInterface(_tokenContract);\n    tokenHolder = _tokenHolder;\n    price = _price;\n  }\n\n  function tokenSupply() constant returns (uint tokens) {\n    uint allowance = tokenContract.allowance(tokenHolder, address(this));\n    uint balance = tokenContract.balanceOf(tokenHolder);\n    if (allowance < balance) return allowance;\n    else return balance;\n  }\n\n  function () {\n    buyTokens(price);\n  }\n\n  function buyTokens() {\n    buyTokens(price);\n  }\n\n  /// @notice DON'T BUY FROM EXCHANGE! Only buy from normal account in your full control (private key).\n  /// @param _bidPrice Price in ETH per 100000 tokens. _bidPrice 2250 means 2.25 ETH per 100 tokens.\n  function buyTokens(uint16 _bidPrice) {\n    if (tx.origin != msg.sender) { // buyer should be able to handle TheDAO (vote, transfer, ...)\n      if (!msg.sender.send(msg.value)) throw; // send ETH back to sender's contract\n      Log(""Please send from a normal account, not contract/multisig"", 0);\n      return;\n    }\n    if (price == 0) {\n      if (!tx.origin.send(msg.value)) throw; // send ETH back\n      Log(""Contract disabled"", 0);\n      return;\n    }\n    if (_bidPrice < price) {\n      if (!tx.origin.send(msg.value)) throw; // send ETH back\n      Log(""Bid too low, price is:"", price);\n      return;\n    }\n    if (msg.value == 0) {\n      Log(""No ether received"", 0);\n      return;\n    }\n    uint _tokenSupply = tokenSupply();\n    if (_tokenSupply == 0) {\n      if (!tx.origin.send(msg.value)) throw; // send ETH back\n      Log(""No tokens available, please try later"", 0);\n      return;\n    }\n\n    uint _tokensToPurchase = (msg.value * 1000) / price;\n\n    if (_tokensToPurchase <= _tokenSupply) { // contract has enough tokens to complete order\n      if (!tokenContract.transferFrom(tokenHolder, tx.origin, _tokensToPurchase)) // send tokens\n        throw;\n      tokensPurchasedTotal += _tokensToPurchase;\n      ethCostTotal += msg.value;\n      TokensPurchased(tx.origin, price, _tokensToPurchase, msg.value, msg.value, 0, _tokenSupply-_tokensToPurchase);\n\n    } else { // contract low on tokens, partial order execution\n      uint _supplyInEth = (_tokenSupply * price) / 1000;\n      if (!tx.origin.send(msg.value-_supplyInEth)) // return extra eth\n        throw;\n      if (!tokenContract.transferFrom(tokenHolder, tx.origin, _tokenSupply)) // send tokens\n        throw;\n      tokensPurchasedTotal += _tokenSupply;\n      ethCostTotal += _supplyInEth;\n      TokensPurchased(tx.origin, price, _tokenSupply, _supplyInEth, msg.value, msg.value-_supplyInEth, 0);\n    }\n  }\n\n  /* == functions below are for owner only == */\n  function setPrice(uint16 _price) onlyOwnerAllowed {\n    price = _price;\n    Log(""Price changed:"", price); // watch the contract to see updates\n  }\n  function tokenSupplyChanged() onlyOwnerAllowed {\n    Log(""Supply changed, new supply:"", tokenSupply()); // watch the contract to see updates\n  }\n  function setTokenHolder(address _tokenHolder) onlyOwnerAllowed {\n    tokenHolder = _tokenHolder;\n  }\n  function setOwner(address _owner) onlyOwnerAllowed {\n    owner = _owner;\n  }\n  function transferETH(address _to, uint _amount) onlyOwnerAllowed {\n    if (_amount > address(this).balance) {\n      _amount = address(this).balance;\n    }\n    _to.send(_amount);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1580751,0xf36b0f457999cbbb436eeb28dbb5944bfc3f99de,false,false,"contract tickingBomb {\n\n    struct team {\n        string name;\n        uint lastUpdate;\n        address[] members;\n        uint nbrMembers;\n    }\n\n    uint public constant DELAY =  60 * 60 * 24; // 24 Hours\n    uint public constant INVEST_AMOUNT = 1000 finney; // 1 ETH\n    uint constant FEE = 3;\n\n    team public red;\n    team public blue;\n\n    mapping(address => uint) public balances;\n    address creator;\n\n    string[] public historyWinner;\n    uint[] public historyRed;\n    uint[] public historyBlue;\n    uint public gameNbr;\n\n    function tickingBomb() {\n        newRound();\n        creator = msg.sender;\n        gameNbr = 0;\n    }\n\n    function helpRed() {\n        uint i;\n        uint amount = msg.value;\n\n        // Check if Exploded, if so save the previous game\n        // And create a new round\n        checkIfExploded();\n\n        // Update the TimeStamp\n        red.lastUpdate = block.timestamp;\n\n        // Split the incoming money every INVEST_AMOUNT\n        while (amount >= INVEST_AMOUNT) {\n            red.members.push(msg.sender);\n            red.nbrMembers++;\n            amount -= INVEST_AMOUNT;\n        }\n\n        // If there is still some money in the balance, sent it back\n        if (amount > 0) {\n            msg.sender.send(amount);\n        }\n    }\n\n    function helpBlue() {\n        uint i;\n        uint amount = msg.value;\n\n        // Check if Exploded, if so save the previous game\n        // And create a new game\n        checkIfExploded();\n\n        // Update the TimeStamp\n        blue.lastUpdate = block.timestamp;\n\n        // Split the incoming money every 100 finneys\n        while (amount >= INVEST_AMOUNT) {\n            blue.members.push(msg.sender);\n            blue.nbrMembers++;\n            amount -= INVEST_AMOUNT;\n        }\n\n        // If there is still some money in the balance, sent it back\n        if (amount > 0) {\n            msg.sender.send(amount);\n        }\n    }\n\n    function checkIfExploded() {\n        if (checkTime()) {\n            newRound();\n        }\n    }\n\n    function checkTime() private returns(bool exploded) {\n        uint i;\n        uint lostAmount = 0;\n        uint gainPerMember = 0;\n        uint feeCollected = 0;\n\n        // If Red and Blue have exploded at the same time, return the amounted invested\n        if (red.lastUpdate == blue.lastUpdate && red.lastUpdate + DELAY < block.timestamp) {\n            for (i = 0; i < red.members.length; i++) {\n                balances[red.members[i]] += INVEST_AMOUNT;\n            }\n            for (i = 0; i < blue.members.length; i++) {\n                balances[blue.members[i]] += INVEST_AMOUNT;\n            }\n\n            historyWinner.push('Tie between Red and Blue');\n            historyRed.push(red.nbrMembers);\n            historyBlue.push(blue.nbrMembers);\n            gameNbr++;\n            return true;\n        }\n\n        // Take the older timestamp\n        if (red.lastUpdate < blue.lastUpdate) {\n            // Check if the Red bomb exploded\n            if (red.lastUpdate + DELAY < block.timestamp) {\n                // Calculate the lost amount by the red team\n                // Number of Red member * Invested amount per user  *\n                feeCollected += (red.nbrMembers * INVEST_AMOUNT * FEE / 100);\n                balances[creator] += feeCollected;\n                lostAmount = (red.nbrMembers * INVEST_AMOUNT) - feeCollected;\n\n                gainPerMember = lostAmount / blue.nbrMembers;\n                for (i = 0; i < blue.members.length; i++) {\n                    balances[blue.members[i]] += (INVEST_AMOUNT + gainPerMember);\n                }\n\n                historyWinner.push('Red');\n                historyRed.push(red.nbrMembers);\n                historyBlue.push(blue.nbrMembers);\n                gameNbr++;\n                return true;\n            }\n            return false;\n        } else {\n            // Check if the Blue bomb exploded\n            if (blue.lastUpdate + DELAY < block.timestamp) {\n                // Calculate the lost amount by the red team\n                // Number of Red member * Invested amount per user  *\n                feeCollected += (blue.nbrMembers * INVEST_AMOUNT * FEE / 100);\n                balances[creator] += feeCollected;\n                lostAmount = (blue.nbrMembers * INVEST_AMOUNT) - feeCollected;\n                gainPerMember = lostAmount / red.nbrMembers;\n                for (i = 0; i < red.members.length; i++) {\n                    balances[red.members[i]] += (INVEST_AMOUNT + gainPerMember);\n                }\n\n                historyWinner.push('Blue');\n                historyRed.push(red.nbrMembers);\n                historyBlue.push(blue.nbrMembers);\n                gameNbr++;\n                return true;\n            }\n            return false;\n        }\n    }\n\n    function newRound() private {\n        red.name = ""Red team"";\n        blue.name = ""Blue team"";\n        red.lastUpdate = block.timestamp;\n        blue.lastUpdate = block.timestamp;\n        red.nbrMembers = 0;\n        blue.nbrMembers = 0;\n        red.members = new address[](0);\n        blue.members = new address[](0);\n    }\n\n    function() {\n        // Help the oldest timestamp (going to explode first)\n        if (red.lastUpdate < blue.lastUpdate) {\n            helpRed();\n        } else {\n            helpBlue();\n        }\n    }\n\n    function collectBalance() {\n        msg.sender.send(balances[msg.sender]);\n        balances[msg.sender] = 0;\n    }\n\n    // Allow the creator to send their balances to the players\n    function sendBalance(address player) {\n        if (msg.sender == creator) {\n            player.send(balances[player]);\n        }\n    }\n\n    function newOwner(address newOwner) {\n        if (msg.sender == creator) {\n            creator = newOwner;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックが中心で芸術性は低い。
1595053,0x48b4cb193b587c6f2dab1a9123a7bd5e7d490ced,false,false,contract SimpleStorage {\n  uint storedData;\n\n  function set(uint x) {\n    storedData = x;\n  }\n\n  function get() constant returns (uint retVal) {\n    return storedData;\n  }\n},1,基本的なストレージ機能を持つシンプルなスマートコントラクト。
1596890,0xf8c35f1cf2dc4dbeaeeb2ecb298a80b506a5781d,false,false,"contract ManagedAccountInterface {\n    // The only address with permission to withdraw from this account\n    address public owner;\n    // If true, only the owner of the account can receive ether from it\n    bool public payOwnerOnly;\n    // The sum of ether (in wei) which has been sent to this contract\n    uint public accumulatedInput;\n\n    /// @notice Sends `_amount` of wei to _recipient\n    /// @param _amount The amount of wei to send to `_recipient`\n    /// @param _recipient The address to receive `_amount` of wei\n    /// @return True if the send completed\n    function payOut(address _recipient, uint _amount) returns (bool);\n\n    event PayOut(address indexed _recipient, uint _amount);\n}\n\n\ncontract ManagedAccount is ManagedAccountInterface{\n\n    // The constructor sets the owner of the account\n    function ManagedAccount(address _owner, bool _payOwnerOnly) {\n        owner = _owner;\n        payOwnerOnly = _payOwnerOnly;\n    }\n\n    // When the contract receives a transaction without data this is called. \n    // It counts the amount of ether it receives and stores it in \n    // accumulatedInput.\n    function() {\n        accumulatedInput += msg.value;\n    }\n\n    function payOut(address _recipient, uint _amount) returns (bool) {\n        if (msg.sender != owner || msg.value > 0 || (payOwnerOnly && _recipient != owner))\n            throw;\n        if (_recipient.call.value(_amount)()) {\n            PayOut(_recipient, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n}\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\ncontract TokenCreationInterface {\n\n    // End of token creation, in Unix time\n    uint public closingTime;\n    // Minimum fueling goal of the token creation, denominated in tokens to\n    // be created\n    uint public minTokensToCreate;\n    // True if the DAO reached its minimum fueling goal, false otherwise\n    bool public isFueled;\n    // For DAO splits - if privateCreation is 0, then it is a public token\n    // creation, otherwise only the address stored in privateCreation is\n    // allowed to create tokens\n    address public privateCreation;\n    // hold extra ether which has been sent after the DAO token\n    // creation rate has increased\n    ManagedAccount public extraBalance;\n    // tracks the amount of wei given from each contributor (used for refund)\n    mapping (address => uint256) weiGiven;\n\n    /// @dev Constructor setting the minimum fueling goal and the\n    /// end of the Token Creation\n    /// @param _minTokensToCreate Minimum fueling goal in number of\n    ///        Tokens to be created\n    /// @param _closingTime Date (in Unix time) of the end of the Token Creation\n    /// @param _privateCreation Zero means that the creation is public.  A\n    /// non-zero address represents the only address that can create Tokens\n    /// (the address can also create Tokens on behalf of other accounts)\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function TokenCreation(\n        //  uint _minTokensTocreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `_tokenHolder` as the initial owner of the Token\n    /// @param _tokenHolder The address of the Tokens's recipient\n    /// @return Whether the token creation was successful\n    function createTokenProxy(address _tokenHolder) returns (bool success);\n\n    /// @notice Refund `msg.sender` in the case the Token Creation did\n    /// not reach its minimum fueling goal\n    function refund();\n\n    /// @return The divisor used to calculate the token creation rate during\n    /// the creation phase\n    function divisor() constant returns (uint divisor);\n\n    event FuelingToDate(uint value);\n    event CreatedToken(address indexed to, uint amount);\n    event Refund(address indexed to, uint value);\n}\n\n\ncontract TokenCreation is TokenCreationInterface, Token {\n    function TokenCreation(\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation) {\n\n        closingTime = _closingTime;\n        minTokensToCreate = _minTokensToCreate;\n        privateCreation = _privateCreation;\n        extraBalance = new ManagedAccount(address(this), true);\n    }\n\n    function createTokenProxy(address _tokenHolder) returns (bool success) {\n        if (now < closingTime && msg.value > 0\n            && (privateCreation == 0 || privateCreation == msg.sender)) {\n\n            uint token = (msg.value * 20) / divisor();\n            extraBalance.call.value(msg.value - token)();\n            balances[_tokenHolder] += token;\n            totalSupply += token;\n            weiGiven[_tokenHolder] += msg.value;\n            CreatedToken(_tokenHolder, token);\n            if (totalSupply >= minTokensToCreate && !isFueled) {\n                isFueled = true;\n                FuelingToDate(totalSupply);\n            }\n            return true;\n        }\n        throw;\n    }\n\n    function refund() noEther {\n        if (now > closingTime && !isFueled) {\n            // Get extraBalance - will only succeed when called for the first time\n            if (extraBalance.balance >= extraBalance.accumulatedInput())\n                extraBalance.payOut(address(this), extraBalance.accumulatedInput());\n\n            // Execute refund\n            if (msg.sender.call.value(weiGiven[msg.sender])()) {\n                Refund(msg.sender, weiGiven[msg.sender]);\n                totalSupply -= balances[msg.sender];\n                balances[msg.sender] = 0;\n                weiGiven[msg.sender] = 0;\n            }\n        }\n    }\n\n    function divisor() constant returns (uint divisor) {\n        // The number of (base unit) tokens per wei is calculated\n        // as `msg.value` * 20 / `divisor`\n        // The fueling period starts with a 1:1 ratio\n        if (closingTime - 2 weeks > now) {\n            return 20;\n        // Followed by 10 days with a daily creation rate increase of 5%\n        } else if (closingTime - 4 days > now) {\n            return (20 + (now - (closingTime - 2 weeks)) / (1 days));\n        // The last 4 days there is a constant creation rate ratio of 1:1.5\n        } else {\n            return 30;\n        }\n    }\n}\n\ncontract DAOInterface {\n\n    // The amount of days for which people who try to participate in the\n    // creation by calling the fallback function will still get their ether back\n    uint constant creationGracePeriod = 40 days;\n    // The minimum debate period that a generic proposal can have\n    uint constant minProposalDebatePeriod = 2 weeks;\n    // The minimum debate period that a split proposal can have\n    uint constant minSplitDebatePeriod = 1 weeks;\n    // Period of days inside which it's possible to execute a DAO split\n    uint constant splitExecutionPeriod = 27 days;\n    // Period of time after which the minimum Quorum is halved\n    uint constant quorumHalvingPeriod = 25 weeks;\n    // Period after which a proposal is closed\n    // (used in the case `executeProposal` fails because it throws)\n    uint constant executeProposalPeriod = 10 days;\n    // Denotes the maximum proposal deposit that can be given. It is given as\n    // a fraction of total Ether spent plus balance of the DAO\n    uint constant maxDepositDivisor = 100;\n\n    // Proposals to spend the DAO's ether or to choose a new Curator\n    Proposal[] public proposals;\n    // The quorum needed for each proposal is partially calculated by\n    // totalSupply / minQuorumDivisor\n    uint public minQuorumDivisor;\n    // The unix time of the last time quorum was reached on a proposal\n    uint  public lastTimeMinQuorumMet;\n\n    // Address of the curator\n    address public curator;\n    // The whitelist: List of addresses the DAO is allowed to send ether to\n    mapping (address => bool) public allowedRecipients;\n\n    // Tracks the addresses that own Reward Tokens. Those addresses can only be\n    // DAOs that have split from the original DAO. Conceptually, Reward Tokens\n    // represent the proportion of the rewards that the DAO has the right to\n    // receive. These Reward Tokens are generated when the DAO spends ether.\n    mapping (address => uint) public rewardToken;\n    // Total supply of rewardToken\n    uint public totalRewardToken;\n\n    // The account used to manage the rewards which are to be distributed to the\n    // DAO Token Holders of this DAO\n    ManagedAccount public rewardAccount;\n\n    // The account used to manage the rewards which are to be distributed to\n    // any DAO that holds Reward Tokens\n    ManagedAccount public DAOrewardAccount;\n\n    // Amount of rewards (in wei) already paid out to a certain DAO\n    mapping (address => uint) public DAOpaidOut;\n\n    // Amount of rewards (in wei) already paid out to a certain address\n    mapping (address => uint) public paidOut;\n    // Map of addresses blocked during a vote (not allowed to transfer DAO\n    // tokens). The address points to the proposal ID.\n    mapping (address => uint) public blocked;\n\n    // The minimum deposit (in wei) required to submit any proposal that is not\n    // requesting a new Curator (no deposit is required for splits)\n    uint public proposalDeposit;\n\n    // the accumulated sum of all current proposal deposits\n    uint sumOfProposalDeposits;\n\n    // Contract that is able to create a new DAO (with the same code as\n    // this one), used for splits\n    DAO_Creator public daoCreator;\n\n    // A proposal with `newCurator == false` represents a transaction\n    // to be issued by this DAO\n    // A proposal with `newCurator == true` represents a DAO split\n    struct Proposal {\n        // The address where the `amount` will go to if the proposal is accepted\n        // or if `newCurator` is true, the proposed Curator of\n        // the new DAO).\n        address recipient;\n        // The amount to transfer to `recipient` if the proposal is accepted.\n        uint amount;\n        // A plain text description of the proposal\n        string description;\n        // A unix timestamp, denoting the end of the voting period\n        uint votingDeadline;\n        // True if the proposal's votes have yet to be counted, otherwise False\n        bool open;\n        // True if quorum has been reached, the votes have been counted, and\n        // the majority said yes\n        bool proposalPassed;\n        // A hash to check validity of a proposal\n        bytes32 proposalHash;\n        // Deposit in wei the creator added when submitting their proposal. It\n        // is taken from the msg.value of a newProposal call.\n        uint proposalDeposit;\n        // True if this proposal is to assign a new Curator\n        bool newCurator;\n        // Data needed for splitting the DAO\n        SplitData[] splitData;\n        // Number of Tokens in favor of the proposal\n        uint yea;\n        // Number of Tokens opposed to the proposal\n        uint nay;\n        // Simple mapping to check if a shareholder has voted for it\n        mapping (address => bool) votedYes;\n        // Simple mapping to check if a shareholder has voted against it\n        mapping (address => bool) votedNo;\n        // Address of the shareholder who created the proposal\n        address creator;\n    }\n\n    // Used only in the case of a newCurator proposal.\n    struct SplitData {\n        // The balance of the current DAO minus the deposit at the time of split\n        uint splitBalance;\n        // The total amount of DAO Tokens in existence at the time of split.\n        uint totalSupply;\n        // Amount of Reward Tokens owned by the DAO at the time of split.\n        uint rewardToken;\n        // The new DAO contract created at the time of split.\n        DAO newDAO;\n    }\n\n    // Used to restrict access to certain functions to only DAO Token Holders\n    modifier onlyTokenholders {}\n\n    /// @dev Constructor setting the Curator and the address\n    /// for the contract able to create another DAO as well as the parameters\n    /// for the DAO Token Creation\n    /// @param _curator The Curator\n    /// @param _daoCreator The contract able to (re)create this DAO\n    /// @param _proposalDeposit The deposit to be paid for a regular proposal\n    /// @param _minTokensToCreate Minimum required wei-equivalent tokens\n    ///        to be created for a successful DAO Token Creation\n    /// @param _closingTime Date (in Unix time) of the end of the DAO Token Creation\n    /// @param _privateCreation If zero the DAO Token Creation is open to public, a\n    /// non-zero address means that the DAO Token Creation is only for the address\n    // This is the constructor: it can not be overloaded so it is commented out\n    //  function DAO(\n        //  address _curator,\n        //  DAO_Creator _daoCreator,\n        //  uint _proposalDeposit,\n        //  uint _minTokensToCreate,\n        //  uint _closingTime,\n        //  address _privateCreation\n    //  );\n\n    /// @notice Create Token with `msg.sender` as the beneficiary\n    /// @return Whether the token creation was successful\n    function () returns (bool success);\n\n\n    /// @dev This function is used to send ether back\n    /// to the DAO, it can also be used to receive payments that should not be\n    /// counted as rewards (donations, grants, etc.)\n    /// @return Whether the DAO received the ether successfully\n    function receiveEther() returns(bool);\n\n    /// @notice `msg.sender` creates a proposal to send `_amount` Wei to\n    /// `_recipient` with the transaction data `_transactionData`. If\n    /// `_newCurator` is true, then this is a proposal that splits the\n    /// DAO and sets `_recipient` as the new DAO's Curator.\n    /// @param _recipient Address of the recipient of the proposed transaction\n    /// @param _amount Amount of wei to be sent with the proposed transaction\n    /// @param _description String describing the proposal\n    /// @param _transactionData Data of the proposed transaction\n    /// @param _debatingPeriod Time used for debating a proposal, at least 2\n    /// weeks for a regular proposal, 10 days for new Curator proposal\n    /// @param _newCurator Bool defining whether this proposal is about\n    /// a new Curator or not\n    /// @return The proposal ID. Needed for voting on the proposal\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID);\n\n    /// @notice Check that the proposal with the ID `_proposalID` matches the\n    /// transaction which sends `_amount` with data `_transactionData`\n    /// to `_recipient`\n    /// @param _proposalID The proposal ID\n    /// @param _recipient The recipient of the proposed transaction\n    /// @param _amount The amount of wei to be sent in the proposed transaction\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposal ID matches the transaction data or not\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) constant returns (bool _codeChecksOut);\n\n    /// @notice Vote on proposal `_proposalID` with `_supportsProposal`\n    /// @param _proposalID The proposal ID\n    /// @param _supportsProposal Yes/No - support of the proposal\n    /// @return The vote ID.\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders returns (uint _voteID);\n\n    /// @notice Checks whether proposal `_proposalID` with transaction data\n    /// `_transactionData` has been voted for or rejected, and executes the\n    /// transaction in the case it has been voted for.\n    /// @param _proposalID The proposal ID\n    /// @param _transactionData The data of the proposed transaction\n    /// @return Whether the proposed transaction has been executed or not\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) returns (bool _success);\n\n    /// @notice ATTENTION! I confirm to move my remaining ether to a new DAO\n    /// with `_newCurator` as the new Curator, as has been\n    /// proposed in proposal `_proposalID`. This will burn my tokens. This can\n    /// not be undone and will split the DAO into two DAO's, with two\n    /// different underlying tokens.\n    /// @param _proposalID The proposal ID\n    /// @param _newCurator The new Curator of the new DAO\n    /// @dev This function, when called for the first time for this proposal,\n    /// will create a new DAO and send the sender's portion of the remaining\n    /// ether and Reward Tokens to the new DAO. It will also burn the DAO Tokens\n    /// of the sender.\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) returns (bool _success);\n\n    /// @dev can only be called by the DAO itself through a proposal\n    /// updates the contract of the DAO by sending all ether and rewardTokens\n    /// to the new DAO. The new DAO needs to be approved by the Curator\n    /// @param _newContract the address of the new contract\n    function newContract(address _newContract);\n\n\n    /// @notice Add a new possible recipient `_recipient` to the whitelist so\n    /// that the DAO can send transactions to them (using proposals)\n    /// @param _recipient New recipient address\n    /// @dev Can only be called by the current Curator\n    /// @return Whether successful or not\n    function changeAllowedRecipients(address _recipient, bool _allowed) external returns (bool _success);\n\n\n    /// @notice Change the minimum deposit required to submit a proposal\n    /// @param _proposalDeposit The new proposal deposit\n    /// @dev Can only be called by this DAO (through proposals with the\n    /// recipient being this DAO itself)\n    function changeProposalDeposit(uint _proposalDeposit) external;\n\n    /// @notice Move rewards from the DAORewards managed account\n    /// @param _toMembers If true rewards are moved to the actual reward account\n    ///                   for the DAO. If not then it's moved to the DAO itself\n    /// @return Whether the call was successful\n    function retrieveDAOReward(bool _toMembers) external returns (bool _success);\n\n    /// @notice Get my portion of the reward that was sent to `rewardAccount`\n    /// @return Whether the call was successful\n    function getMyReward() returns(bool _success);\n\n    /// @notice Withdraw `_account`'s portion of the reward from `rewardAccount`\n    /// to `_account`'s balance\n    /// @return Whether the call was successful\n    function withdrawRewardFor(address _account) internal returns (bool _success);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`. Prior to this\n    /// getMyReward() is called.\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferWithoutReward(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`. Prior to this getMyReward() is called.\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transfered\n    /// @return Whether the transfer was successful or not\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) returns (bool success);\n\n    /// @notice Doubles the 'minQuorumDivisor' in the case quorum has not been\n    /// achieved in 52 weeks\n    /// @return Whether the change was successful or not\n    function halveMinQuorum() returns (bool _success);\n\n    /// @return total number of proposals ever created\n    function numberOfProposals() constant returns (uint _numberOfProposals);\n\n    /// @param _proposalID Id of the new curator proposal\n    /// @return Address of the new DAO\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO);\n\n    /// @param _account The address of the account which is checked.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function isBlocked(address _account) internal returns (bool);\n\n    /// @notice If the caller is blocked by a proposal whose voting deadline\n    /// has exprired then unblock him.\n    /// @return Whether the account is blocked (not allowed to transfer tokens) or not.\n    function unblockMe() returns (bool);\n\n    event ProposalAdded(\n        uint indexed proposalID,\n        address recipient,\n        uint amount,\n        bool newCurator,\n        string description\n    );\n    event Voted(uint indexed proposalID, bool position, address indexed voter);\n    event ProposalTallied(uint indexed proposalID, bool result, uint quorum);\n    event NewCurator(address indexed _newCurator);\n    event AllowedRecipientChanged(address indexed _recipient, bool _allowed);\n}\n\n// The DAO contract itself\ncontract DAO is DAOInterface, Token, TokenCreation {\n\n    // Modifier that allows only shareholders to vote and create new proposals\n    modifier onlyTokenholders {\n        if (balanceOf(msg.sender) == 0) throw;\n            _\n    }\n\n    function DAO(\n        address _curator,\n        DAO_Creator _daoCreator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime,\n        address _privateCreation\n    ) TokenCreation(_minTokensToCreate, _closingTime, _privateCreation) {\n\n        curator = _curator;\n        daoCreator = _daoCreator;\n        proposalDeposit = _proposalDeposit;\n        rewardAccount = new ManagedAccount(address(this), false);\n        DAOrewardAccount = new ManagedAccount(address(this), false);\n        if (address(rewardAccount) == 0)\n            throw;\n        if (address(DAOrewardAccount) == 0)\n            throw;\n        lastTimeMinQuorumMet = now;\n        minQuorumDivisor = 5; // sets the minimal quorum to 20%\n        proposals.length = 1; // avoids a proposal with ID 0 because it is used\n\n        allowedRecipients[address(this)] = true;\n        allowedRecipients[curator] = true;\n    }\n\n    function () returns (bool success) {\n        if (now < closingTime + creationGracePeriod && msg.sender != address(extraBalance))\n            return createTokenProxy(msg.sender);\n        else\n            return receiveEther();\n    }\n\n\n    function receiveEther() returns (bool) {\n        return true;\n    }\n\n\n    function newProposal(\n        address _recipient,\n        uint _amount,\n        string _description,\n        bytes _transactionData,\n        uint _debatingPeriod,\n        bool _newCurator\n    ) onlyTokenholders returns (uint _proposalID) {\n\n        // Sanity check\n        if (_newCurator && (\n            _amount != 0\n            || _transactionData.length != 0\n            || _recipient == curator\n            || msg.value > 0\n            || _debatingPeriod < minSplitDebatePeriod)) {\n            throw;\n        } else if (\n            !_newCurator\n            && (!isRecipientAllowed(_recipient) || (_debatingPeriod <  minProposalDebatePeriod))\n        ) {\n            throw;\n        }\n\n        if (_debatingPeriod > 8 weeks)\n            throw;\n\n        if (!isFueled\n            || now < closingTime\n            || (msg.value < proposalDeposit && !_newCurator)) {\n\n            throw;\n        }\n\n        if (now + _debatingPeriod < now) // prevents overflow\n            throw;\n\n        // to prevent a 51% attacker to convert the ether into deposit\n        if (msg.sender == address(this))\n            throw;\n\n        _proposalID = proposals.length++;\n        Proposal p = proposals[_proposalID];\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.description = _description;\n        p.proposalHash = sha3(_recipient, _amount, _transactionData);\n        p.votingDeadline = now + _debatingPeriod;\n        p.open = true;\n        //p.proposalPassed = False; // that's default\n        p.newCurator = _newCurator;\n        if (_newCurator)\n            p.splitData.length++;\n        p.creator = msg.sender;\n        p.proposalDeposit = msg.value;\n\n        sumOfProposalDeposits += msg.value;\n\n        ProposalAdded(\n            _proposalID,\n            _recipient,\n            _amount,\n            _newCurator,\n            _description\n        );\n    }\n\n\n    function checkProposalCode(\n        uint _proposalID,\n        address _recipient,\n        uint _amount,\n        bytes _transactionData\n    ) noEther constant returns (bool _codeChecksOut) {\n        Proposal p = proposals[_proposalID];\n        return p.proposalHash == sha3(_recipient, _amount, _transactionData);\n    }\n\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) onlyTokenholders noEther returns (uint _voteID) {\n\n        Proposal p = proposals[_proposalID];\n        if (p.votedYes[msg.sender]\n            || p.votedNo[msg.sender]\n            || now >= p.votingDeadline) {\n\n            throw;\n        }\n\n        if (_supportsProposal) {\n            p.yea += balances[msg.sender];\n            p.votedYes[msg.sender] = true;\n        } else {\n            p.nay += balances[msg.sender];\n            p.votedNo[msg.sender] = true;\n        }\n\n        if (blocked[msg.sender] == 0) {\n            blocked[msg.sender] = _proposalID;\n        } else if (p.votingDeadline > proposals[blocked[msg.sender]].votingDeadline) {\n            // this proposal's voting deadline is further into the future than\n            // the proposal that blocks the sender so make it the blocker\n            blocked[msg.sender] = _proposalID;\n        }\n\n        Voted(_proposalID, _supportsProposal, msg.sender);\n    }\n\n\n    function executeProposal(\n        uint _proposalID,\n        bytes _transactionData\n    ) noEther returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        uint waitPeriod = p.newCurator\n            ? splitExecutionPeriod\n            : executeProposalPeriod;\n        // If we are over deadline and waiting period, assert proposal is closed\n        if (p.open && now > p.votingDeadline + waitPeriod) {\n            closeProposal(_proposalID);\n            return;\n        }\n\n        // Check if the proposal can be executed\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            // Have the votes been counted?\n            || !p.open\n            // Does the transaction code match the proposal?\n            || p.proposalHash != sha3(p.recipient, p.amount, _transactionData)) {\n\n            throw;\n        }\n\n        // If the curator removed the recipient from the whitelist, close the proposal\n        // in order to free the deposit and allow unblocking of voters\n        if (!isRecipientAllowed(p.recipient)) {\n            closeProposal(_proposalID);\n            p.creator.send(p.proposalDeposit);\n            return;\n        }\n\n        bool proposalCheck = true;\n\n        if (p.amount > actualBalance())\n            proposalCheck = false;\n\n        uint quorum = p.yea + p.nay;\n\n        // require 53% for calling newContract()\n        if (_transactionData.length >= 4 && _transactionData[0] == 0x68\n            && _transactionData[1] == 0x37 && _transactionData[2] == 0xff\n            && _transactionData[3] == 0x1e\n            && quorum < minQuorum(actualBalance() + rewardToken[address(this)])) {\n\n                proposalCheck = false;\n        }\n\n        if (quorum >= minQuorum(p.amount)) {\n            if (!p.creator.send(p.proposalDeposit))\n                throw;\n\n            lastTimeMinQuorumMet = now;\n            // set the minQuorum to 20% again, in the case it has been reached\n            if (quorum > totalSupply / 5)\n                minQuorumDivisor = 5;\n        }\n\n        // Execute result\n        if (quorum >= minQuorum(p.amount) && p.yea > p.nay && proposalCheck) {\n            if (!p.recipient.call.value(p.amount)(_transactionData))\n                throw;\n\n            p.proposalPassed = true;\n            _success = true;\n\n            // only create reward tokens when ether is not sent to the DAO itself and\n            // related addresses. Proxy addresses should be forbidden by the curator.\n            if (p.recipient != address(this) && p.recipient != address(rewardAccount)\n                && p.recipient != address(DAOrewardAccount)\n                && p.recipient != address(extraBalance)\n                && p.recipient != address(curator)) {\n\n                rewardToken[address(this)] += p.amount;\n                totalRewardToken += p.amount;\n            }\n        }\n\n        closeProposal(_proposalID);\n\n        // Initiate event\n        ProposalTallied(_proposalID, _success, quorum);\n    }\n\n\n    function closeProposal(uint _proposalID) internal {\n        Proposal p = proposals[_proposalID];\n        if (p.open)\n            sumOfProposalDeposits -= p.proposalDeposit;\n        p.open = false;\n    }\n\n    function splitDAO(\n        uint _proposalID,\n        address _newCurator\n    ) noEther onlyTokenholders returns (bool _success) {\n\n        Proposal p = proposals[_proposalID];\n\n        // Sanity check\n\n        if (now < p.votingDeadline  // has the voting deadline arrived?\n            //The request for a split expires XX days after the voting deadline\n            || now > p.votingDeadline + splitExecutionPeriod\n            // Does the new Curator address match?\n            || p.recipient != _newCurator\n            // Is it a new curator proposal?\n            || !p.newCurator\n            // Have you voted for this split?\n            || !p.votedYes[msg.sender]\n            // Did you already vote on another proposal?\n            || (blocked[msg.sender] != _proposalID && blocked[msg.sender] != 0) )  {\n\n            throw;\n        }\n\n        // If the new DAO doesn't exist yet, create the new DAO and store the\n        // current split data\n        if (address(p.splitData[0].newDAO) == 0) {\n            p.splitData[0].newDAO = createNewDAO(_newCurator);\n            // Call depth limit reached, etc.\n            if (address(p.splitData[0].newDAO) == 0)\n                throw;\n            // should never happen\n            if (this.balance < sumOfProposalDeposits)\n                throw;\n            p.splitData[0].splitBalance = actualBalance();\n            p.splitData[0].rewardToken = rewardToken[address(this)];\n            p.splitData[0].totalSupply = totalSupply;\n            p.proposalPassed = true;\n        }\n\n        // Move ether and assign new Tokens\n        uint fundsToBeMoved =\n            (balances[msg.sender] * p.splitData[0].splitBalance) /\n            p.splitData[0].totalSupply;\n        if (p.splitData[0].newDAO.createTokenProxy.value(fundsToBeMoved)(msg.sender) == false)\n            throw;\n\n\n        // Assign reward rights to new DAO\n        uint rewardTokenToBeMoved =\n            (balances[msg.sender] * p.splitData[0].rewardToken) /\n            p.splitData[0].totalSupply;\n\n        uint paidOutToBeMoved = DAOpaidOut[address(this)] * rewardTokenToBeMoved /\n            rewardToken[address(this)];\n\n        rewardToken[address(p.splitData[0].newDAO)] += rewardTokenToBeMoved;\n        if (rewardToken[address(this)] < rewardTokenToBeMoved)\n            throw;\n        rewardToken[address(this)] -= rewardTokenToBeMoved;\n\n        DAOpaidOut[address(p.splitData[0].newDAO)] += paidOutToBeMoved;\n        if (DAOpaidOut[address(this)] < paidOutToBeMoved)\n            throw;\n        DAOpaidOut[address(this)] -= paidOutToBeMoved;\n\n        // Burn DAO Tokens\n        Transfer(msg.sender, 0, balances[msg.sender]);\n        withdrawRewardFor(msg.sender); // be nice, and get his rewards\n        totalSupply -= balances[msg.sender];\n        balances[msg.sender] = 0;\n        paidOut[msg.sender] = 0;\n        return true;\n    }\n\n    function newContract(address _newContract){\n        if (msg.sender != address(this) || !allowedRecipients[_newContract]) return;\n        // move all ether\n        if (!_newContract.call.value(address(this).balance)()) {\n            throw;\n        }\n\n        //move all reward tokens\n        rewardToken[_newContract] += rewardToken[address(this)];\n        rewardToken[address(this)] = 0;\n        DAOpaidOut[_newContract] += DAOpaidOut[address(this)];\n        DAOpaidOut[address(this)] = 0;\n    }\n\n\n    function retrieveDAOReward(bool _toMembers) external noEther returns (bool _success) {\n        DAO dao = DAO(msg.sender);\n\n        if ((rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken < DAOpaidOut[msg.sender])\n            throw;\n\n        uint reward =\n            (rewardToken[msg.sender] * DAOrewardAccount.accumulatedInput()) /\n            totalRewardToken - DAOpaidOut[msg.sender];\n        if(_toMembers) {\n            if (!DAOrewardAccount.payOut(dao.rewardAccount(), reward))\n                throw;\n            }\n        else {\n            if (!DAOrewardAccount.payOut(dao, reward))\n                throw;\n        }\n        DAOpaidOut[msg.sender] += reward;\n        return true;\n    }\n\n    function getMyReward() noEther returns (bool _success) {\n        return withdrawRewardFor(msg.sender);\n    }\n\n\n    function withdrawRewardFor(address _account) noEther internal returns (bool _success) {\n        if ((balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply < paidOut[_account])\n            throw;\n\n        uint reward =\n            (balanceOf(_account) * rewardAccount.accumulatedInput()) / totalSupply - paidOut[_account];\n        if (!rewardAccount.payOut(_account, reward))\n            throw;\n        paidOut[_account] += reward;\n        return true;\n    }\n\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(msg.sender)\n            && transferPaidOut(msg.sender, _to, _value)\n            && super.transfer(_to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferWithoutReward(address _to, uint256 _value) returns (bool success) {\n        if (!getMyReward())\n            throw;\n        return transfer(_to, _value);\n    }\n\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (isFueled\n            && now > closingTime\n            && !isBlocked(_from)\n            && transferPaidOut(_from, _to, _value)\n            && super.transferFrom(_from, _to, _value)) {\n\n            return true;\n        } else {\n            throw;\n        }\n    }\n\n\n    function transferFromWithoutReward(\n        address _from,\n        address _to,\n        uint256 _value\n    ) returns (bool success) {\n\n        if (!withdrawRewardFor(_from))\n            throw;\n        return transferFrom(_from, _to, _value);\n    }\n\n\n    function transferPaidOut(\n        address _from,\n        address _to,\n        uint256 _value\n    ) internal returns (bool success) {\n\n        uint transferPaidOut = paidOut[_from] * _value / balanceOf(_from);\n        if (transferPaidOut > paidOut[_from])\n            throw;\n        paidOut[_from] -= transferPaidOut;\n        paidOut[_to] += transferPaidOut;\n        return true;\n    }\n\n\n    function changeProposalDeposit(uint _proposalDeposit) noEther external {\n        if (msg.sender != address(this) || _proposalDeposit > (actualBalance() + rewardToken[address(this)])\n            / maxDepositDivisor) {\n\n            throw;\n        }\n        proposalDeposit = _proposalDeposit;\n    }\n\n\n    function changeAllowedRecipients(address _recipient, bool _allowed) noEther external returns (bool _success) {\n        if (msg.sender != curator)\n            throw;\n        allowedRecipients[_recipient] = _allowed;\n        AllowedRecipientChanged(_recipient, _allowed);\n        return true;\n    }\n\n\n    function isRecipientAllowed(address _recipient) internal returns (bool _isAllowed) {\n        if (allowedRecipients[_recipient]\n            || (_recipient == address(extraBalance)\n                // only allowed when at least the amount held in the\n                // extraBalance account has been spent from the DAO\n                && totalRewardToken > extraBalance.accumulatedInput()))\n            return true;\n        else\n            return false;\n    }\n\n    function actualBalance() constant returns (uint _actualBalance) {\n        return this.balance - sumOfProposalDeposits;\n    }\n\n\n    function minQuorum(uint _value) internal constant returns (uint _minQuorum) {\n        // minimum of 20% and maximum of 53.33%\n        return totalSupply / minQuorumDivisor +\n            (_value * totalSupply) / (3 * (actualBalance() + rewardToken[address(this)]));\n    }\n\n\n    function halveMinQuorum() returns (bool _success) {\n        // this can only be called after `quorumHalvingPeriod` has passed or at anytime\n        // by the curator with a delay of at least `minProposalDebatePeriod` between the calls\n        if ((lastTimeMinQuorumMet < (now - quorumHalvingPeriod) || msg.sender == curator)\n            && lastTimeMinQuorumMet < (now - minProposalDebatePeriod)) {\n            lastTimeMinQuorumMet = now;\n            minQuorumDivisor *= 2;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewDAO(address _newCurator) internal returns (DAO _newDAO) {\n        NewCurator(_newCurator);\n        return daoCreator.createDAO(_newCurator, 0, 0, now + splitExecutionPeriod);\n    }\n\n    function numberOfProposals() constant returns (uint _numberOfProposals) {\n        // Don't count index 0. It's used by isBlocked() and exists from start\n        return proposals.length - 1;\n    }\n\n    function getNewDAOAddress(uint _proposalID) constant returns (address _newDAO) {\n        return proposals[_proposalID].splitData[0].newDAO;\n    }\n\n    function isBlocked(address _account) internal returns (bool) {\n        if (blocked[_account] == 0)\n            return false;\n        Proposal p = proposals[blocked[_account]];\n        if (now > p.votingDeadline) {\n            blocked[_account] = 0;\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    function unblockMe() returns (bool) {\n        return isBlocked(msg.sender);\n    }\n}\n\ncontract DAO_Creator {\n    function createDAO(\n        address _curator,\n        uint _proposalDeposit,\n        uint _minTokensToCreate,\n        uint _closingTime\n    ) returns (DAO _newDAO) {\n\n        return new DAO(\n            _curator,\n            DAO_Creator(this),\n            _proposalDeposit,\n            _minTokensToCreate,\n            _closingTime,\n            msg.sender\n        );\n    }\n}\n\ncontract DAOSecurity {\n\n    // The total cost of the Offer. Exactly this amount is transfered from the\n    // Client to the Offer contract when the Offer is signed by the Client.\n    // Set once by the Offerer.\n    uint totalCosts;\n\n    // Initial withdraw to the Contractor. It is done the moment the Offer is\n    // signed.\n    // Set once by the Offerer.\n    uint oneTimeCosts;\n\n    // The minimal daily withdraw limit that the Contractor accepts.\n    // Set once by the Offerer.\n    uint128 minDailyWithdrawLimit;\n\n    // The amount of wei the Contractor has right to withdraw daily above the\n    // initial withdraw. The Contractor does not have to do the withdraws every\n    // day as this amount accumulates.\n    uint128 dailyWithdrawLimit;\n\n    // The address of the Contractor.\n    address contractor;\n\n    // The hash of the Proposal/Offer document.\n    bytes32 hashOfTheProposalDocument;\n\n    // The time of the last withdraw to the Contractor.\n    uint lastPayment;\n\n    uint dateOfSignature;\n    DAO client; // address of DAO\n    DAO originalClient; // address of DAO who signed the contract\n    bool isContractValid;\n\n    modifier onlyClient {\n        if (msg.sender != address(client))\n            throw;\n        _\n    }\n\n    // Prevents methods from perfoming any value transfer\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function DAOSecurity(\n        address _contractor,\n        address _client,\n        bytes32 _hashOfTheProposalDocument,\n        uint _totalCosts,\n        uint _oneTimeCosts,\n        uint128 _minDailyWithdrawLimit\n    ) {\n        contractor = _contractor;\n        originalClient = DAO(_client);\n        client = DAO(_client);\n        hashOfTheProposalDocument = _hashOfTheProposalDocument;\n        totalCosts = _totalCosts;\n        oneTimeCosts = _oneTimeCosts;\n        minDailyWithdrawLimit = _minDailyWithdrawLimit;\n        dailyWithdrawLimit = _minDailyWithdrawLimit;\n    }\n\n    // non-value-transfer getters\n    function getTotalCosts() noEther constant returns (uint) {\n        return totalCosts;\n    }\n\n    function getOneTimeCosts() noEther constant returns (uint) {\n        return oneTimeCosts;\n    }\n\n    function getMinDailyWithdrawLimit() noEther constant returns (uint128) {\n        return minDailyWithdrawLimit;\n    }\n\n    function getDailyWithdrawLimit() noEther constant returns (uint128) {\n        return dailyWithdrawLimit;\n    }\n\n    function getContractor() noEther constant returns (address) {\n        return contractor;\n    }\n\n    function getHashOfTheProposalDocument() noEther constant returns (bytes32) {\n        return hashOfTheProposalDocument;\n    }\n\n    function getLastPayment() noEther constant returns (uint) {\n        return lastPayment;\n    }\n\n    function getDateOfSignature() noEther constant returns (uint) {\n        return dateOfSignature;\n    }\n\n    function getClient() noEther constant returns (DAO) {\n        return client;\n    }\n\n    function getOriginalClient() noEther constant returns (DAO) {\n        return originalClient;\n    }\n\n    function getIsContractValid() noEther constant returns (bool) {\n        return isContractValid;\n    }\n\n    function sign() {\n        if (msg.sender != address(originalClient) // no good samaritans give us ether\n            || msg.value != totalCosts    // no under/over payment\n            || dateOfSignature != 0)      // don't sign twice\n            throw;\n        if (!contractor.send(oneTimeCosts))\n            throw;\n        dateOfSignature = now;\n        isContractValid = true;\n        lastPayment = now;\n    }\n\n    function setDailyWithdrawLimit(uint128 _dailyWithdrawLimit) onlyClient noEther {\n        if (_dailyWithdrawLimit >= minDailyWithdrawLimit)\n            dailyWithdrawLimit = _dailyWithdrawLimit;\n    }\n\n    // ""fire the contractor""\n    function returnRemainingEther() onlyClient {\n        if (originalClient.DAOrewardAccount().call.value(this.balance)())\n            isContractValid = false;\n    }\n\n    // Withdraw to the Contractor.\n    //\n    // Withdraw the amount of ether the Contractor has right to according to\n    // the current withdraw limit.\n    // Executing this function before the Offer is signed off by the Client\n    // makes no sense as this contract has no ether.\n    function getDailyPayment() noEther {\n        if (msg.sender != contractor)\n            throw;\n        uint timeSinceLastPayment = now - lastPayment;\n        // Calculate the amount using 1 second precision.\n        uint amount = (timeSinceLastPayment * dailyWithdrawLimit) / (1 days);\n        if (amount > this.balance) {\n            amount = this.balance;\n        }\n        if (contractor.send(amount))\n            lastPayment = now;\n    }\n\n    // Change the client DAO by giving the new DAO's address\n    // warning: The new DAO must come either from a split of the original\n    // DAO or an update via `newContract()` so that it can claim rewards\n    function updateClientAddress(DAO _newClient) onlyClient noEther {\n        client = _newClient;\n    }\n\n    function () {\n        throw; // this is a business contract, no donations\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。DAOの機能を実装しており、芸術的要素は少ない。
1620420,0xd88838359c8ad2fa9577bd3e8bfe1cc49b70ac47,false,false,"contract MPO { \n	uint256 public reading;\n	uint256 public time;\n	address public operator; \n	uint256 shift;\n	string public name =""MP"";\n	string public symbol =""Wh"";\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	mapping (address => uint256) public balanceOf;\n	address[] public listeners;\n	\n	function MPO() {\n		operator=msg.sender;\n		shift=0;\n	}\n	\n	function updateReading(uint256 last_reading,uint256 timeofreading) {		\n		if(msg.sender!=operator) throw;\n		if((timeofreading<time)||(reading>last_reading)) throw;	\n		var oldreading=last_reading;\n		reading=last_reading-shift;\n		time=timeofreading;	\n		balanceOf[this]=last_reading;\n		for(var i=0;i<listeners.length;i++) {\n			balanceOf[listeners[i]]=last_reading;\n			Transfer(msg.sender,listeners[i],last_reading-oldreading);\n		}\n	}\n	\n	function reqisterListening(address a) {\n		listeners.push(a);\n		balanceOf[a]=reading;\n		Transfer(msg.sender,a,reading);\n	}\n	function transferOwnership(address to) {\n		if(msg.sender!=operator) throw;\n		operator=to;\n	}\n	function transfer(address _to, uint256 _value) {\n		/* Function stub required to see tokens in wallet */		\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	function assetMoveInformation(address newmpo,address gridMemberToInform) {\n		if(msg.sender!=operator) throw;\n		/*var gm=GridMember(gridMemberToInform);\n		gm.switchMPO(this,newmpo);\n		*/\n	}\n	\n}\ncontract MPOListener {\n	MPO public mp;\n	\n	function switchMPO(address from, address to) {\n		if(msg.sender!=mp.operator()) throw;\n		if(mp==from) {\n			mp=MPO(to);			\n		}\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1625565,0x01bfbb9b1a2abe32ceb0a9f2291e5d7e36e38b20,true,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        mint *= 10 ** _b;\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n/*\nBasic, standardized Token contract with no ""premine"". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function _transfer(address _to, uint256 _amount) internal returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function _transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) internal returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\ncontract KissBTCCallback {\n    function kissBTCCallback(uint id, uint amount);\n}\n\ncontract ApprovalRecipient {\n    function receiveApproval(address _from, uint256 _amount,\n                             address _tokenContract, bytes _extraData);\n}\n\ncontract KissBTC is usingOraclize, Token {\n    string constant PRICE_FEED =\n        ""json(https://api.kraken.com/0/public/Ticker?pair=ETHXBT).result.XETHXXBT.c.0"";\n    uint constant MAX_AMOUNT =\n        0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\n    uint constant MAX_ETH_VALUE = 10 ether;\n    uint constant MIN_ETH_VALUE = 50 finney;\n    uint constant MAX_KISS_BTC_VALUE = 25000000;\n    uint constant MIN_KISS_BTC_VALUE = 125000;\n    uint constant DEFAULT_GAS_LIMIT = 200000;\n\n    string public standard = ""Token 0.1"";\n    string public name = ""kissBTC"";\n    string public symbol = ""kissBTC"";\n    uint8 public decimals = 8;\n\n    struct Task {\n        bytes32 oraclizeId;\n        bool toKissBTC;\n        address sender;\n        uint value;\n        address callback;\n        uint timestamp;\n    }\n\n    mapping (uint => Task) public tasks;\n    mapping (bytes32 => uint) public oraclizeRequests;\n    uint public exchangeRate;\n    uint public nextId = 1;\n\n    address public owner;\n    uint public timestamp;\n\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    function KissBTC() {\n        owner = msg.sender;\n    }\n\n    // default action is to turn Ether into kissBTC\n    function () {\n        buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\n    }\n\n    function buyKissBTC() {\n        buyKissBTCWithCallback(0, DEFAULT_GAS_LIMIT);\n    }\n\n    function buyKissBTCWithCallback(address callback,\n                                    uint gasLimit) oraclizeAPI\n                                    returns (uint id) {\n        if (msg.value < MIN_ETH_VALUE || msg.value > MAX_ETH_VALUE) throw;\n        if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\n\n        uint oraclizePrice = oraclize.getPrice(""URL"", gasLimit);\n        uint fee = msg.value / 100; // for the contract's coffers\n\n        if (msg.value <= oraclizePrice + fee) throw;\n        uint value = msg.value - (oraclizePrice + fee);\n\n        id = nextId++;\n        bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\n            0,\n            ""URL"",\n            PRICE_FEED,\n            gasLimit\n        );\n        tasks[id].oraclizeId = oraclizeId;\n        tasks[id].toKissBTC = true;\n        tasks[id].sender = msg.sender;\n        tasks[id].value = value;\n        tasks[id].callback = callback;\n        tasks[id].timestamp = now;\n        oraclizeRequests[oraclizeId] = id;\n    }\n\n    function transfer(address _to,\n                      uint256 _amount) noEther returns (bool success) {\n        if (_to == address(this)) {\n            sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\n            return true;\n        } else {\n            return _transfer(_to, _amount);    // standard transfer\n        }\n    }\n\n    function transferFrom(address _from,\n                          address _to,\n                          uint256 _amount) noEther returns (bool success) {\n        if (_to == address(this)) throw;       // not supported;\n        return _transferFrom(_from, _to, _amount);\n    }\n\n    function sellKissBTC(uint256 _amount) returns (uint id) {\n        return sellKissBTCWithCallback(_amount, 0, DEFAULT_GAS_LIMIT);\n    }\n\n    function sellKissBTCWithCallback(uint256 _amount,\n                                     address callback,\n                                     uint gasLimit) oraclizeAPI\n                                     returns (uint id) {\n        if (_amount < MIN_KISS_BTC_VALUE\n            || _amount > MAX_KISS_BTC_VALUE) throw;\n        if (balances[msg.sender] < _amount) throw;\n        if (gasLimit < DEFAULT_GAS_LIMIT) gasLimit = DEFAULT_GAS_LIMIT;\n\n        if (!safeToSell(_amount)) throw;    // we need a bailout\n\n        uint oraclizePrice = oraclize.getPrice(""URL"", gasLimit);\n        uint oraclizePriceKissBTC = inKissBTC(oraclizePrice);\n        uint fee = _amount / 100; // for the contract's coffers\n\n        if (_amount <= oraclizePriceKissBTC + fee) throw;\n        uint value = _amount - (oraclizePriceKissBTC + fee);\n\n        balances[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        Transfer(msg.sender, address(this), _amount);\n\n        id = nextId++;\n        bytes32 oraclizeId = oraclize.query_withGasLimit.value(oraclizePrice)(\n            0,\n            ""URL"",\n            PRICE_FEED,\n            gasLimit\n        );\n        tasks[id].oraclizeId = oraclizeId;\n        tasks[id].toKissBTC = false;\n        tasks[id].sender = msg.sender;\n        tasks[id].value = value;\n        tasks[id].callback = callback;\n        tasks[id].timestamp = now;\n        oraclizeRequests[oraclizeId] = id;\n    }\n\n    function inKissBTC(uint amount) constant returns (uint) {\n        return (amount * exchangeRate) / 1000000000000000000;\n    }\n\n    function inEther(uint amount) constant returns (uint) {\n        return (amount * 1000000000000000000) / exchangeRate;\n    }\n\n    function safeToSell(uint amount) constant returns (bool) {\n        // Only allow sales when we have an extra 25 % in reserve.\n        return inEther(amount) * 125 < this.balance * 100;\n    }\n\n    function __callback(bytes32 oraclizeId, string result) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        uint _exchangeRate = parseInt(result, 6) * 100;\n        if (_exchangeRate > 0) {\n            exchangeRate = _exchangeRate;\n        }\n\n        uint id = oraclizeRequests[oraclizeId];\n        if (id == 0) return;\n\n        address sender = tasks[id].sender;\n        address callback = tasks[id].callback;\n        if (tasks[id].toKissBTC) {\n            uint freshKissBTC = inKissBTC(tasks[id].value);\n\n            totalSupply += freshKissBTC;\n            balances[sender] += freshKissBTC;\n            Transfer(address(this), sender, freshKissBTC);\n\n            if (callback != 0) {\n                // Note: If the callback throws an exception, everything\n                // will be rolled back and you won't receive any tokens.\n                // You can however invoke retryOraclizeRequest() in that case.\n                KissBTCCallback(callback).kissBTCCallback.\n                    value(0)(id, freshKissBTC);\n            }\n        } else {\n            uint releasedEther = inEther(tasks[id].value);\n\n            sender.send(releasedEther);\n\n            if (callback != 0) {\n                KissBTCCallback(callback).kissBTCCallback.\n                    value(0)(id, releasedEther);\n            }\n        }\n\n        delete oraclizeRequests[oraclizeId];\n        delete tasks[id];\n    }\n\n    function retryOraclizeRequest(uint id) oraclizeAPI {\n        if (tasks[id].oraclizeId == 0) throw;\n\n        uint timePassed = now - tasks[id].timestamp;\n        if (timePassed < 60 minutes) throw;\n\n        // Allow to retry a request to Oraclize if there has been\n        // no reply within the last hour for some reason. Because a\n        // failed callback might have been the problem, we discard those.\n        uint price = oraclize.getPrice(""URL"", DEFAULT_GAS_LIMIT);\n        bytes32 newOraclizeId = oraclize.query_withGasLimit.value(price)(\n            0,\n            ""URL"",\n            PRICE_FEED,\n            DEFAULT_GAS_LIMIT\n        );\n\n        delete oraclizeRequests[tasks[id].oraclizeId];\n        tasks[id].oraclizeId = newOraclizeId;\n        tasks[id].callback = 0;\n        tasks[id].timestamp = now;\n        oraclizeRequests[newOraclizeId] = id;\n    }\n\n    function whitelist(address _spender) returns (bool success) {\n        return approve(_spender, MAX_AMOUNT);\n    }\n\n    function approveAndCall(address _spender,\n                            uint256 _amount,\n                            bytes _extraData) returns (bool success) {\n        approve(_spender, _amount);\n        ApprovalRecipient(_spender).receiveApproval.\n            value(0)(msg.sender, _amount, this, _extraData);\n        return true;\n    }\n\n    function donate() {\n        // Send ether here if you would like to\n        // increase the contract's reserves.\n    }\n\n    function toldYouItWouldWork() onlyowner {\n        if (now - timestamp < 24 hours) throw;  // only once a day\n\n        uint obligations = inEther(totalSupply);\n        if (this.balance <= obligations * 3) throw;\n\n        // Owner can withdraw 1 % of excess funds if the contract\n        // has more than three times its obligations in reserve.\n        uint excess = this.balance - (obligations * 3);\n        uint payment = excess / 100;\n        if (payment > 0) owner.send(payment);\n        timestamp = now;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1625605,0x71107a8959f1249920cf87dc8c994b9b483d25ef,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        mint *= 10 ** _b;\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\ncontract KissBTC {\n    function transferFrom(address _from, address _to,\n                          uint256 _amount) returns (bool success);\n    function sellKissBTCWithCallback(uint256 _amount, address callback,\n                                     uint gasLimit) returns (uint id);\n}\n\ncontract BitcoinSender is usingOraclize {\n    address constant KISS_BTC = 0x6777c314B412F0196aCA852632969F63e7971340;\n\n    struct StepOne {\n        bool inProcess;\n        string addr;\n    }\n\n    struct StepTwo {\n        bool inProcess;\n        uint amount;\n    }\n\n    mapping (uint => StepOne) stepOneTasks;\n    mapping (bytes32 => StepTwo) stepTwoTasks;\n\n    function sendBitcoin(string _address, uint _amount) {\n        if (!KissBTC(KISS_BTC).transferFrom(msg.sender, this, _amount)) throw;\n        uint id = KissBTC(KISS_BTC).sellKissBTCWithCallback(\n            _amount, this, 300000);\n        stepOneTasks[id].inProcess = true;\n        stepOneTasks[id].addr = _address;\n    }\n\n    function kissBTCCallback(uint id, uint amount) oraclizeAPI {\n        if (msg.sender != KISS_BTC) throw;\n        if (!stepOneTasks[id].inProcess) return;\n\n        uint price = oraclize.getPrice(""URL"");\n        if (price >= amount) return;\n\n        string memory json = strConcat(\n            '{""pair"": ""eth_btc"", ""withdrawal"": ""',\n            stepOneTasks[id].addr,\n            '""}'\n        );\n        bytes32 oraclizeId = oraclize_query(\n            ""URL"",\n            ""json(https://shapeshift.io/shift).deposit"",\n            json\n        );\n        stepTwoTasks[oraclizeId].inProcess = true;\n        stepTwoTasks[oraclizeId].amount = amount - price;\n\n        delete stepOneTasks[id];\n    }\n\n    function __callback(bytes32 oraclizeId, string result) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        if (!stepTwoTasks[oraclizeId].inProcess) return;\n\n        address addr = parseAddr(result);\n        addr.send(stepTwoTasks[oraclizeId].amount);\n\n        delete stepTwoTasks[oraclizeId];\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1629187,0x90a8ed56e469e16df02151c1c3273de3fc917f6f,false,false,"contract aEthereumlotteryNet {\n	/*\n		aEthereumlotteryNet\n		Coded by: iFA\n		http://a.ethereumlottery.net\n		ver: 1.0.1\n	*/\n	address private owner;\n	uint private collectedFee;\n	bool public contractEnabled = true;\n	uint public ticketPrice = 1 finney; // 0.01 ether\n	uint private feeP = 5; // 5 %\n	uint private drawDelay = 7 days;\n	uint private drawAtLeastTicketCount = 10000;\n	uint private drawAtLeastPlayerCount = 10;\n	uint private placeMultiple  =  10000;\n	uint private place1P    	= 600063; // 60.0063 %\n	uint private place2P    	= 240025; // 24.0025 %\n	uint private place3P    	=  96010; //  9.6010 %\n	uint private place4P    	=  38404; //  3.8404 %\n	uint private place5P    	=  15362; //  1.5362 %\n	uint private place6P    	=   6145; //  0.6145 %\n	uint private place7P    	=   2458; //  0.2458 %\n	uint private place8P    	=    983; //  0.0983 %\n	uint private place9P    	=    393; //  0.0393 %\n	uint private place10P       =    157; //  0.0157 %\n	\n	uint private constant prepareBlockDelay = 5;\n	\n	enum drawStatus_ { Wait, Prepared ,Done }\n	\n	struct players_s {\n		address addr;\n		uint ticketCount;\n	}\n	struct game_s {\n		players_s[] players;\n		uint startDate;\n		uint endDate;\n		uint totalTickets;\n		uint prepareDrawBlock;\n		drawStatus_ drawStatus;\n	}\n	game_s private game;\n	\n	mapping (address => uint) public balances;\n	\n	string constant public Information = ""http://a.ethereumlottery.net"";\n	\n	function Details() constant returns(uint start, uint end, uint tickets, uint players) {\n		start = game.startDate;\n		end = game.endDate;\n		tickets = game.totalTickets;\n		players = game.players.length;\n	}\n	function Prizes() constant returns(bool estimated, uint place1, uint place2, uint place3, \n	uint place4, uint place5, uint place6, uint place7, uint place8, uint place9, uint place10) {\n		uint pot;\n		if (game.totalTickets < drawAtLeastTicketCount) {\n			estimated = true;\n			pot = drawAtLeastTicketCount*ticketPrice*(100-feeP)/100;\n		} else {\n			estimated = false;\n			pot = game.totalTickets*ticketPrice*(100-feeP)/100;\n		}\n		place1 = pot*place1P/placeMultiple/100;\n		place2 = pot*place2P/placeMultiple/100;\n		place3 = pot*place3P/placeMultiple/100;\n		place4 = pot*place4P/placeMultiple/100;\n		place5 = pot*place5P/placeMultiple/100;\n		place6 = pot*place6P/placeMultiple/100;\n		place7 = pot*place7P/placeMultiple/100;\n		place8 = pot*place8P/placeMultiple/100;\n		place9 = pot*place9P/placeMultiple/100;\n		place10 = pot*place10P/placeMultiple/100;\n	}\n	function aEthereumlotteryNet() {\n		owner = msg.sender;\n		createNewDraw();\n	}\n	function () {\n		BuyTickets();\n	}\n	function BuyTickets() OnlyInTime OnlyWhileWait onValidContract {\n		if (msg.value < ticketPrice) { throw; }\n		uint ticketsCount = msg.value / ticketPrice;\n		if (game.totalTickets+ticketsCount >= 255**4) { throw; }\n		if (msg.value > (ticketsCount * ticketPrice)) { if (msg.sender.send(msg.value - (ticketsCount * ticketPrice)) == false) { throw; } }\n		game.totalTickets += ticketsCount;\n		uint a;\n		uint playersid = game.players.length;\n		for ( a = 0 ; a < playersid ; a++ ) {\n			if (game.players[a].addr == msg.sender) {\n				game.players[a].ticketCount += ticketsCount;\n				return;\n			}\n		}\n		game.players.length += 1;\n		game.players[playersid].addr = msg.sender;\n		game.players[playersid].ticketCount = ticketsCount;\n	}\n	function PrepareDraw() external ReadyForPrepare onValidContract {\n	    reFund();\n		if (game.players.length < drawAtLeastPlayerCount && game.totalTickets < drawAtLeastTicketCount) {\n			game.endDate = calcNextDrawTime();\n		} else {\n			game.prepareDrawBlock = block.number + prepareBlockDelay;\n			game.drawStatus = drawStatus_.Prepared;\n		}\n	}\n	event announceWinner(address addr,uint prize);\n	function Draw() external OnlyWhilePrepared ReadyForDraw onValidContract {\n	    reFund();\n		bytes32 WinHash = makeHash();\n		uint a;\n		uint b;\n		uint c;\n		uint d;\n		uint e;\n		uint num;\n		address[10] memory winners;\n		bool next;\n		for ( a = 0 ; a < 10 ; a++ ) {\n			while (true) {\n				next = true;\n				if (b == 8) {\n					WinHash = sha3(WinHash);\n					b = 0;\n				}\n				num = getNum(WinHash,b) % game.totalTickets;\n				d = 0;\n				for ( c = 0 ; c < game.players.length ; c++ ) {\n					d += game.players[c].ticketCount;\n					if (d >= num) {\n						for ( e = 0 ; e < 10 ; e++ ){\n							if (game.players[c].addr == winners[e]) {\n								next = false;\n								break;\n							}\n						}\n						if (next == true) {\n							winners[a] = game.players[c].addr;\n							break;\n						}\n					}\n				}\n				b++;\n				if (next == true) { break; }\n			}\n		}\n		uint fee = game.totalTickets * ticketPrice * feeP / 100;\n		uint pot = game.totalTickets * ticketPrice - fee;\n		collectedFee += fee;\n		balances[winners[0]] += pot * place1P / placeMultiple / 100;\n		balances[winners[1]] += pot * place2P / placeMultiple / 100;\n		balances[winners[2]] += pot * place3P / placeMultiple / 100;\n		balances[winners[3]] += pot * place4P / placeMultiple / 100;\n		balances[winners[4]] += pot * place5P / placeMultiple / 100;\n		balances[winners[5]] += pot * place6P / placeMultiple / 100;\n		balances[winners[6]] += pot * place7P / placeMultiple / 100;\n		balances[winners[7]] += pot * place8P / placeMultiple / 100;\n		balances[winners[8]] += pot * place9P / placeMultiple / 100;\n		balances[winners[9]] += pot * place10P / placeMultiple / 100;\n		announceWinner(winners[0],balances[winners[0]]);\n		announceWinner(winners[1],balances[winners[1]]);\n		announceWinner(winners[2],balances[winners[2]]);\n		announceWinner(winners[3],balances[winners[3]]);\n		announceWinner(winners[4],balances[winners[4]]);\n		announceWinner(winners[5],balances[winners[5]]);\n		announceWinner(winners[6],balances[winners[6]]);\n		announceWinner(winners[7],balances[winners[7]]);\n		announceWinner(winners[8],balances[winners[8]]);\n		announceWinner(winners[9],balances[winners[9]]);\n		if (contractEnabled == true) {\n			createNewDraw();\n		} else {\n			game.drawStatus = drawStatus_.Done;\n		}\n	}\n	function GetPrize() external {\n	    reFund();\n	    if (contractEnabled) { \n            if (balances[msg.sender] == 0) { throw; }\n        	if (msg.sender.send(balances[msg.sender]) == false) { throw; }\n        	balances[msg.sender] = 0;\n	    } else {\n            for ( uint a = 0 ; a < game.players.length ; a++ ) {\n    			if (game.players[a].addr == msg.sender) {\n    			    if (game.players[a].ticketCount > 0) {\n    			        if ( ! msg.sender.send(game.players[a].ticketCount * ticketPrice)) { throw; }\n    			        game.totalTickets -= game.players[a].ticketCount;\n    			        delete game.players[a];\n    			    } else {\n    			        throw;\n    			    }\n    			}\n    		}\n	    }\n	}\n	function OwnerGetFee() external OnlyOwner {\n	    reFund();\n		if (owner.send(collectedFee) == false) { throw; }\n		collectedFee = 0;\n	}\n	function OwnerCloseContract() external OnlyOwner {\n	    reFund();\n	    if (!contractEnabled) { throw; }\n		contractEnabled = false;\n	}\n	function createNewDraw() private {\n		game.startDate = now;\n		game.endDate = calcNextDrawTime();\n		game.players.length = 0;\n		game.totalTickets = 0;\n		game.prepareDrawBlock = 0;\n		game.drawStatus = drawStatus_.Wait;\n	}\n	function calcNextDrawTime() private returns (uint ret) {\n		ret = 1461499200; // 2016.04.24 12:00:00\n		while (ret < now) {\n			ret += drawDelay;\n		}\n	}\n	function makeHash() private returns (bytes32 hash) {\n		for ( uint a = 0 ; a <= prepareBlockDelay ; a++ ) {\n			hash = sha3(hash, block.blockhash(game.prepareDrawBlock - prepareBlockDelay + a));\n		}\n		hash = sha3(hash, game.players.length, game.totalTickets);\n	}\n	function reFund() private { if (msg.value > 0) { if (msg.sender.send(msg.value) == false) { throw; } } }\n	function getNum(bytes32 a, uint i) private returns (uint) { return uint32(bytes4(bytes32(uint(a) * 2 ** (8 * (i*4))))); }\n	modifier onValidContract() { if (!contractEnabled) { throw; } _ }\n	modifier OnlyInTime() { if (game.endDate < now) { throw; } _ }\n	modifier OnlyWhileWait() { if (game.drawStatus != drawStatus_.Wait) { throw; } _ }\n	modifier OnlyWhilePrepared() { if (game.drawStatus != drawStatus_.Prepared) { throw; } _ }\n	modifier ReadyForPrepare() { if (game.endDate > now || game.drawStatus != drawStatus_.Wait) { throw; } _ }\n	modifier ReadyForDraw() { if (game.prepareDrawBlock > block.number) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n}",1,実用的なロトリーコントラクトで、特に芸術的な要素は見られません。
1631765,0x50c5712624b58905c19aee87deca593a2690e3f4,false,false,"contract Docsign\n{\n    //Fire when document hash is added to contract\n    event Added(address indexed _from);\n\n    //Fire when contract is deployed on the blockchain\n    event Created(address indexed _from);\n\n\n    struct Document {\n        uint version;\n        string name;\n        address creator;\n        string hash;\n        uint date;\n    }\n    Document[] public a_document;\n    uint length;\n\n    // Constructor. Can be used to track contract deployment\n    function Docsign() {\n        Created(msg.sender);\n    }\n\n    function Add(uint _version, string _name, string _hash) {\n        a_document.push(Document(_version,_name,msg.sender, _hash, now));\n        Added(msg.sender);\n    }\n    // Get number of element in Array a_document (does not used GAS)\n    function getCount() public constant returns(uint) {\n        return a_document.length;\n    }\n    \n    // fallback function (send back ether if contrat is used as wallet contract)\n    function() { throw; }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1633067,0x222bf5c06cf4cb86554e165e6082350a6078735a,false,false,"/**\n * Decentraliced Grid Organization\n * Version: 0.0.1\n * Author: Thorsten Zoerner <me@thorsten-zoerner.com>\n * Donations: btc:1MvghD6TE2nurN4iCUSLdmcCRiwohgCA86 eth:0x697a040b13aefdd9553f3922dcb547be6efd88d2\n * Implementation: Ethereum/Solidity\n */\n\n/**\nBusiness Case / Purpose\n=========================================================================================\nIntroduces a smart contract for members of a power grid to facilitate P2P balancing.\n\n- Implements post delivery balancing with peers\n- Provides tokens per GridMember for clearing\n- Handles simple prioty list for merit order \n- Allow Exchange of Meter Device\n- Allow multiple ""Listeners"" (Push Clients) per MP (according to Smart Meter Gateway Concept)\n\nRequires independend smart meter operator.\n*/\n/*\n[{""constant"":false,""inputs"":[{""name"":""from"",""type"":""address""},{""name"":""to"",""type"":""address""}],""name"":""switchMPO"",""outputs"":[],""type"":""function""},{""constant"":true,""inputs"":[],""name"":""mp"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""}]\n*/\ncontract MPO { \n	uint256 public reading;\n	uint256 public time;\n	address public operator; \n	uint256 shift;\n	string public name =""MP"";\n	string public symbol =""Wh"";\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	mapping (address => uint256) public balanceOf;\n	address[] public listeners;\n	\n	function MPO() {\n		operator=msg.sender;\n		shift=0;\n	}\n	\n	function updateReading(uint256 last_reading,uint256 timeofreading) {		\n		if(msg.sender!=operator) throw;\n		if((timeofreading<time)||(reading>last_reading)) throw;	\n		var oldreading=last_reading;\n		reading=last_reading-shift;\n		time=timeofreading;	\n		balanceOf[this]=last_reading;\n		for(var i=0;i<listeners.length;i++) {\n			balanceOf[listeners[i]]=last_reading;\n			Transfer(msg.sender,listeners[i],last_reading-oldreading);\n		}\n	}\n	\n	function registerListening(address a) {\n		listeners.push(a);\n		balanceOf[a]=reading;\n		Transfer(msg.sender,a,reading);\n	}\n	\n	function unregisterListening(address a) {\n	\n		for(var i=0;i<listeners.length;i++) {\n			if(listeners[i]==a) listeners[i]=0;\n		}\n		\n	}\n	function transferOwnership(address to) {\n		if(msg.sender!=operator) throw;\n		operator=to;\n	}\n	function transfer(address _to, uint256 _value) {\n		/* Function stub required to see tokens in wallet */		\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	function assetMoveInformation(address newmpo,address gridMemberToInform) {\n		if(msg.sender!=operator) throw;\n		/*var gm=GridMember(gridMemberToInform);\n		gm.switchMPO(this,newmpo);\n		*/\n	}\n	\n}\ncontract MPOListener {\n	MPO public mp;\n	\n	function switchMPO(address from, address to) {\n		if(msg.sender!=mp.operator()) throw;\n		if(mp==from) {\n			mp=MPO(to);			\n		}\n	}\n}\ncontract operated {\n    address public operator;\n\n    function operated() {\n        operator = msg.sender;\n    }\n\n    modifier onlyOperator {\n        if (msg.sender != operator) throw;\n        _\n    }\n\n    function transferOperator(address newOperator) onlyOperator {\n        operator = newOperator;\n    }\n}\n\ncontract GridMember is operated,MPOListener {\n		\n	\n	address[] public peers;\n	uint256 public lastreading;\n	string public name;\n	uint256 public actual_feedin=0;\n	uint256 public actual_feedout=0;	\n	uint256 public total_feedin;\n	uint256 public total_feedout;\n	string public symbol =""Wh"";\n	uint256 public managedbalance;\n	bool public feedin;\n	bool public autobalancepeers;\n	bool listening;\n	address public aggregate;\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	mapping (address => uint256) public balanceOf;\n	mapping (address => uint256) public allowance;	\n	\n	mapping (address => uint256) public molist;\n	\n	function GridMember(string membername,uint256 managablebalance,bool directionFeedin,address mpo,address aggregation) {			\n		name=membername;\n		managedbalance=managablebalance;\n		balanceOf[this]=managablebalance;\n		Transfer(msg.sender,this,managablebalance);\n		feedin=directionFeedin;		\n		if(feedin) total_feedin=lastreading; else total_feedout=lastreading;\n		autobalancepeers=false;	\n		mp=MPO(mpo);\n		updateReading(mp.reading());		\n		actual_feedin=0;\n		actual_feedout=0;\n		listening=false;\n		aggregate=aggregation;\n	}\n	\n	function switchMPO(address from, address to) {\n		if(msg.sender!=mp.operator()) throw;\n		updateWithMPO();\n		lastreading=0;\n		super.switchMPO(from,to);\n		updateWithMPO();\n		listening=false;\n	}\n	function registerListening() onlyOperator {\n		mp.registerListening(this);\n		listening=true;\n	}\n	\n	function addPowerSource(address peer,uint256 manageallowed,uint merritorder) onlyOperator {\n		if(merritorder>9) throw;\n		if(feedin) throw;\n 		allowance[peer]=manageallowed;\n		peers.push(peer);\n		molist[peer]=merritorder;\n		\n	} \n	\n	function updateWithMPO() {			\n		updateReading(mp.balanceOf(mp));\n	}\n		\n	function updateReading(uint256 reading) private {	\n		if(getActual()>0) runPeerBalance();\n		if(reading<lastreading) throw;\n		var actual = reading -lastreading;\n		if(feedin) actual_feedin+=actual; else actual_feedout+=actual;		\n		if(feedin) total_feedin+=actual; else total_feedout+=actual;										\n		lastreading=reading;\n		runPeerBalance();\n	}\n	\n	function requestPeerBalance() onlyOperator {\n		updateWithMPO();\n		runPeerBalance();\n		Aggregation a = Aggregation(aggregate);\n		a.doBalanceFor(this);\n		\n	}\n	\n	function runPeerBalance() private {\n		for(var j=0;j<10;j++) {\n			for(var i=0;i<peers.length;i++) {\n				if(molist[peers[i]]==j) {\n				GridMember peer = GridMember(peers[i]);\n				allowance[peer]=getActual();\n				peer.doBalance(this);\n				}\n			}\n		}	\n	}\n	function getActual() returns(uint256) {\n		if(feedin) return actual_feedin; else return actual_feedout;				\n	}\n	\n	function receiveTransfer(uint256 amount) {\n		if(tx.origin!=operator) throw;	\n		if(feedin) actual_feedin-=amount; else actual_feedout-=amount;\n	}\n	function sendToAggregation(uint256 amount) {\n		balanceOf[this]-=amount;\n		balanceOf[aggregate]+=amount;\n		if(feedin) actual_feedin-=amount; else actual_feedout-=amount;\n		Transfer(this,aggregate,amount);\n	}\n	function doBalance(address requester) {		\n		updateWithMPO();\n		if(autobalancepeers) {\n			if((actual_feedin>0)||(actual_feedout>0)) {\n				// Prevent Loop Condition!\n				\n			}				\n		}\n		GridMember peer = GridMember(requester);		\n		\n		if(feedin==peer.feedin()) return;\n		uint256 peer_allowance = peer.allowance(this);\n		uint256 balance_amount=0;\n		//\n		if(feedin) { balance_amount=actual_feedin; } else { balance_amount=actual_feedout; }\n		if(peer_allowance<balance_amount) { balance_amount=peer_allowance; }		\n		if(balanceOf[this]<balance_amount) balance_amount=balanceOf[this];	\n		\n		if((peer.managedbalance()-peer.balanceOf(requester))+peer.getActual()<balance_amount) balance_amount=(peer.managedbalance()-peer.balanceOf(requester))+peer.getActual();\n		\n		if(balance_amount>0) {\n			balanceOf[this]-=balance_amount;\n			balanceOf[requester]+=balance_amount;\n			Transfer(this,requester,balance_amount);\n			if(feedin) { actual_feedin-=balance_amount; 						\n					   } else { actual_feedout-=balance_amount; }\n			peer.receiveTransfer(balance_amount);\n		}		\n	}\n\n	\n	function transfer(address _to, uint256 _value) {\n		/* Function stub required to see tokens in wallet */		\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n   \n}\n\n\ncontract Aggregation {\n	address public owner;\n	address[] public members;\n	uint256 public actual_feedin;\n	uint256 public actual_feedout;\n	uint256 public balance_in;\n	uint256 public balance_out;\n	uint256 public last_balance;\n	uint256 public next_balance;\n	string public name=""Aggregation"";\n	string public symbol=""Wh"";\n	mapping (address => uint256) public balanceOf;\n	mapping (address => uint256) public lastbalancing;\n	\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	function Aggregation() {\n		owner=msg.sender;\n		next_balance=now+3600;\n	}\n	\n	function addGridMember(address gridmember) {\n		if(msg.sender!=owner) throw;\n	\n		members.push(gridmember);\n	}\n	function transfer(address _to, uint256 _value) {\n		/* Function stub required to see tokens in wallet */		\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	\n	function doBalanceFor(address a) {\n		bool found=false;\n		for(var i=0;i<members.length;i++) {\n			if(members[i]==a) found=true; \n		}\n		if(!found) throw;\n		\n		GridMember g = GridMember(a);\n		actual_feedin+=g.actual_feedin();\n		actual_feedout+=g.actual_feedout();\n		// as a member is either feeder or consumer this is not dangerous... :)\n\n		g.sendToAggregation(g.actual_feedin()+g.actual_feedout());\n		lastbalancing[a]=now;\n		\n	}	\n	function doBalance() {\n		if(now<next_balance) throw;\n		for(var i=0;i<members.length;i++) {\n			doBalanceFor(members[i]);			\n		}\n		next_balance=now+3600;\n	}\n}\n// Aggregation Testnet: 0x70F24857194520Fd70a788C6a9D9638bA44a0B85",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。エネルギー管理のための機能的な設計。
1634314,0xe3b6638f0c1c0fa37282fab6ef9457e457a1e9a8,false,false,"/*\n\nAuthor: psdev\n\np@psdev.io\n\n0x13370CA2e8426a82BcfcCE21C97817A243c521Cf\n\n*/\n\ncontract TokenInterface {\n  function balanceOf(address _owner) constant returns (uint256 balance);\n  function transfer(address _to, uint256 _amount) returns (bool success);\n  function receiveEther() returns(bool);\n}\n\ncontract SellTokens {\n    address constant THE_DAO_ADDRESS = 0xbb9bc244d798123fde783fcc1c72d3bb8c189413;\n\n    TokenInterface public theDao;\n    mapping (address => uint) public allowedFreeExchanges;\n\n    event TransferEvent(address _from, address _to, uint256 _value);\n    event ReturnEvent(uint256 _value);\n    event NotEnoughEthErrorEvent(uint trySend, uint available);\n    event NotEnoughDaoErrorEvent(uint trySend, uint available);\n\n    function SellTokens(){\n        theDao = TokenInterface(THE_DAO_ADDRESS);\n        populateAllowedFreeExchanges();\n    }\n\n    function requestTokensBack() {\n        if (msg.value != 0 || allowedFreeExchanges[msg.sender] == 0) throw;\n        if (!theDao.transfer(msg.sender, allowedFreeExchanges[msg.sender])) throw;\n        allowedFreeExchanges[msg.sender] = 0;\n    }\n\n    function buy100DaoFor1Eth(){\n        var tokens_to_send = msg.value;\n        uint daoBalance = theDao.balanceOf(this);\n        if (tokens_to_send > daoBalance) {\n            NotEnoughDaoErrorEvent(tokens_to_send, daoBalance);\n            throw;\n        }\n        if (msg.value > this.balance) {\n            NotEnoughEthErrorEvent(msg.value, this.balance);\n            throw;\n        }\n\n        // send tokens back to buyer\n        if (!theDao.transfer(msg.sender, tokens_to_send)) throw;\n        TransferEvent(this, msg.sender, tokens_to_send);\n        // send eth from buyer to dao\n        if (!theDao.receiveEther.value(msg.value)()) throw;\n        ReturnEvent(msg.value);\n    }\n\n    // accounts and amounts sent to dao, rounded down & only txn > 100 tokens\n    function populateAllowedFreeExchanges() internal {\n        // from etherscan\n        allowedFreeExchanges[address(0x900b1d91f8931e3e1de3076341accb2f6011214f)] = 4000000000000000000;\n        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 31560000000000000000;\n        allowedFreeExchanges[address(0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13)] = 9900000000000000000;\n        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 1040000000000000000;\n        allowedFreeExchanges[address(0x8b3b3b624c3c0397d3da8fd861512393d51dcbac)] = 90000000000000000000;\n        allowedFreeExchanges[address(0xdf21fa922215b1a56f5a6d6294e6e36c85a0acfb)] = 49990000000000000000;\n        allowedFreeExchanges[address(0x0a9de66f5fda96a5b40d1ca9cd18bfb298c67d1c)] = 16440000000000000000;\n        allowedFreeExchanges[address(0x946c555081313c5e0986c6cd5f6978257a406237)] = 1000000000000000000;\n        allowedFreeExchanges[address(0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13)] = 295510000000000000000;\n    }\n\n\n\n\n}",1,標準的なトークン販売コントラクトで、特に芸術的な要素は見られません。
1635436,0xc3113bcda42b1824c07f8317b40152d6730a6f37,true,false,"contract EtherTreasuryInterface {\n    function withdraw(address _to, uint _value) returns(bool);\n    function withdrawWithReference(address _to, uint _value, string _reference) returns(bool);\n}\n\ncontract MultiAsset {\n    function owner(bytes32 _symbol) constant returns(address);\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract Asset {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\n            return false;\n        }\n        return true;\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return false;\n        }\n        return true;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\n            return false;\n        }\n        return true;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\n            return false;\n        }\n        return true;\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() returns(bool) {\n        return multiAsset.transfer(multiAsset.owner(symbol), balanceOf(address(this)), symbol);\n    }\n}\n\ncontract Ambi {\n    function getNodeAddress(bytes32) constant returns(address);\n    function addNode(bytes32, address) external returns(bool);    \n    function hasRelation(bytes32, bytes32, address) constant returns(bool);\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract OpenDollar is Asset, AmbiEnabled {\n    uint public txGasPriceLimit = 21000000000;\n    uint public refundGas = 40000;\n    uint public transferCallGas = 21000;\n    uint public transferWithReferenceCallGas = 21000;\n    uint public transferFromCallGas = 21000;\n    uint public transferFromWithReferenceCallGas = 21000;\n    uint public transferToICAPCallGas = 21000;\n    uint public transferToICAPWithReferenceCallGas = 21000;\n    uint public transferFromToICAPCallGas = 21000;\n    uint public transferFromToICAPWithReferenceCallGas = 21000;\n    uint public approveCallGas = 21000;\n    uint public forwardCallGas = 21000;\n    uint public setCosignerCallGas = 21000;\n    EtherTreasuryInterface public treasury;\n    mapping(uint32 => address) public allowedForwards;\n\n    function updateRefundGas() checkAccess(""setup"") returns(uint) {\n        uint startGas = msg.gas;\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\n        if (tx.gasprice > txGasPriceLimit) {\n            return 0;\n        }\n        if (!_refund(1)) {\n            return 0;\n        }\n        refundGas = startGas - msg.gas;\n        return refundGas;\n    }\n\n    function setOperationsCallGas\n        (\n            uint _transfer,\n            uint _transferFrom,\n            uint _transferToICAP,\n            uint _transferFromToICAP,\n            uint _transferWithReference,\n            uint _transferFromWithReference,\n            uint _transferToICAPWithReference,\n            uint _transferFromToICAPWithReference,\n            uint _approve,\n            uint _forward,\n            uint _setCosigner\n        ) checkAccess(""setup"") returns(bool)\n    {\n        transferCallGas = _transfer;\n        transferFromCallGas = _transferFrom;\n        transferToICAPCallGas = _transferToICAP;\n        transferFromToICAPCallGas = _transferFromToICAP;\n        transferWithReferenceCallGas = _transferWithReference;\n        transferFromWithReferenceCallGas = _transferFromWithReference;\n        transferToICAPWithReferenceCallGas = _transferToICAPWithReference;\n        transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference;\n        approveCallGas = _approve;\n        forwardCallGas = _forward;\n        setCosignerCallGas = _setCosigner;\n        return true;\n    }\n\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(""admin"") returns(bool) {\n        if (_txGasPriceLimit == 0) {\n            return false;\n        }\n        treasury = EtherTreasuryInterface(_treasury);\n        txGasPriceLimit = _txGasPriceLimit;\n        if (msg.value > 0 && !address(treasury).send(msg.value)) {\n            throw;\n        }\n        return true;\n    }\n\n    function setForward(bytes4 _msgSig, address _forward) checkAccess(""admin"") returns(bool) {\n        allowedForwards[uint32(_msgSig)] = _forward;\n        return true;\n    }\n\n    function _stringGas(string _string) constant internal returns(uint) {\n        return bytes(_string).length * 75;\n    }\n\n    function _applyRefund(uint _startGas) internal returns(bool) {\n        if (tx.gasprice > txGasPriceLimit) {\n            return false;\n        }\n        uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice;\n        return _refund(refund);\n    }\n\n    function _refund(uint _value) internal returns(bool) {\n        return treasury.withdraw(tx.origin, _value);\n    }\n\n    function _transfer(address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferCallGas;\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, """")) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromCallGas;\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, """")) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPCallGas;\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, """")) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPCallGas;\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, """")) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference);\n        if (!multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromWithReferenceCallGas + _stringGas(_reference);\n        if (!multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _approve(address _spender, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + approveCallGas;\n        if (!multiAsset.proxyApprove(_spender, _value, symbol)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _setCosignerAddress(address _cosigner) internal returns(bool, bool) {\n        uint startGas = msg.gas + setCosignerCallGas;\n        if (!multiAsset.proxySetCosignerAddress(_cosigner, symbol)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transfer(_to, _value);\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFrom(_from, _to, _value);\n        return success;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferToICAP(_icap, _value);\n        return success;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAP(_from, _icap, _value);\n        return success;\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferWithReference(_to, _value, _reference);\n        return success;\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromWithReference(_from, _to, _value, _reference);\n        return success;\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferToICAPWithReference(_icap, _value, _reference);\n        return success;\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n        return success;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        bool success;\n        (success,) = _approve(_spender, _value);\n        return success;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        bool success;\n        (success,) = _setCosignerAddress(_cosigner);\n        return success;\n    }\n\n    function checkTransfer(address _to, uint _value) constant returns(bool, bool) {\n        return _transfer(_to, _value);\n    }\n\n    function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) {\n        return _transferFrom(_from, _to, _value);\n    }\n\n    function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferToICAP(_icap, _value);\n    }\n\n    function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferFromToICAP(_from, _icap, _value);\n    }\n\n    function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferWithReference(_to, _value, _reference);\n    }\n\n    function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function checkApprove(address _spender, uint _value) constant returns(bool, bool) {\n        return _approve(_spender, _value);\n    }\n\n    function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) {\n        return _setCosignerAddress(_cosigner);\n    }\n\n    function _forward(address _to, bytes _data) internal returns(bool) {\n        uint startGas = msg.gas + forwardCallGas + (_data.length * 50);\n        if (_to == 0x0) {\n            return false;\n        }\n        _to.call.value(msg.value)(_data);\n        return _applyRefund(startGas);\n    }\n\n    function () returns(bool) {\n        return _forward(allowedForwards[uint32(msg.sig)], msg.data);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1646801,0x3f2d17ed39876c0864d321d8a533ba8080273ede,false,false,"contract NoxonFund {\n\n    address public owner;\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply; //18160ddd for rpc call https://api.etherscan.io/api?module=proxy&data=0x18160ddd&to=0xContractAdress&apikey={eserscan api}&action=eth_call\n    uint256 public Entropy;\n    uint256 public ownbalance; //d9c7041b\n\n	uint256 public sellPrice; //4b750334\n    uint256 public buyPrice; //8620410b\n    \n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    \n    \n    /* Initializes cont ract with initial supply tokens to the creator of the contract */\n    function token()  {\n    \n        if (owner!=0) throw;\n        buyPrice = msg.value;\n        balanceOf[msg.sender] = 1;    // Give the creator all initial tokens\n        totalSupply = 1;              // Update total supply\n        Entropy = 1;\n        name = 'noxonfund.com';       // Set the name for display purposes\n        symbol = '? SHARE';             // Set the symbol for display purposes\n        decimals = 0;                 // Amount of decimals for display purposes\n        owner = msg.sender;\n        setPrices();\n    }\n    \n\n    \n     /* Send shares function */\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;    \n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	\n\n    function setPrices() {\n        ownbalance = this.balance; //own contract balance\n        sellPrice = ownbalance/totalSupply;\n        buyPrice = sellPrice*2; \n    }\n    \n    \n   function () returns (uint buyreturn) {\n       \n        uint256 amount = msg.value / buyPrice;                // calculates the amount\n        balanceOf[msg.sender] += amount;                   // adds the amount to buyer's balance\n       \n        totalSupply += amount;\n        Entropy += amount;\n        \n        Transfer(0, msg.sender, amount);\n        \n        owner.send(msg.value/2);\n        //set next price\n        setPrices();\n        return buyPrice;\n   }\n   \n\n    \n    function sell(uint256 amount) {\n        setPrices();\n        if (balanceOf[msg.sender] < amount ) throw;        // checks if the sender has enough to sell\n        Transfer(msg.sender, this, amount);                 //return shares to contract\n        totalSupply -= amount;\n        balanceOf[msg.sender] -= amount;                   // subtracts the amount from seller's balance\n        msg.sender.send(amount * sellPrice);               // sends ether to the seller\n        setPrices();\n\n    }\n	\n	//All incomse will send using newIncome method\n	event newincomelog(uint amount,string description);\n	function newIncome(\n        string JobDescription\n    )\n        returns (string result)\n    {\n        if (msg.value <= 1 ether/100) throw;\n        newincomelog(msg.value,JobDescription);\n        return JobDescription;\n    }\n    \n    \n    \n    //some democracy\n    \n    uint votecount;\n    uint voteno; \n    uint voteyes;\n    \n    mapping (address => uint256) public voters;\n    \n    function newProposal(\n        string JobDescription\n    )\n        returns (string result)\n    {\n        if (msg.sender == owner) {\n            votecount = 0;\n            newProposallog(JobDescription);\n            return ""ok"";\n        } else {\n            return ""Only admin can do this"";\n        }\n    }\n    \n\n    \n    \n    function ivote(bool myposition) returns (uint result) {\n        votecount += balanceOf[msg.sender];\n        \n        if (voters[msg.sender]>0) throw;\n        voters[msg.sender]++;\n        votelog(myposition,msg.sender,balanceOf[msg.sender]);\n        return votecount;\n    }\n\n    \n    event newProposallog(string description);\n    event votelog(bool position, address voter, uint sharesonhand);\n   \n    \n}",1,標準的なトークン管理と投票機能を持つ実用的なスマートコントラクトです。
1653270,0x1f36f2249ec89266ad4ee4351538148aaebc72e8,false,false,"contract euroteambet {\n\n	struct team {\n		string teamName;\n		mapping(address => uint) bet;\n		uint totalBet;\n	}\n\n	team[] public euroTeams;\n\n	bool winningTeamDefined;\n	uint winningTeam;\n\n	/** Bets close at the opening day of the EuroCup: 10 June 2016 **/\n	uint startCompetitionTime;\n\n	/**  Overall amount bet **/\n	uint public globalBet;\n\n	/** Define the creator and fees collected **/\n	address creator;\n	uint feeCollected;\n\n	/**\n	* Constructor: Defines team and creator\n	*/\n	function euroteambet() {\n		// Define the Teams\n		team memory toCreate;\n		// Post a dummy team to ensure the actual range is from 1 to 24 and not 0 to 23.\n		toCreate.teamName = '';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Albania';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Austria';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Belgium';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Croatia';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Czech Republic';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'England';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'France';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Germany';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Hungary';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Iceland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Italy';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Nothern Ireland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Poland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Portugal';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Republic of Ireland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Romania';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Russia';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Slovakia';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Spain';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Sweden';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Switzerland';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Turkey';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Ukraine';\n		euroTeams.push(toCreate);\n		toCreate.teamName = 'Wales';\n		euroTeams.push(toCreate);\n\n		creator = msg.sender;\n\n		winningTeamDefined = false;\n\n		// Euro Cup starts in 4 days\n		startCompetitionTime = block.timestamp + (60 * 60 * 24) * 4;\n\n	}\n\n\n	event BetFromTransaction(address indexed from, uint value);\n	event CollectFromTransaction(address indexed from, uint value);	\n	event BetClosedNoWinningTeam(address indexed from, uint value);	\n	/**\n	 * Catch-All Function: Un case of transaction received going though a Contract Function\n	 * 1: Check if bets are still open\n	 * 2: Check if the bet is more than 0.1 ETH\n	 * 3: Divided by 1000000000000000 to have an integer (0.016 Eth to 16) and call betOnATeam\n	 *    If the EeasyBet value is not correct (possible value 1 to 24), it will be throw in BetOnAteam function\n	 * 4: Check if the winning team as been defined    \n	 */\n	function () {\n		if (startCompetitionTime >= block.timestamp) {\n			if (msg.value >= 100 finney) {\n				BetFromTransaction(msg.sender, msg.value);\n				betOnATeam((msg.value % 100 finney) / 1000000000000000);\n			} else {\n				msg.sender.send(msg.value);\n				return;\n			}\n		} else if (winningTeamDefined == true) {\n			CollectFromTransaction(msg.sender, msg.value);\n			collectEarnings();\n		} else {\n			BetClosedNoWinningTeam(msg.sender, msg.value);\n			if(msg.value > 0){\n				msg.sender.send(msg.value);\n			}\n			return;\n		}\n	}\n\n	/**\n	 * Used to defined the winner of the Tournament\n	 * 1: The winning team is updated \n	 * 2: All amount invested are gathered in globalBet\n	 * 3: All balances of the winning team updated proportionally to the amount invested\n	 *\n	 * param      {uint  teamWinningName  The identifier of the team winning\n	 */\n	function setWinner(uint teamWinningID) {\n		// Check if the sender is the creator and if the tournament has ended\n		if (msg.sender == creator) {\n			winningTeam = teamWinningID;\n			winningTeamDefined = true;\n		} else {\n			if(msg.value > 0){\n				msg.sender.send(msg.value);\n			}\n			return;\n		}\n	}\n\n\n	event BetOnATeam(address indexed from, uint indexed id, uint value);\n	/**\n	 * Used to bet on the winner of the Tournament\n	 * 1: Check if bets are still open\n	 * 2: Check if the bet is more than 0.1 ETH\n	 * 3: Check if the id of the team is correct (possible value 1 to 24)\n	 * param      {uint}  id      The identifier of the team to bet on\n	 */\n	function betOnATeam(uint id) {\n		if (startCompetitionTime >= block.timestamp && msg.value >= 100 finney && id >= 1 && id <= 24) {\n\n			uint amount = msg.value;\n\n			// Collect 3% Fee\n			feeCollected += (amount * 3 / 100);\n			amount -= (amount * 3 / 100);\n\n			BetOnATeam(msg.sender, id, amount);\n\n			euroTeams[id].bet[msg.sender] += amount;\n			euroTeams[id].totalBet += amount;\n			globalBet += amount;\n		} else {\n			if(msg.value > 0){\n				msg.sender.send(msg.value);\n			}\n			return;\n		}\n	}\n\n	/**\n	* Check earnings for a specific address\n	* \n	* param      address  toCheck  Address to check its earnings \n	* return     uint   Amount earned\n	*/\n	function checkEarnings(address toCheck) returns (uint) {\n		if(msg.value > 0){\n			msg.sender.send(msg.value);\n		}\n\n		if (winningTeamDefined == true) {\n			return (globalBet * (euroTeams[winningTeam].bet[toCheck] / euroTeams[winningTeam].totalBet));\n		} else {\n			return 0;\n		}\n	}\n\n	/**\n	 * Only allowed the withdrawals of the fund once the Winning team is updated\n	 */\n	function collectEarnings() {\n		if(msg.value > 0){\n			msg.sender.send(msg.value);\n		}\n		if (winningTeamDefined == true) {\n			uint earnings = (globalBet * (euroTeams[winningTeam].bet[msg.sender] / euroTeams[winningTeam].totalBet));\n			msg.sender.send(earnings);\n			euroTeams[winningTeam].bet[msg.sender] = 0;\n		} else {\n			return;\n		}\n	}\n\n	/**\n	* Allow the creator of the game to send balance\n	* \n	* param      address  toSend  Address to receive its earnings \n	*/\n	function sendEarnings(address toSend) {\n		if(msg.value > 0){\n			msg.sender.send(msg.value);\n		}\n		if (msg.sender == creator && winningTeamDefined == true) {\n			uint earnings = (globalBet * (euroTeams[winningTeam].bet[toSend] / euroTeams[winningTeam].totalBet));\n			toSend.send(earnings);\n			euroTeams[winningTeam].bet[toSend] = 0;\n		} else {\n			return;\n		}\n	}\n\n	/**\n	* Allow the creator to collect the 3% Fee\n	*/\n	function collectFee() {\n		msg.sender.send(msg.value);\n		if (msg.sender == creator) {\n			creator.send(feeCollected);\n			feeCollected = 0;\n		} else {\n			return;\n		}\n	}\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1653557,0xe0cfa488bb6442d39a4abf844d5876f209f03871,false,false,"contract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		https://d.ethereumlottery.net\n		ver: 2.0.0\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	uint private constant fee = 5;\n	uint private constant investorFee = 50;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 26;\n	\n    bool public ContractEnabled = true;\n    uint public ContractDisabledBlock;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] investors;\n	\n	string constant public Information = ""https://d.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function dEthereumlotteryNet() {\n		owner = msg.sender;\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n	    if (jackpot_ == 0) {\n	        Rate = 0;\n	        Bet = 0;\n	        return;\n	    }\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		if (Value < Bet) {\n		    Rate++;\n		    Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n		    Rate = BestRollRate;\n		    Bet = getRealBet(Rate);\n        }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(uint id) constant returns(address Owner, uint Investment, uint Balance, bool Live) {\n		if (id < investors.length) {\n			Owner = investors[id].owner;\n			Investment = investors[id].value;\n			Balance = investors[id].balance;\n			Live = investors[id].live;\n		} else {\n			Owner = 0;\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() OnlyEnabled external {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if ( ! investors[a].valid) {\n				newInvest(a,msg.sender,value_);\n				return;\n			}\n		}\n		investors.length++;\n		newInvest(investors.length-1,msg.sender,value_);\n	}\n	function GetMyInvestFee() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].owner == msg.sender && ! investors[a].valid) {\n				balance_ = investors[a].balance;\n				investors[a].valid = false;\n			}\n		}\n		if (balance_ > 0) { if ( ! msg.sender.send(balance_)) { throw; } }\n	}\n	function CancelMyInvest() external {\n		reFund();\n		uint balance_;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if ((investors[a].owner == msg.sender && investors[a].valid)) {\n			    if (investors[a].timestamp < now || ! ContractEnabled) {\n    				if (investors[a].live) {\n    					balance_ = investors[a].value + investors[a].balance;\n    					jackpot_ -= investors[a].value;\n    					delete investors[a];\n    				} else {\n    					balance_ = investors[a].balance;\n    					delete investors[a];\n    				}\n			    }\n			}\n		}\n		setJackpot();\n		if (balance_ > 0) { if ( ! msg.sender.send(balance_)) { throw; } }\n	}\n	/* For Players */\n	function DoRoll() external {\n		reFund();\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if ( ! ContractEnabled || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if (value_ > 0) { if (msg.sender.send(value_)) { throw; } }\n		if ( ! found) { throw; }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		uint _rate = getRate(msg.value);\n		uint _realBet = getRealBet(_rate);\n		if (msg.value < _realBet) {\n		    _rate++;\n		    _realBet = getRealBet(_rate);\n		}\n		if (_rate < BestRollRate) { \n		    _rate = BestRollRate;\n		    _realBet = getRealBet(_rate);\n        }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner {\n		reFund();\n		if ( ! ContractEnabled) {\n		    if (ContractDisabledBlock < block.number) {\n		        uint balance_ = this.balance;\n		        for ( uint a=0 ; a < investors.length ; a++ ) {\n		            balance_ -= investors[a].balance;\n		        }\n		        if (balance_ > 0) {\n                    if ( ! msg.sender.send(balance_)) { throw; }\n		        }\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner {\n		reFund();\n		if (feeValue == 0) { throw; }\n		if ( ! owner.send(feeValue)) { throw; }\n		feeValue = 0;\n	}\n	\n	/*\n		Private functions\n	*/\n	function newInvest(uint investorsID, address investor, uint value) private {\n		investors[investorsID].owner = investor;\n		investors[investorsID].value = value;\n		investors[investorsID].balance = 0;\n		investors[investorsID].valid = true;\n		investors[investorsID].live = true;\n		investors[investorsID].timestamp = now + investMinDuration;\n		jackpot_ += value;\n		setJackpot();\n	}\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n		}\n		RollEvent(msg.sender, _rate, bigNumber % _rate, bigNumber ,win);\n		delete players[msg.sender][id];\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function reFund() private { if (msg.value > 0) { if ( ! msg.sender.send(msg.value)) { throw; } } }\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		RollCount++;\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, bet);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1000000 / value * 100 / investorFee * extraRate / 100 / 1000000;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1000000 / ( rate * 1000000 * investorFee / extraRate);\n	}\n	\n	/*\n		Events\n	*/	\n	event RollEvent(address Player, uint Rate, uint Result, uint Number, uint Win);\n	event PrepareRollEvent(address Player, uint Block, uint Bet);\n	\n	/*\n		Modifiders\n	*/\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1655997,0x597cc90774efed11ead1dd72828768d4563350f5,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public ownerEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    \n    uint constant safeGas = 25000;\n    uint constant oraclizeGasLimit = 150000;\n\n    struct Investor {\n        address user;\n        uint capital;\n    }\n    mapping(uint => Investor) investors; //starts at 1\n    uint public numInvestors = 0;\n    mapping(address => uint) investorIDs;\n    uint public invested = 0;\n    \n    address owner;\n    bool public isStopped;\n\n    struct Bet {\n        address user;\n        uint bet; // amount\n        uint roll; // result\n	uint fee; \n    }\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n    uint public amountWagered = 0;\n    int public profit = 0;\n    int public takenProfit = 0;\n    int public ownerProfit = 0;\n\n    function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) {\n        \n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n        \n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        ownerEdge = ownerEdgeInitial;\n        divestFee = divestFeeInitial;\n        \n        owner = msg.sender;\n    }\n\n\n    function() {\n        bet();\n    }\n\n    function bet() {\n        if (isStopped) throw;\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", oraclizeGasLimit);\n        if (msg.value < oraclizeFee) throw;\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"", 'BDXJhrVpBJ53o2CxlJRlQtZJKZqLYt5IQe+73YDS4HtNjS5HodbIB3tvfow7UquyAk085VkLnL9EpKgwqWQz7ZLdGvsQlRd2sKxIolNg9DbnfPspGqLhLbbYSVnN8CwvsjpAXcSSo3c+4cNwC90yF4oNibkvD3ytapoZ7goTSyoUYTfwSjnw3ti+HJVH7N3+c0iwOCqZjDdsGQUcX3m3S/IHWbOOQQ5osO4Lbj3Gg0x1UdNtfUzYCFY79nzYgWIQEFCuRBI0n6NBvBQW727+OsDRY0J/9/gjt8ucibHWic0=', oraclizeGasLimit); // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee);\n            betsKeys.push(myid);\n        } else {\n            throw; // invalid bet size\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n    \n    function minBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", oraclizeGasLimit);\n        return oraclizeFee+minBet;\n    }\n    \n    function safeSend(address addr, uint value) internal {\n        if (!(addr.call.gas(safeGas).value(value)())){\n            ownerProfit += int(value);\n        }\n    }\n  \n    function __callback(bytes32 myid, string result, bytes proof) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        \n        Bet thisBet = bets[myid];\n        if (thisBet.bet>0) {\n            if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) {\n                uint roll = parseInt(result);\n                if (roll<1 || roll>10000){\n                    safeSend(thisBet.user, thisBet.bet);\n                    return;    \n                }\n\n                bets[myid].roll = roll;\n                \n                int profitDiff;\n                if (roll-1 < pwin) { //win\n                    uint winAmount = (thisBet.bet * (10000 - edge)) / pwin;\n                    safeSend(thisBet.user, winAmount);\n                    profitDiff = int(thisBet.bet - winAmount);\n                } else { //lose\n                    safeSend(thisBet.user, 1);\n                    profitDiff = int(thisBet.bet) - 1;\n                }\n                \n                ownerProfit += (profitDiff*int(ownerEdge))/10000;\n                profit += profitDiff-(profitDiff*int(ownerEdge))/10000;\n                \n                amountWagered += thisBet.bet;\n            } else {\n                //bet is too big (bankroll may have changed since the bet was made)\n                safeSend(thisBet.user, thisBet.bet);\n            }\n        }\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint, uint) {\n        if(id<betsKeys.length)\n        {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee);\n        }\n    }\n\n    function invest() {\n        if (isStopped) throw;\n        \n        if (investorIDs[msg.sender]>0) {\n            rebalance();\n            investors[investorIDs[msg.sender]].capital += msg.value;\n            invested += msg.value;\n        } else {\n            rebalance();\n            uint investorID = 0;\n            if (numInvestors<maxInvestors) {\n                investorID = ++numInvestors;\n            } else {\n                for (uint i=1; i<=numInvestors; i++) {\n                    if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) {\n                        investorID = i;\n                    }\n                }\n            }\n            if (investorID>0) {\n                if (investors[investorID].capital>0) {\n                    divest(investors[investorID].user, investors[investorID].capital);\n                    investorIDs[investors[investorID].user] = 0;\n                }\n                if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) {\n                    investors[investorID].user = msg.sender;\n                    investors[investorID].capital = msg.value;\n                    invested += msg.value;\n                    investorIDs[msg.sender] = investorID;\n                } else {\n                    throw;\n                }\n            } else {\n                throw;\n            }\n        }\n    }\n\n    function rebalance() private {\n        if (takenProfit != profit) {\n            uint newInvested = 0;\n            uint initialBankroll = getBankroll();\n            for (uint i=1; i<=numInvestors; i++) {\n                investors[i].capital = getBalance(investors[i].user);\n                newInvested += investors[i].capital;\n            }\n            invested = newInvested;\n            if (newInvested != initialBankroll && numInvestors>0) {\n                ownerProfit += int(initialBankroll - newInvested); //give the rounding error to the first investor\n                invested += (initialBankroll - newInvested);\n            }\n            takenProfit = profit;\n        }\n    }\n\n    function divest(address user, uint amount) private {\n        if (investorIDs[user]>0) {\n            rebalance();\n            if (amount>getBalance(user)) {\n                amount = getBalance(user);\n            }\n            investors[investorIDs[user]].capital -= amount;\n            invested -= amount;\n            \n            uint newAmount = (amount*divestFee)/10000; // take a fee from the deinvest amount\n            ownerProfit += int(newAmount);\n            safeSend(user, (amount-newAmount));\n        }\n    }\n\n    function divest(uint amount) {\n        if (msg.value>0) throw;\n        divest(msg.sender, amount);\n    }\n\n    function divest() {\n        if (msg.value>0) throw;\n        divest(msg.sender, getBalance(msg.sender));\n    }\n\n    function getBalance(address user) constant returns(uint) {\n        if (investorIDs[user]>0 && invested>0) {\n            return investors[investorIDs[user]].capital * getBankroll() / invested;\n        } else {\n            return 0;\n        }\n    }\n\n    function getBankroll() constant returns(uint) {\n        uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit);\n        if (this.balance < bankroll){\n            log0(""bankroll_mismatch"");\n            bankroll = this.balance;\n        }\n        return bankroll;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors<maxInvestors) {\n            return 0;\n        } else {\n            uint investorID;\n            for (uint i=1; i<=numInvestors; i++) {\n                if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) {\n                    investorID = i;\n                }\n            }\n            return getBalance(investors[investorID].user);\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) {\n        return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length);\n    }\n\n    function stopContract() {\n        if (owner != msg.sender) throw;\n        isStopped = true;\n    }\n  \n    function resumeContract() {\n        if (owner != msg.sender) throw;\n        isStopped = false;\n    }\n    \n    function forceDivestAll() {\n        forceDivestAll(false);\n    }\n    \n    function forceDivestAll(bool ownerTakeChangeAndProfit) {\n        if (owner != msg.sender) throw;\n        for (uint investorID=1; investorID<=numInvestors; investorID++) {\n            divest(investors[investorID].user, getBalance(investors[investorID].user));\n        }\n        if (ownerTakeChangeAndProfit) owner.send(this.balance);\n    }\n    \n    function ownerTakeProfit() {\n        ownerTakeProfit(false);\n    }\n    \n    function ownerTakeProfit(bool takeChange) {\n        if (owner != msg.sender) throw;\n        if (takeChange){\n            uint investorsCapital = 0;\n            for (uint i=1; i<=numInvestors; i++) {\n                investorsCapital += investors[i].capital;\n            }\n            if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){\n                owner.send(this.balance);\n                ownerProfit = 0;\n            }\n        } else {\n            owner.send(uint(ownerProfit));\n            ownerProfit = 0;\n        }\n    }\n   \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1661238,0x1b4fb4d0bcb3e80d9314b866aaf15c84eb0f1234,true,false,"/*\nThis file is part of the DAO.\n000000000000000000000000bb9bc244d798123fde783fcc1c72d3bb8c189413\n\nAccount 0xB3267B3B37a1C153Ca574c3A50359f9d1613F95d\ndthPool 0xB256D572885A5246DDbF548F39da57f5f8074b9a\n\nHello all! I just deployed the first DTHPool (Delegate) in the real net.\nThe delegate in this contract is myself. My intention is not to be a stable delegate but to construct a repository of delegates where DTH’s can choose.\nI tested to delegate and undelegate some tokens. I also set up the votes for the proposals made to the DAO until now. \nIf any body wants to delegate me some tokens, he will be wellcome!. You can also check the votes set up and his motivations. \nI'll appreciate any feedback.\nIf any body wants to be a delegate, I’m absolutely open to help him to deploy the contract.\n\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n\n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   }\n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n\n\n}\n// </ORACLIZE_API>\n\n\n/*\nBasic, standardized Token contract with no ""premine"". Defines the functions to\ncheck token balances, send tokens, send tokens on behalf of a 3rd party and the\ncorresponding approval process. Tokens need to be created by a derived\ncontract (e.g. TokenCreation.sol).\n\nThank you ConsenSys, this contract originated from:\nhttps://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/Standard_Token.sol\nWhich is itself based on the Ethereum standardized contract APIs:\nhttps://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs\n*/\n\n/// @title Standard Token Contract.\n\ncontract TokenInterface {\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n\n    /// Public variables of the token, all used for display \n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    string public standard = 'Token 0.1';\n\n    /// Total amount of tokens\n    uint256 public totalSupply;\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance);\n\n    /// @notice Send `_amount` tokens to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\n    /// is approved by `_from`\n    /// @param _from The address of the origin of the transfer\n    /// @param _to The address of the recipient\n    /// @param _amount The amount of tokens to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\n    /// its behalf\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _amount The amount of tokens to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _amount) returns (bool success);\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\n    /// to spend\n    function allowance(\n        address _owner,\n        address _spender\n    ) constant returns (uint256 remaining);\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount\n    );\n}\n\ncontract tokenRecipient { \n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); \n}\n\ncontract Token is TokenInterface {\n    // Protects users by preventing the execution of method calls that\n    // inadvertently also transferred ether\n    modifier noEther() {if (msg.value > 0) throw; _}\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) noEther returns (bool success) {\n        if (balances[msg.sender] >= _amount && _amount > 0) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n           return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) noEther returns (bool success) {\n\n        if (balances[_from] >= _amount\n            && allowed[_from][msg.sender] >= _amount\n            && _amount > 0) {\n\n            balances[_to] += _amount;\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n    \n    /// Allow another contract to spend some tokens in your behalf \n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        tokenRecipient spender = tokenRecipient(_spender);\n        spender.receiveApproval(msg.sender, _value, this, _extraData);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}\n\n\n/*\nThis file is part of the DAO.\n\nThe DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nThe DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with the DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/////////////////////\n// There is a solidity bug in the return parameters that it's not solved\n// when the bug is solved, the import from DAO is more clean.\n// In the meantime, a workaround proxy is defined\n\n// Uncoment this line when error fixed\n// import ""./DAO.sol"";\n\n// Workaround proxy remove when fixed\ncontract DAO {\n    function proposals(uint _proposalID) returns(\n        address recipient,\n        uint amount,\n        uint descriptionIdx,\n        uint votingDeadline,\n        bool open,\n        bool proposalPassed,\n        bytes32 proposalHash,\n        uint proposalDeposit,\n        bool newCurator\n    );\n\n    function transfer(address _to, uint256 _amount) returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _amount) returns (bool success);\n\n    function vote(\n        uint _proposalID,\n        bool _supportsProposal\n    ) returns (uint _voteID);\n\n    function balanceOf(address _owner) constant returns (uint256 balance);\n}\n// End of workaround proxy\n////////////////////\n\n\ncontract DTHPoolInterface {\n\n    // delegae url\n    string public delegateUrl;\n\n    // Max time the tokens can be blocked.\n    // The real voting in the DAO will be called in the last moment in order\n    // to block the tokens for the minimum time. This parameter defines the\n    // seconds before the voting period ends that the vote can be performed\n    uint maxTimeBlocked;\n\n\n    // Address of the delegate\n    address public delegate;\n\n    // The DAO contract\n    address public daoAddress;\n\n    struct ProposalStatus {\n\n        // True when the delegate sets the vote\n        bool voteSet;\n\n        // True if the proposal should ve voted\n        bool willVote;\n\n        // True if the proposal should be accepted.\n        bool suportProposal;\n\n        // True when the vote is performed;\n        bool executed;\n\n        // Proposal votingDeadline\n        uint votingDeadline;\n\n        // String set by the delegator with the motivation\n        string motivation;\n    }\n\n    // Statuses of the diferent proposal\n    mapping (uint => ProposalStatus) public proposalStatuses;\n\n\n    // Index of proposals by oraclizeId\n    mapping (bytes32 => uint) public oraclizeId2proposalId;\n\n    /// @dev Constructor setting the dao address and the delegate\n    /// @param _daoAddress address of the DAO\n    /// @param _delegate adddress of the delegate.\n    /// @param _maxTimeBlocked the maximum time the tokens will be blocked\n    /// @param _delegateName Name of the delegate\n    /// @param _delegateUrl Url of the delegate\n    /// @param _tokenSymbol token  symbol.\n    // DTHPool(address _daoAddress, address _delegate, uint _maxTimeBlocked, string _delegateName, string _delegateUrl, string _tokenSymbol);\n\n\n    /// @notice send votes to this contract.\n    /// @param _amount Tokens that will be transfered to the pool.\n    /// @return Whether the transfer was successful or not\n    function delegateDAOTokens(uint _amount) returns (bool _success);\n\n    /// Returns DAO tokens to the original\n    /// @param _amount that will be transfered back to the owner.\n    /// @return Whether the transfer was successful or not\n    function undelegateDAOTokens(uint _amount) returns (bool _success);\n\n\n    /// @notice This method will be called by the delegate to publish what will\n    /// be his vote in a specific proposal.\n    /// @param _proposalID The proposal to set the vote.\n    /// @param _willVote true If the proposal will be voted.\n    /// @param _supportsProposal What will be the vote.\n    function setVoteIntention(\n        uint _proposalID,\n        bool _willVote,\n        bool _supportsProposal,\n        string _motivation\n    ) returns (bool _success);\n\n    /// @notice This method will be doing the actual voting in the DAO\n    /// for the _proposalID\n    /// @param _proposalID The proposal to set the vote.\n    /// @return _finalized true if this vote Proposal must not be executed again.\n    function executeVote(uint _proposalID) returns (bool _finalized);\n\n\n    /// @notice This function is intended because if some body sends tokens\n    /// directly to this contract, the tokens can be sent to the delegate\n    function fixTokens() returns (bool _success);\n\n\n    /// @notice If some body sends ether to this contract, the delegate will be\n    /// able to extract it.\n    function getEther() returns (uint _amount);\n\n    /// @notice Called when some body delegates token to the pool\n    event Delegate(address indexed _from, uint256 _amount);\n\n    /// @notice Called when some body undelegates token to the pool\n    event Undelegate(address indexed _from, uint256 _amount);\n\n    /// @notice Called when the delegate set se vote intention\n    event VoteIntentionSet(uint indexed _proposalID, bool _willVote, bool _supportsProposal);\n\n    /// @notice Called when the vote is executed in the DAO\n    event VoteExecuted(uint indexed _proposalID);\n\n}\n\ncontract DTHPool is DTHPoolInterface, Token, usingOraclize {\n\n    modifier onlyDelegate() {if (msg.sender != delegate) throw; _}\n\n    // DTHPool(address _daoAddress, address _delegate, uint _maxTimeBlocked, string _delegateName, string _delegateUrl, string _tokenSymbol);\n\n    function DTHPool(\n        address _daoAddress,\n        address _delegate,\n        uint _maxTimeBlocked,\n        string _delegateName,\n        string _delegateUrl,\n        string _tokenSymbol\n    ) {\n        daoAddress = _daoAddress;\n        delegate = _delegate;\n        delegateUrl = _delegateUrl;\n        maxTimeBlocked = _maxTimeBlocked;\n        name = _delegateName;\n        symbol = _tokenSymbol;\n        decimals = 16;\n        oraclize_setNetwork(networkID_auto);\n    }\n\n    function delegateDAOTokens(uint _amount) returns (bool _success) {\n        DAO dao = DAO(daoAddress);\n        if (!dao.transferFrom(msg.sender, address(this), _amount)) {\n            throw;\n        }\n\n        balances[msg.sender] += _amount;\n        totalSupply += _amount;\n        Delegate(msg.sender, _amount);\n        return true;\n    }\n\n    function undelegateDAOTokens(uint _amount) returns (bool _success) {\n        DAO dao = DAO(daoAddress);\n        if (_amount > balances[msg.sender]) {\n            throw;\n        }\n\n        if (!dao.transfer(msg.sender, _amount)) {\n            throw;\n        }\n\n        balances[msg.sender] -= _amount;\n        totalSupply -= _amount;\n        Undelegate(msg.sender, _amount);\n        return true;\n    }\n\n    function setVoteIntention(\n        uint _proposalID,\n        bool _willVote,\n        bool _supportsProposal,\n        string _motivation\n    ) onlyDelegate returns (bool _success) {\n        DAO dao = DAO(daoAddress);\n\n        ProposalStatus proposalStatus = proposalStatuses[_proposalID];\n\n        if (proposalStatus.voteSet) {\n            throw;\n        }\n\n        var (,,,votingDeadline, ,,,,newCurator) = dao.proposals(_proposalID);\n\n        if (votingDeadline < now || newCurator ) {\n            throw;\n        }\n\n        proposalStatus.voteSet = true;\n        proposalStatus.willVote = _willVote;\n        proposalStatus.suportProposal = _supportsProposal;\n        proposalStatus.votingDeadline = votingDeadline;\n        proposalStatus.motivation = _motivation;\n\n        VoteIntentionSet(_proposalID, _willVote, _supportsProposal);\n\n        if (!_willVote) {\n            proposalStatus.executed = true;\n            VoteExecuted(_proposalID);\n        }\n\n        bool finalized = executeVote(_proposalID);\n\n        if ((!finalized)&&(address(OAR) != 0)) {\n            bytes32 oraclizeId = oraclize_query(votingDeadline - maxTimeBlocked +15, ""URL"", """");\n\n            oraclizeId2proposalId[oraclizeId] = _proposalID;\n        }\n\n        return true;\n    }\n\n    function executeVote(uint _proposalID) returns (bool _finalized) {\n        DAO dao = DAO(daoAddress);\n        ProposalStatus proposalStatus = proposalStatuses[_proposalID];\n\n        if (!proposalStatus.voteSet\n            || now > proposalStatus.votingDeadline\n            || !proposalStatus.willVote\n            || proposalStatus.executed) {\n\n            return true;\n        }\n\n        if (now < proposalStatus.votingDeadline - maxTimeBlocked) {\n            return false;\n        }\n\n        dao.vote(_proposalID, proposalStatus.suportProposal);\n        proposalStatus.executed = true;\n        VoteExecuted(_proposalID);\n\n        return true;\n    }\n\n    function __callback(bytes32 oid, string result) {\n        uint proposalId = oraclizeId2proposalId[oid];\n        executeVote(proposalId);\n        oraclizeId2proposalId[oid] = 0;\n    }\n\n    function fixTokens() returns (bool _success) {\n        DAO dao = DAO(daoAddress);\n        uint ownedTokens = dao.balanceOf(this);\n        if (ownedTokens < totalSupply) {\n            throw;\n        }\n        uint fixTokens = ownedTokens - totalSupply;\n\n        if (fixTokens == 0) {\n            return true;\n        }\n\n        balances[delegate] += fixTokens;\n        totalSupply += fixTokens;\n\n        return true;\n    }\n\n    function getEther() onlyDelegate returns (uint _amount) {\n        uint amount = this.balance;\n\n        if (!delegate.call.value(amount)()) {\n            throw;\n        }\n\n        return amount;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1665138,0xb9ecee3caa88e1864b8264b18d74a267c79aa2d1,false,false,"contract EthereumRouletteInterface {\n\n  // The owner is responsible for committing and revealing spin results.\n  address public owner;\n  // Funds that are kept in reserve in order to pay off the winners in all revealed spins.\n  // This number increases when new bets are made and decreases when winners collect their\n  // winnings. When all winnings have been collected, this should be 0.\n  uint public locked_funds_for_revealed_spins;\n  // How much time (in seconds) the owner has to reveal the result to a spin after the\n  // first bet has been made.\n  uint public owner_time_limit;\n  // Used to calculate the maximum bet a player can make.\n  uint public fraction;\n  // Maximum bet that a player can make on one of the numbers this spin.\n  uint public max_bet_this_spin;\n  // Contains all spins that happened so far. All spins, except that last two, are\n  // settled. A spin is settled if and only if the spin_result and nonce are revealed by\n  // the owner or owner_took_too_long flag is true. If a spin is settled, then players can\n  // collect their winnings from that spin. It's possible that the last two spins are also\n  // settled if the owner took too long.\n  Spin[] public spins;\n\n  struct Spin {\n    // If owner takes too long (does not respond in time and someone calls the\n    // player_declare_taking_too_long function), owner_took_too_long will be set to true\n    // and all players will be paid out. This represents the total sum that will be paid\n    // out in that case.\n    uint total_payout;\n    // The owner privately computes the sha3 of spin_result + nonce.\n    bytes32 commit_hash;\n    // Should be in [0, 37] range. 0 and 37 represent 0 and 00 on the roulette wheel.\n    uint8 spin_result;\n    // Some random value that the owner generates to make it impossible for someone to\n    // guess the spin_result based on the commit_hash.\n    bytes32 nonce;\n    // Total amount that was bet on a particular number. Used to verify that the amount\n    // bet on a number does not exceed max_bet_this_spin.\n    mapping(uint8 => uint) total_bet_on_number;\n    // Maps player address to a bet on a particular spin_result.\n    mapping(address => mapping(uint8 => Bet)) bets;\n    // This can be set to true if player_declare_taking_too_long is called if the owner is\n    // taking too long. In that case all bets in this round will be winners.\n    bool owner_took_too_long;\n    // Time (in seconds) by which the spin result should be revealed by the owner.\n    uint time_of_latest_reveal;\n  }\n\n  struct Bet {\n    uint amount;\n    // True if this bet was already paid.\n    bool already_paid;\n  }\n\n  // Allows only the owner to call certain functions.\n  modifier onlyOwner {}\n  // Verifies no Ether is sent when calling a function.\n  modifier noEther {}\n  // Verifies that more than 0 Ether is sent when calling a function.\n  modifier etherRequired {}\n\n  // Player makes a bet on a particular spin_result.\n  function player_make_bet(uint8 spin_result) etherRequired;\n\n  // Player calls this function to collect all winnings from a particular spin.\n  function player_collect_winnings(uint spin_num) noEther;\n\n  // If the owner is taking too long to reveal the spin result, player can call this\n  // function. If enough time passed, all bets in the last two spins (which are\n  // unrevealed) will become winners. Player can then call player_collect_winnings.\n  function player_declare_taking_too_long() noEther;\n\n  // Owner reveals the spin_result and nonce for the first unrevealed spin (which is\n  // second last in the spins array). Owner also also adds a new unrevealed spin to the\n  // spins array. All new player bets will be on this new spin after this function is\n  // called.\n  //\n  // The reason why we always have two unrevealed spins (instead of 1) is because of this\n  // function. If there was only 1 unrevealed spin, when the owner tried revealing it,\n  // an attacker would be able to see the spin result in the transaction that the owner\n  // submits and quickly try to place a bet on the spin_result to try to get his\n  // trasaction to be processed before the owner.\n  function owner_reveal_and_commit(uint8 spin_result, bytes32 nonce, bytes32 commit_hash) onlyOwner noEther;\n\n  // Set a new time limit for the owner between commit and reveal.\n  function owner_set_time_limit(uint new_time_limit) onlyOwner noEther;\n\n  // Allows the owner to deposit additional funds into the contract.\n  function owner_deposit() onlyOwner etherRequired;\n\n  // Allows the owner to withdraw the winnings. Makes sure that the owner does not\n  // withdraw any funds that should be paid out to the players.\n  function owner_withdraw(uint amount) onlyOwner noEther;\n\n  // Updates the fraction (has an effect on how large the player bets can be).\n  function owner_set_fraction(uint _fraction) onlyOwner noEther;\n\n  function owner_transfer_ownership(address new_owner) onlyOwner noEther;\n\n  event MadeBet(uint amount, uint8 spin_result, address player_addr);\n  event Revealed(uint spin_number, uint8 spin_result);\n}\n\n\ncontract EthereumRoulette is EthereumRouletteInterface {\n\n  modifier onlyOwner {if (msg.sender != owner) throw; _}\n\n  modifier noEther {if (msg.value > 0) throw; _}\n\n  modifier etherRequired {if (msg.value == 0) throw; _}\n\n  function EthereumRoulette() {\n    owner = msg.sender;\n    fraction = 800;\n    owner_time_limit = 7 days;\n    // The contract must always have 2 unrevealed spins. This is why we commit the first\n    // two spins in the constructor. This means that it's not possible to bet on spin #1.\n    bytes32 first_num_hash = 0x3c81cf7279de81901303687979a6b62fdf04ec93480108d2ef38090d6135ad9f;\n    bytes32 second_num_hash = 0xb1540f17822cbe4daef5f1d96662b2dc92c5f9a2411429faaf73555d3149b68e;\n    spins.length++;\n    spins[spins.length - 1].commit_hash = first_num_hash;\n    spins.length++;\n    spins[spins.length - 1].commit_hash = second_num_hash;\n    max_bet_this_spin = address(this).balance / fraction;\n  }\n\n  function player_make_bet(uint8 spin_result) etherRequired {\n    Spin second_unrevealed_spin = spins[spins.length - 1];\n    if (second_unrevealed_spin.owner_took_too_long\n        || spin_result > 37\n        || msg.value + second_unrevealed_spin.total_bet_on_number[spin_result] > max_bet_this_spin\n        // verify it will be possible to pay the player in the worst case\n        || msg.value * 36 + reserved_funds() > address(this).balance) {\n      throw;\n    }\n    Bet b = second_unrevealed_spin.bets[msg.sender][spin_result];\n    b.amount += msg.value;\n    second_unrevealed_spin.total_bet_on_number[spin_result] += msg.value;\n    second_unrevealed_spin.total_payout += msg.value * 36;\n    if (second_unrevealed_spin.time_of_latest_reveal == 0) {\n      second_unrevealed_spin.time_of_latest_reveal = now + owner_time_limit;\n    }\n    MadeBet(msg.value, spin_result, msg.sender);\n  }\n\n  function player_collect_winnings(uint spin_num) noEther {\n    Spin s = spins[spin_num];\n    if (spin_num >= spins.length - 2) {\n      throw;\n    }\n    if (s.owner_took_too_long) {\n      bool at_least_one_number_paid = false;\n      for (uint8 roulette_num = 0; roulette_num < 38; roulette_num++) {\n        Bet messed_up_bet = s.bets[msg.sender][roulette_num];\n        if (messed_up_bet.already_paid) {\n          throw;\n        }\n        if (messed_up_bet.amount > 0) {\n          msg.sender.send(messed_up_bet.amount * 36);\n          locked_funds_for_revealed_spins -= messed_up_bet.amount * 36;\n          messed_up_bet.already_paid = true;\n          at_least_one_number_paid = true;\n        }\n      }\n      if (!at_least_one_number_paid) {\n        // If at least one number does not get paid, we let the user know when they try to estimate gas.\n        throw;\n      }\n    } else {\n      Bet b = s.bets[msg.sender][s.spin_result];\n      if (b.already_paid || b.amount == 0) {\n        throw;\n      }\n      msg.sender.send(b.amount * 36);\n      locked_funds_for_revealed_spins -= b.amount * 36;\n      b.already_paid = true;\n    }\n  }\n\n  function player_declare_taking_too_long() noEther {\n    Spin first_unrevealed_spin = spins[spins.length - 2];\n    bool first_spin_too_long = first_unrevealed_spin.time_of_latest_reveal != 0\n        && now > first_unrevealed_spin.time_of_latest_reveal;\n    Spin second_unrevealed_spin = spins[spins.length - 1];\n    bool second_spin_too_long = second_unrevealed_spin.time_of_latest_reveal != 0\n        && now > second_unrevealed_spin.time_of_latest_reveal;\n    if (!(first_spin_too_long || second_spin_too_long)) {\n      throw;\n    }\n    first_unrevealed_spin.owner_took_too_long = true;\n    second_unrevealed_spin.owner_took_too_long = true;\n    locked_funds_for_revealed_spins += (first_unrevealed_spin.total_payout + second_unrevealed_spin.total_payout);\n  }\n\n  function () {\n    // Do not allow sending Ether without calling a function.\n    throw;\n  }\n\n  function commit(bytes32 commit_hash) internal {\n    uint spin_num = spins.length++;\n    Spin second_unrevealed_spin = spins[spins.length - 1];\n    second_unrevealed_spin.commit_hash = commit_hash;\n    max_bet_this_spin = (address(this).balance - reserved_funds()) / fraction;\n  }\n\n  function owner_reveal_and_commit(uint8 spin_result, bytes32 nonce, bytes32 commit_hash) onlyOwner noEther {\n    Spin first_unrevealed_spin = spins[spins.length - 2];\n    if (!first_unrevealed_spin.owner_took_too_long) {\n      if (sha3(spin_result, nonce) != first_unrevealed_spin.commit_hash || spin_result > 37) {\n        throw;\n      }\n      first_unrevealed_spin.spin_result = spin_result;\n      first_unrevealed_spin.nonce = nonce;\n      locked_funds_for_revealed_spins += first_unrevealed_spin.total_bet_on_number[spin_result] * 36;\n      Revealed(spins.length - 2, spin_result);\n    }\n    // If owner took too long, the spin result and nonce can be ignored because all payers\n    // won.\n    commit(commit_hash);\n  }\n\n  function owner_set_time_limit(uint new_time_limit) onlyOwner noEther {\n    if (new_time_limit > 2 weeks) {\n      // We don't want the owner to be able to set a time limit of something like 1000\n      // years.\n      throw;\n    }\n    owner_time_limit = new_time_limit;\n  }\n\n  function owner_deposit() onlyOwner etherRequired {}\n\n  function owner_withdraw(uint amount) onlyOwner noEther {\n    if (amount > address(this).balance - reserved_funds()) {\n      throw;\n    }\n    owner.send(amount);\n  }\n\n  function owner_set_fraction(uint _fraction) onlyOwner noEther {\n    if (_fraction == 0) {\n      throw;\n    }\n    fraction = _fraction;\n  }\n\n  function owner_transfer_ownership(address new_owner) onlyOwner noEther {\n    owner = new_owner;\n  }\n\n  function seconds_left() constant returns(int) {\n    // Seconds left until player_declare_taking_too_long can be called.\n    Spin s = spins[spins.length - 1];\n    if (s.time_of_latest_reveal == 0) {\n      return -1;\n    }\n    if (now > s.time_of_latest_reveal) {\n      return 0;\n    }\n    return int(s.time_of_latest_reveal - now);\n  }\n\n  function reserved_funds() constant returns (uint) {\n    // These funds cannot be withdrawn by the owner. This is the amount contract will have\n    // to keep in reserve to be able to pay all players in the worst case.\n    uint total = locked_funds_for_revealed_spins;\n    Spin first_unrevealed_spin = spins[spins.length - 2];\n    if (!first_unrevealed_spin.owner_took_too_long) {\n      total += first_unrevealed_spin.total_payout;\n    }\n    Spin second_unrevealed_spin = spins[spins.length - 1];\n    if (!second_unrevealed_spin.owner_took_too_long) {\n      total += second_unrevealed_spin.total_payout;\n    }\n    return total;\n  }\n\n  function get_hash(uint8 number, bytes32 nonce) constant returns (bytes32) {\n    return sha3(number, nonce);\n  }\n\n  function bet_this_spin() constant returns (bool) {\n    // Returns true if there was a bet placed in the latest spin.\n    Spin s = spins[spins.length - 1];\n    return s.time_of_latest_reveal != 0;\n  }\n\n  function check_bet(uint spin_num, address player_addr, uint8 spin_result) constant returns (uint) {\n    // Returns the amount of ether a player player bet on a spin result in a given spin\n    // number.\n    Spin s = spins[spin_num];\n    Bet b = s.bets[player_addr][spin_result];\n    return b.amount;\n  }\n\n  function current_spin_number() constant returns (uint) {\n    // Returns the number of the current spin.\n    return spins.length - 1;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ルーレットゲームのロジックを実装。
1674585,0x51053a30e0243653a6c7daf8e87f5764e97685ee,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\ncontract BitcoinBridge is usingOraclize {\n    string constant SHAPESHIFT_ENDPOINT =\n        ""json(https://shapeshift.io/shift).deposit"";\n\n    struct Task {\n        bytes32 oraclizeId;\n        bytes bitcoinAddress;\n        uint value;\n        uint timestamp;\n    }\n\n    mapping (uint => Task) public tasks;\n    mapping (bytes32 => uint) public oraclizeRequests;\n\n    uint public nextId = 1;\n\n    function queuePayment(bytes bitcoinAddress) oraclizeAPI\n                                                returns (bool successful) {\n        uint oraclizePrice = oraclize.getPrice(""URL"");\n        if (msg.value <= oraclizePrice) throw;\n\n        uint value = msg.value - oraclizePrice;\n\n        uint id = nextId++;\n        string memory json = strConcat(\n            '{""pair"": ""eth_btc"", ""withdrawal"": ""',\n            string(bitcoinAddress),\n            '""}'\n        );\n        bytes32 oraclizeId = oraclize.query2.value(oraclizePrice)(\n            0,\n            ""URL"",\n            SHAPESHIFT_ENDPOINT,\n            json\n        );\n        tasks[id].oraclizeId = oraclizeId;\n        tasks[id].bitcoinAddress = bitcoinAddress;\n        tasks[id].value = value;\n        tasks[id].timestamp = now;\n        oraclizeRequests[oraclizeId] = id;\n\n        return true;\n    }\n\n    function __callback(bytes32 oraclizeId, string result) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n\n        uint id = oraclizeRequests[oraclizeId];\n        if (id == 0) return;\n\n        address addr = parseAddr(result);\n        addr.send(tasks[id].value);\n\n        delete oraclizeRequests[oraclizeId];\n        delete tasks[id];\n    }\n\n    function retryOraclizeRequest(uint id) oraclizeAPI {\n        if (tasks[id].oraclizeId == 0) throw;\n\n        uint timePassed = now - tasks[id].timestamp;\n        if (timePassed < 60 minutes) throw;\n\n        uint oraclizePrice = oraclize.getPrice(""URL"");\n        if (msg.value < oraclizePrice) throw;\n\n        string memory json = strConcat(\n            '{""pair"": ""eth_btc"", ""withdrawal"": ""',\n            string(tasks[id].bitcoinAddress),\n            '""}'\n        );\n        bytes32 newOraclizeId = oraclize.query2.value(oraclizePrice)(\n            0,\n            ""URL"",\n            SHAPESHIFT_ENDPOINT,\n            json\n        );\n\n        delete oraclizeRequests[tasks[id].oraclizeId];\n        tasks[id].oraclizeId = newOraclizeId;\n        tasks[id].timestamp = now;\n        oraclizeRequests[newOraclizeId] = id;\n\n        if (msg.value > oraclizePrice) {\n            msg.sender.send(msg.value - oraclizePrice);\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1680647,0x1d9e61248f88dc60889bb269fcf2244827f3a682,false,false,"contract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		http://d.ethereumlottery.net\n		ver: 2.1.0\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	uint private constant fee = 5;\n	uint private constant investorFee = 50;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 26;\n	\n    bool public ContractEnabled = true;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private ContractDisabledBlock;\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n		uint id;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] private investors;\n	\n	string constant public Information = ""http://d.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function dEthereumlotteryNet() {\n		owner = msg.sender;\n		investors.length = 1;\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n	    if (jackpot_ == 0) {\n	        Rate = 0;\n	        Bet = 0;\n	        return;\n	    }\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		if (Value < Bet) {\n		    Rate++;\n		    Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n		    Rate = BestRollRate;\n		    Bet = getRealBet(Rate);\n        }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		uint InvestorID = getInvestorByAddress(Address);\n		if (InvestorID == 0 || ! investors[InvestorID].valid) {\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n		Investment = investors[InvestorID].value;\n		Balance = investors[InvestorID].balance;\n		Live = investors[InvestorID].live;\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() OnlyEnabled external {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) {\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].timestamp = now + investMinDuration;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		jackpot_ += value_;\n		setJackpot();\n	}\n	function GetMyInvestmentBalance() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].balance == 0) { throw; }\n		if ( ! msg.sender.send( investors[InvestorID].balance )) { throw; }\n		investors[InvestorID].balance = 0;\n	}\n	function CancelMyInvestment() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].timestamp > now && ContractEnabled) { throw; }\n		uint balance_;\n		if (investors[InvestorID].live) {\n			jackpot_ -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		if ( ! msg.sender.send( balance_ )) { throw; }\n		delete investors[InvestorID];\n	}\n	/* For Players */\n	function DoRoll() external noEther {\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, false, true, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if ( ! ContractEnabled || jackpot_ == 0 || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, true, false, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if ( ! found) { throw; }\n		if (value_ > 0) { if ( ! msg.sender.send(value_)) { throw; } }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		uint _rate = getRate(msg.value);\n		uint _realBet = getRealBet(_rate);\n		if (msg.value < _realBet) {\n		    _rate++;\n		    _realBet = getRealBet(_rate);\n		}\n		if (_rate < BestRollRate) { \n		    _rate = BestRollRate;\n		    _realBet = getRealBet(_rate);\n        }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! ContractEnabled) {\n		    if (ContractDisabledBlock < block.number) {\n				if (playersPot == 0) { throw; }\n				if ( ! msg.sender.send( playersPot )) { throw; }\n				playersPot = 0;\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n			ContractDisabled(ContractDisabledBlock);\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner noEther {\n		if (feeValue == 0) { throw; }\n		if ( ! owner.send(feeValue)) { throw; }\n		feeValue = 0;\n	}\n	\n	/*\n		Private functions\n	*/\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=1 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n			DoRollEvent(msg.sender, win, players[msg.sender][id].id, false, false, false, true, bigNumber, _rate, bigNumber % _rate);\n		} else {\n			DoRollEvent(msg.sender, players[msg.sender][id].value, players[msg.sender][id].id, false, false, true, false, bigNumber, _rate, bigNumber % _rate);\n		}\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=1 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		RollCount++;\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		players[msg.sender][rollID].id = RollCount;\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, players[msg.sender][rollID].value, players[msg.sender][rollID].id);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1000000 / value * 100 / investorFee * extraRate / 100 / 1000000;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1000000 / ( rate * 1000000 * investorFee / extraRate);\n	}\n	function getInvestorByAddress(address Address) internal returns (uint id) {\n		for ( id=1 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return;\n			}\n		}\n		return 0;\n	}\n	\n	/*\n		Events\n	*/	\n	event DoRollEvent(address Player, uint Value, uint RollID, bool Refund, bool LostBet, bool LossRoll, bool WinRoll, uint BigNumber, uint Rate, uint RollResult);\n	event PrepareRollEvent(address Player, uint Block, uint Bet, uint RollID);\n	event ContractDisabled(uint LossAllBetBlockNumber);\n	\n	/*\n		Modifiers\n	*/\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1685116,0x7fd022cc8b6e019260627fafa1d9c3afece18cef,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :   \n//   The ROULETH \n//\n//  Play the Roulette on ethereum blockchain !\n//  (or become an investor in the Casino and share the profits/losses.) \n//\n//\n//   website : www.WhySoS3rious.com/Rouleth\n//               with a flashy roulette :) !\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n//\n//\n//  Stake : Variable, check on website for the max bet.\n//  At launch the max stake is 0.05 ETH\n//\n//\n//  How to play ?\n//  1) Simplest (via transactions from your wallet, not an exchange) : \n//  Just send the value you want to bet to the contract and add enough gas \n//  (you can enter the max gas amount of ~4,5Million, any excess is refunded anyways)\n//  This will by default place a bet on number 7\n//  Wait 2 minutes (6 blocks) and send (with enough gas) 1 wei (or any amount, it will be refunded)\n//  This will spin the wheel and you will receive * 35 your bet if you win.\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\n//\n//  2) Advanced (via contract functions, e.g. Mist, cf. tutorial on my website for more details) :\n//  Import the contract in Mist wallet using the code of the ABI (link on my website)\n//  Use the functions (betOnNumber, betOnColor ...) to place any type of bet you want\n//  Provide the appropriate input (ex: check box Red or Black)\n//  add the amount you want to bet.\n//  wait 6 blocks, then use the function spinTheWheel, this will solve the bet.\n//  You can only place one bet at a time before you spin the wheel.\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\n//\n//\n//\n//  Use the website to track your bets and the results of the spins\n//\n//\n//   How to invest ?\n//   Import the contract in Mist Wallet using the code of the ABI (link on my website)\n//   Use the Invest function with an amount >10 Ether (can change, check on my website)\n//   You will become an investor and share the profits and losses of the roulette\n//   proportionally to your investment. There is a 2% fee on investment to help with the server/website\n//   cost and also 2% on profit that go to the developper.\n//   The rest of your investment goes directly to the payroll and 98% of profits are shared between \n//   investors relatively to their share of total. Losses are split similarly.\n//   You can withdraw your funds at any time after the initial lock period (set to 1 week)\n//   To withdraw use the function withdraw and specify the amoutn you want to withdraw in Wei.\n//   If your withdraw brings your investment under 10 eth (the min invest, subject to change)\n//   then you will execute a full withdraw and stop being an investor.\n//   Check your current investor balance in Mist by using the information functions on the left side\n//   If you want to update the balances to the last state (otherwise they are automatically\n//   updated after each invest or withdraw), you can use the function manualUpdateBalances in Mist.\n//   \n//   The casino should be profitable in the long run (with 99% confidence). \n//   The maximum bet allowed has been computed through statistical analysis to yield high confidence \n//   in the long run survival of the casino. The maximum bet is always smaller than the current payroll \n//   of the casino * 35 (max pay multiplier) * casinoStatisticalLimit (statistical sample size that allows \n//   to have enough confidence in survival, set at 20 at start, should increase to 200 when we have more \n//   investors to increase the safety).\n//   \n//   At start there is a limit of 50 investors (can be changed via settings up to 150)\n//   If there is no open position and you want to invest, you can try to buyout a current investor.\n//   To buyout, you have to invest more than any investor whose funds are unlocked (after 1 week grace lock period)\n//   If there are no remaining open position and all investors are under grace period, it is not possible to \n//   become a new investor in the casino.\n//\n//   At any time an investor can add funds to his investment with the withdraw function.\n//   Doing so will refresh the lock period and secure your position.\n//\n//\n//   A provably fair roulette :  note on Random Number Generation.\n//   The roulette result is based on the hash of the 6th block after the player commits his bet.\n//   This guarantees a provably fair roulette with equiprobable results and non predictable\n//   unless someone has more computing power than all the Ethereum Network.\n//   Yet Miners could try to exploit their position in 2 ways.\n//   First they could try to mine 7 blocks in a row (to commit their bet based on result for a sure win),\n//   but this is highly improbable and not predictible.\n//   Second they could commit a bet, then wait 6 blocks and hope that they will be the one forming the \n//   block on which their commited bet depends. If this is the case and the hash they find is not a\n//   winning one, they could decide to not share the block with the network but would lose 5 ether.\n//   To counter this potential miner edge (=base win proba + (miner proba to find block)*base win proba )\n//   we keep wager amounts far smaller than 5 Eth so that the miner prefers to get his block reward than cheat.\n//   Note that a miner could place several bets on the same block to increase his potential profit from dropping a block\n//   For this reason we limit the number of bets per block to 2 at start (configurable later if needed).\ncontract Rouleth\n{\n\n    //Variables, Structure\n    address developer;\n    uint8 blockDelay; //nb of blocks to wait before spin\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\n    uint256 maxGamble; //max gamble value manually set by config\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\n    uint casinoStatisticalLimit;\n    //Current gamble value possibly lower than config (<payroll/(20*35))\n    uint256 currentMaxGamble; \n    //Gambles\n    struct Gamble\n    {\n	address player;\n        bool spinned; //Was the rouleth spinned ?\n	bool win;\n	BetTypes betType; //number/color/dozen/oddeven\n	uint8 input; //stores number, color, dozen or oddeven\n	uint256 wager;\n	uint256 blockNumber; //block of bet -1\n        uint8 wheelResult;\n    }\n    Gamble[] private gambles;\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\n    //Tracking progress of players\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\n    enum Status {waitingForBet, waitingForSpin} Status status; //gamble status\n    mapping (address=>Status) playerStatus; //progress of the player's gamble\n\n    //**********************************************\n    //        Management & Config FUNCTIONS        //\n    //**********************************************\n	function  Rouleth() private //creation settings\n    { \n        developer = msg.sender;\n        blockDelay=6; //delay to wait between bet and spin\n	blockExpiration=200; //delay after which gamble expires\n        maxGamble=50 finney; //0.05 ether as max bet to start (payroll of 35 eth)\n        maxBetsPerBlock=2; // limit of 2 bets per block, to prevent multiple bets per miners (to keep max reward<5ETH)\n        casinoStatisticalLimit=20;\n    }\n	\n    modifier onlyDeveloper() {\n	    if (msg.sender!=developer) throw;\n	    _\n    }\n	\n	function changeDeveloper(address new_dev)\n        noEthSent\n	    onlyDeveloper\n	{\n		developer=new_dev;\n	}\n\n\n    //Activate, Deactivate Betting\n    enum States{active, inactive} States private state;\n	function disableBetting()\n    noEthSent\n	onlyDeveloper\n	{\n            state=States.inactive;\n	}\n	function enableBetting()\n	onlyDeveloper\n        noEthSent\n	{\n            state=States.active;\n	}\n    \n	modifier onlyActive\n    {\n        if (state==States.inactive) throw;\n        _\n    }\n\n         //Change some settings within safety bounds\n	function changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\n	noEthSent\n	onlyDeveloper\n	{\n	        // changes the statistical multiplier that guarantees the long run casino survival\n	        if (newCasinoStatLimit<20) throw;\n	        casinoStatisticalLimit=newCasinoStatLimit;\n	        //Max number of bets per block to prevent miner cheating\n	        maxBetsPerBlock=newMaxBetsBlock;\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\n		if (newMaxGamble<=0 || newMaxGamble>=this.balance/(20*35)) throw; \n		else { maxGamble=newMaxGamble; }\n                //MAX NB of INVESTORS (can only increase and max of 149)\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\n                else { setting_maxInvestors=newMaxInvestor;}\n                //MIN INVEST : \n                setting_minInvestment=newMinInvestment;\n                //Invest LOCK PERIOD\n                if (setting_lockPeriod>5184000) throw; //2 months max\n                setting_lockPeriod=newLockPeriod;\n		        //Delay before roll :\n		if (blockDelay<1) throw;\n		        blockDelay=newBlockDelay;\n                updateMaxBet();\n		if (newBlockExpiration<100) throw;\n		blockExpiration=newBlockExpiration;\n	}\n \n\n    //**********************************************\n    //                 BETTING FUNCTIONS                    //\n    //**********************************************\n\n//***//basic betting without Mist or contract call\n    //activates when the player only sends eth to the contract\n    //without specifying any type of bet.\n    function () \n   {\n       //if player is not playing : bet on 7\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnNumber(7);\n       //if player is already playing, spin the wheel\n       else spinTheWheel();\n    } \n\n    function updateMaxBet() private\n    {\n    //check that maxGamble setting is still within safety bounds\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \n		{ \n			currentMaxGamble=maxGamble;\n                }\n	else\n		{ \n			currentMaxGamble = payroll/(20*35);\n		}\n     }\n\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\n    function checkBetValue() private returns(uint256 playerBetValue)\n    {\n        updateMaxBet();\n		if (msg.value > currentMaxGamble) //if above max, send difference back\n		{\n		    msg.sender.send(msg.value-currentMaxGamble);\n		    playerBetValue=currentMaxGamble;\n		}\n                else\n                { playerBetValue=msg.value; }\n       }\n\n\n    //check number of bets in block (to prevent miner cheating and keep max reward per block <5ETH)\n    modifier checkNbBetsCurrentBlock()\n    {\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\n        else nbBetsCurrentBlock=0;\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\n        _\n    }\n    //check that the player is not playing already (unless it has expired)\n    modifier checkWaitingForBet{\n        //if player is already in gamble\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\n        {\n             //case not expired\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\n             //case expired\n             else\n             {\n                  //add bet to PL and reset status\n                  solveBet(msg.sender, 255, false, 0) ;\n\n              }\n        }\n	_\n	}\n\n    //Possible bet types\n    enum BetTypes{ number, color, parity, dozen, column, lowhigh} BetTypes private initbetTypes;\n\n    function updateStatusPlayer() private\n    expireGambles\n    {\n	playerStatus[msg.sender]=Status.waitingForSpin;\n	gambleIndex[msg.sender]=gambles.length-1;\n     }\n\n//***//bet on Number	\n    function betOnNumber(uint8 numberChosen)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        //check that number chosen is valid and records bet\n        if (numberChosen>36) throw;\n		//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnColor\n	//bet type : color\n	//input : 0 for red\n	//input : 1 for black\n    function betOnColor(bool Red, bool Black)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Red) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Black) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnLow_High\n	//bet type : lowhigh\n	//input : 0 for low\n	//input : 1 for low\n    function betOnLowHigh(bool Low, bool High)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Low) \n        { \n             count+=1; \n             input=0;\n         }\n        if (High) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnOdd_Even\n	//bet type : parity\n     //input : 0 for even\n    //input : 1 for odd\n    function betOnOddEven(bool Odd, bool Even)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Even) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Odd) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n\n//***// function betOnDozen\n//     //bet type : dozen\n//     //input : 0 for first dozen\n//     //input : 1 for second dozen\n//     //input : 2 for third dozen\n    function betOnDozen(bool First, bool Second, bool Third)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\n    }\n\n\n// //***// function betOnColumn\n//     //bet type : column\n//     //input : 0 for first column\n//     //input : 1 for second column\n//     //input : 2 for third column\n    function betOnColumn(bool First, bool Second, bool Third)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\n     }\n\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\n    { \n        uint8 count;\n        uint8 input;\n        if (First) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Second) \n        {\n             count+=1; \n             input=1;\n         }\n        if (Third) \n        {\n             count+=1; \n             input=2;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n    //**********************************************\n    // Spin The Wheel & Check Result FUNCTIONS//\n    //**********************************************\n\n	event Win(address player, uint8 result, uint value_won);\n	event Loss(address player, uint8 result, uint value_loss);\n\n    //check that player has to spin the wheel\n    modifier checkWaitingForSpin{\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\n	_\n	}\n    //Prevents accidental sending of Eth when you shouldn't\n    modifier noEthSent()\n    {\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n\n//***//function to spin\n    function spinTheWheel()\n    checkWaitingForSpin\n    noEthSent\n    {\n        //check that the player waited for the delay before spin\n        //and also that the bet is not expired (200 blocks limit)\n	uint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\n	if (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\n    else\n	{\n	    uint8 wheelResult;\n        //Spin the wheel, Reset player status and record result\n		wheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\n		updateFirstActiveGamble(gambleIndex[msg.sender]);\n		gambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\n        //check result against bet and pay if win\n		checkBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\n	}\n    }\n\nfunction updateFirstActiveGamble(uint bet_id) private\n     {\n         if (bet_id==firstActiveGamble)\n         {   \n              uint index=firstActiveGamble;\n              while (true)\n              {\n                 if (index<gambles.length && gambles[index].spinned){\n                     index=index+1;\n                 }\n                 else {break; }\n               }\n              firstActiveGamble=index;\n              return;\n          }\n }\n	\n//checks if there are expired gambles\nmodifier expireGambles{\n    if (  (gambles.length!=0 && gambles.length-1>=firstActiveGamble ) \n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number && !gambles[firstActiveGamble].spinned )  \n    { \n	solveBet(gambles[firstActiveGamble].player, 255, false, 0);\n        updateFirstActiveGamble(firstActiveGamble);\n    }\n        _\n}\n	\n\n     //CHECK BETS FUNCTIONS private\n     function checkBetResult(uint8 result, BetTypes betType) private\n     {\n          //bet on Number\n          if (betType==BetTypes.number) checkBetNumber(result);\n          else if (betType==BetTypes.parity) checkBetParity(result);\n          else if (betType==BetTypes.color) checkBetColor(result);\n	 else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\n	 else if (betType==BetTypes.dozen) checkBetDozen(result);\n	else if (betType==BetTypes.column) checkBetColumn(result);\n          updateMaxBet(); \n     }\n\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\n     {\n        playerStatus[msg.sender]=Status.waitingForBet;\n        gambles[gambleIndex[player]].spinned=true;\n	uint bet_v = gambles[gambleIndex[player]].wager;\n            if (win)\n            {\n		  gambles[gambleIndex[player]].win=true;\n		  uint win_v = multiplier*bet_v;\n                  player.send(win_v);\n                  lossSinceChange+=win_v-bet_v;\n		  Win(player, result, win_v);\n             }\n            else\n            {\n		Loss(player, result, bet_v);\n                profitSinceChange+=bet_v;\n            }\n\n      }\n\n\n     // checkbeton number(input)\n    // bet type : number\n    // input : chosen number\n     function checkBetNumber(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result==gambles[gambleIndex[msg.sender]].input)\n	    {\n                  win=true;  \n             }\n             solveBet(msg.sender, result,win,35);\n     }\n\n\n     // checkbet on oddeven\n    // bet type : parity\n    // input : 0 for even, 1 for odd\n     function checkBetParity(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\n	    {\n                  win=true;                \n             }\n             solveBet(msg.sender,result,win,2);\n        \n     }\n	\n     // checkbet on lowhigh\n     // bet type : lowhigh\n     // input : 0 low, 1 high\n     function checkBetLowhigh(uint8 result) private\n     {\n            bool win;\n            //win\n		 if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\n			 || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\n			 ) )\n	    {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n     }\n\n     // checkbet on color\n     // bet type : color\n     // input : 0 red, 1 black\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\n      function checkBetColor(uint8 result) private\n      {\n             bool red;\n             //check if red\n             for (uint8 k; k<18; k++)\n             { \n                    if (red_list[k]==result) \n                    { \n                          red=true; \n                          break;\n                    }\n             }\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n       }\n\n     // checkbet on dozen\n     // bet type : dozen\n     // input : 0 first, 1 second, 2 third\n     function checkBetDozen(uint8 result) private\n     { \n            bool win;\n            //win on first dozen\n     		 if ( result!=0 &&\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\n     			||\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\n                    ||\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\n     	    {\n                   win=true;                \n             }\n             solveBet(msg.sender,result,win,3);\n     }\n\n     // checkbet on column\n     // bet type : column\n     // input : 0 first, 1 second, 2 third\n      function checkBetColumn(uint8 result) private\n      {\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,3);\n      }\n\n\n//INVESTORS FUNCTIONS\n\n\n//total casino payroll\n    uint256 payroll;\n//Profit Loss since last investor change\n    uint256 profitSinceChange;\n    uint256 lossSinceChange;\n//investor struct array (hard capped to 150)\n    uint8 setting_maxInvestors = 50;\n    struct Investor\n    {\n	    address investor;\n	    uint256 time;\n    }	\n	Investor[150] private investors ;\n    //Balances of the investors\n    mapping (address=>uint256) balance; \n    //Investor lockPeriod\n    //lock time to avoid invest and withdraw for refresh only\n    //also time during which you cannot be outbet by a new investor if it is full\n    uint256 setting_lockPeriod=604800 ; //1 week in sec\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\n    //if full and unlocked position, indicates the cheapest amount to outbid\n    //otherwise cheapestUnlockedPosition=255\n    uint8 cheapestUnlockedPosition; \n    uint256 minCurrentInvest; \n    //record open position index\n    // =255 if full\n    uint8 openPosition;\n	\n    event newInvest(address player, uint invest_v);\n\n\n     function invest()\n     {\n          // check that min 10 ETH is sent (variable setting)\n          if (msg.value<setting_minInvestment) throw;\n          // check if already investor\n          bool alreadyInvestor;\n          // reset the position counters to values out of bounds\n          openPosition=255;\n          cheapestUnlockedPosition=255;\n          minCurrentInvest=10000000000000000000000000;//\n          // update balances before altering the investor shares\n          updateBalances();\n          // loop over investor's array to find if already investor, \n          // or openPosition and cheapest UnlockedPosition\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\n          { \n               //captures an index of an open position\n               if (investors[k].investor==0) openPosition=k; \n               //captures if already an investor \n               else if (investors[k].investor==msg.sender)\n               {\n                    investors[k].time=now; //refresh time invest\n                    alreadyInvestor=true;\n                }\n               //captures the index of the investor with the min investment (after lock period)\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\n               {\n                    cheapestUnlockedPosition=k;\n                    minCurrentInvest=balance[investors[k].investor];\n                }\n           }\n           //case New investor\n           if (alreadyInvestor==false)\n           {\n                    //case : investor array not full, record new investor\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\n                    //case : investor array full\n                    else\n                    {\n                         //subcase : investor has not outbid or all positions under lock period\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\n                         //subcase : investor outbid, record investor change and refund previous\n                         else\n                         {\n                              address previous = investors[cheapestUnlockedPosition].investor;\n                              if (previous.send(balance[previous])==false) throw;\n                              balance[previous]=0;\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\n                          }\n                     }\n            }\n          //add investment to balance of investor and to payroll\n\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\n          uint256 netInvest=msg.value - maintenanceFees;\n          newInvest(msg.sender, netInvest);\n          balance[msg.sender]+=netInvest; //add invest to balance\n          payroll+=netInvest;\n          //send maintenance fees to developer \n          if (developer.send(maintenanceFees)==false) throw;\n          updateMaxBet();\n      }\n\n//***// Withdraw function (only after lockPeriod)\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\n    // if your withdraw brings your balance under the min investment required,\n    // your balance is fully withdrawn\n	event withdraw(address player, uint withdraw_v);\n	\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\n    noEthSent\n    {\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\n        updateBalances();\n	//check that amount requested is authorized  \n	if (amountToWithdrawInWei>balance[msg.sender]) throw;\n        //retrieve investor ID\n        uint8 investorID=255;\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\n        {\n               if (investors[k].investor==msg.sender)\n               {\n                    investorID=k;\n                    break;\n               }\n        }\n           if (investorID==255) throw; //stop if not an investor\n           //check if investment lock period is over\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\n           //if balance left after withdraw is still above min investment accept partial withdraw\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\n           {\n               balance[msg.sender]-=amountToWithdrawInWei;\n               payroll-=amountToWithdrawInWei;\n               //send amount to investor (with security if transaction fails)\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\n	       withdraw(msg.sender, amountToWithdrawInWei);\n           }\n           else\n           //if amountToWithdraw=0 : user wants full withdraw\n           //if balance after withdraw is < min invest, withdraw all and delete investor\n           {\n               //send amount to investor (with security if transaction fails)\n               uint256 fullAmount=balance[msg.sender];\n               payroll-=fullAmount;\n               balance[msg.sender]=0;\n               if (msg.sender.send(fullAmount)==false) throw;\n               //delete investor\n               delete investors[investorID];\n   	       withdraw(msg.sender, fullAmount);\n            }\n          updateMaxBet();\n     }\n\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\n\n	function manualUpdateBalances()\n	expireGambles\n	noEthSent\n	{\n	    updateBalances();\n	}\n    function updateBalances() private\n    {\n         //split Profits\n         uint256 profitToSplit;\n         uint256 lossToSplit;\n         if (profitSinceChange==0 && lossSinceChange==0)\n         { return; }\n         \n         else\n         {\n             // Case : Global profit (more win than losses)\n             // 2% fees for developer on global profit (if profit>loss)\n             if (profitSinceChange>lossSinceChange)\n             {\n                profitToSplit=profitSinceChange-lossSinceChange;\n                uint256 developerFees=profitToSplit*2/100;\n                profitToSplit-=developerFees;\n                if (developer.send(developerFees)==false) throw;\n             }\n             else\n             {\n                lossToSplit=lossSinceChange-profitSinceChange;\n             }\n         \n         //share the loss and profits between all invest \n         //(proportionnaly. to each investor balance)\n         uint totalShared;\n             for (uint8 k=0; k<setting_maxInvestors; k++)\n             {\n                 address inv=investors[k].investor;\n                 if (inv==0) continue;\n                 else\n                 {\n                       if (profitToSplit!=0) \n                       {\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\n                           balance[inv]+=profitShare;\n                           totalShared+=profitShare;\n                       }\n                       if (lossToSplit!=0) \n                       {\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\n                           balance[inv]-=lossShare;\n                           totalShared+=lossShare;\n                           \n                       }\n                 }\n             }\n          // update payroll\n          if (profitToSplit !=0) \n          {\n              payroll+=profitToSplit;\n              balance[developer]+=profitToSplit-totalShared;\n          }\n          if (lossToSplit !=0) \n          {\n              payroll-=lossToSplit;\n              balance[developer]-=lossToSplit-totalShared;\n          }\n          profitSinceChange=0; //reset Profit;\n          lossSinceChange=0; //reset Loss ;\n          \n          }\n     }\n     \n     \n     //INFORMATION FUNCTIONS\n     \n     function checkProfitLossSinceInvestorChange() constant returns(uint profit, uint loss)\n     {\n        profit=profitSinceChange;\n        loss=lossSinceChange;\n        return;\n     }\n\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\n    {\n          balanceInWei=balance[investor];\n          return;\n     }\n\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\n    {\n          investor=investors[index].investor;\n          endLockPeriod=investors[index].time+setting_lockPeriod;\n          return;\n    }\n	\n\n	function investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\n	{\n		if (openPosition!=255) open_position=true;\n		if (cheapestUnlockedPosition!=255) \n		{\n			unlocked_position=true;\n			buyout_amount=minCurrentInvest;\n		}\n		investLockPeriod=setting_lockPeriod;\n		return;\n	}\n	\n	function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\n	{\n	    maxBet=currentMaxGamble;\n	    blockDelayBeforeSpin=blockDelay;\n	    return ;\n	}\n	\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\n    {\n          player_status=playerStatus[player];\n          bettype=gambles[gambleIndex[player]].betType;\n          input=gambles[gambleIndex[player]].input;\n          value=gambles[gambleIndex[player]].wager;\n          result=gambles[gambleIndex[player]].wheelResult;\n          wheelspinned=gambles[gambleIndex[player]].spinned;\n          win=gambles[gambleIndex[player]].win;\n		blockNb=gambles[gambleIndex[player]].blockNumber;\n		  return;\n     }\n\n} //end of contract",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1687367,0x6dfaa563d04a77aff4c4ad2b17cf4c64d2983dc8,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :   \n//   The ROULETH \n//\n//  Play the Roulette on ethereum blockchain !\n//  (or become an investor in the Casino and share the profits/losses.) \n//\n//\n//   website : www.WhySoS3rious.com/Rouleth\n//               with a flashy roulette :) !\n//\n//   check latest contract version on website\n//   V 1.0.2\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n//\n//\n//  Stake : Variable, check on website for the max bet.\n//  At launch the max stake is 0.05 ETH\n//\n//\n//  How to play ?\n//  1) Simplest (via transactions from your wallet, not an exchange) : \n//  Just send the value you want to bet to the contract and add enough gas \n//  (you can enter the max gas amount of ~4,5Million, any excess is refunded anyways)\n//  This will by default place a bet on number 7\n//  Wait 2 minutes (6 blocks) and send (with enough gas) 1 wei (or any amount, it will be refunded)\n//  This will spin the wheel and you will receive * 35 your bet if you win.\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\n//\n//  2) Advanced (via contract functions, e.g. Mist, cf. tutorial on my website for more details) :\n//  Import the contract in Mist wallet using the code of the ABI (link on my website)\n//  Use the functions (betOnNumber, betOnColor ...) to place any type of bet you want\n//  Provide the appropriate input (ex: check box Red or Black)\n//  add the amount you want to bet.\n//  wait 6 blocks, then use the function spinTheWheel, this will solve the bet.\n//  You can only place one bet at a time before you spin the wheel.\n//  Don't wait more than 200 blocks before you spin the wheel or your bet will expire.\n//\n//\n//\n//  Use the website to track your bets and the results of the spins\n//\n//\n//   How to invest ?\n//   Import the contract in Mist Wallet using the code of the ABI (link on my website)\n//   Use the Invest function with an amount >10 Ether (can change, check on my website)\n//   You will become an investor and share the profits and losses of the roulette\n//   proportionally to your investment. There is a 2% fee on investment to help with the server/website\n//   cost and also 2% on profit that go to the developper.\n//   The rest of your investment goes directly to the payroll and 98% of profits are shared between \n//   investors relatively to their share of total. Losses are split similarly.\n//   You can withdraw your funds at any time after the initial lock period (set to 1 week)\n//   To withdraw use the function withdraw and specify the amoutn you want to withdraw in Wei.\n//   If your withdraw brings your investment under 10 eth (the min invest, subject to change)\n//   then you will execute a full withdraw and stop being an investor.\n//   Check your current investor balance in Mist by using the information functions on the left side\n//   If you want to update the balances to the last state (otherwise they are automatically\n//   updated after each invest or withdraw), you can use the function manualUpdateBalances in Mist.\n//   \n//   The casino should be profitable in the long run (with 99% confidence). \n//   The maximum bet allowed has been computed through statistical analysis to yield high confidence \n//   in the long run survival of the casino. The maximum bet is always smaller than the current payroll \n//   of the casino * 35 (max pay multiplier) * casinoStatisticalLimit (statistical sample size that allows \n//   to have enough confidence in survival, set at 20 at start, should increase to 200 when we have more \n//   investors to increase the safety).\n//   \n//   At start there is a limit of 50 investors (can be changed via settings up to 150)\n//   If there is no open position and you want to invest, you can try to buyout a current investor.\n//   To buyout, you have to invest more than any investor whose funds are unlocked (after 1 week grace lock period)\n//   If there are no remaining open position and all investors are under grace period, it is not possible to \n//   become a new investor in the casino.\n//\n//   At any time an investor can add funds to his investment with the withdraw function.\n//   Doing so will refresh the lock period and secure your position.\n//\n//\n//   A provably fair roulette :  note on Random Number Generation.\n//   The roulette result is based on the hash of the 6th block after the player commits his bet.\n//   This guarantees a provably fair roulette with equiprobable results and non predictable\n//   unless someone has more computing power than all the Ethereum Network.\n//   Yet Miners could try to exploit their position in 2 ways.\n//   First they could try to mine 7 blocks in a row (to commit their bet based on result for a sure win),\n//   but this is highly improbable and not predictible.\n//   Second they could commit a bet, then wait 6 blocks and hope that they will be the one forming the \n//   block on which their commited bet depends. If this is the case and the hash they find is not a\n//   winning one, they could decide to not share the block with the network but would lose 5 ether.\n//   To counter this potential miner edge (=base win proba + (miner proba to find block)*base win proba )\n//   we keep wager amounts far smaller than 5 Eth so that the miner prefers to get his block reward than cheat.\n//   Note that a miner could place several bets on the same block to increase his potential profit from dropping a block\n//   For this reason we limit the number of bets per block to 2 at start (configurable later if needed).\ncontract Rouleth\n{\n\n    //Variables, Structure\n    address developer;\n    uint8 blockDelay; //nb of blocks to wait before spin\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\n    uint256 maxGamble; //max gamble value manually set by config\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\n    uint casinoStatisticalLimit;\n    //Current gamble value possibly lower than config (<payroll/(20*35))\n    uint256 currentMaxGamble; \n    //Gambles\n    struct Gamble\n    {\n	address player;\n        bool spinned; //Was the rouleth spinned ?\n	bool win;\n	BetTypes betType; //number/color/dozen/oddeven\n	uint8 input; //stores number, color, dozen or oddeven\n	uint256 wager;\n	uint256 blockNumber; //block of bet -1\n        uint8 wheelResult;\n    }\n    Gamble[] private gambles;\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\n    //Tracking progress of players\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\n    enum Status {waitingForBet, waitingForSpin} Status status; //gamble status\n    mapping (address=>Status) playerStatus; //progress of the player's gamble\n\n    //**********************************************\n    //        Management & Config FUNCTIONS        //\n    //**********************************************\n	function  Rouleth() private //creation settings\n    { \n        developer = msg.sender;\n        blockDelay=6; //delay to wait between bet and spin\n	blockExpiration=200; //delay after which gamble expires\n        maxGamble=50 finney; //0.05 ether as max bet to start (payroll of 35 eth)\n        maxBetsPerBlock=2; // limit of 2 bets per block, to prevent multiple bets per miners (to keep max reward<5ETH)\n        casinoStatisticalLimit=20;\n    }\n	\n    modifier onlyDeveloper() {\n	    if (msg.sender!=developer) throw;\n	    _\n    }\n	\n	function changeDeveloper(address new_dev)\n        noEthSent\n	    onlyDeveloper\n	{\n		developer=new_dev;\n	}\n\n\n    //Activate, Deactivate Betting\n    enum States{active, inactive} States private state;\n	function disableBetting()\n    noEthSent\n	onlyDeveloper\n	{\n            state=States.inactive;\n	}\n	function enableBetting()\n	onlyDeveloper\n        noEthSent\n	{\n            state=States.active;\n	}\n    \n	modifier onlyActive\n    {\n        if (state==States.inactive) throw;\n        _\n    }\n\n         //Change some settings within safety bounds\n	function changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\n	noEthSent\n	onlyDeveloper\n	{\n	        // changes the statistical multiplier that guarantees the long run casino survival\n	        if (newCasinoStatLimit<20) throw;\n	        casinoStatisticalLimit=newCasinoStatLimit;\n	        //Max number of bets per block to prevent miner cheating\n	        maxBetsPerBlock=newMaxBetsBlock;\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\n		if (newMaxGamble<=0 || newMaxGamble>=this.balance/(20*35)) throw; \n		else { maxGamble=newMaxGamble; }\n                //MAX NB of INVESTORS (can only increase and max of 149)\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\n                else { setting_maxInvestors=newMaxInvestor;}\n                //MIN INVEST : \n                setting_minInvestment=newMinInvestment;\n                //Invest LOCK PERIOD\n                if (setting_lockPeriod>5184000) throw; //2 months max\n                setting_lockPeriod=newLockPeriod;\n		        //Delay before roll :\n		if (blockDelay<1) throw;\n		        blockDelay=newBlockDelay;\n                updateMaxBet();\n		if (newBlockExpiration<100) throw;\n		blockExpiration=newBlockExpiration;\n	}\n \n\n    //**********************************************\n    //                 BETTING FUNCTIONS                    //\n    //**********************************************\n\n//***//basic betting without Mist or contract call\n    //activates when the player only sends eth to the contract\n    //without specifying any type of bet.\n    function () \n   {\n       //if player is not playing : bet on 7\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnNumber(7);\n       //if player is already playing, spin the wheel\n       else spinTheWheel();\n    } \n\n    function updateMaxBet() private\n    {\n    //check that maxGamble setting is still within safety bounds\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \n		{ \n			currentMaxGamble=maxGamble;\n                }\n	else\n		{ \n			currentMaxGamble = payroll/(20*35);\n		}\n     }\n\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\n    function checkBetValue() private returns(uint256 playerBetValue)\n    {\n        updateMaxBet();\n		if (msg.value > currentMaxGamble) //if above max, send difference back\n		{\n		    msg.sender.send(msg.value-currentMaxGamble);\n		    playerBetValue=currentMaxGamble;\n		}\n                else\n                { playerBetValue=msg.value; }\n       }\n\n\n    //check number of bets in block (to prevent miner cheating and keep max reward per block <5ETH)\n    modifier checkNbBetsCurrentBlock()\n    {\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\n        else nbBetsCurrentBlock=0;\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\n        _\n    }\n    //check that the player is not playing already (unless it has expired)\n    modifier checkWaitingForBet{\n        //if player is already in gamble\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\n        {\n             //case not expired\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\n             //case expired\n             else\n             {\n                  //add bet to PL and reset status\n                  solveBet(msg.sender, 255, false, 0) ;\n\n              }\n        }\n	_\n	}\n\n    //Possible bet types\n    enum BetTypes{ number, color, parity, dozen, column, lowhigh} BetTypes private initbetTypes;\n\n    function updateStatusPlayer() private\n    expireGambles\n    {\n	playerStatus[msg.sender]=Status.waitingForSpin;\n	gambleIndex[msg.sender]=gambles.length-1;\n     }\n\n//***//bet on Number	\n    function betOnNumber(uint8 numberChosen)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        //check that number chosen is valid and records bet\n        if (numberChosen>36) throw;\n		//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnColor\n	//bet type : color\n	//input : 0 for red\n	//input : 1 for black\n    function betOnColor(bool Red, bool Black)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Red) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Black) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnLow_High\n	//bet type : lowhigh\n	//input : 0 for low\n	//input : 1 for low\n    function betOnLowHigh(bool Low, bool High)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Low) \n        { \n             count+=1; \n             input=0;\n         }\n        if (High) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n//***// function betOnOdd_Even\n	//bet type : parity\n     //input : 0 for even\n    //input : 1 for odd\n    function betOnOddEven(bool Odd, bool Even)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Even) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Odd) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n\n//***// function betOnDozen\n//     //bet type : dozen\n//     //input : 0 for first dozen\n//     //input : 1 for second dozen\n//     //input : 2 for third dozen\n    function betOnDozen(bool First, bool Second, bool Third)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\n    }\n\n\n// //***// function betOnColumn\n//     //bet type : column\n//     //input : 0 for first column\n//     //input : 1 for second column\n//     //input : 2 for third column\n    function betOnColumn(bool First, bool Second, bool Third)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\n     }\n\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\n    { \n        uint8 count;\n        uint8 input;\n        if (First) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Second) \n        {\n             count+=1; \n             input=1;\n         }\n        if (Third) \n        {\n             count+=1; \n             input=2;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	    gambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\n        updateStatusPlayer();\n    }\n\n    //**********************************************\n    // Spin The Wheel & Check Result FUNCTIONS//\n    //**********************************************\n\n	event Win(address player, uint8 result, uint value_won);\n	event Loss(address player, uint8 result, uint value_loss);\n\n    //check that player has to spin the wheel\n    modifier checkWaitingForSpin{\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\n	_\n	}\n    //Prevents accidental sending of Eth when you shouldn't\n    modifier noEthSent()\n    {\n        if (msg.value>0) msg.sender.send(msg.value);\n        _\n    }\n\n//***//function to spin\n    function spinTheWheel()\n    checkWaitingForSpin\n    noEthSent\n    {\n        //check that the player waited for the delay before spin\n        //and also that the bet is not expired (200 blocks limit)\n	uint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\n	if (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\n    else\n	{\n	    uint8 wheelResult;\n        //Spin the wheel, Reset player status and record result\n		wheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\n		gambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\n        //check result against bet and pay if win\n		checkBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\n		updateFirstActiveGamble(gambleIndex[msg.sender]);\n	}\n    }\n\nfunction updateFirstActiveGamble(uint bet_id) private\n     {\n         if (bet_id==firstActiveGamble)\n         {   \n              uint index;\n              if (firstActiveGamble!=0) index=firstActiveGamble-1;\n              while (true)\n              {\n                 if (index<gambles.length && gambles[index].spinned)\n                 {\n                     index=index+1;\n                 }\n                 else {break; }\n               }\n              firstActiveGamble=index;\n              return;\n          }\n }\n	\n//checks if there are expired gambles\nmodifier expireGambles{\n    if (  (gambles.length!=0 && gambles.length-1>=firstActiveGamble ) \n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number && !gambles[firstActiveGamble].spinned )  \n    { \n	solveBet(gambles[firstActiveGamble].player, 255, false, 0);\n        updateFirstActiveGamble(firstActiveGamble);\n    }\n        _\n}\n	\n\n     //CHECK BETS FUNCTIONS private\n     function checkBetResult(uint8 result, BetTypes betType) private\n     {\n          //bet on Number\n          if (betType==BetTypes.number) checkBetNumber(result);\n          else if (betType==BetTypes.parity) checkBetParity(result);\n          else if (betType==BetTypes.color) checkBetColor(result);\n	 else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\n	 else if (betType==BetTypes.dozen) checkBetDozen(result);\n	else if (betType==BetTypes.column) checkBetColumn(result);\n          updateMaxBet(); \n     }\n\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\n     {\n        playerStatus[msg.sender]=Status.waitingForBet;\n        gambles[gambleIndex[player]].spinned=true;\n	uint bet_v = gambles[gambleIndex[player]].wager;\n            if (win)\n            {\n		  gambles[gambleIndex[player]].win=true;\n		  uint win_v = multiplier*bet_v;\n                  player.send(win_v);\n                  lossSinceChange+=win_v-bet_v;\n		  Win(player, result, win_v);\n             }\n            else\n            {\n		Loss(player, result, bet_v);\n                profitSinceChange+=bet_v;\n            }\n\n      }\n\n\n     // checkbeton number(input)\n    // bet type : number\n    // input : chosen number\n     function checkBetNumber(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result==gambles[gambleIndex[msg.sender]].input)\n	    {\n                  win=true;  \n             }\n             solveBet(msg.sender, result,win,35);\n     }\n\n\n     // checkbet on oddeven\n    // bet type : parity\n    // input : 0 for even, 1 for odd\n     function checkBetParity(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\n	    {\n                  win=true;                \n             }\n             solveBet(msg.sender,result,win,2);\n        \n     }\n	\n     // checkbet on lowhigh\n     // bet type : lowhigh\n     // input : 0 low, 1 high\n     function checkBetLowhigh(uint8 result) private\n     {\n            bool win;\n            //win\n		 if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\n			 || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\n			 ) )\n	    {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n     }\n\n     // checkbet on color\n     // bet type : color\n     // input : 0 red, 1 black\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\n      function checkBetColor(uint8 result) private\n      {\n             bool red;\n             //check if red\n             for (uint8 k; k<18; k++)\n             { \n                    if (red_list[k]==result) \n                    { \n                          red=true; \n                          break;\n                    }\n             }\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n       }\n\n     // checkbet on dozen\n     // bet type : dozen\n     // input : 0 first, 1 second, 2 third\n     function checkBetDozen(uint8 result) private\n     { \n            bool win;\n            //win on first dozen\n     		 if ( result!=0 &&\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\n     			||\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\n                    ||\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\n     	    {\n                   win=true;                \n             }\n             solveBet(msg.sender,result,win,3);\n     }\n\n     // checkbet on column\n     // bet type : column\n     // input : 0 first, 1 second, 2 third\n      function checkBetColumn(uint8 result) private\n      {\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,3);\n      }\n\n\n//INVESTORS FUNCTIONS\n\n\n//total casino payroll\n    uint256 payroll;\n//Profit Loss since last investor change\n    uint256 profitSinceChange;\n    uint256 lossSinceChange;\n//investor struct array (hard capped to 150)\n    uint8 setting_maxInvestors = 50;\n    struct Investor\n    {\n	    address investor;\n	    uint256 time;\n    }	\n	Investor[150] private investors ;\n    //Balances of the investors\n    mapping (address=>uint256) balance; \n    //Investor lockPeriod\n    //lock time to avoid invest and withdraw for refresh only\n    //also time during which you cannot be outbet by a new investor if it is full\n    uint256 setting_lockPeriod=604800 ; //1 week in sec\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\n    //if full and unlocked position, indicates the cheapest amount to outbid\n    //otherwise cheapestUnlockedPosition=255\n    uint8 cheapestUnlockedPosition; \n    uint256 minCurrentInvest; \n    //record open position index\n    // =255 if full\n    uint8 openPosition;\n	\n    event newInvest(address player, uint invest_v);\n\n\n     function invest()\n     {\n          // check that min 10 ETH is sent (variable setting)\n          if (msg.value<setting_minInvestment) throw;\n          // check if already investor\n          bool alreadyInvestor;\n          // reset the position counters to values out of bounds\n          openPosition=255;\n          cheapestUnlockedPosition=255;\n          minCurrentInvest=10000000000000000000000000;//\n          // update balances before altering the investor shares\n          updateBalances();\n          // loop over investor's array to find if already investor, \n          // or openPosition and cheapest UnlockedPosition\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\n          { \n               //captures an index of an open position\n               if (investors[k].investor==0) openPosition=k; \n               //captures if already an investor \n               else if (investors[k].investor==msg.sender)\n               {\n                    investors[k].time=now; //refresh time invest\n                    alreadyInvestor=true;\n                }\n               //captures the index of the investor with the min investment (after lock period)\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\n               {\n                    cheapestUnlockedPosition=k;\n                    minCurrentInvest=balance[investors[k].investor];\n                }\n           }\n           //case New investor\n           if (alreadyInvestor==false)\n           {\n                    //case : investor array not full, record new investor\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\n                    //case : investor array full\n                    else\n                    {\n                         //subcase : investor has not outbid or all positions under lock period\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\n                         //subcase : investor outbid, record investor change and refund previous\n                         else\n                         {\n                              address previous = investors[cheapestUnlockedPosition].investor;\n                              if (previous.send(balance[previous])==false) throw;\n                              balance[previous]=0;\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\n                          }\n                     }\n            }\n          //add investment to balance of investor and to payroll\n\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\n          uint256 netInvest=msg.value - maintenanceFees;\n          newInvest(msg.sender, netInvest);\n          balance[msg.sender]+=netInvest; //add invest to balance\n          payroll+=netInvest;\n          //send maintenance fees to developer \n          if (developer.send(maintenanceFees)==false) throw;\n          updateMaxBet();\n      }\n\n//***// Withdraw function (only after lockPeriod)\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\n    // if your withdraw brings your balance under the min investment required,\n    // your balance is fully withdrawn\n	event withdraw(address player, uint withdraw_v);\n	\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\n    noEthSent\n    {\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\n        updateBalances();\n	//check that amount requested is authorized  \n	if (amountToWithdrawInWei>balance[msg.sender]) throw;\n        //retrieve investor ID\n        uint8 investorID=255;\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\n        {\n               if (investors[k].investor==msg.sender)\n               {\n                    investorID=k;\n                    break;\n               }\n        }\n           if (investorID==255) throw; //stop if not an investor\n           //check if investment lock period is over\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\n           //if balance left after withdraw is still above min investment accept partial withdraw\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\n           {\n               balance[msg.sender]-=amountToWithdrawInWei;\n               payroll-=amountToWithdrawInWei;\n               //send amount to investor (with security if transaction fails)\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\n	       withdraw(msg.sender, amountToWithdrawInWei);\n           }\n           else\n           //if amountToWithdraw=0 : user wants full withdraw\n           //if balance after withdraw is < min invest, withdraw all and delete investor\n           {\n               //send amount to investor (with security if transaction fails)\n               uint256 fullAmount=balance[msg.sender];\n               payroll-=fullAmount;\n               balance[msg.sender]=0;\n               if (msg.sender.send(fullAmount)==false) throw;\n               //delete investor\n               delete investors[investorID];\n   	       withdraw(msg.sender, fullAmount);\n            }\n          updateMaxBet();\n     }\n\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\n\n	function manualUpdateBalances()\n	expireGambles\n	noEthSent\n	{\n	    updateBalances();\n	}\n    function updateBalances() private\n    {\n         //split Profits\n         uint256 profitToSplit;\n         uint256 lossToSplit;\n         if (profitSinceChange==0 && lossSinceChange==0)\n         { return; }\n         \n         else\n         {\n             // Case : Global profit (more win than losses)\n             // 2% fees for developer on global profit (if profit>loss)\n             if (profitSinceChange>lossSinceChange)\n             {\n                profitToSplit=profitSinceChange-lossSinceChange;\n                uint256 developerFees=profitToSplit*2/100;\n                profitToSplit-=developerFees;\n                if (developer.send(developerFees)==false) throw;\n             }\n             else\n             {\n                lossToSplit=lossSinceChange-profitSinceChange;\n             }\n         \n         //share the loss and profits between all invest \n         //(proportionnaly. to each investor balance)\n         uint totalShared;\n             for (uint8 k=0; k<setting_maxInvestors; k++)\n             {\n                 address inv=investors[k].investor;\n                 if (inv==0) continue;\n                 else\n                 {\n                       if (profitToSplit!=0) \n                       {\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\n                           balance[inv]+=profitShare;\n                           totalShared+=profitShare;\n                       }\n                       if (lossToSplit!=0) \n                       {\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\n                           balance[inv]-=lossShare;\n                           totalShared+=lossShare;\n                           \n                       }\n                 }\n             }\n          // update payroll\n          if (profitToSplit !=0) \n          {\n              payroll+=profitToSplit;\n              balance[developer]+=profitToSplit-totalShared;\n          }\n          if (lossToSplit !=0) \n          {\n              payroll-=lossToSplit;\n              balance[developer]-=lossToSplit-totalShared;\n          }\n          profitSinceChange=0; //reset Profit;\n          lossSinceChange=0; //reset Loss ;\n          \n          }\n     }\n     \n     \n     //INFORMATION FUNCTIONS\n     \n     function checkProfitLossSinceInvestorChange() constant returns(uint profit, uint loss)\n     {\n        profit=profitSinceChange;\n        loss=lossSinceChange;\n        return;\n     }\n\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\n    {\n          balanceInWei=balance[investor];\n          return;\n     }\n\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\n    {\n          investor=investors[index].investor;\n          endLockPeriod=investors[index].time+setting_lockPeriod;\n          return;\n    }\n	\n\n	function investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\n	{\n		if (openPosition!=255) open_position=true;\n		if (cheapestUnlockedPosition!=255) \n		{\n			unlocked_position=true;\n			buyout_amount=minCurrentInvest;\n		}\n		investLockPeriod=setting_lockPeriod;\n		return;\n	}\n	\n	function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\n	{\n	    maxBet=currentMaxGamble;\n	    blockDelayBeforeSpin=blockDelay;\n	    return ;\n	}\n\n	function getFirstActiveDuel() constant returns(uint _firstActiveGamble)\n	{\n            _firstActiveGamble=firstActiveGamble;\n	    return ;\n	}\n\n	\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\n    {\n          player_status=playerStatus[player];\n          bettype=gambles[gambleIndex[player]].betType;\n          input=gambles[gambleIndex[player]].input;\n          value=gambles[gambleIndex[player]].wager;\n          result=gambles[gambleIndex[player]].wheelResult;\n          wheelspinned=gambles[gambleIndex[player]].spinned;\n          win=gambles[gambleIndex[player]].win;\n	blockNb=gambles[gambleIndex[player]].blockNumber;\n	  return;\n     }\n\n} //end of contract",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。コメントが多く、機能説明が詳細。
1695670,0xe709c6c933bda30963274d5bdd1e556c655c59fe,false,false,"contract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\n//token contract used as reward\ncontract token {\n    mapping (address => uint256) public totalInvestmentOf;\n    function transfer(address receiver, uint amount){  }\n    function updateInvestmentTotal(address _to, uint256 _value){ }\n    function burnUnsoldCoins(address _removeCoinsFrom){ }\n}\n\ncontract Crowdsale is owned {\n    uint public amountRaised;\n    //20160 minutes (two weeks)\n    uint public deadline;\n    //1 token for 1 ETH week 1\n    uint public price = 1 ether;\n    //address of token used as reward\n    token public tokenReward;\n    Funder[] public funders;\n    event FundTransfer(address backer, uint amount, bool isContribution);\n    //crowdsale is open\n    bool crowdsaleClosed = false;\n    //countdown to week two price increase\n    uint weekTwoPriceRiseBegin = now + 10080 * 1 minutes;\n    //refund any remainders\n    uint remainderRefund;\n    uint amountAfterRefund;\n    //80/20 split\n    uint bankrollBeneficiaryAmount;\n    uint etherollBeneficiaryAmount;\n    //80% sent here at end of crowdsale\n    address public beneficiary;\n    //20% to etheroll\n    address etherollBeneficiary = 0x5de92686587b10cd47e03b71f2e2350606fcaf14;\n\n    //data structure to hold information about campaign contributors\n    struct Funder {\n        address addr;\n        uint amount;\n    }\n\n    //owner\n    function Crowdsale(\n        address ifSuccessfulSendTo,\n        uint durationInMinutes,\n        //uint etherCostOfEachToken,\n        token addressOfTokenUsedAsReward\n    ) {\n        beneficiary = ifSuccessfulSendTo;\n        deadline = now + durationInMinutes * 1 minutes;\n        //price = price;\n        tokenReward = token(addressOfTokenUsedAsReward);\n    }\n\n\n\n    function () {\n        //crowdsale period is over\n        if(now > deadline) crowdsaleClosed = true;\n        if (crowdsaleClosed) throw;\n        uint amount = msg.value;\n\n        //refund if value sent is below token price\n        if(amount < price) throw;\n\n        //week 1 price\n        if(now < weekTwoPriceRiseBegin){\n            //return any ETH in case of remainder\n            remainderRefund = amount % price;\n            if(remainderRefund > 0){\n                //quietly refund any spare change\n                msg.sender.send(remainderRefund);\n                amountAfterRefund = amount-remainderRefund;\n                tokenReward.transfer(msg.sender, amountAfterRefund / price);\n                amountRaised += amountAfterRefund;\n                funders[funders.length++] = Funder({addr: msg.sender, amount: amountAfterRefund});\n                tokenReward.updateInvestmentTotal(msg.sender, amountAfterRefund);\n                FundTransfer(msg.sender, amountAfterRefund, true);\n            }\n\n            //same but no remainder\n            if(remainderRefund == 0){\n                 amountRaised += amount;\n                 tokenReward.transfer(msg.sender, amount / price);\n                 funders[funders.length++] = Funder({addr: msg.sender, amount: amount});\n                 tokenReward.updateInvestmentTotal(msg.sender, amount);\n                 FundTransfer(msg.sender, amount, true);\n            }\n        }\n\n        //week 2 price\n        if(now >= weekTwoPriceRiseBegin){\n            //price rise in week two\n            //1 token for 1.5ETH\n            if(price == 1 ether){price = (price*150)/100;}\n            //tokenReward.transfer(msg.sender, amount / price, amount);\n            //return any ETH in case of remainder\n            remainderRefund = amount % price;\n            if(remainderRefund > 0){\n                //quietly refund any spare change\n                msg.sender.send(remainderRefund);\n                amountAfterRefund = amount-remainderRefund;\n                tokenReward.transfer(msg.sender, amountAfterRefund / price);\n                amountRaised += amountAfterRefund;\n                funders[funders.length++] = Funder({addr: msg.sender, amount: amountAfterRefund});\n                tokenReward.updateInvestmentTotal(msg.sender, amountAfterRefund);\n                FundTransfer(msg.sender, amountAfterRefund, true);\n            }\n\n            //same but no remainder\n            if(remainderRefund == 0){\n                 tokenReward.transfer(msg.sender, amount / price);\n                 amountRaised += amount;\n                 funders[funders.length++] = Funder({addr: msg.sender, amount: amount});\n                 tokenReward.updateInvestmentTotal(msg.sender, amount);\n                 FundTransfer(msg.sender, amount, true);\n            }\n        }\n    }\n\n    //modifier for only after end of crowdsale\n    modifier afterDeadline() { if (now >= deadline) _ }\n\n    //modifier for only after week 1 price rise\n    modifier afterPriceRise() { if (now >= weekTwoPriceRiseBegin) _ }\n\n    /*checks if the time limit has been reached and ends the campaign\n    anybody can call this after the deadline\n    80% of funds sent to final etheroll bankroll SC\n    20% of funds  sent to an address for etheroll salaries*/\n    function checkGoalReached() afterDeadline {\n        //house bankroll receives 80%\n        bankrollBeneficiaryAmount = (amountRaised*80)/100;\n        beneficiary.send(bankrollBeneficiaryAmount);\n        FundTransfer(beneficiary, bankrollBeneficiaryAmount, false);\n        //etheroll receives 20%\n        etherollBeneficiaryAmount = (amountRaised*20)/100;\n        etherollBeneficiary.send(etherollBeneficiaryAmount);\n        FundTransfer(etherollBeneficiary, etherollBeneficiaryAmount, false);\n        etherollBeneficiary.send(this.balance); // send any remaining balance to etherollBeneficiary anyway\n        //burn any remaining unsold coins\n        //tokenReward.burnUnsoldCoins();\n        crowdsaleClosed = true;\n    }\n\n    //update token price week two\n    //this does happen automatically when someone purchases tokens week 2\n    //but nice to update for users\n    function updateTokenPriceWeekTwo() afterPriceRise {\n        //funky price updates\n        if(price == 1 ether){price = (price*150)/100;}\n    }\n\n    function burnCoins(address _removeCoinsFrom)\n        onlyOwner\n    {\n        tokenReward.burnUnsoldCoins(_removeCoinsFrom);\n    }\n\n    //in case of absolute emergency\n    //returns all funds to investors\n    //divestment schedule is better in the beneficiary contract as no gas limit concerns\n    function returnFunds()\n        onlyOwner\n    {\n        for (uint i = 0; i < funders.length; ++i) {\n          funders[i].addr.send(funders[i].amount);\n          FundTransfer(funders[i].addr, funders[i].amount, false);\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1698925,0x02268047f5c77a6a533619773474d1a6e510443f,false,false,"contract Creator {\n    function newContract(bytes data) public returns (address) {\n        address theNewContract;\n        uint s = data.length;\n\n        assembly {\n            calldatacopy(mload(0x40), 68, s)\n            theNewContract := create(callvalue, mload(0x40), s)\n        }\n\n        return theNewContract;\n    }\n}",1,低レベルのアセンブリを使用した実用的なコントラクト作成機能。
1702741,0x580114cbeb41c62f55ff55ca9e6f028ceb92ae91,false,false,"contract RandomInterface {\n	function getRandom() returns (bytes32 hash) {}\n}\ncontract WinnerDBInterface {\n	function Winners(uint id) constant returns(uint date, address addr, uint value, uint rate, uint bet)  {}\n	function newWinner(uint date, address addr, uint value, uint rate, uint bet) external returns (bool) {}\n}\ncontract dEthereumlotteryNet {\n	/*\n		dEthereumlotteryNet\n		Coded by: iFA\n		http://d.ethereumlottery.net\n		ver: 2.2.1\n	*/\n	\n	/*\n		Vars\n	*/\n	address private owner;\n	address private winnersDB;\n	address private randomAddr;\n	uint private constant fee = 5;\n	uint private constant investorFee = 70;\n	uint private constant prepareBlockDelay = 4;\n	uint private constant rollLossBlockDelay = 30;\n	uint private constant investUnit = 1 ether;\n	uint private constant extraRate = 130;\n	uint private constant minimumRollPrice = 10 finney;\n	uint private constant investMinDuration = 1 days;\n	uint private constant BestRollRate = 100;\n	\n    bool public ContractEnabled = true;\n	uint public Jackpot;\n	uint public RollCount;\n	uint public JackpotHits;\n	\n	uint private ContractDisabledBlock;\n	uint private jackpot_;\n	uint private extraJackpot_;\n	uint private feeValue;\n	uint private playersPot;\n	\n	struct rolls_s {\n		uint blockNumber;\n		bytes32 extraHash;\n		bool valid;\n		uint value;\n		uint game;\n		uint id;\n		uint sumInvest;\n	}\n	\n	mapping(address => rolls_s[]) private players;\n	\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint timestamp;\n	}\n	\n	investors_s[] private investors;\n	\n	string constant public Information = ""http://d.ethereumlottery.net"";\n	\n	/*\n		Deploy\n	*/\n	function dEthereumlotteryNet(address _winnersDB, address _oldcontract, address _randomAddr) {\n		owner = msg.sender;\n		investors.length++;\n		winnersDB = _winnersDB;\n		randomAddr = _randomAddr;\n		if (_oldcontract != 0x0) {\n			RollCount = dEthereumlotteryNet( _oldcontract ).RollCount();\n			JackpotHits = dEthereumlotteryNet( _oldcontract ).JackpotHits();\n		}\n	}\n	\n	/* \n		Constans functions\n	*/\n	function ChanceOfWinning(uint Value) constant returns(uint Rate, uint Bet) {\n	    if (jackpot_ == 0) {\n	        Rate = 0;\n	        Bet = 0;\n	        return;\n	    }\n		if (Value < minimumRollPrice) {\n			Value = minimumRollPrice;\n		}\n		Rate = getRate(Value);\n		Bet = getRealBet(Rate);\n		while (Value < Bet) {\n		    Rate++;\n		    Bet = getRealBet(Rate);\n		}\n		if (Rate < BestRollRate) { \n		    Rate = BestRollRate;\n		    Bet = getRealBet(Rate);\n        }\n	}\n	function BetPriceLimit() constant returns(uint min,uint max) {\n		min = minimumRollPrice;\n		max = getRealBet(BestRollRate);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		uint InvestorID = getInvestorByAddress(Address);\n		if (InvestorID == 0 || ! investors[InvestorID].valid) {\n			Investment = 0;\n			Balance = 0;\n			Live = false;\n		}\n		Investment = investors[InvestorID].value;\n		Balance = investors[InvestorID].balance;\n		Live = investors[InvestorID].live;\n	}\n	function Winners(uint id) constant returns(uint date, address addr, uint value, uint rate, uint bet)  {\n		return WinnerDBInterface(winnersDB).Winners(id);\n	}\n	\n	/*\n		External functions\n	*/\n	/* Fallback */\n	function () {\n		PrepareRoll(0);\n	}\n	/* For Investors */\n	function Invest() external OnlyEnabled noContract {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send(value_ % investUnit)) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) {\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].timestamp = now + investMinDuration;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		jackpot_ += value_;\n		setJackpot();\n	}\n	function GetMyInvestmentBalance() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].balance == 0) { throw; }\n		if ( ! msg.sender.send( investors[InvestorID].balance )) { throw; }\n		investors[InvestorID].balance = 0;\n	}\n	function CancelMyInvestment() external noEther {\n		uint InvestorID = getInvestorByAddress(msg.sender);\n		if (InvestorID == 0) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (investors[InvestorID].timestamp > now && ContractEnabled) { throw; }\n		uint balance_;\n		if (investors[InvestorID].live) {\n			jackpot_ -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		if ( ! msg.sender.send( balance_ )) { throw; }\n		delete investors[InvestorID];\n	}\n	/* For Players */\n	function DoRoll() external noEther noContract {\n		uint value_;\n		bool found;\n		for ( uint a=0 ; a < players[msg.sender].length ; a++ ) {\n			if (players[msg.sender][a].valid) {\n			    if (players[msg.sender][a].blockNumber+rollLossBlockDelay <= block.number) {\n			        uint feeValue_ = players[msg.sender][a].value/2;\n			        feeValue += feeValue_;\n			        investorAddFee(players[msg.sender][a].value - feeValue_);\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, false, true, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n			    }\n				if ( ! ContractEnabled || players[msg.sender][a].sumInvest != jackpot_ || players[msg.sender][a].game != JackpotHits) {\n					value_ += players[msg.sender][a].value;\n					playersPot -= players[msg.sender][a].value;\n					DoRollEvent(msg.sender, players[msg.sender][a].value, players[msg.sender][a].id, true, false, false, false, 0, 0, 0);\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n				if (players[msg.sender][a].blockNumber < block.number) {\n					value_ += makeRoll(a);\n					playersPot -= players[msg.sender][a].value;\n					delete players[msg.sender][a];\n					found = true;\n					continue;\n				}\n			}\n		}\n		if ( ! found) { throw; }\n		if (value_ > 0) { if ( ! msg.sender.send(value_)) { throw; } }\n	}\n	function PrepareRoll(uint seed) OnlyEnabled {\n		if (msg.value < minimumRollPrice) { throw; }\n		if (jackpot_ == 0) { throw; }\n		uint _rate;\n		uint _realBet;\n		(_rate, _realBet) = ChanceOfWinning(msg.value);\n		if (_realBet > msg.value) { throw; }\n		if (msg.value-_realBet > 0) {\n			if ( ! msg.sender.send( msg.value-_realBet )) { throw; }\n		}\n		for (uint a = 0 ; a < players[msg.sender].length ; a++) {\n			if ( ! players[msg.sender][a].valid) {\n				prepareRoll( a, _realBet, seed );\n				return;\n			}\n		}\n		players[msg.sender].length++;\n		prepareRoll( players[msg.sender].length-1, _realBet, seed );\n	}\n	/* For Owner */\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! ContractEnabled) {\n		    if (ContractDisabledBlock < block.number) {\n				if (playersPot == 0) { throw; }\n				if ( ! msg.sender.send( playersPot )) { throw; }\n				playersPot = 0;\n		    }\n		} else {\n    		ContractEnabled = false;\n    		ContractDisabledBlock = block.number+rollLossBlockDelay;\n			ContractDisabled(ContractDisabledBlock);\n    		feeValue += extraJackpot_;\n    		extraJackpot_ = 0;\n		}\n	}\n	function OwnerGetFee() external OnlyOwner noEther {\n		if (feeValue == 0) { throw; }\n		if ( ! owner.send(feeValue)) { throw; }\n		feeValue = 0;\n	}\n	\n	/*\n		Private functions\n	*/\n	function setJackpot() private {\n		Jackpot = extraJackpot_ + jackpot_;\n	}\n	function makeRoll(uint id) private returns(uint win) {\n		uint feeValue_ = players[msg.sender][id].value * fee / 100 ;\n		feeValue += feeValue_;\n		uint investorFee_ = players[msg.sender][id].value * investorFee / 100;\n		investorAddFee(investorFee_);\n		extraJackpot_ += players[msg.sender][id].value - feeValue_ - investorFee_;\n		setJackpot();\n		bytes32 hash_ = players[msg.sender][id].extraHash;\n		for ( uint a = 1 ; a <= prepareBlockDelay ; a++ ) {\n			hash_ = sha3(hash_, block.blockhash(players[msg.sender][id].blockNumber - prepareBlockDelay+a));\n		}\n		uint _rate = getRate(players[msg.sender][id].value);\n		uint bigNumber = uint64(hash_);\n		if (bigNumber == 0 || _rate == 0) { return; }\n		if (bigNumber % _rate == 0 ) {\n			win = Jackpot;\n			for ( a=1 ; a < investors.length ; a++ ) {\n				investors[a].live = false;\n			}\n			JackpotHits++;\n			extraJackpot_ = 0;\n			jackpot_ = 0;\n			Jackpot = 0;\n			WinnerDBInterface( winnersDB ).newWinner(now, msg.sender, win, _rate, players[msg.sender][id].value);\n			DoRollEvent(msg.sender, win, players[msg.sender][id].id, false, false, false, true, bigNumber, _rate, bigNumber % _rate);\n		} else {\n			DoRollEvent(msg.sender, players[msg.sender][id].value, players[msg.sender][id].id, false, false, true, false, bigNumber, _rate, bigNumber % _rate);\n		}\n	}\n	function investorAddFee(uint value) private {\n		bool done;\n		for ( uint a=1 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / jackpot_;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			feeValue += value;\n		}\n	}\n	function prepareRoll(uint rollID, uint bet, uint seed) private {\n		RollCount++;\n		players[msg.sender][rollID].blockNumber = block.number + prepareBlockDelay;\n		players[msg.sender][rollID].extraHash = sha3(RollCount, now, seed, RandomInterface(randomAddr).getRandom(), address(seed).balance);\n		players[msg.sender][rollID].valid = true;\n		players[msg.sender][rollID].value = bet;\n		players[msg.sender][rollID].game = JackpotHits;\n		players[msg.sender][rollID].id = RollCount;\n		players[msg.sender][rollID].sumInvest = jackpot_;	\n		playersPot += bet;\n		PrepareRollEvent(msg.sender, players[msg.sender][rollID].blockNumber, players[msg.sender][rollID].value, players[msg.sender][rollID].id);\n	}\n	\n	/*\n		Internal functions\n	*/	\n	function getRate(uint value) internal returns(uint){\n		return jackpot_ * 1 ether / value * 100 / investorFee * extraRate / 100 / 1 ether;\n	}\n	function getRealBet(uint rate) internal returns (uint) {\n		return jackpot_ * 1 ether / ( rate * 1 ether * investorFee / extraRate);\n	}\n	function getInvestorByAddress(address Address) internal returns (uint id) {\n		for ( id=1 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return;\n			}\n		}\n		return 0;\n	}\n	\n	/*\n		Events\n	*/	\n	event DoRollEvent(address Player, uint Value, uint RollID, bool Refund, bool LostBet, bool LossRoll, bool WinRoll, uint BigNumber, uint Rate, uint RollResult);\n	event PrepareRollEvent(address Player, uint Block, uint Bet, uint RollID);\n	event ContractDisabled(uint LossAllBetBlockNumber);\n	\n	/*\n		Modifiers\n	*/\n	modifier noContract() {if (tx.origin != msg.sender) { throw; } _ }\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! ContractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1709572,0x4b8e1ad58657f8b4b036ad12afbcef54d24ac9ba,false,false,"contract BasicSign {\n\n    event Created(\n        address indexed from,\n        uint256 id\n    );\n    event Signed(\n        address indexed from,\n        uint256 docId,\n        uint8 singId,\n        bytes16 signType,\n        bytes sign\n    );\n\n    address owner;\n    mapping (uint256 => Document) public documents;\n\n    struct Document {\n        address organizer;\n        Sign[] signs;\n    }\n\n    struct Sign {\n        address signer;\n        bytes16 signType;\n        bytes   sign;\n    }\n\n    function SimpleSign() {\n        owner = msg.sender;\n    }\n\n    function createDocument(uint256 nonce) returns (uint256 docId) {\n        docId = generateId(nonce);\n        if (documents[docId].organizer != 0) throw;\n        documents[docId].organizer = msg.sender;\n        Created(msg.sender, docId);\n    }\n\n    function removeDocument(uint256 docId) {\n        Document doc = documents[docId];\n        if (doc.organizer != msg.sender) throw;\n        delete documents[docId];\n    }\n\n    function addSignature(uint256 docId, bytes16 _type, bytes _sign) {\n        Document doc = documents[docId];\n        if (doc.organizer != msg.sender) throw;\n        if (doc.signs.length >= 0xFF) throw;\n        uint idx = doc.signs.push(Sign(msg.sender, _type, _sign));\n        Signed(msg.sender, docId, uint8(idx), _type, _sign);\n    }\n\n    function getDocumentDetails(uint256 docId) returns (address organizer, uint count) {\n        Document doc = documents[docId];\n        organizer = doc.organizer;\n        count = doc.signs.length;\n    }\n\n    function getSignsCount(uint256 docId) returns (uint) {\n        return documents[docId].signs.length;\n    }\n\n    function getSignDetails(uint256 docId, uint8 signId) returns (address, bytes16) {\n        Document doc = documents[docId];\n        Sign s = doc.signs[signId];\n        return (s.signer, s.signType);\n    }\n\n    function getSignData(uint256 docId, uint8 signId) returns (bytes) {\n        Document doc = documents[docId];\n        Sign s = doc.signs[signId];\n        return s.sign;\n    }\n\n    function generateId(uint256 nonce) returns (uint256) {\n        return uint256(sha3(msg.sender, nonce));\n    }\n\n    function () {\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1716755,0x8f13a1d43408b6434dd10e161361386f3952d665,false,false,"contract StackyGame {\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n    uint public payoutIdx = 0;\n    uint public collectedFees;\n    uint public balance = 0;\n\n    address public owner;\n\n    // simple single-sig function modifier\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // this function is executed at initialization and sets the owner of the contract\n    function Doubler() {\n        owner = msg.sender;\n    }\n\n    // fallback function - simple transactions trigger this\n    function() {\n        enter();\n    }\n    \n    function enter() {\n        // Maximum of 1 ether allowed\n        if (msg.value > 1 ether) {\n            msg.sender.send(msg.value);\n            return;\n        }\n\n      	// add a new participant to array\n        uint idx = participants.length;\n        participants.length += 1;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value;\n        \n        // collect fees and update contract balance\n        if (idx != 0) {\n            collectedFees += msg.value * 1 / 20;\n            balance += msg.value;\n        } else {\n            // first participant has no one above him,\n            // so it goes all to fees\n            collectedFees += msg.value;\n        }\n\n	    // if there are enough ether on the balance we can pay out to an earlier participant\n        if (balance > participants[payoutIdx].amount * 2) {\n            uint transactionAmount = 2 * (participants[payoutIdx].amount - participants[payoutIdx].amount / 20);\n            participants[payoutIdx].etherAddress.send(transactionAmount);\n\n            balance -= participants[payoutIdx].amount * 2;\n            payoutIdx += 1;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if (collectedFees == 0) return;\n\n        owner.send(collectedFees);\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1717907,0xe5544a2a5fa9b175da60d8eec67add5582bb31b0,true,false,"// Most of the code taken from\n// https://github.com/ConsenSys/Tokens/blob/master/Token_Contracts/contracts/StandardToken.sol\n\ncontract TokenInterface {\n\n    /// @return total amount of tokens\n    function totalSupply() constant returns (uint256 supply) {}\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n}\n\ncontract HashToken is TokenInterface {\n\n    mapping (address => uint256) balances;\n    mapping (address => mapping (address => uint256)) allowed;\n    uint256 public totalSupply;\n\n    bytes32 public prev_hash;\n    uint public max_value;\n\n    // Meta info\n    string public name;\n    uint8 public decimals;\n    string public symbol;\n    \n    function HashToken() {\n        prev_hash = sha3(block.blockhash(block.number));\n        max_value = 2 ** 255;\n        // Meta info\n        name = 'HashToken';\n        decimals = 16;\n        symbol = 'HTK';\n    }\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    event Mint(address indexed minter);\n\n    function mint(bytes32 value) {\n        if (uint(sha3(value, prev_hash)) > max_value) {\n            throw;\n        }\n        balances[msg.sender] += 10 ** 16;\n        prev_hash = sha3(block.blockhash(block.number), prev_hash);\n        // increase the difficulty\n        max_value -=  max_value / 100;\n        Mint(msg.sender);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1722340,0x032747313c4e914b5fce356ab8dc4df551972dcd,false,false,"//\n// This file is part of TrustEth.\n// Copyright (c) 2016 Jacob Dawid <jacob@omg-it.works>\n//\n// TrustEth is free software: you can redistribute it and/or modify\n// it under the terms of the GNU Affero General Public License as\n// published by the Free Software Foundation, either version 3 of the\n// License, or (at your option) any later version.\n//\n// TrustEth is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU Affero General Public License for more details.\n//\n// You should have received a copy of the GNU Affero General Public\n// License along with TrustEth.\n// If not, see <http://www.gnu.org/licenses/>.\n//\n\ncontract TrustEth {\n    // A registered transaction initiated by the seller.\n    struct Transaction {\n      // Supplied by the seller (Step 1).\n      uint sellerId; // The seller id of the seller who initiated this transaction and is about to receive the payment.\n      uint amount; // The amount to pay to the seller for this transaction.\n\n      // Filled out by the contract when transaction has been paid (Step 2).\n      address paidWithAddress; // The address of the buyer issueing the payment.\n      bool paid; // Flag that states this transaction has already been paid.\n   \n      // Rating supplied by the buyer (Step 3, optional).\n      uint ratingValue; // Seller rating supplied by buyer.\n      string ratingComment; // Comment on this transaction supplied by the buyer.\n      bool rated; // Flag that states this transaction has already been rated.\n    }\n\n    // A registered seller on this contract.\n    // Registered sellers can put up transactions and can be rated\n    // by those who paid the transactions.\n    struct Seller {\n      // Seller information\n      address etherAddress; // The sellers ether address.\n      uint[] ratingIds; // The ids of the rating linked with this seller.\n      uint[] transactionIds; // The ids of transactions linked with this seller.\n      \n      // Statistics about the seller\n      uint averageRating; // Average value of ratings.\n      uint transactionsPaid; // How many transactions have been paid?\n      uint transactionsRated; // How many transactions have been rated?\n    }\n\n    Transaction[] public transactions; // All transactions.\n    Seller[] public sellers; // All sellers\n\n    // This mapping makes it easier to loopkup the seller that belongs to a certain address.\n    mapping (address => uint) sellerLookup;\n\n    // The sole contract owner.\n    address public owner;\n\n    // Configured fees.\n    uint public registrationFee;\n    uint public transactionFee;\n\n    // Only owner administration flag.\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n    // Administrative functions.\n    function TrustEth() {\n      owner = msg.sender;\n      \n      // Index 0 is a marker for invalid ids.\n      sellers.length = 1;\n      transactions.length = 1;\n\n      // Initialize fees.\n      registrationFee = 1 ether;\n      transactionFee = 50 finney;\n    }\n\n    function retrieveFunds() onlyowner {\n      owner.send(this.balance);\n    }\n\n    function adjustRegistrationFee(uint fee) onlyowner {\n      registrationFee = fee;\n    }\n\n    function adjustTransactionFee(uint fee) onlyowner {\n      transactionFee = fee;\n    }\n\n    function setOwner(address _owner) onlyowner {\n      owner = _owner;\n    }\n\n    // Fallback function, do not accepts payments made directly to this contract address.\n    function() {\n      throw;\n    }\n\n    // Make a donation and acknowledge our development efforts. Thank you!\n    function donate() {\n      // That's awesome. Thank you.\n      return;\n    }\n\n    // Register your seller address for a small fee to prevent flooding and\n    // and recurring address recreation.\n    function register() {\n      // Retrieve the amount of ethers that have been sent along.\n      uint etherPaid = msg.value;\n      \n      if(etherPaid < registrationFee) { throw; }\n\n      // Create a new seller.\n      uint sellerId = sellers.length;\n      sellers.length += 1;\n\n      // Store seller details and bind to address.\n      sellers[sellerId].etherAddress = msg.sender;\n      sellers[sellerId].averageRating = 0;\n\n      // Save sellerId in lookup mapping.\n      sellerLookup[msg.sender] = sellerId;\n    }\n\n\n    // Workflow\n\n    // As a seller, put up a transaction.\n    function askForEther(uint amount) {\n      // Lookup the seller.\n      uint sellerId = sellerLookup[msg.sender];\n\n      // Check whether the seller is a registered seller.\n      if(sellerId == 0) { throw; }\n      \n      // Create a new invoice.\n      uint transactionId = transactions.length;\n      transactions.length += 1;\n\n      // Fill out seller info.\n      transactions[transactionId].sellerId = sellerId;\n      transactions[transactionId].amount = amount;\n\n      // -> Pass transactionId to customer now.\n    }\n\n    // As a buyer, pay a transaction.\n    function payEther(uint transactionId) {\n      // Bail out in case the transaction id is invalid.      \n      if(transactionId < 1 || transactionId >= transactions.length) { throw; }\n\n      // Retrieve the amount of ethers that have been sent along.\n      uint etherPaid = msg.value;\n      uint etherAskedFor = transactions[transactionId].amount;\n      uint etherNeeded = etherAskedFor + transactionFee;\n\n      // If the amount of ethers does not suffice to pay, bail out :(      \n      if(etherPaid < etherNeeded) { throw; }\n\n      // Calculate how much has been overpaid.\n      uint payback = etherPaid - etherNeeded;\n      // ..and kindly return the payback :)\n      msg.sender.send(payback);\n\n      // Now take the remaining amount and send to the seller.\n      sellers[transactions[transactionId].sellerId].etherAddress.send(etherAskedFor);\n      // Rise transactions paid counter.\n      sellers[transactions[transactionId].sellerId].transactionsPaid += 1;\n\n      // Overpaid ethers send back, seller has been paid, now we're done.\n      // Mark the transaction as finished.\n\n      // Flag the invoice as paid.\n      transactions[transactionId].paid = true;\n      // Save the payers address so he is eligible to rate.\n      transactions[transactionId].paidWithAddress = msg.sender;\n    \n      // -> Now the transaction can be rated by the address that has paid it.\n    }\n\n    // As a buyer, rate a transaction.\n    function rate(uint transactionId, uint ratingValue, string ratingComment) {\n      // Only the address that has paid the transaction may rate it.\n      if(transactions[transactionId].paidWithAddress != msg.sender) { throw; }\n      // Bail out in case the transaction id is invalid.        \n      if(transactionId < 1 || transactionId >= transactions.length) { throw; }\n      // Oops, transaction has already been rated!\n      if(transactions[transactionId].rated) { throw; }\n      // Oops, transaction has not been paid yet and cannot be rated!\n      if(!transactions[transactionId].paid) { throw; }\n      // Rating range is from 1 (incl.) to 10 (incl.).\n      if(ratingValue < 1 || ratingValue > 10) { throw; }\n\n      transactions[transactionId].ratingValue = ratingValue;\n      transactions[transactionId].ratingComment = ratingComment;\n      transactions[transactionId].rated = true;\n      \n      uint previousTransactionCount = sellers[transactions[transactionId].sellerId].transactionsRated;\n      uint previousTransactionRatingSum = sellers[transactions[transactionId].sellerId].averageRating * previousTransactionCount;\n\n      sellers[transactions[transactionId].sellerId].averageRating = (previousTransactionRatingSum + ratingValue) / (previousTransactionCount + 1);\n      sellers[transactions[transactionId].sellerId].transactionsRated += 1;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1722391,0x4ed65e408439a7f6459b5cfbd364f373bd6ed5f7,false,false,"contract PRNG_Challenge {\n\n    // PRIVATE VARIABLES\n    address private admin;\n    uint256 private constant min_value = 100 finney; // 0.1 ETH\n    \n    // PUBLIC VARIABLES\n    uint256 public constant lucky_number = 108435827775939881852079940206236050880764931249577763315065068000725104274235;\n    uint256 public last_number;\n    uint256 public attempts;\n    address public winner;\n    \n    // EVENTS\n    event Attempt(address Participant, uint256 Number);\n    event Winner(address Winner_Address, uint256 Amount);\n\n    // CONSTRUCTOR\n    function PRNG_Challenge()\n        private\n    {\n        admin = msg.sender;\n        last_number = 0;\n        attempts = 0;\n        winner = 0;\n    }\n\n    // MODIFIERS\n    modifier only_min_value() {\n        if (msg.value < min_value) throw;\n        _\n    }\n    modifier only_no_value() {\n        if (msg.value != 0)  throw;\n        _\n    }\n    modifier only_admin() {\n        if (msg.sender != admin) throw;\n        _\n    }\n    modifier not_killed() {\n        if (winner != 0) throw;\n        _\n    }\n    \n    // CHALLENGE\n    function challenge()\n        private\n    {\n        address participant = msg.sender;\n        uint64 shift_32 = uint64(4294967296); // Shift by 32 bit\n        uint32 hash32 = uint32(sha3(msg.value,participant,participant.balance,block.blockhash(block.number-1),block.timestamp,block.number)); // Entropy\n        uint64 hash64 = uint64(hash32)*shift_32 + uint32(sha3(hash32));\n        uint96 hash96 = uint96(hash64)*shift_32 + uint32(sha3(hash64));\n        uint128 hash128 = uint128(hash96)*shift_32 + uint32(sha3(hash96));\n        uint160 hash160 = uint160(hash128)*shift_32 + uint32(sha3(hash128));\n        uint192 hash192 = uint192(hash160)*shift_32 + uint32(sha3(hash160));\n        uint224 hash224 = uint224(hash192)*shift_32 + uint32(sha3(hash192));\n        uint256 hash256 = uint256(hash224)*shift_32 + uint32(sha3(hash224));\n        if (hash256 == lucky_number) {\n            Winner(participant, this.balance);\n            if (!participant.send(this.balance)) throw;\n            winner = participant;\n        }\n        last_number = hash256;\n        attempts++;\n        Attempt(participant, last_number);\n    }\n    \n    // KILL\n    function admin_kill()\n        public\n        not_killed()\n        only_admin()\n        only_no_value()\n    {\n        if (!admin.send(this.balance)) throw;\n        winner = admin;\n    }\n    \n    // DEFAULT FUNCTION\n    function()\n        public\n        not_killed()\n        only_min_value()\n    {\n        challenge();\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1723370,0x683c53084d997e6056c555f85f031f8317e26c2b,false,false,"/* \nMicroDAO V0.0.2 - <me@thorsten-zoerner.com>\n===========================================================\nSimplified DAO allowing to do initial funding.\n- Funders are able to specify how long to keep funds in.\n- If funding is not closed by this time fundes returned\n- Close funding is a manual taken by the director\n\nSingle Director\n- Has the possibility to file SpendingRequest\n- allowed to change fundamental parameters\n- allowed to move directorship forward\n- deadman switch prevents lost DAO.\n\nEach Spending needs to be approved by share holders (Vote)\n- spendings have a time to vote\n- spendings require to be executed in a given number of days\n\n- Checked for recursive withdraw bug (DAO Hack) \n*/\n\ncontract SpendingRequest {\n	string public name=""SpendingRequest 4 MicroDAO"";\n	 address public creator;\n	 string public description;\n	 uint256 public request_until;\n	 uint256 public vote_until;\n		\n	 option[] public  options;\n 	 address public dao;\n	 mapping(address=>bool) public voted;\n	 bool public voting_started;\n	 bool public executed;\n	 address public result_payto;\n	 uint256 public result_amount;\n	 uint256 public result_votes;\n	\n	struct option {\n		string description;\n		address payout_to;\n		uint256 eth_amount;		\n		uint256 votes_pro;\n		uint256 votes_veto;\n	}\n	\n	function SpendingRequest () {\n		creator=msg.sender;\n	}\n	\n	function setDescription(string _description) {\n		if(voting_started) throw;\n		description=_description;		\n	}\n	\n	function setDAO(address _dao) {\n		if(msg.sender!=creator) throw;\n		if(voting_started) throw;\n 		if(dao!=0) throw;\n		MicroDAO d = MicroDAO(_dao);\n		if(d.balanceOf(creator)<1) throw;\n		dao=_dao;		\n	}\n	\n	function execute(){\n		if(vote_until>now) return;\n		if(request_until<now) return;\n		if((msg.sender!=dao)&&(msg.sender!=creator)) throw;\n		for(var i=0;i<options.length;i++) {\n			if(options[i].votes_pro-options[i].votes_veto>result_votes) {\n				result_payto=options[i].payout_to;\n				result_amount=options[i].eth_amount;\n				if(options[i].votes_veto>options[i].votes_pro) result_votes=0; else \n				result_votes=options[i].votes_pro-options[i].votes_veto;\n			}\n		}\n		executed=true;		\n	}\n	\n	function vote(uint256 option,bool veto) {		\n		if(voted[msg.sender]) throw;\n		if(now<vote_until) throw;\n		voting_started=true;\n		MicroDAO d = MicroDAO(dao);\n		if(!veto) options[option].votes_pro+=d.balanceOf(msg.sender);	else options[option].votes_veto+=d.balanceOf(msg.sender);\n		\n		d.blockTransfer(msg.sender,vote_until);\n	}\n	function setRequestUntil(uint8 days_from_now) {\n		if(msg.sender!=creator) throw;\n		if(voting_started) throw;\n		request_until=now+(86400*days_from_now);		\n	}\n	function setVotetUntil(uint8 days_from_now) {\n		if(msg.sender!=creator) throw;\n		if(voting_started) throw;\n		vote_until=now+(86400*days_from_now);		\n	}\n	function addOption(string _description,address _payout_to,uint256 _amount) {\n		if(msg.sender!=creator) throw;\n		if(voting_started) throw;\n		options.push(option(_description,_payout_to,_amount,0,0));\n	}	\n}\ncontract MicroDAO\n{\n	string public directorNode;\n	address public director;\n	string public directorName;\n	string public directorJurisdication;\n	bool public initialFunding;	\n	uint256 public sharesRaised;\n	uint public lockInDays;	\n	string public name =""MicroDAO"";\n	string public symbol =""E/"";\n	uint256 public fundingGoal;\n	uint256 public balanceFinney;\n	uint256 public directorLockUntil;\n	uint256 public directorLockDays;\n	uint256 public directorTransferShareRequired;\n	mapping (address => uint256) public balanceOf;		\n	mapping (address => uint256) public fundsExpire;\n	mapping (address => uint256) public blockedtransfer;\n	\n	\n	address[] public funders;\n	SpendingRequest[]  public allowances;\n	struct booking {\n		uint256 time;\n		uint256 funding;\n		uint256 spending;\n		address counterpart;\n		string text;\n	}\n	booking[] public bookings;\n	\n	event Transfer(address indexed from, address indexed to, uint256 value);\n	\n	function MicroDAO() {\n		initialFunding=true;\n		director=msg.sender;	\n		directorLockUntil=now+(86400*30);		\n	}\n	function setDirectorNode(string node) {\n		if(msg.sender!=director) throw;\n		directorNode=node;\n		directorLockUntil=now+(86400*directorLockDays);\n	} \n	\n	function blockTransfer(address a,uint256 until) {\n		bool found=false;\n		for(var i=0;((i<allowances.length)&&(found==false));i++) {\n			if(allowances[i]==msg.sender) found=true;\n		}\n		if(found) {\n			if(blockedtransfer[a]>until) {\n				blockedtransfer[a]=until;\n			}\n		}\n	}\n	\n	function setDirectorLock(uint256 number_of_days,uint256 requiredShares) {\n		if(msg.sender!=director) throw; \n		if(requiredShares>sharesRaised) throw;\n		if(number_of_days>365) number_of_days=365;\n		\n		\n		directorLockDays=number_of_days;\n		directorTransferShareRequired=requiredShares;\n	}\n	\n	function transferDirector(address director) {\n		// Dead Director check ...		\n		if(msg.sender==director) {\n			director=director;\n			directorName="""";\n			directorJurisdication="""";\n			initialFunding=true;\n		} else if((now>directorLockUntil)&&(balanceOf[msg.sender]>directorTransferShareRequired)) {\n			director=msg.sender;\n			directorName="""";\n			directorJurisdication="""";\n			initialFunding=true;\n		}\n	}\n	function setdirectorName(string name) {\n		if(msg.sender!=director) throw;\n		if(!initialFunding) throw;\n		directorName=name;\n	}\n	\n	function setFundingGoal(uint256 goal) {\n		if(msg.sender!=director) throw;\n		fundingGoal=goal;\n	}\n	\n	function setInitialLockinDays(uint number_of_days) {\n		if(msg.sender!=director) throw;\n		lockInDays=number_of_days;\n	}\n	\n	\n	function setJurisdication(string juri) {\n		if(msg.sender!=director) throw;\n		if(!initialFunding) throw;\n		directorJurisdication=juri;\n	}\n	\n	function addSpendingRequest(address spendingRequest) {\n		if(msg.sender!=director) throw;	\n		SpendingRequest s = SpendingRequest(spendingRequest);		\n		if(s.executed()) throw;\n		if(s.vote_until()<now) throw; \n		allowances.push(s);		\n	}\n	\n	function executeSpendingRequests() {\n		for(var i=0;i<allowances.length;i++) {\n			SpendingRequest s =SpendingRequest(allowances[i]);\n			if(!s.executed()) {\n				if((s.vote_until()<now)&&(s.request_until()>now)) {\n					s.execute();\n					directorLockUntil=now+(86400*directorLockDays);\n					if(s.result_amount()>0) {\n						if(s.result_payto()!=0) {\n							s.result_payto().send(s.result_amount()*1 ether);\n							bookings.push(booking(now,0,s.result_amount()*1 ether,s.result_payto(),""Executed SpendingRequest""));\n						}\n					}\n				}\n			}\n		}\n	}\n	\n	function myFundsExpireIn(uint256 number_of_days) {\n		var exp=now+(86400*number_of_days);\n		if(exp>fundsExpire[msg.sender]) fundsExpire[msg.sender]=exp; else throw;\n	}\n		\n	function closeFunding() {\n		if(msg.sender!=director) throw;\n		initialFunding=false;		\n		checkExpiredfunds();		\n	}\n	\n	function checkExpiredfunds() {\n		if(!initialFunding) return;\n		for(var i=0;i<funders.length;i++) {\n			if((fundsExpire[funders[i]]>0)&&((fundsExpire[funders[i]]<now))) {\n				var amount=balanceOf[funders[i]]*1 finney;				\n				Transfer(funders[i],this,balanceOf[funders[i]]);\n				sharesRaised-=balanceOf[funders[i]];\n				balanceOf[funders[i]]=0;\n				funders[i].send(amount);				\n			}\n		}\n	}\n	\n	function transfer(address _to, uint256 _value) {\n		if(blockedtransfer[msg.sender]>now) throw;\n		if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n		if(balanceOf[_to]==0) {\n			funders.push(_to);\n		}\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n	\n	function() {	\n		 var funding_type=""Incomming"";			\n			var finneys=msg.value/1 finney;\n			if(initialFunding) {\n				\n				if(balanceOf[msg.sender]==0) {\n					funders.push(msg.sender);\n				}		\n				if(msg.value<100 finney) throw;\n				\n				fundsExpire[msg.sender]=now+(lockInDays*86400);\n				balanceOf[msg.sender]+=finneys;\n				Transfer(this,msg.sender,finneys);\n				sharesRaised+=finneys;\n				funding_type=""Initial Funding"";\n			}\n			bookings.push(booking(now,msg.value,0,msg.sender,funding_type));\n			balanceFinney=this.balance/1 finney;\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1727430,0x655f01313bb55c04e8ed36a5098984f3f3de57bc,false,false,"contract RNG {\n    mapping (address => uint) nonces;\n    uint public last;\n    function RNG() { }\n    function RandomNumber() returns(uint) {\n        return RandomNumberFromSeed(uint(sha3(block.number))^uint(sha3(now))^uint(msg.sender)^uint(tx.origin));\n    }\n    function RandomNumberFromSeed(uint seed) returns(uint) {\n        nonces[msg.sender]++;\n        last = seed^(uint(sha3(block.blockhash(block.number),nonces[msg.sender]))*0x000b0007000500030001);\n        GeneratedNumber(last);\n        return last;\n    }\n    event GeneratedNumber(uint random_number);\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1727533,0xaed5a41450b38fc0ea0f6f203a985653fe187d9c,false,false,"contract RNG {\n    mapping (address => uint) nonces;\n    uint public last;\n    function RNG() { }\n    function RandomNumber() returns(uint) {\n        return RandomNumberFromSeed(uint(sha3(block.number))^uint(sha3(now))^uint(msg.sender)^uint(tx.origin));\n    }\n    function RandomNumberFromSeed(uint seed) returns(uint) {\n        nonces[msg.sender]++;\n        last = seed^(uint(sha3(block.blockhash(block.number),nonces[msg.sender]))*0x000b0007000500030001);\n        GeneratedNumber(last);\n        return last;\n    }\n    event GeneratedNumber(uint random_number);\n    event RandomNumberGuessed(uint random_number, address guesser);\n    function Guess(uint _guess) returns (bool) {\n        if (RandomNumber() == _guess) {\n            if (!msg.sender.send(this.balance)) throw;\n            RandomNumberGuessed(_guess, msg.sender);\n            return true;\n        }\n        return false;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1734329,0x4de2372fbfda6a27ab9a1429c22041f53c6d8f0b,false,false,contract storadge {\n    event log(string description);\n	function save(\n        string mdhash\n    )\n    {\n        log(mdhash);\n    }\n},1,標準的なイベントログ機能を持つシンプルなスマートコントラクト。
1743242,0x02e01e9a73ed2cb24b32628c935256e455b0a078,false,false,"/*\n\nLast contributor before the deadline gets all ether, stored in the contract!\nTry your luck!\n\nvar raceAddress = ""0x02e01e9a73ed2cb24b32628c935256e455b0a078 "";\nvar raceftwContract = web3.eth.contract([{""constant"":false,""inputs"":[],""name"":""getCurrentWinner"",""outputs"":[{""name"":"""",""type"":""address""}],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""claimReward"",""outputs"":[],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""getDisclaimer"",""outputs"":[{""name"":"""",""type"":""string""}],""type"":""function""},{""constant"":false,""inputs"":[],""name"":""getRaceEndBlock"",""outputs"":[{""name"":"""",""type"":""uint256""}],""type"":""function""},{""inputs"":[],""type"":""constructor""},{""anonymous"":false,""inputs"":[{""indexed"":false,""name"":""newWinner"",""type"":""address""}],""name"":""LastContributorChanged"",""type"":""event""}]);\nvar raceftw = raceftwContract.at(raceAddress);\n\nconsole.log(""current winner: "", raceftw.getCurrentWinner.call());\nconsole.log(""race ends at block: "", raceftw.getRaceEndBlock.call(), "" current block:"", eth.blockNumber);\nconsole.log(""current balance: "", web3.fromWei(eth.getBalance(raceAddress), ""ether""));\n\n\n\n//To participate in the race:\neth.sendTransaction({from:<your address>, to:""0x02e01e9a73ed2cb24b32628c935256e455b0a078 "", value:web3.toWei(10, ""finney""), gas:50000});\n\n//The winner can claim their reward by sending the following transaction:\nraceftw.claimReward.sendTransaction({from:<your address>, gas:50000})\n\n*/\ncontract RaceFTW {\n    \n    /* Disclaimer */\n    string disclaimer = ""Copyright (c) 2016 \""The owner of this contract\"" \nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \""Software\""), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \""AS IS\"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."";\n    \n    function getDisclaimer() returns (string) {\n        return disclaimer;\n    }\n    \n    address lastContributor;\n    uint fixedContribution = 10 finney;\n    \n    uint raceEnds = 0;\n    \n    // number of blocks. roughly 3 months at the contract creation blocks rate\n    uint RACE_LENGTH = 555555;\n    \n    event LastContributorChanged(address newWinner);\n    \n    function RaceFTW () {\n        raceEnds = block.number + RACE_LENGTH;\n    }\n    \n    function getRaceEndBlock() returns (uint) {\n        return raceEnds;\n    }\n    \n    function getCurrentWinner() returns (address) {\n        return lastContributor;\n    }\n    \n    function () {\n        //refund if the race ended\n        if (block.number > raceEnds) {\n            throw;\n        }\n        //refund if sent amount not equal to 1 finney\n        if (msg.value != fixedContribution) {\n            throw;\n        }\n        //raise event if needed\n        if (lastContributor != msg.sender) {\n            LastContributorChanged(msg.sender);\n        }\n        \n        //change the last contributor\n        lastContributor = msg.sender;\n    }\n    \n    \n    function claimReward() {\n        //only lastContributor can claim\n        if (msg.sender != lastContributor) {\n            throw;\n        }\n        //refund if race is not over yet\n        if (block.number < raceEnds) {\n            throw;\n        }\n        if (this.balance > 0) {\n            lastContributor.send(this.balance);\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1745465,0x32304cdbe41fe4f1c48b08356414a52957d22d3b,false,false,"contract BTCRelay {\n    function getBlockHeader(int blockHash) returns (bytes32[3]);\n    function getLastBlockHeight() returns (int);\n    function getBlockchainHead() returns (int);\n    function getFeeAmount(int blockHash) returns (int);\n}\n\n\ncontract BlockhashFetch {\n\n  BTCRelay relay;\n  mapping(int => int) blockHashes; //Cache blockhashes\n\n  function BlockhashFetch(address _relay){\n    relay = BTCRelay(_relay);\n  }\n\n\n  function getPrevHash(int currentHash) returns (int parentHash, uint fee){\n\n    if(blockHashes[currentHash] != 0) return (blockHashes[currentHash], 0);\n\n    fee = uint(relay.getFeeAmount(currentHash));\n\n    if(fee > this.balance) return (0,0);\n    bytes32 head = relay.getBlockHeader.value(fee)(currentHash)[2];\n    bytes32 temp;\n\n    assembly {\n        let x := mload(0x40)\n        mstore(x,head)\n        temp := mload(add(x,0x04))\n    }\n\n    for(int i; i<32; i++){\n      parentHash = parentHash | int(temp[uint(i)]) * (0x100**i);\n    }\n\n    blockHashes[currentHash] = int(parentHash);\n  }\n\n  function getBlockHash (int blockHeight) returns (bytes32, uint totalFee){\n    int highestBlock = relay.getLastBlockHeight();\n    int currentHash = relay.getBlockchainHead();\n    if(blockHeight > highestBlock) return (0x0, 0);\n\n    for(int i; i < highestBlock - blockHeight; i++){\n      if(currentHash == 0) return (0x0,totalFee);\n      uint fee;\n      (currentHash, fee) = getPrevHash(currentHash);\n      totalFee += fee;\n    }\n\n    return (bytes32(currentHash), totalFee);\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1757102,0x5a5eff38da95b0d58b6c616f2699168b480953c9,false,false,"// A life-log, done for Charlyn Greeff, born 18 April 2016 @ 15h30 (1460993400)\n//    Mother: Mirana Hotz, 16 December 1977 (251078400)\n//    Father: Jaco Greeff, 11 June 1973 (108604800)\n//\n// version: 1.0.0\n// source: https://github.com/jacogr/ethcontracts/tree/master/src/LifeLog\n\ncontract CharlyLifeLog {\n  // allow a maximum 20% withdrawal at any time\n  uint private constant MAX_WITHDRAW_DIV = 5; // 100/20\n\n  // allow one withdrawal every 6 months/180 days\n  uint private constant WITHDRAW_INTERVAL = 180 days;\n\n  // all the actual events that can be created\n  event LogDonation(address indexed by, uint loggedAt, uint amount);\n  event LogWithdrawal(address indexed by, uint loggedAt, uint amount);\n  event LogPersonNew(address indexed by, uint loggedAt, uint index);\n  event LogPersonUpdate(address indexed by, uint loggedAt, uint index, string field);\n  event LogWhitelistAdd(address indexed by, uint loggedAt, address addr);\n  event LogWhitelistRemove(address indexed by, uint loggedAt);\n  event LogEvent(address indexed by, uint loggedAt, uint when, string description);\n\n  // a structure describing a person\n  struct Person {\n    bool active;\n    uint activatedAt;\n    uint deactivatedAt;\n    int dateOfBirth;\n    int dateOfDeath;\n    string name;\n    string relation;\n  }\n\n  // next time whitelist address is allowed to get some funds\n  uint public nextWithdrawal = now + WITHDRAW_INTERVAL;\n\n  // totals of received and withdrawn amounts\n  uint public totalDonated = 0;\n  uint public totalWithdrawn = 0;\n\n  // people in the life of ([0] == 'self')\n  Person[] public people;\n\n  // donations received\n  mapping(address => uint) public donations;\n\n  // whitelisted modifier accounts\n  mapping(address => bool) public whitelist;\n\n  // modifier to allow only the whitelisted addresses\n  modifier isOnWhitelist {\n    // if not in the whitelist, throw error\n    if (!whitelist[msg.sender]) {\n      throw;\n    }\n\n    // if any value attached, don't accept it\n    if (msg.value > 0) {\n      throw;\n    }\n\n    // original code executes in here\n    _\n  }\n\n  // construct a lifelog for this specific person\n  function CharlyLifeLog(string name, int dateOfBirth) {\n    // creator should go on the whitelist\n    whitelist[msg.sender] = true;\n\n    // add the first person\n    personAdd(name, dateOfBirth, 0, 'self');\n\n    // any donations?\n    if (msg.value > 0) {\n      donate();\n    }\n  }\n\n  // log an event\n  function log(string description, uint _when) public isOnWhitelist {\n    // infer timestamp or use specified\n    uint when = _when;\n    if (when == 0) {\n      when = now;\n    }\n\n    // create the event\n    LogEvent(msg.sender, now, when, description);\n  }\n\n  // add a specific person\n  function personAdd(string name, int dateOfBirth, int dateOfDeath, string relation) public isOnWhitelist {\n    // create the event\n    LogPersonNew(msg.sender, now, people.length);\n\n    // add the person\n    people.push(\n      Person({\n        active: true,\n        activatedAt: now,\n        deactivatedAt: 0,\n        dateOfBirth: dateOfBirth,\n        dateOfDeath: dateOfDeath,\n        name: name,\n        relation: relation\n      })\n    );\n  }\n\n  // activate/deactivate a specific person\n  function personUpdateActivity(uint index, bool active) public isOnWhitelist {\n    // set the flag\n    people[index].active = active;\n\n    // activate/deactivate\n    if (active) {\n      // create the event\n      LogPersonUpdate(msg.sender, now, index, 'active');\n\n      // make it so\n      people[index].activatedAt = now;\n      people[index].deactivatedAt = 0;\n    } else {\n      // create the event\n      LogPersonUpdate(msg.sender, now, index, 'inactive');\n\n      // make it so\n      people[index].deactivatedAt = now;\n    }\n  }\n\n  // update a person's name\n  function personUpdateName(uint index, string name) public isOnWhitelist {\n    // create the event\n    LogPersonUpdate(msg.sender, now, index, 'name');\n\n    // update\n    people[index].name = name;\n  }\n\n  // update a person's relation\n  function personUpdateRelation(uint index, string relation) public isOnWhitelist {\n    // create the event\n    LogPersonUpdate(msg.sender, now, index, 'relation');\n\n    // update\n    people[index].relation = relation;\n  }\n\n  // update a person's DOB\n  function personUpdateDOB(uint index, int dateOfBirth) public isOnWhitelist {\n    // create the event\n    LogPersonUpdate(msg.sender, now, index, 'dateOfBirth');\n\n    // update\n    people[index].dateOfBirth = dateOfBirth;\n  }\n\n  // update a person's DOD\n  function personUpdateDOD(uint index, int dateOfDeath) public isOnWhitelist {\n    // create the event\n    LogPersonUpdate(msg.sender, now, index, 'dateOfDeath');\n\n    // update\n    people[index].dateOfDeath = dateOfDeath;\n  }\n\n  // add a whitelist address\n  function whitelistAdd(address addr) public isOnWhitelist {\n    // create the event\n    LogWhitelistAdd(msg.sender, now, addr);\n\n    // update\n    whitelist[addr] = true;\n  }\n\n  // remove a whitelist address\n  function whitelistRemove(address addr) public isOnWhitelist {\n    // we can only remove ourselves, double-validate failsafe\n    if (msg.sender != addr) {\n      throw;\n    }\n\n    // create the event\n    LogWhitelistRemove(msg.sender, now);\n\n    // remove\n    whitelist[msg.sender] = false;\n  }\n\n  // withdraw funds as/when needed\n  function withdraw(uint amount) public isOnWhitelist {\n    // the maximum we are allowed to take out right now\n    uint max = this.balance / MAX_WITHDRAW_DIV;\n\n    // see that we are in range and the timing matches\n    if (amount > max || now < nextWithdrawal) {\n      throw;\n    }\n\n    // update the event log with the action\n    LogWithdrawal(msg.sender, now, amount);\n\n    // set the next withdrawal date/time & totals\n    nextWithdrawal = now + WITHDRAW_INTERVAL;\n    totalWithdrawn += amount;\n\n    // send and throw if not ok\n    if (!msg.sender.send(amount)) {\n      throw;\n    }\n  }\n\n  // accept donations from anywhere and give credit\n  function donate() public {\n    // there needs to be something here\n    if (msg.value == 0) {\n      throw;\n    }\n\n    // update the event log with the action\n    LogDonation(msg.sender, now, msg.value);\n\n    // store the donation\n    donations[msg.sender] += msg.value;\n    totalDonated += msg.value;\n  }\n\n  // fallback is a donation\n  function() public {\n    donate();\n  }\n}",2,個人の人生を記録する詩的な要素があり、実用性と芸術性が融合しています。
1785174,0x22f83d39a2148dd389ed4c7a9280f57d5c8679da,false,false,"contract Emailer {\n    /* Define variable owner of the type address*/\n    address owner;\n	event Sent(address from, uint256 price, string to, string body);\n	\n    function Emailer() { \n        owner = msg.sender; \n    }\n    function kill() { \n		suicide(owner); \n    }\n	function withdraw(uint256 _amount){\n		owner.send(_amount);\n	}\n    function SendEmail(string _Recipient, string _Message) { \n        Sent(msg.sender, msg.value, _Recipient, _Message);\n    }    \n}",1,基本的な機能を持つ実用的なスマートコントラクトで、特に芸術的要素はありません。
1785290,0xe25a0c5a9213e958a2c6f79ad2d1b1acf518ddfc,false,false,"contract bbb{\n    /* Define variable owner of the type address*/\n    address owner;\n	event EmailSent(address Sender, uint256 PricePaid, string EmailAddress, string Message);\n	\n    function bbb() { \n        owner = msg.sender; \n    }\n    function Kill() { \n		if(msg.sender==owner){\n			suicide(owner); \n		}		\n    }\n	function Withdraw(uint256 AmountToWithdraw){\n		owner.send(AmountToWithdraw);\n	}\n    function SendEmail(string EmailAddress, string Message) { \n        EmailSent(msg.sender, msg.value, EmailAddress, Message);\n    }    \n}",1,基本的な機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。
1788006,0xd77c717b04d056902e6304c9be464d12aefb9db6,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\n\n\n    \n\n\n\n\n\n\ncontract Ethereum_twelve_bagger is usingOraclize\n{\n\n 							//declares global variables\nstring hexcomparisonchr;\nstring A;\nstring B;\n\nuint8 lotteryticket;\naddress creator;\nint lastgainloss;\nstring lastresult;\nstring K;\nstring information;\n  \n \naddress player;\nuint8 gameResult;\nuint128 wager; \n mapping (bytes32=>uint) bets;\nmapping (bytes32 => address) gamesPlayer;\n \n\n   function  Ethereum_twelve_bagger() private \n    { \n        creator = msg.sender; 								\n    }\n\n    function Set_your_game_number_between_1_15(string Set_your_game_number_between_1_15)			//sets game number\n {\n	player=msg.sender;\n    	A=Set_your_game_number_between_1_15;\n	wager =uint128(msg.value);\n	\n	lastresult = ""Waiting for a lottery number from Wolfram Alpha"";\n	lastgainloss = 0;\n	B=""The new right lottery number is not ready yet"";\n	information = ""The new right lottery number is not ready yet"";\n	testWager();\n	\n	WolframAlpha();\n}\n\n     	 \n	 \n	\n\n\n    \n\n    function WolframAlpha() private {\n	if (wager == 0) return;		//if wager is 0, abort \n        oraclize_setNetwork(networkID_testnet);\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n     	bytes32 myid =  oraclize_query(0,""WolframAlpha"", ""random number between 1 and 15"");\n	bets[myid] = wager;\n	gamesPlayer[myid] = player;\n    }\n\n 	    function __callback(bytes32 myid, string result, bytes proof) {\n        if (msg.sender != oraclize_cbAddress()) throw;\n	\n        B = result;\n	\n	wager=uint128(bets[myid]);\n	player=gamesPlayer[myid];\n	test(A,B);\n	returnmoneycreator(gameResult,wager);\n	return;\n        \n}\n \nfunction test(string A,string B) private\n{ \ninformation =""The right lottery number is now ready. One Eth is 10**18 Wei."";\nK=""K"";\nbytes memory test = bytes(A);\nbytes memory kill = bytes(K);\n	 if (test[0]==kill[0] && player == creator)			//Creator can kill contract. Contract does not hold players money.\n	{\n		suicide(creator);} \n \n    	\n    \n\n\nif (equal(A,B))\n{\nlastgainloss =(12*wager);\n	    	lastresult = ""Win!"";\n	    	player.send(wager * 12);  \n\ngameResult=0;\nreturn;}\nelse \n{\nlastgainloss = int(wager) * -1;\n	    	lastresult = ""Loss"";\n	    	gameResult=1;\n	    									// Player lost. Return nothing.\n	    	return;\n\n\n \n	}\n}\n\n\n \nfunction testWager() private\n{if((wager * 12) > this.balance) 					// contract has to have 12*wager funds to be able to pay out. (current balance includes the wager sent)\n    	{\n    		lastresult = ""Bet is larger than games's ability to pay"";\n    		lastgainloss = 0;\n    		player.send(wager); // return wager\n		gameResult=0;\n		wager=0;\n		B=""Bet is larger than games's ability to pay"";\n		information =""Bet is larger than games's ability to pay"";\n    		return;\n}\n\nelse if (wager < 100000000000000000)					// Minimum bet is 0.1 eth \n    	{\n    		lastresult = ""Minimum bet is 0.1 eth"";\n    		lastgainloss = 0;\n    		player.send(wager); // return wager\n		gameResult=0;\n		wager=0;\n		B=""Minimum bet is 0.1 eth"";\n		information =""Minimum bet is 0.1 eth"";\n    		return;\n}\n\n\n\n\n	else if (wager == 0)\n    	{\n    		lastresult = ""Wager was zero"";\n    		lastgainloss = 0;\n		gameResult=0;\n    		// nothing wagered, nothing returned\n    		return;\n    	}\n}\n\n\n\n    /// @dev Does a byte-by-byte lexicographical comparison of two strings.\n    /// @return a negative number if `_a` is smaller, zero if they are equal\n    /// and a positive numbe if `_b` is smaller.\n    function compare(string A, string B) private returns (int) {\n        bytes memory a = bytes(A);\n        bytes memory b = bytes(B);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        //@todo unroll the loop into increments of 32 and do full 32 byte comparisons\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n    /// @dev Compares two strings and returns true iff they are equal.\n    function equal(string A, string B) private returns (bool) \n       {\n        return compare(A, B) == 0;\n}\n\nfunction returnmoneycreator(uint8 gameResult,uint wager) private		//If game has over 50 eth, contract will send all additional eth to owner\n	{\n	if (gameResult==1&&this.balance>50000000000000000000)\n	{creator.send(wager);\n	return; \n	}\n \n	else if\n	(\n	gameResult==1&&this.balance>20000000000000000000)				//If game has over 20 eth, contract will send œ of any additional eth to owner\n	{creator.send(wager/2);\n	return; }\n	}\n \n/**********\nfunctions below give information about the game in Ethereum Wallet\n **********/\n \n 	function Results_of_the_last_round() constant returns (uint players_bet_in_Wei, string last_result,string Last_player_s_lottery_ticket,address last_player,string The_right_lottery_number,int Player_s_gain_or_Loss_in_Wei,string info)\n    { \n   	last_player=player;	\n	Last_player_s_lottery_ticket=A;\n	The_right_lottery_number=B;\n	last_result=lastresult;\n	players_bet_in_Wei=wager;\n	Player_s_gain_or_Loss_in_Wei=lastgainloss;\n	info = information;\n	\n \n    }\n\n \n    \n   \n	function Game_balance_in_Ethers() constant returns (uint balance, string info)\n    { \n        info = ""Choose number between 1 and 15. Win pays wager*12. Minimum bet is 0.1 eth. Maximum bet is game balance/12. Game balance is shown in full Ethers."";\n    	balance=(this.balance/10**18);\n\n    }\n    \n   \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1789087,0x80ddae5251047d6ceb29765f38fed1c0013004b7,false,false,"contract Lottery {\n    event GetBet(uint betAmount, uint blockNumber, bool won); \n\n    struct Bet {\n        uint betAmount;\n        uint blockNumber;\n        bool won;\n    }\n\n    address private organizer;\n    Bet[] private bets;\n\n    // Create a new lottery with numOfBets supported bets.\n    function Lottery() {\n        organizer = msg.sender;\n    }\n    \n    // Fallback function returns ether\n    function() {\n        throw;\n    }\n    \n    // Make a bet\n    function makeBet() {\n        // Won if block number is even\n        // (note: this is a terrible source of randomness, please don't use this with real money)\n        bool won = (block.number % 2) == 0; \n        \n        // Record the bet with an event\n        bets.push(Bet(msg.value, block.number, won));\n        \n        // Payout if the user won, otherwise take their money\n        if(won) { \n            if(!msg.sender.send(msg.value)) {\n                // Return ether to sender\n                throw;\n            } \n        }\n    }\n    \n    // Get all bets that have been made\n    function getBets() {\n        if(msg.sender != organizer) { throw; }\n        \n        for (uint i = 0; i < bets.length; i++) {\n            GetBet(bets[i].betAmount, bets[i].blockNumber, bets[i].won);\n        }\n    }\n    \n    // Suicide :(\n    function destroy() {\n        if(msg.sender != organizer) { throw; }\n        \n        suicide(organizer);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1789671,0xd588b586d61c826a0e87919b3d1a239206d58bf2,false,false,"// Ethereum Name Registrar as it should be!\n//\n// Written by Alexandre Naverniouk\n// twitter @AlexNa\n\n\ncontract EtherId {\n\nuint constant MAX_PROLONG = 2000000; // Maximum number of blocks to prolong the ownership. About one year.\n\nuint public n_domains = 0;      // total number of registered domains\nuint public root_domain = 0;    // name of the first domain in the linked list\naddress contract_owner = 0; //\n\nstruct Id {                     // Id record. Double linked list. Allows to delete ID\n    uint value;\n    uint next_id;\n    uint prev_id;\n}\n\nstruct Domain {                 // Domain record. Linked list. \n    address owner;              // Owner of the domain\n    uint expires;               // Expiration block namber\n    uint price;                 // Sale price ( 0 - not for sale )\n    address transfer;           // Address of the new owner\n    uint next_domain;           // Makes linked list for scanning\n    uint root_id;               // Name of the first ID in the list\n    mapping (uint => Id) ids;   // Map of the ID's\n}\n\nmapping (uint => Domain) domains; // Map of the domains\n\nfunction EtherId()\n{\n    contract_owner = msg.sender;\n}\n\nevent DomainChanged( address indexed sender, uint domain, uint id ); // Fired every time the registry is changed\n\nfunction getId( uint domain, uint id ) constant returns (uint v, uint next_id, uint prev_id )\n{\n    Id i = domains[domain].ids[id]; \n\n    v = i.value;\n    next_id = i.next_id;\n    prev_id = i.prev_id;\n}\n\nfunction getDomain( uint domain ) constant returns \n    (address owner, uint expires, uint price, address transfer, uint next_domain, uint root_id )\n{\n    Domain d = domains[ domain ];\n    \n    owner = d.owner;\n    expires = d.expires;\n    price = d.price;\n    transfer = d.transfer;\n    next_domain = d.next_domain;\n    root_id = d.root_id;    \n}\n\n\nfunction changeDomain( uint domain, uint expires, uint price, address transfer ) \n{\n    uint money_used = 0;            // How much was spent here\n\n    if( expires > MAX_PROLONG )     // Not prolong for too long\n    {\n        expires = MAX_PROLONG;\n    }\n    \n    if( domain == 0 ) throw;        // Prevents creating 0 domain\n\n    Domain d = domains[ domain ];\n\n    if( d.owner == 0 )              // 0 means the domain is not yet registered\n    { \n        d.owner = msg.sender;       // Simple calim\n        d.price = price;\n        d.transfer = transfer;\n        d.expires = block.number + expires;\n        \n        d.next_domain = root_domain;// Put the new domain into the linked list\n        root_domain = domain;\n        \n        //****************************************************************************\n        //*** SPECIAL CODE FOR TRANSFERING FIRST 32301 DOMAINS INTO THE NEW CONTRACT\n        if( msg.sender == contract_owner && n_domains < 32301 && transfer != 0 ) { \n            d.owner = transfer; // immediately transfer the ownership to the old owner\n            d.transfer = 0;\n        }\n        //****************************************************************************\n        \n        \n        n_domains = n_domains + 1;\n        DomainChanged( msg.sender, domain, 0 );\n    }\n    else                            // The domain already has an owner\n    {\n        if( d.owner == msg.sender || block.number > d.expires ) { // If it is yours or expired, you have all rights to change\n            d.owner = msg.sender;   // Possible change of the ownershp if expired\n            d.price = price;\n            d.transfer = transfer;\n            d.expires = block.number + expires;\n            DomainChanged( msg.sender, domain, 0 );\n        }\n        else                        // Not yours and not expired\n        {\n            if( d.transfer != 0 ) { // The new owner is specified and ...\n                if( d.transfer == msg.sender && msg.value >= d.price ) // ... it is you and enought money \n                {\n                    if( d.price > 0 ) \n                    { \n                        if( address( d.owner ).send( d.price ) ) // The money goes to the owner\n                        {\n                            money_used = d.price;   // remember how much spent\n                        }\n                        else throw; // problem with send()\n                    }\n\n                    d.owner = msg.sender;   // Change the ownership\n                    d.price = price;        // New price\n                    d.transfer = transfer;  // New transfer\n                    d.expires = block.number + expires; //New expiration\n                    DomainChanged( msg.sender, domain, 0 );\n                }\n            } \n            else  // not set for transfer, but...\n            {\n                if( d.price > 0 &&  msg.value >= d.price ) // ... on sale, and enough money\n                {\n                    if( address( d.owner ).send( d.price ) ) // The money goes to the owner\n                    {\n                        money_used = d.price; // remember how much spent\n                    }\n                    else throw; // problem with send()\n\n                    d.owner = msg.sender;   // Change the ownership\n                    d.price = price;        // New price\n                    d.transfer = transfer;  // New transfer\n                    d.expires = block.number + expires; // New expiration\n                    DomainChanged( msg.sender, domain, 0 );\n                }\n            }\n        }\n    }\n    \n    if( msg.value > money_used ) // If transaction has more money than was needed\n    {\n        if( !msg.sender.send( msg.value - money_used ) ) throw; // We do not need your leftover\n    }\n}\n\nfunction changeId( uint domain, uint name, uint value ) {\n\n    if( domain == 0 ) throw;        // Prevents creating 0 domain\n    if( name == 0 ) throw;          // Prevents creating 0 id\n    \n    Domain d = domains[ domain ];\n\n    if( d.owner == msg.sender )     // Only owner can change the ID\n    {\n        Id id = d.ids[ name ];\n\n        if( id.value == 0 ) {       // 0 means the ID was not found\n            if( value != 0 ) {      // Only add non zero values\n                id.value = value;   \n                id.next_id = d.root_id; // Put into the head of the list\n                // id.prev_id = 0;  // 0 is the default, no need to assign\n                \n                if( d.root_id != 0 ) \n                {\n                    d.ids[ d.root_id ].prev_id = name; // link the next ID back\n                }\n\n                d.root_id = name;   \n                DomainChanged( msg.sender, domain, name );\n            }\n        }\n        else                        // The ID was found\n        {\n            if( value != 0 )        // Simple change of the value\n            {\n                id.value = value;\n                DomainChanged( msg.sender, domain, name );\n            }\n            else                    // Deleting the ID\n            {\n                if( id.prev_id != 0 ) // Modify the double linked list\n                {\n                    d.ids[ id.prev_id ].next_id = id.next_id;   \n                }\n                else\n                {\n                    d.root_id = id.next_id;\n                }\n\n                if( id.next_id != 0 )\n                {\n                    d.ids[ id.next_id ].prev_id = id.prev_id;   \n                }\n                \n                id.prev_id = 0;   // Clear the storage\n                id.next_id = 0;   \n                id.value = 0;   \n                DomainChanged( msg.sender, domain, name );\n            }\n        }\n    }\n    \n    if( msg.value > 0 ) // If transaction has any money...\n    {\n        if( !msg.sender.send( msg.value ) ) throw; // ... it is a mistake, so send it back\n    }\n}\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ドメイン管理のための機能が中心。
1792116,0x7d11a8518cbc6560e36cbc23b788d415b9982404,false,false,"contract Soleau {\n\n  uint price = 0.001 ether;\n  struct Record {\n    address holder;\n    bool exists; \n    uint createdAt; /* Time */ \n    uint createdIn; /* Block number */\n  }\n  mapping (string => Record) _records;\n\n  function record(string hash) returns (bool success, bool already, uint theBlock) {\n    if (msg.value < price) {\n      success = false;\n      msg.sender.send(msg.value); /* We're nice, we refund */\n      return;\n    } /* Else we keep the money but there is currently no way to use\n	 it: it is locked in the contract for ever */\n    if (_records[hash].exists) {\n      success = true;\n      already = true;\n      theBlock = _records[hash].createdIn;\n    } else {\n      _records[hash].exists = true;\n      _records[hash].holder = msg.sender;\n      _records[hash].createdAt = now;\n      _records[hash].createdIn = block.number;\n      success = true;\n      already = false;\n      theBlock = _records[hash].createdIn;\n    }\n  }\n\n  function get(string hash) constant returns (bool success, uint theBlock, uint theTime, address holder) {\n    if (_records[hash].exists) {\n      success = true;\n      theBlock = _records[hash].createdIn;\n      theTime = _records[hash].createdAt;\n      holder = _records[hash].holder;\n    } else {\n      success = false;\n    }\n  }\n\n  /* No fallback function */\n  function () {\n    throw;\n  }\n  \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1792868,0xa782e28a912ef9c44cbf827f8a3fefc3a8cb85e0,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//   WHYSOS3RIOUS   PRESENTS :   \n//   The ROULETH \n//\n//  Play the Roulette on ethereum blockchain !\n//  (or become an investor in the Casino and share the profits/losses.) \n//\n//\n//   Full GUI on website with all info to play : \n//                   \n//                  www.Rouleth.com\n//\n//\n//   All documentation on playing and investing are on the website.\n//\n//   News : www.reddit.com/r/Rouleth\n//   twitter : https://twitter.com/TheRouleth\n//\n//   Github : https://github.com/Bunjin/Rouleth\n//\n//   check latest contract version on website\n//   V 1.2\n//\n// *** coded by WhySoS3rious, 2016.                                       ***//\n// *** please do not copy without authorization                          ***//\n// *** contact : reddit    /u/WhySoS3rious                               ***//\n//\n//\n//  Stake : Variable, check on website for the max bet.\n\ncontract Rouleth\n{\n\n    //Variables, Structure\n    address developer;\n    uint8 blockDelay; //nb of blocks to wait before spin\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\n    uint256 maxGamble; //max gamble value manually set by config\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\n    uint casinoStatisticalLimit;\n    //Current gamble value possibly lower than config (<payroll/(casinoStatisticalLimit*35))\n    uint256 currentMaxGamble; \n    //Gambles\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \n    struct Gamble\n    {\n	address player;\n        bool spinned; //Was the rouleth spinned ?\n	bool win;\n	//Possible bet types\n        BetTypes betType;\n	uint8 input; //stores number, color, dozen or oddeven\n	uint256 wager;\n	uint256 blockNumber; //block of bet -1\n        uint8 wheelResult;\n    }\n    Gamble[] private gambles;\n    uint firstActiveGamble; //pointer to track the first non spinned and non expired gamble.\n    //Tracking progress of players\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; //records current status of player\n\n    //**********************************************\n    //        Management & Config FUNCTIONS        //\n    //**********************************************\n    function  Rouleth() private //creation settings\n    { \n        developer = msg.sender;\n        blockDelay=2; //delay to wait between bet and spin\n	blockExpiration=200; //delay after which gamble expires\n        maxGamble=500 finney; //configurable max bet\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\n        casinoStatisticalLimit=20;\n    }\n	\n    modifier onlyDeveloper() \n    {\n	if (msg.sender!=developer) throw;\n	_\n    }\n	\n    function changeDeveloper(address new_dev)\n    noEthSent\n    onlyDeveloper\n    {\n	developer=new_dev;\n    }\n\n\n    //Activate, Deactivate Betting\n    enum States{active, inactive} States private state;\n	\n    function disableBetting()\n    noEthSent\n    onlyDeveloper\n    {\n        state=States.inactive;\n    }\n    function enableBetting()\n    onlyDeveloper\n    noEthSent\n    {\n        state=States.active;\n    }\n    \n    modifier onlyActive\n    {\n        if (state==States.inactive) throw;\n        _\n    }\n\n    //Change some settings within safety bounds\n    function changeSettings(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMaxGamble, uint8 newMaxInvestor, uint256 newMinInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\n    noEthSent\n    onlyDeveloper\n	{\n	        // changes the statistical multiplier that guarantees the long run casino survival\n	        if (newCasinoStatLimit<10) throw;\n	        casinoStatisticalLimit=newCasinoStatLimit;\n	        //Max number of bets per block to prevent miner cheating\n	        maxBetsPerBlock=newMaxBetsBlock;\n                //MAX BET : limited by payroll/(casinoStatisticalLimit*35) for statiscal confidence in longevity of casino\n		if (newMaxGamble<=0) throw; \n		else { maxGamble=newMaxGamble; }\n                //MAX NB of INVESTORS (can only increase and max of 149)\n                if (newMaxInvestor<setting_maxInvestors || newMaxInvestor>149) throw;\n                else { setting_maxInvestors=newMaxInvestor;}\n                //MIN INVEST : \n                setting_minInvestment=newMinInvestment;\n                //Invest LOCK PERIOD\n                if (setting_lockPeriod>90 days) throw; //3 months max\n                setting_lockPeriod=newLockPeriod;\n		//Delay before roll :\n		if (blockDelay<1) throw;\n		blockDelay=newBlockDelay;\n                updateMaxBet();\n		if (newBlockExpiration<50) throw;\n		blockExpiration=newBlockExpiration;\n	}\n \n\n    //**********************************************\n    //                 BETTING FUNCTIONS                    //\n    //**********************************************\n\n//***//basic betting without Mist or contract call\n    //activates when the player only sends eth to the contract\n    //without specifying any type of bet.\n    function () \n   {\n       //if player is not playing : bet on Red\n       if (playerStatus[msg.sender]==Status.waitingForBet)  betOnColor(true,false);\n       //if player is already playing, spin the wheel\n       else spinTheWheel();\n    } \n\n    function updateMaxBet() private\n    {\n    //check that maxGamble setting is still within safety bounds\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \n		{ \n			currentMaxGamble=maxGamble;\n                }\n	else\n		{ \n			currentMaxGamble = payroll/(casinoStatisticalLimit*35);\n		}\n     }\n\n//***//Guarantees that gamble is under (statistical) safety limits for casino survival.\n    function checkBetValue() private returns(uint256 playerBetValue)\n    {\n        updateMaxBet();\n		if (msg.value > currentMaxGamble) //if above max, send difference back\n		{\n			if (msg.sender.send(msg.value-currentMaxGamble)==false) throw;\n		    playerBetValue=currentMaxGamble;\n		}\n                else\n                { playerBetValue=msg.value; }\n         return;\n       }\n\n\n    //check number of bets in block (to prevent miner cheating)\n    modifier checkNbBetsCurrentBlock()\n    {\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\n        else nbBetsCurrentBlock=0;\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\n        _\n    }\n    //check that the player is not playing already (unless it has expired)\n    modifier checkWaitingForBet{\n        //if player is already in gamble\n        if (playerStatus[msg.sender]!=Status.waitingForBet)\n        {\n             //case not expired\n             if (gambles[gambleIndex[msg.sender]].blockNumber+blockExpiration>block.number) throw;\n             //case expired\n             else\n             {\n                  //add bet to PL and reset status\n                  solveBet(msg.sender, 255, false, 0) ;\n\n              }\n        }\n	_\n	}\n\n    function updateStatusPlayer() private\n    expireGambles\n    {\n	playerStatus[msg.sender]=Status.waitingForSpin;\n	gambleIndex[msg.sender]=gambles.length;\n     }\n\n//***//bet on Number	\n    function betOnNumber(uint8 numberChosen)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        updateStatusPlayer();\n        //check that number chosen is valid and records bet\n        if (numberChosen>36) throw;\n        //adapts wager to casino limits\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.number, numberChosen, betValue, block.number, 37));\n    }\n\n//***// function betOnColor\n	//bet type : color\n	//input : 0 for red\n	//input : 1 for black\n    function betOnColor(bool Red, bool Black)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        updateStatusPlayer();\n        uint8 count;\n        uint8 input;\n        if (Red) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Black) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.color, input, betValue, block.number, 37));\n    }\n\n//***// function betOnLow_High\n	//bet type : lowhigh\n	//input : 0 for low\n	//input : 1 for low\n    function betOnLowHigh(bool Low, bool High)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        updateStatusPlayer();\n        uint8 count;\n        uint8 input;\n        if (Low) \n        { \n             count+=1; \n             input=0;\n         }\n        if (High) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.lowhigh, input, betValue, block.number, 37));\n    }\n\n//***// function betOnOdd_Even\n	//bet type : parity\n     //input : 0 for even\n    //input : 1 for odd\n    function betOnOddEven(bool Odd, bool Even)\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        updateStatusPlayer();\n        uint8 count;\n        uint8 input;\n        if (Even) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Odd) \n        {\n             count+=1; \n             input=1;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, BetTypes.parity, input, betValue, block.number, 37));\n    }\n\n\n//***// function betOnDozen\n//     //bet type : dozen\n//     //input : 0 for first dozen\n//     //input : 1 for second dozen\n//     //input : 2 for third dozen\n    function betOnDozen(bool First, bool Second, bool Third)\n    {\n         betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\n    }\n\n\n// //***// function betOnColumn\n//     //bet type : column\n//     //input : 0 for first column\n//     //input : 1 for second column\n//     //input : 2 for third column\n    function betOnColumn(bool First, bool Second, bool Third)\n    {\n         betOnColumnOrDozen(First, Second, Third, BetTypes.column);\n     }\n\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\n    checkWaitingForBet\n    onlyActive\n    checkNbBetsCurrentBlock\n    { \n        updateStatusPlayer();\n        uint8 count;\n        uint8 input;\n        if (First) \n        { \n             count+=1; \n             input=0;\n         }\n        if (Second) \n        {\n             count+=1; \n             input=1;\n         }\n        if (Third) \n        {\n             count+=1; \n             input=2;\n         }\n        if (count!=1) throw;\n	//check that wager is under limit\n        uint256 betValue= checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, bet, input, betValue, block.number, 37));\n    }\n\n    //**********************************************\n    // Spin The Wheel & Check Result FUNCTIONS//\n    //**********************************************\n\n	event Win(address player, uint8 result, uint value_won);\n	event Loss(address player, uint8 result, uint value_loss);\n\n    //check that player has to spin the wheel\n    modifier checkWaitingForSpin{\n        if (playerStatus[msg.sender]!=Status.waitingForSpin) throw;\n	_\n	}\n    //Prevents accidental sending of Eth when you shouldn't\n    modifier noEthSent()\n    {\n        if (msg.value>0) \n		{\n				if (msg.sender.send(msg.value)==false) throw;\n		}\n        _\n    }\n\n//***//function to spin\n    function spinTheWheel()\n    noEthSent\n    checkWaitingForSpin\n    {\n        //check that the player waited for the delay before spin\n        //and also that the bet is not expired\n	uint playerblock = gambles[gambleIndex[msg.sender]].blockNumber;\n	if (block.number<playerblock+blockDelay || block.number>playerblock+blockExpiration) throw;\n        else\n	{\n	    uint8 wheelResult;\n            //Spin the wheel, Reset player status and record result\n	    wheelResult = uint8(uint256(block.blockhash(playerblock+blockDelay))%37);\n	    gambles[gambleIndex[msg.sender]].wheelResult=wheelResult;\n            //check result against bet and pay if win\n	    checkBetResult(wheelResult, gambles[gambleIndex[msg.sender]].betType);\n	    updateFirstActiveGamble();\n	}\n    }\n\n//update pointer of first gamble not spinned\nfunction updateFirstActiveGamble() private\n     {\n              for (uint k=firstActiveGamble; k<=firstActiveGamble+50; k++) \n              //limit the update to 50 to cap the gas cost and share the work among users\n              {\n                 if (k>=gambles.length || !gambles[k].spinned)\n                 {\n                    firstActiveGamble=k;\n                    break; \n                 }\n              }\n }\n	\n//checks if there are expired gambles\nmodifier expireGambles{\n    if (  gambles.length!=0 && gambles.length-1>=firstActiveGamble \n          && gambles[firstActiveGamble].blockNumber + blockExpiration <= block.number \n          && !gambles[firstActiveGamble].spinned )  \n    { \n	solveBet(gambles[firstActiveGamble].player, 255, false, 0); //expires\n    }\n        updateFirstActiveGamble(); //update pointer\n        _\n}\n	\n\n     //CHECK BETS FUNCTIONS private\n     function checkBetResult(uint8 result, BetTypes betType) private\n     {\n          //bet on Number\n          if (betType==BetTypes.number) checkBetNumber(result);\n          else if (betType==BetTypes.parity) checkBetParity(result);\n          else if (betType==BetTypes.color) checkBetColor(result);\n	 else if (betType==BetTypes.lowhigh) checkBetLowhigh(result);\n	 else if (betType==BetTypes.dozen) checkBetDozen(result);\n	else if (betType==BetTypes.column) checkBetColumn(result);\n          updateMaxBet(); \n     }\n\n     // function solve Bet once result is determined : sends to winner, adds loss to profit\n     function solveBet(address player, uint8 result, bool win, uint8 multiplier) private\n     {\n        playerStatus[player]=Status.waitingForBet;\n        gambles[gambleIndex[player]].spinned=true;\n	uint bet_v = gambles[gambleIndex[player]].wager;\n            if (win)\n            {\n                  if (player!=gambles[gambleIndex[player]].player) throw; //security failcheck\n		  gambles[gambleIndex[player]].win=true;\n		  uint win_v = multiplier*bet_v;\n                  lossSinceChange+=win_v-bet_v;\n		  Win(player, result, win_v);\n				if (player.send(win_v)==false) throw;\n             }\n            else\n            {\n		Loss(player, result, bet_v);\n                profitSinceChange+=bet_v;\n            }\n\n      }\n\n\n     // checkbeton number(input)\n    // bet type : number\n    // input : chosen number\n     function checkBetNumber(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result==gambles[gambleIndex[msg.sender]].input)\n	    {\n                  win=true;  \n             }\n             solveBet(msg.sender, result,win,36);\n     }\n\n\n     // checkbet on oddeven\n    // bet type : parity\n    // input : 0 for even, 1 for odd\n     function checkBetParity(uint8 result) private\n     {\n            bool win;\n            //win\n	    if (result%2==gambles[gambleIndex[msg.sender]].input && result!=0)\n	    {\n                  win=true;                \n             }\n             solveBet(msg.sender,result,win,2);\n        \n     }\n	\n     // checkbet on lowhigh\n     // bet type : lowhigh\n     // input : 0 low, 1 high\n     function checkBetLowhigh(uint8 result) private\n     {\n            bool win;\n            //win\n		 if (result!=0 && ( (result<19 && gambles[gambleIndex[msg.sender]].input==0)\n			 || (result>18 && gambles[gambleIndex[msg.sender]].input==1)\n			 ) )\n	    {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n     }\n\n     // checkbet on color\n     // bet type : color\n     // input : 0 red, 1 black\n      uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\n      function checkBetColor(uint8 result) private\n      {\n             bool red;\n             //check if red\n             for (uint8 k; k<18; k++)\n             { \n                    if (red_list[k]==result) \n                    { \n                          red=true; \n                          break;\n                    }\n             }\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && red)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && !red)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,2);\n       }\n\n     // checkbet on dozen\n     // bet type : dozen\n     // input : 0 first, 1 second, 2 third\n     function checkBetDozen(uint8 result) private\n     { \n            bool win;\n            //win on first dozen\n     		 if ( result!=0 &&\n                      ( (result<13 && gambles[gambleIndex[msg.sender]].input==0)\n     			||\n                     (result>12 && result<25 && gambles[gambleIndex[msg.sender]].input==1)\n                    ||\n                     (result>24 && gambles[gambleIndex[msg.sender]].input==2) ) )\n     	    {\n                   win=true;                \n             }\n             solveBet(msg.sender,result,win,3);\n     }\n\n     // checkbet on column\n     // bet type : column\n     // input : 0 first, 1 second, 2 third\n      function checkBetColumn(uint8 result) private\n      {\n             bool win;\n             //win\n             if ( result!=0\n                && ( (gambles[gambleIndex[msg.sender]].input==0 && result%3==1)  \n                || ( gambles[gambleIndex[msg.sender]].input==1 && result%3==2)\n                || ( gambles[gambleIndex[msg.sender]].input==2 && result%3==0)  ) )\n             {\n                  win=true;\n             }\n             solveBet(msg.sender,result,win,3);\n      }\n\n\n//INVESTORS FUNCTIONS\n\n\n//total casino payroll\n    uint256 payroll;\n//Profit Loss since last investor change\n    uint256 profitSinceChange;\n    uint256 lossSinceChange;\n//investor struct array (hard capped to 150)\n    uint8 setting_maxInvestors = 50;\n    struct Investor\n    {\n	    address investor;\n	    uint256 time;\n    }	\n	\n    Investor[250] private investors ;\n    //Balances of the investors\n    mapping (address=>uint256) balance; \n    //Investor lockPeriod\n    //lock time to avoid invest and withdraw for refresh only\n    //also time during which you cannot be outbet by a new investor if it is full\n    uint256 setting_lockPeriod=30 days ;\n    uint256 setting_minInvestment=10 ether; //min amount to send when using invest()\n    //if full and unlocked position, indicates the cheapest amount to outbid\n    //otherwise cheapestUnlockedPosition=255\n    uint8 cheapestUnlockedPosition; \n    uint256 minCurrentInvest; \n    //record open position index\n    // =255 if full\n    uint8 openPosition;\n	\n    event newInvest(address player, uint invest_v);\n\n\n     function invest()\n     {\n          // check that min 10 ETH is sent (variable setting)\n          if (msg.value<setting_minInvestment) throw;\n          // check if already investor\n          bool alreadyInvestor;\n          // reset the position counters to values out of bounds\n          openPosition=255;\n          cheapestUnlockedPosition=255;\n          minCurrentInvest=1000000000 ether;\n          // update balances before altering the investor shares\n          updateBalances();\n          // loop over investor's array to find if already investor, \n          // or openPosition and cheapest UnlockedPosition\n          for (uint8 k = 0; k<setting_maxInvestors; k++)\n          { \n               //captures an index of an open position\n               if (investors[k].investor==0) openPosition=k; \n               //captures if already an investor \n               else if (investors[k].investor==msg.sender)\n               {\n                    investors[k].time=now; //refresh time invest\n                    alreadyInvestor=true;\n                }\n               //captures the index of the investor with the min investment (after lock period)\n               else if (investors[k].time+setting_lockPeriod<now && balance[investors[k].investor]<minCurrentInvest && investors[k].investor!=developer)\n               {\n                    cheapestUnlockedPosition=k;\n                    minCurrentInvest=balance[investors[k].investor];\n                }\n           }\n           //case New investor\n           if (alreadyInvestor==false)\n           {\n                    //case : investor array not full, record new investor\n                    if (openPosition!=255) investors[openPosition]=Investor(msg.sender, now);\n                    //case : investor array full\n                    else\n                    {\n                         //subcase : investor has not outbid or all positions under lock period\n                         if (msg.value<=minCurrentInvest || cheapestUnlockedPosition==255) throw;\n                         //subcase : investor outbid, record investor change and refund previous\n                         else\n                         {\n                              address previous = investors[cheapestUnlockedPosition].investor;\n                              balance[previous]=0;\n                              investors[cheapestUnlockedPosition]=Investor(msg.sender, now);\n                              if (previous.send(balance[previous])==false) throw;\n                          }\n                     }\n            }\n          //add investment to balance of investor and to payroll\n\n          uint256 maintenanceFees=2*msg.value/100; //2% maintenance fees\n          uint256 netInvest=msg.value - maintenanceFees;\n          newInvest(msg.sender, netInvest);\n          balance[msg.sender]+=netInvest; //add invest to balance\n          payroll+=netInvest;\n          //send maintenance fees to developer \n          if (developer.send(maintenanceFees)==false) throw;\n          updateMaxBet();\n      }\n\n//***// Withdraw function (only after lockPeriod)\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\n    // if your withdraw brings your balance under the min investment required,\n    // your balance is fully withdrawn\n	event withdraw(address player, uint withdraw_v);\n	\n    function withdrawInvestment(uint256 amountToWithdrawInWei)\n    noEthSent\n    {\n        //before withdraw, update balances of the investors with the Profit and Loss sinceChange\n        updateBalances();\n	//check that amount requested is authorized  \n	if (amountToWithdrawInWei>balance[msg.sender]) throw;\n        //retrieve investor ID\n        uint8 investorID=255;\n        for (uint8 k = 0; k<setting_maxInvestors; k++)\n        {\n               if (investors[k].investor==msg.sender)\n               {\n                    investorID=k;\n                    break;\n               }\n        }\n           if (investorID==255) throw; //stop if not an investor\n           //check if investment lock period is over\n           if (investors[investorID].time+setting_lockPeriod>now) throw;\n           //if balance left after withdraw is still above min investment accept partial withdraw\n           if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\n           {\n               balance[msg.sender]-=amountToWithdrawInWei;\n               payroll-=amountToWithdrawInWei;\n               //send amount to investor (with security if transaction fails)\n               if (msg.sender.send(amountToWithdrawInWei)==false) throw;\n	       withdraw(msg.sender, amountToWithdrawInWei);\n           }\n           else\n           //if amountToWithdraw=0 : user wants full withdraw\n           //if balance after withdraw is < min invest, withdraw all and delete investor\n           {\n               //send amount to investor (with security if transaction fails)\n               uint256 fullAmount=balance[msg.sender];\n               payroll-=fullAmount;\n               balance[msg.sender]=0;\n               //delete investor\n               delete investors[investorID];\n               if (msg.sender.send(fullAmount)==false) throw;\n   	       withdraw(msg.sender, fullAmount);\n            }\n          updateMaxBet();\n     }\n\n//***// updates balances with Profit Losses when there is a withdraw/deposit of investors\n\n	function manualUpdateBalances()\n	expireGambles\n	noEthSent\n	onlyDeveloper\n	{\n	    updateBalances();\n	}\n    function updateBalances() private\n    {\n         //split Profits\n         uint256 profitToSplit;\n         uint256 lossToSplit;\n         if (profitSinceChange==0 && lossSinceChange==0)\n         { return; }\n         \n         else\n         {\n             // Case : Global profit (more win than losses)\n             // 2% fees for developer on global profit (if profit>loss)\n             if (profitSinceChange>lossSinceChange)\n             {\n                profitToSplit=profitSinceChange-lossSinceChange;\n                uint256 developerFees=profitToSplit*2/100;\n                profitToSplit-=developerFees;\n                if (developer.send(developerFees)==false) throw;\n             }\n             else\n             {\n                lossToSplit=lossSinceChange-profitSinceChange;\n             }\n         \n         //share the loss and profits between all invest \n         //(proportionnaly. to each investor balance)\n         uint totalShared;\n             for (uint8 k=0; k<setting_maxInvestors; k++)\n             {\n                 address inv=investors[k].investor;\n                 if (inv==0) continue;\n                 else\n                 {\n                       if (profitToSplit!=0) \n                       {\n                           uint profitShare=(profitToSplit*balance[inv])/payroll;\n                           balance[inv]+=profitShare;\n                           totalShared+=profitShare;\n                       }\n                       if (lossToSplit!=0) \n                       {\n                           uint lossShare=(lossToSplit*balance[inv])/payroll;\n                           balance[inv]-=lossShare;\n                           totalShared+=lossShare;\n                           \n                       }\n                 }\n             }\n          // update payroll\n          if (profitToSplit !=0) \n          {\n              payroll+=profitToSplit;\n              balance[developer]+=profitToSplit-totalShared;\n          }\n          if (lossToSplit !=0) \n          {\n              payroll-=lossToSplit;\n              balance[developer]-=lossToSplit-totalShared;\n          }\n          profitSinceChange=0; //reset Profit;\n          lossSinceChange=0; //reset Loss ;\n          \n          }\n     }\n     \n     \n     //INFORMATION FUNCTIONS\n     \n     function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances)\n     {\n        profit_since_update_balances=profitSinceChange;\n        loss_since_update_balances=lossSinceChange;\n        return;\n     }\n\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\n    {\n          balanceInWei=balance[investor];\n          return;\n     }\n\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\n    {\n          investor=investors[index].investor;\n          endLockPeriod=investors[index].time+setting_lockPeriod;\n          return;\n    }\n	\n\n	function investmentEntryCost() constant returns(bool open_position, bool unlocked_position, uint buyout_amount, uint investLockPeriod)\n	{\n		if (openPosition!=255) open_position=true;\n		if (cheapestUnlockedPosition!=255) \n		{\n			unlocked_position=true;\n			buyout_amount=minCurrentInvest;\n		}\n		investLockPeriod=setting_lockPeriod;\n		return;\n	}\n	\n	function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\n	{\n	    maxBet=currentMaxGamble;\n	    blockDelayBeforeSpin=blockDelay;\n	    return ;\n	}\n\n	function getFirstActiveGamble() constant returns(uint _firstActiveGamble)\n	{\n            _firstActiveGamble=firstActiveGamble;\n	    return ;\n	}\n	\n	function getPayroll() constant returns(uint payroll_at_last_update_balances)\n	{\n            payroll_at_last_update_balances=payroll;\n	    return ;\n	}\n\n	\n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\n    {\n          player_status=playerStatus[player];\n          bettype=gambles[gambleIndex[player]].betType;\n          input=gambles[gambleIndex[player]].input;\n          value=gambles[gambleIndex[player]].wager;\n          result=gambles[gambleIndex[player]].wheelResult;\n          wheelspinned=gambles[gambleIndex[player]].spinned;\n          win=gambles[gambleIndex[player]].win;\n          blockNb=gambles[gambleIndex[player]].blockNumber;\n	  return;\n     }\n     \n         function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb)\n    {\n          player=gambles[index].player;\n          bettype=gambles[index].betType;\n          input=gambles[index].input;\n          value=gambles[index].wager;\n          result=gambles[index].wheelResult;\n          wheelspinned=gambles[index].spinned;\n          win=gambles[index].win;\n	  blockNb=gambles[index].blockNumber;\n	  return;\n     }\n\n} //end of contract",2,アスキーアートとコメントが詩的要素を加えているが、機能は実用的。
1799878,0x606ddac6f2928369e8515340f8de97fe2d166777,false,false,"// https://github.com/pipermerriam/ethereum-stack-depth-lib\n\nlibrary StackDepthLib {\n    // This will probably work with a value of 390 but no need to cut it\n    // that close in the case that the optimizer changes slightly or\n    // something causing that number to rise slightly.\n    uint constant GAS_PER_DEPTH = 400;\n\n    function checkDepth(address self, uint n) constant returns(bool) {\n        if (n == 0) return true;\n        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n    }\n\n    function __dig(uint n) constant {\n        if (n == 0) return;\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n    }\n}",1,実用的なコードで、スタック深度を管理するライブラリとして機能しています。
1801441,0x55190829f2b43323b61421b36d6bd1c5b85d1297,false,false,"contract BTCRelay {\n    function getLastBlockHeight() returns (int);\n    function getBlockchainHead() returns (int);\n    function getFeeAmount(int blockHash) returns (int);\n    function getBlockHeader(int blockHash) returns (bytes32[3]);\n}\n\ncontract Lottery {\n    int constant LOTTERY_BLOCKS = 7 * 24 * 6;\n    uint constant LOTTERY_INTERVAL = 7 days;\n    int constant CUTOFF_BLOCKS = 6 * 6;\n    uint constant CUTOFF_INTERVAL = 6 hours;\n    uint constant TICKET_PRICE = 10 finney;\n    uint constant FEE_FACTOR = 200; // 0.5 %\n\n    BTCRelay btcRelay = BTCRelay(0x41f274c0023f83391de4e0733c609df5a124c3d4);\n\n    struct Bucket {\n        uint numHolders;\n        address[] ticketHolders;\n    }\n\n    struct Payout {\n        address winner;\n        uint amount;\n        uint blockNumber;\n        uint timestamp;\n        address processor;\n    }\n\n    int public decidingBlock;\n    int public cutoffBlock;\n    uint public cutoffTimestamp;\n    int public nearestKnownBlock;\n    int public nearestKnownBlockHash;\n\n    uint public numTickets;\n    uint public numBuckets;\n    mapping (uint => Bucket) buckets;\n    uint public lastSaleTimestamp;\n\n    Payout[] public payouts;\n    uint public payoutIdx;\n\n    address public owner;\n\n    modifier onlyOwner { if (msg.sender == owner) _ }\n\n    event Activity();\n\n    function Lottery() {\n        owner = msg.sender;\n        payouts.length = 3;\n        prepareLottery();\n    }\n\n    function prepareLottery() internal {\n        decidingBlock = btcRelay.getLastBlockHeight() + LOTTERY_BLOCKS;\n        cutoffBlock = decidingBlock - CUTOFF_BLOCKS;\n        cutoffTimestamp = now + LOTTERY_INTERVAL - CUTOFF_INTERVAL;\n        nearestKnownBlock = 0;\n        nearestKnownBlockHash = 0;\n\n        numTickets = 0;\n        for (uint i = 0; i < numBuckets; i++) {\n            buckets[i].numHolders = 0;\n        }\n        numBuckets = 0;\n        lastSaleTimestamp = 0;\n    }\n\n    function resetLottery() {\n        if (numTickets > 0) throw;\n        if (!payoutReady()) throw;\n\n        prepareLottery();\n        Activity();\n    }\n\n    function () {\n        buyTickets(msg.sender);\n    }\n\n    function buyTickets(address ticketHolder) {\n        if (msg.value < TICKET_PRICE) throw;\n        if (!ticketsAvailable()) throw;\n\n        uint n = msg.value / TICKET_PRICE;\n        numTickets += n;\n\n        // We maintain the list of ticket holders in a number of buckets.\n        // Entries in the first bucket represent one ticket each, in the\n        // second bucket they represent two tickets each, then four tickets\n        // each and so on. This allows us to process the sale of n tickets\n        // with a gas cost of O(log(n)).\n        uint bucket = 0;\n        while (n > 0) {\n            uint inThisBucket = n & (2 ** bucket);\n            if (inThisBucket > 0) {\n                uint pos = buckets[bucket].numHolders++;\n                if (buckets[bucket].ticketHolders.length <\n                    buckets[bucket].numHolders) {\n                    buckets[bucket].ticketHolders.length =\n                        buckets[bucket].numHolders;\n                }\n                buckets[bucket].ticketHolders[pos] = ticketHolder;\n                n -= inThisBucket;\n            }\n            bucket += 1;\n        }\n\n        if (bucket > numBuckets) numBuckets = bucket;\n\n        int missingBlocks = decidingBlock - btcRelay.getLastBlockHeight();\n        uint betterCutoffTimestamp =\n            now + uint(missingBlocks) * 10 minutes - CUTOFF_INTERVAL;\n        if (betterCutoffTimestamp < cutoffTimestamp) {\n            cutoffTimestamp = betterCutoffTimestamp;\n        }\n\n        lastSaleTimestamp = now;\n        Activity();\n    }\n\n    function ticketsAvailable() constant returns (bool) {\n        return now < cutoffTimestamp &&\n            btcRelay.getLastBlockHeight() < cutoffBlock;\n    }\n\n    function lookupTicketHolder(uint idx) constant returns (address) {\n        uint bucket = 0;\n        while (idx >= buckets[bucket].numHolders * (2 ** bucket)) {\n            idx -= buckets[bucket].numHolders * (2 ** bucket);\n            bucket += 1;\n        }\n\n        return buckets[bucket].ticketHolders[idx / (2 ** bucket)];\n    }\n\n    function getNumHolders(uint bucket) constant returns (uint) {\n        return buckets[bucket].numHolders;\n    }\n\n    function getTicketHolders(uint bucket) constant returns (address[]) {\n        return buckets[bucket].ticketHolders;\n    }\n\n    function getLastBlockHeight() constant returns (int) {\n        return btcRelay.getLastBlockHeight();\n    }\n\n    function getOperatingBudget() constant returns (uint) {\n        return this.balance - numTickets * TICKET_PRICE;\n    }\n\n    function payoutReady() constant returns (bool) {\n        return decidingBlock <= btcRelay.getLastBlockHeight();\n    }\n\n    function processPayout() returns (bool done) {\n        if (!payoutReady()) throw;\n        if (getOperatingBudget() < 1 ether) throw;\n        if (numTickets == 0) throw;\n\n        var (walkingDone, blockHash) = walkTowardsBlock();\n        if (!walkingDone) return false;\n\n        int winnerIdx = blockHash % int(numTickets);\n        address winner = lookupTicketHolder(uint(winnerIdx));\n        uint fee = (numTickets * TICKET_PRICE) / FEE_FACTOR;\n        uint amount = (numTickets * TICKET_PRICE) - fee;\n\n        // keep some records\n        payouts[payoutIdx].winner = winner;\n        payouts[payoutIdx].amount = amount;\n        payouts[payoutIdx].blockNumber = block.number;\n        payouts[payoutIdx].timestamp = now;\n        payouts[payoutIdx].processor = msg.sender;\n        payoutIdx = (payoutIdx + 1) % 3;\n\n        prepareLottery();   // prepare next round\n        var _ = winner.send(amount);\n        Activity();\n\n        return true;\n    }\n\n    function walkTowardsBlock() internal returns (bool, int) {\n        int blockHeight;\n        int blockHash;\n        if (nearestKnownBlock == 0) {\n            blockHeight = btcRelay.getLastBlockHeight();\n            blockHash = btcRelay.getBlockchainHead();\n        } else {\n            blockHeight = nearestKnownBlock;\n            blockHash = nearestKnownBlockHash;\n        }\n\n        // Walk at most 5 steps to keep an upper limit on gas costs.\n        for (uint steps = 0; steps < 5; steps++) {\n            if (blockHeight == decidingBlock) {\n                return (true, blockHash);\n            }\n\n            uint fee = uint(btcRelay.getFeeAmount(blockHash));\n            bytes32 blockHeader =\n                btcRelay.getBlockHeader.value(fee)(blockHash)[2];\n            bytes32 temp;\n\n            assembly {\n                let x := mload(0x40)\n                mstore(x, blockHeader)\n                temp := mload(add(x, 0x04))\n            }\n\n            blockHeight -= 1;\n            blockHash = 0;\n            for (int i = 0; i < 32; i++) {\n                blockHash = blockHash | int(temp[uint(i)]) * (256 ** i);\n            }\n        }\n\n        // Store the progress to pick up from there next time.\n        nearestKnownBlock = blockHeight;\n        nearestKnownBlockHash = blockHash;\n\n        return (false, 0);\n    }\n\n    function accessOperatingBudget(uint amount) onlyOwner {\n        if (getOperatingBudget() < 1 ether) throw;\n\n        uint safeToAccess = getOperatingBudget() - 1 ether;\n        if (amount > safeToAccess) throw;\n\n        var _ = owner.send(amount);\n    }\n\n    function setOwner(address _owner) onlyOwner {\n        owner = _owner;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ロジックが明確で、芸術的要素は少ない。
1805671,0x705f04a4f1e7a1e23caea390b8903bd43d96e18e,false,false,contract mortal {\n    address private owner;\n    /* this function is executed at initialization and sets the owner of the contract */\n    function mortal() { owner = msg.sender; }\n    /* Function to recover the funds on the contract */\n    function kill() { if (msg.sender == owner) selfdestruct(owner); }\n}\n\ncontract EtherPennySlots is mortal {\n    address private hotAccount = 0xD837ACd68e7dd0A0a9F03d72623d5CE5180e3bB8;\n    address public lastWinner;\n    address[]  private currentTicketHolders;\n    \n    function placeWager() {\n       if (msg.value > 0 finney && msg.value < 51 finney) {\n            uint i = 0;\n            for (i = 0; i < msg.value; i++){\n                currentTicketHolders.length++;\n                currentTicketHolders[currentTicketHolders.length-1] = msg.sender; \n            }\n                       \n            if (this.balance >= 601 finney) {\n                uint nr_tickets = currentTicketHolders.length;\n                uint randomTicket = block.number % nr_tickets;\n                address randomEntry = currentTicketHolders[randomTicket];\n                if (hotAccount.send(100 finney) && randomEntry.send(500 finney)) {\n                    lastWinner = randomEntry;\n                    currentTicketHolders.length = 0;\n                }\n            } \n        }\n    }\n},1,実用的なギャンブル機能を持つ標準的なスマートコントラクト。
1807799,0x0698a6229fff6b82bee731056ca01c298d8eff4d,true,false,"/**\n * Spork Token Contracts\n * See Spork contract below for more detail.\n *\n * The DAO and Spork is free software: you can redistribute it and/or modify\n * it under the terms of the GNU lesser General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * The DAO and Spork is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU lesser General Public License for more details.\n *\n * http://www.gnu.org/licenses/\n *\n * credit\n *   The DAO, Slock.it, Ethereum Foundation, EthCore, Consensys, pseudonymous\n *   rebels everywhere, and every lunch spot with proper eating utensils. ?\n */\n\n/**\n * @title TokenInterface\n * @notice ERC 20 token standard and DAO token interface.\n */\ncontract TokenInterface {\n\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _amount);\n\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _amount);\n\n    mapping (address => // owner\n        uint256) balances;\n\n    mapping (address => // owner\n    mapping (address => // spender\n        uint256)) allowed;\n\n    uint256 public totalSupply;\n\n    function balanceOf(address _owner)\n    constant\n    returns (uint256 balance);\n\n    function transfer(address _to, uint256 _amount)\n    returns (bool success);\n\n    function transferFrom(address _from, address _to, uint256 _amount)\n    returns (bool success);\n\n    function approve(address _spender, uint256 _amount)\n    returns (bool success);\n\n    function allowance(address _owner, address _spender)\n    constant\n    returns (uint256 remaining);\n\n}\n\n/**\n * @title Spork\n *\n * @notice A rogue upgrade token for The DAO. There is nothing safe about this\n *   contract or this life so strap in, bitches. You are responsible for you.\n *   A Spork is minted through burning DAO tokens. This is irreversible and for\n *   entertainment purposes. So why would you do this? Do it for love, do it\n *   for So Tokey Nada Mojito, do it for the lulz; just do it with conviction!\n *\n * usage\n *   1. Use The DAO to grant an allowance of DAO for the Spork contract.\n *      + `DAO.approve(spork_contract_address, amount_of_DAO_to_burn)`\n *      + Only grant the amount of DAO you are ready to destroy forever.\n *   2. Use the Spork mint function to ...\n *      1. Burn an amount of DAO up to the amount approved in the previous step.\n *      2. Mint an equivalent amount of Spork.\n *      3. Assign Spork tokens to the sender account.\n *   3. You now have Sporks. Dig in!\n */\ncontract Spork is TokenInterface {\n\n    // crash and burn\n    address constant TheDAO = 0xbb9bc244d798123fde783fcc1c72d3bb8c189413;\n\n    event Mint(\n        address indexed _sender,\n        uint256 indexed _amount,\n        string _lulz);\n\n    // vanity attributes\n    string public name = ""Spork"";\n    string public symbol = ""SPRK"";\n    string public version = ""Spork:0.1"";\n    uint8 public decimals = 0;\n\n    // @see {Spork.mint}\n    function () {\n        throw; // this is a coin, not a wallet.\n    }\n\n    /**\n     * @notice Burn DAO tokens in exchange for Spork tokens\n     * @param _amount Amount of DAO to burn and equivalent Spork to mint\n     * @param _lulz If you gotta go, go with a smile! ?\n     * @return Determine if request was successful\n     */\n    function mint(uint256 _amount, string _lulz)\n    returns (bool success) {\n        if (totalSupply + _amount <= totalSupply)\n            return false; // zero or rollover value\n\n        if (!TokenInterface(TheDAO).transferFrom(msg.sender, this, _amount))\n            return false; // unable to retrieve DAO tokens for sender\n\n        balances[msg.sender] += _amount;\n        totalSupply += _amount;\n\n        Mint(msg.sender, _amount, _lulz);\n        return true;\n    }\n\n    /**\n     * @notice Transfer Spork tokens from `msg.sender` to another account.\n     * @param _to Account receiving tokens\n     * @param _amount Amount of tokens to transfer\n     * @return Determine if request was successful\n     */\n    function transfer(address _to, uint256 _amount)\n    returns (bool success) {\n        if (balances[_to] + _amount <= balances[_to])\n            return false; // zero or rollover value\n\n        if (balances[msg.sender] < _amount)\n            return false; // party foul, sender does not have enough sporks\n\n        balances[msg.sender] -= _amount;\n        balances[_to] += _amount;\n\n        Transfer(msg.sender, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Transfer Spork tokens from one account to another\n     * @param _from Account holding tokens for which `msg.sender` is an approved\n     *              spender with an allowance of at least `_amount` tokens\n     * @param _to Account receiving tokens\n     * @param _amount Amount of tokens to transfer\n     * @return Determine if request was successful\n     */\n    function transferFrom(address _from, address _to, uint256 _amount)\n    returns (bool success) {\n        if (balances[_to] + _amount <= balances[_to])\n            return false; // zero or rollover value\n\n        if (allowed[_from][msg.sender] < _amount)\n            return false; // sender does not have enough allowance\n\n        if (balances[msg.sender] < _amount)\n            return false; // party foul, sender does not have enough sporks\n\n        balances[_to] += _amount;\n        balances[_from] -= _amount;\n        allowed[_from][msg.sender] -= _amount;\n\n        Transfer(_from, _to, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Determine the Spork token balance for an account\n     * @param _owner Account holding tokens\n     * @return Token balance\n     */\n    function balanceOf(address _owner)\n    constant\n    returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    /**\n     * @notice Approve an address to spend tokens on your behalf\n     * @param _spender Account to spend tokens on behalf of `msg.sender`\n     * @param _amount Maximum amount `_spender` can transfer from `msg.sender`\n     * @return Determine if request was successful\n     */\n    function approve(address _spender, uint256 _amount)\n    returns (bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    /**\n     * @notice Maximum amount a spender can withdraw from an account\n     * @param _owner The account holding tokens\n     * @param _spender The account spending tokens\n     * @return Remaining allowance `_spender` can withdraw from `_owner`\n     */\n    function allowance(address _owner, address _spender)\n    constant\n    returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n}",2,ユーモラスなコメントと独特なテーマが詩的要素を加えている。
1823550,0x587d6669a2743a1d6094f150006f56f85b5aade3,false,false,contract Vote {\n    address creator;\n\n    function Vote() {\n        creator = msg.sender;\n    }\n\n    function() {\n        if (msg.value > 0) {\n            tx.origin.send(msg.value);\n        }\n    }\n\n    function kill() {\n        if (msg.sender == creator) {\n            suicide(creator);\n        }\n    }\n},1,基本的な投票コントラクトで、特に芸術的な要素はありません。
1825466,0x1e5f704ed1d62b6b42fc841f0d7d4e340cbbaf7d,false,false,"contract DaoChallenge\n{\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	event notifySellToken(uint256 n, address buyer);\n	event notifyRefundToken(uint256 n, address tokenHolder);\n	event notifyTerminate(uint256 finalBalance);\n\n	/* This creates an array with all balances */\n  mapping (address => uint256) public tokenBalanceOf;\n\n	uint256 constant tokenPrice = 1000000000000000; // 1 finney\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address owner;\n\n	function DaoChallenge () {\n		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () {\n		address sender = msg.sender;\n		if(tokenBalanceOf[sender] != 0) {\n			throw;\n		}\n		tokenBalanceOf[sender] = msg.value / tokenPrice; // rounded down\n		notifySellToken(tokenBalanceOf[sender], sender);\n	}\n\n	function refund() noEther {\n		address sender = msg.sender;\n		uint256 tokenBalance = tokenBalanceOf[sender];\n		if (tokenBalance <= 0) { throw; }\n		tokenBalanceOf[sender] = 0;\n		sender.send(tokenBalance * tokenPrice);\n		notifyRefundToken(tokenBalance, sender);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyOwner {\n		notifyTerminate(this.balance);\n		suicide(owner);\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1828705,0x096133503887a77e524f2690ba6aae2fa66b032c,false,false,"contract MyEtherBank\n{\n    /* LICENSE :\n\n    MIT License\n\n    Copyright (c) 2016 Consent Development\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the ""Software""), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n\n    */\n	\n    // Author : Alex Darby \n    // Contact email : consentdev@gmail.com \n    // Version : 1.0 - initial release\n	// GitHub : https://github.com/ConsentDevelopment/EtherBank\n    //\n    // \n	// This smart contract is free to use but donations are always welcome :\n	//   Donate Ether - 0x65850dfd9c511a5da3132461d57817f56acc1906\n    //   Donate Bitcoin - 36XRasACPNEvd3YxbLoWWeUfSgCUyZ69z8\n\n    /* -------- State data -------- */\n\n    // Owner\n    address private _owner;\n    uint256 private _bankDonationsBalance = 0;\n    bool private _connectBankAccountToNewOwnerAddressEnabled = true;\n\n    // Bank accounts    \n    struct BankAccount\n    {\n        // Members placed in order for optimization, not readability\n        bool passwordSha3HashSet;\n        uint32 number; \n        uint32 passwordAttempts;\n        uint256 balance;\n        address owner;       \n        bytes32 passwordSha3Hash;   \n        mapping(bytes32 => bool) passwordSha3HashesUsed;\n    }   \n\n    struct BankAccountAddress\n    {\n        bool accountSet;\n        uint32 accountNumber; // accountNumber member is used to index the bank accounts array\n    }\n \n    uint32 private _totalBankAccounts = 0;\n    BankAccount[] private _bankAccountsArray; \n    mapping(address => BankAccountAddress) private _bankAccountAddresses;  \n\n\n    /* -------- Constructor -------- */\n\n    function MyEtherBank() public\n    {\n        // Set the contract owner\n        _owner = msg.sender; \n    }\n\n\n    /* -------- Events -------- */\n\n    // Donation\n    event event_donationMadeToBank_ThankYou(uint256 donationAmount);\n    event event_getBankDonationsBalance(uint256 donationBalance);\n    event event_bankDonationsWithdrawn(uint256 donationsAmount);\n\n    // General banking\n    event event_bankAccountOpened_Successful(address indexed bankAccountOwner, uint32 indexed bankAccountNumber, uint256 indexed depositAmount);\n    event event_getBankAccountNumber_Successful(uint32 indexed bankAccountNumber);\n    event event_getBankAccountBalance_Successful(uint32 indexed bankAccountNumber, uint256 indexed balance);\n    event event_depositMadeToBankAccount_Successful(uint32 indexed bankAccountNumber, uint256 indexed depositAmount); \n    event event_depositMadeToBankAccount_Failed(uint32 indexed bankAccountNumber, uint256 indexed depositAmount); \n    event event_depositMadeToBankAccountFromDifferentAddress_Successful(uint32 indexed bankAccountNumber, address indexed addressFrom, uint256 indexed depositAmount);\n    event event_depositMadeToBankAccountFromDifferentAddress_Failed(uint32 indexed bankAccountNumber, address indexed addressFrom, uint256 indexed depositAmount);\n    event event_withdrawalMadeFromBankAccount_Successful(uint32 indexed bankAccountNumber, uint256 indexed withdrawalAmount); \n    event event_withdrawalMadeFromBankAccount_Failed(uint32 indexed bankAccountNumber, uint256 indexed withdrawalAmount); \n    event event_transferMadeFromBankAccountToAddress_Successful(uint32 indexed bankAccountNumber, uint256 indexed transferalAmount, address indexed destinationAddress); \n    event event_transferMadeFromBankAccountToAddress_Failed(uint32 indexed bankAccountNumber, uint256 indexed transferalAmount, address indexed destinationAddress); \n\n    // Security\n    event event_securityConnectingABankAccountToANewOwnerAddressIsDisabled();\n    event event_securityHasPasswordSha3HashBeenAddedToBankAccount_Yes(uint32 indexed bankAccountNumber);\n    event event_securityHasPasswordSha3HashBeenAddedToBankAccount_No(uint32 indexed bankAccountNumber);\n	event event_securityPasswordSha3HashAddedToBankAccount_Successful(uint32 indexed bankAccountNumber);\n    event event_securityPasswordSha3HashAddedToBankAccount_Failed_PasswordHashPreviouslyUsed(uint32 indexed bankAccountNumber);\n    event event_securityBankAccountConnectedToNewAddressOwner_Successful(uint32 indexed bankAccountNumber, address indexed newAddressOwner);\n    event event_securityBankAccountConnectedToNewAddressOwner_Failed_PasswordHashHasNotBeenAddedToBankAccount(uint32 indexed bankAccountNumber);\n    event event_securityBankAccountConnectedToNewAddressOwner_Failed_SentPasswordDoesNotMatchAccountPasswordHash(uint32 indexed bankAccountNumber, uint32 indexed passwordAttempts);\n    event event_securityGetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress(uint32 indexed bankAccountNumber, uint32 indexed attempts);\n\n\n    /* -------- Modifiers -------- */\n\n    modifier modifier_isContractOwner()\n    { \n        // Contact owner?\n        if (msg.sender != _owner)\n        {\n            throw;       \n        }\n        _ \n    }\n\n    modifier modifier_doesSenderHaveABankAccount() \n    { \n        // Does this sender have a bank account?\n        if (_bankAccountAddresses[msg.sender].accountSet == false)\n        {\n            throw;\n        }\n        else\n        {\n            // Does the bank account owner address match the sender address?\n            uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;\n            if (msg.sender != _bankAccountsArray[accountNumber_].owner)\n            {\n                // Sender address previously had a bank account that was transfered to a new owner address\n                throw;        \n            }\n        }\n        _ \n    }\n\n    modifier modifier_wasValueSent()\n    { \n        // Value sent?\n        if (msg.value > 0)\n        {\n            // Prevent users from sending value accidentally\n            throw;        \n        }\n        _ \n    }\n\n\n    /* -------- Contract owner functions -------- */\n\n    function Donate() public\n    {\n        if (msg.value > 0)\n        {\n            _bankDonationsBalance += msg.value;\n            event_donationMadeToBank_ThankYou(msg.value);\n        }\n    }\n\n    function BankOwner_GetDonationsBalance() public      \n        modifier_isContractOwner()\n        modifier_wasValueSent()\n        returns (uint256)\n    {\n        event_getBankDonationsBalance(_bankDonationsBalance);\n  	    return _bankDonationsBalance;\n    }\n\n    function BankOwner_WithdrawDonations() public\n        modifier_isContractOwner()\n        modifier_wasValueSent()\n    { \n        if (_bankDonationsBalance > 0)\n        {\n            uint256 amount_ = _bankDonationsBalance;\n            _bankDonationsBalance = 0;\n\n            // Check if using send() is successful\n            if (msg.sender.send(amount_))\n            {\n                event_bankDonationsWithdrawn(amount_);\n            }\n            // Check if using call.value() is successful\n            else if (msg.sender.call.value(amount_)())\n            {  \n                event_bankDonationsWithdrawn(amount_);\n            }\n            else\n            {\n                // Set the previous balance\n                _bankDonationsBalance = amount_;\n            }\n        }\n    }\n\n    function BankOwner_EnableConnectBankAccountToNewOwnerAddress() public\n        modifier_isContractOwner()\n    { \n        if (_connectBankAccountToNewOwnerAddressEnabled == false)\n        {\n            _connectBankAccountToNewOwnerAddressEnabled = true;\n        }\n    }\n\n    function  BankOwner_DisableConnectBankAccountToNewOwnerAddress() public\n        modifier_isContractOwner()\n    { \n        if (_connectBankAccountToNewOwnerAddressEnabled)\n        {\n            _connectBankAccountToNewOwnerAddressEnabled = false;\n        }\n    }\n\n\n    /* -------- General bank account functions -------- */\n\n    // Open bank account\n    function OpenBankAccount() public\n        returns (uint32 newBankAccountNumber) \n    {\n        // Does this sender already have a bank account or a previously used address for a bank account?\n        if (_bankAccountAddresses[msg.sender].accountSet)\n        {\n            throw;\n        }\n\n        // Assign the new bank account number\n        newBankAccountNumber = _totalBankAccounts;\n\n        // Add new bank account to the array\n        _bankAccountsArray.push( \n            BankAccount(\n            {\n                passwordSha3HashSet: false,\n                passwordAttempts: 0,\n                number: newBankAccountNumber,\n                balance: 0,\n                owner: msg.sender,\n                passwordSha3Hash: ""0"",\n            }\n            ));\n\n        // Prevent people using ""password"" or ""Password"" sha3 hash for the Security_AddPasswordSha3HashToBankAccount() function\n        bytes32 passwordHash_ = sha3(""password"");\n        _bankAccountsArray[newBankAccountNumber].passwordSha3HashesUsed[passwordHash_] = true;\n        passwordHash_ = sha3(""Password"");\n        _bankAccountsArray[newBankAccountNumber].passwordSha3HashesUsed[passwordHash_] = true;\n\n        // Add the new account\n        _bankAccountAddresses[msg.sender].accountSet = true;\n        _bankAccountAddresses[msg.sender].accountNumber = newBankAccountNumber;\n\n        // Value sent?\n        if (msg.value > 0)\n        {         \n            _bankAccountsArray[newBankAccountNumber].balance += msg.value;\n        }\n\n        // Move to the next bank account\n        _totalBankAccounts++;\n\n        // Event\n        event_bankAccountOpened_Successful(msg.sender, newBankAccountNumber, msg.value);\n        return newBankAccountNumber;\n    }\n\n    // Get account number from a owner address\n    function GetBankAccountNumber() public      \n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (uint32)\n    {\n        event_getBankAccountNumber_Successful(_bankAccountAddresses[msg.sender].accountNumber);\n	    return _bankAccountAddresses[msg.sender].accountNumber;\n    }\n\n    function GetBankAccountBalance() public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (uint256)\n    {   \n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;\n        event_getBankAccountBalance_Successful(accountNumber_, _bankAccountsArray[accountNumber_].balance);\n        return _bankAccountsArray[accountNumber_].balance;\n    }\n\n\n    /* -------- Deposit functions -------- */\n\n    function DepositToBankAccount() public\n        modifier_doesSenderHaveABankAccount()\n        returns (bool)\n    {\n        // Value sent?\n        if (msg.value > 0)\n        {\n            uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n            // Check for overflow  \n            if ((_bankAccountsArray[accountNumber_].balance + msg.value) < _bankAccountsArray[accountNumber_].balance)\n            {\n                throw;\n            }\n\n            _bankAccountsArray[accountNumber_].balance += msg.value; \n            event_depositMadeToBankAccount_Successful(accountNumber_, msg.value);\n            return true;\n        }\n        else\n        {\n            event_depositMadeToBankAccount_Failed(accountNumber_, msg.value);\n            return false;\n        }\n    }\n\n    function DepositToBankAccountFromDifferentAddress(uint32 bankAccountNumber) public\n        returns (bool)\n    {\n        // Check if bank account number is valid\n        if (bankAccountNumber >= _totalBankAccounts)\n        {\n           event_depositMadeToBankAccountFromDifferentAddress_Failed(bankAccountNumber, msg.sender, msg.value);\n           return false;     \n        }    \n            \n        // Value sent?\n        if (msg.value > 0)\n        {   \n            // Check for overflow  \n            if ((_bankAccountsArray[bankAccountNumber].balance + msg.value) < _bankAccountsArray[bankAccountNumber].balance)\n            {\n                throw;\n            }\n\n            _bankAccountsArray[bankAccountNumber].balance += msg.value; \n            event_depositMadeToBankAccountFromDifferentAddress_Successful(bankAccountNumber, msg.sender, msg.value);\n            return true;\n        }\n        else\n        {\n            event_depositMadeToBankAccountFromDifferentAddress_Failed(bankAccountNumber, msg.sender, msg.value);\n            return false;\n        }\n    }\n    \n\n    /* -------- Withdrawal / transfer functions -------- */\n\n    function WithdrawAmountFromBankAccount(uint256 amount) public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        bool withdrawalSuccessful_ = false;\n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n        // Bank account has value that can be withdrawn?\n        if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)\n        {\n            // Reduce the account balance \n            _bankAccountsArray[accountNumber_].balance -= amount;\n\n            // Check if using send() is successful\n            if (msg.sender.send(amount))\n            {\n 	            withdrawalSuccessful_ = true;\n            }\n            // Check if using call.value() is successful\n            else if (msg.sender.call.value(amount)())\n            {  \n                withdrawalSuccessful_ = true;\n            }  \n            else\n            {\n                // Set the previous balance\n                _bankAccountsArray[accountNumber_].balance += amount;\n            }\n        }\n\n        if (withdrawalSuccessful_)\n        {\n            event_withdrawalMadeFromBankAccount_Successful(accountNumber_, amount); \n            return true;\n        }\n        else\n        {\n            event_withdrawalMadeFromBankAccount_Failed(accountNumber_, amount); \n            return false;\n        }\n    }\n\n    function WithdrawFullBalanceFromBankAccount() public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        bool withdrawalSuccessful_ = false;\n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n        uint256 fullBalance_ = 0;\n\n        // Bank account has value that can be withdrawn?\n        if (_bankAccountsArray[accountNumber_].balance > 0)\n        {\n            fullBalance_ = _bankAccountsArray[accountNumber_].balance;\n\n            // Reduce the account balance \n            _bankAccountsArray[accountNumber_].balance = 0;\n\n            // Check if using send() is successful\n            if (msg.sender.send(fullBalance_))\n            {\n 	            withdrawalSuccessful_ = true;\n            }\n            // Check if using call.value() is successful\n            else if (msg.sender.call.value(fullBalance_)())\n            {  \n                withdrawalSuccessful_ = true;\n            }  \n            else\n            {\n                // Set the previous balance\n                _bankAccountsArray[accountNumber_].balance = fullBalance_;\n            }\n        }  \n\n        if (withdrawalSuccessful_)\n        {\n            event_withdrawalMadeFromBankAccount_Successful(accountNumber_, fullBalance_); \n            return true;\n        }\n        else\n        {\n            event_withdrawalMadeFromBankAccount_Failed(accountNumber_, fullBalance_); \n            return false;\n        }\n    }\n\n    function TransferAmountFromBankAccountToAddress(uint256 amount, address destinationAddress) public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        bool transferSuccessful_ = false; \n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n        // Bank account has value that can be transfered?\n        if (amount > 0 && _bankAccountsArray[accountNumber_].balance >= amount)\n        {\n            // Reduce the account balance \n            _bankAccountsArray[accountNumber_].balance -= amount; \n\n            // Check if using send() is successful\n            if (destinationAddress.send(amount))\n            {\n 	            transferSuccessful_ = true;\n            }\n            // Check if using call.value() is successful\n            else if (destinationAddress.call.value(amount)())\n            {  \n                transferSuccessful_ = true;\n            }  \n            else\n            {\n                // Set the previous balance\n                _bankAccountsArray[accountNumber_].balance += amount;\n            }\n        }  \n\n        if (transferSuccessful_)\n        {\n            event_transferMadeFromBankAccountToAddress_Successful(accountNumber_, amount, destinationAddress); \n            return true;\n        }\n        else\n        {\n            event_transferMadeFromBankAccountToAddress_Failed(accountNumber_, amount, destinationAddress); \n            return false;\n        }\n    }\n\n\n    /* -------- Security functions -------- */\n\n    function Security_HasPasswordSha3HashBeenAddedToBankAccount() public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n        // Password sha3 hash added to the account?\n        if (_bankAccountsArray[accountNumber_].passwordSha3HashSet)\n        {\n            event_securityHasPasswordSha3HashBeenAddedToBankAccount_Yes(accountNumber_);\n            return true;\n        }\n        else\n        {\n            event_securityHasPasswordSha3HashBeenAddedToBankAccount_No(accountNumber_);\n            return false;\n        }\n    }\n\n    function Security_AddPasswordSha3HashToBankAccount(bytes32 sha3Hash) public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        // VERY IMPORTANT -\n        // \n        // Ethereum uses KECCAK-256. It should be noted that it does not follow the FIPS-202 based standard (a.k.a SHA-3), \n        // which was finalized in August 2015.\n        // \n        // Keccak-256 generator link (produces same output as solidity sha3()) - http://emn178.github.io/online-tools/keccak_256.html\n            \n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n\n        // Has this password hash been used before for this account?\n        if (_bankAccountsArray[accountNumber_].passwordSha3HashesUsed[sha3Hash] == true)\n        {\n            event_securityPasswordSha3HashAddedToBankAccount_Failed_PasswordHashPreviouslyUsed(accountNumber_);\n            return false;        \n        }\n\n        // Set the account password sha3 hash\n        _bankAccountsArray[accountNumber_].passwordSha3HashSet = true;\n        _bankAccountsArray[accountNumber_].passwordSha3Hash = sha3Hash;\n        _bankAccountsArray[accountNumber_].passwordSha3HashesUsed[sha3Hash] = true;\n\n        // Reset password attempts\n        _bankAccountsArray[accountNumber_].passwordAttempts = 0;\n\n        event_securityPasswordSha3HashAddedToBankAccount_Successful(accountNumber_);\n        return true;\n    }\n\n    function Security_ConnectBankAccountToNewOwnerAddress(uint32 bankAccountNumber, string password) public\n        modifier_wasValueSent()\n        returns (bool)\n    {\n        // VERY IMPORTANT -\n        // \n        // Ethereum uses KECCAK-256. It should be noted that it does not follow the FIPS-202 based standard (a.k.a SHA-3), \n        // which was finalized in August 2015.\n        // \n        // Keccak-256 generator link (produces same output as solidity sha3()) - http://emn178.github.io/online-tools/keccak_256.html\n\n        // Can bank accounts be connected to a new owner address?\n        if (_connectBankAccountToNewOwnerAddressEnabled == false)\n        {\n            event_securityConnectingABankAccountToANewOwnerAddressIsDisabled();\n            return false;        \n        }\n\n        // Check if bank account number is valid\n        if (bankAccountNumber >= _totalBankAccounts)\n        {\n            return false;     \n        }    \n\n        // Does the sender already have a bank account?\n        if (_bankAccountAddresses[msg.sender].accountSet)\n        {\n            // A owner address can only have one bank account\n            return false;\n        }\n\n        // Has password sha3 hash been set?\n        if (_bankAccountsArray[bankAccountNumber].passwordSha3HashSet == false)\n        {\n            event_securityBankAccountConnectedToNewAddressOwner_Failed_PasswordHashHasNotBeenAddedToBankAccount(bankAccountNumber);\n            return false;           \n        }\n\n        // Check if the password sha3 hash matches.\n        bytes memory passwordString = bytes(password);\n        if (sha3(passwordString) != _bankAccountsArray[bankAccountNumber].passwordSha3Hash)\n        {\n            // Keep track of the number of attempts to connect a bank account to a new owner address\n            _bankAccountsArray[bankAccountNumber].passwordAttempts++;  \n            event_securityBankAccountConnectedToNewAddressOwner_Failed_SentPasswordDoesNotMatchAccountPasswordHash(bankAccountNumber, _bankAccountsArray[bankAccountNumber].passwordAttempts); \n            return false;        \n        }\n\n        // Set new bank account address owner and the update the owner address details \n        _bankAccountsArray[bankAccountNumber].owner = msg.sender;\n        _bankAccountAddresses[msg.sender].accountSet = true;\n        _bankAccountAddresses[msg.sender].accountNumber = bankAccountNumber;\n\n        // Reset password sha3 hash\n        _bankAccountsArray[bankAccountNumber].passwordSha3HashSet = false;\n        _bankAccountsArray[bankAccountNumber].passwordSha3Hash = ""0"";\n       \n        // Reset password attempts\n        _bankAccountsArray[bankAccountNumber].passwordAttempts = 0;\n\n        event_securityBankAccountConnectedToNewAddressOwner_Successful(bankAccountNumber, msg.sender);\n        return true;\n    }\n\n    function Security_GetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress() public\n        modifier_doesSenderHaveABankAccount()\n        modifier_wasValueSent()\n        returns (uint64)\n    {\n        uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber; \n        event_securityGetNumberOfAttemptsToConnectBankAccountToANewOwnerAddress(accountNumber_, _bankAccountsArray[accountNumber_].passwordAttempts);\n        return _bankAccountsArray[accountNumber_].passwordAttempts;\n    }\n\n\n    /* -------- Default function -------- */\n\n    function() \n    {    \n        // Does this sender have a bank account?\n        if (_bankAccountAddresses[msg.sender].accountSet)\n        {\n            // Does the bank account owner address match the sender address?\n            uint32 accountNumber_ = _bankAccountAddresses[msg.sender].accountNumber;\n            address accountOwner_ = _bankAccountsArray[accountNumber_].owner;\n            if (msg.sender == accountOwner_) \n            {\n                // Value sent?\n                if (msg.value > 0)\n                {                \n                    // Check for overflow\n                    if ((_bankAccountsArray[accountNumber_].balance + msg.value) < _bankAccountsArray[accountNumber_].balance)\n                    {\n                        throw;\n                    }\n \n                    // Update the bank account balance\n                    _bankAccountsArray[accountNumber_].balance += msg.value;\n                    event_depositMadeToBankAccount_Successful(accountNumber_, msg.value);\n                }\n                else\n                {\n                    throw;\n                }\n            }\n            else\n            {\n                // Sender address previously had a bank account that was transfered to a new owner address\n                throw;\n            }\n        }\n        else\n        {\n            // Open a new bank account for the sender address - this function will also add any value sent to the bank account balance\n            OpenBankAccount();\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。銀行機能を実装しており、芸術的要素は少ない。
1830408,0xb19ff6657a80a68c94ca3fe6aac3b6cfd16bdcd4,false,false,"/*\nthis smartcontract used to store documents text on the Ethereum blockchain\n*/\n\ncontract ProofOfExistence{\n\n    /* ---- Public variables: */\n    string public created;\n    address public manager; // account that adds info to this smartcontract\n    uint256 public index;   // record's numbers and number of records\n    mapping (uint256 => Doc) public docs; // index => Doc\n    // to get Doc obj call ProofOfExistence.docs(index);\n\n    /* ---- Stored document structure: */\n\n    struct Doc {\n        string publisher; // publisher's email\n        uint256 publishedOnUnixTime; // block timestamp (block.timestamp)\n        uint256 publishedInBlockNumber; // block.number\n        string text; // text of the document\n    }\n\n    /* ---- Constructor: */\n\n    function ProofOfExistence(){\n        manager = msg.sender;\n        created = ""cryptonomica.net"";\n        index = 0; //\n    }\n\n    /* ---- Event:  */\n    // This generates a public event on the blockchain that will notify clients. In 'Mist' SmartContract page enable 'Watch contract events'\n    event DocumentAdded(uint256 indexed index,\n                        string indexed publisher,\n                        uint256 publishedOnUnixTime,\n                        string indexed text);\n\n    /* ----- Main method: */\n\n    function addDoc(string _publisher, string _text) returns (uint256) {\n        // authorization\n        if (msg.sender != manager) throw;\n        // document number\n        index += 1;\n        // add document data:\n        docs[index] = Doc(_publisher, now, block.number, _text);\n        // add event\n        DocumentAdded(index,\n                      docs[index].publisher,\n                      docs[index].publishedOnUnixTime,\n                      docs[index].text);\n        // return number of the stored document\n        return index;\n    }\n\n    /* ---- Utilities: */\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1833984,0xbf7316fab5c8cfbda5e763a5a1f94c4e0ce7ec37,false,false,"// A name registry in Ethereum\n\n// ""Real"" attempts to a name registry with Ethereum:\n// <http://etherid.org/> <https://github.com/sinking-point/dns2/>\n\n// TODO: use the registry interface described in\n// <https://github.com/ethereum/wiki/wiki/Standardized_Contract_APIs>?\n\n// Standard strings are poor, we need an extension library,\n// github.com/Arachnid/solidity-stringutils/strings.sol TODO: use it as soon as https://github.com/Arachnid/solidity-stringutils/issues/1 is solved.\n// import ""strings.sol"";\n\ncontract Registry {\n\n  // using strings for *; // TODO see above\n\n  address public nic; // The Network Information Center\n  \n  struct Record {\n    string value; // IP addresses, emails, etc TODO accept an array\n		     // as soon as we have a strings library to\n		     // serialize/deserialize. TODO type the values with an Enum\n    address holder;\n    bool exists; // Or a more detailed state, with an enum?\n    uint idx;\n  }\n  mapping (string => Record) records;\n  mapping (uint => string) index;\n  \n  // TODO define accessors instead\n  uint public maxRecords;\n  uint public currentRecords;\n\n  event debug(string indexed label, string msg);\n  event created(string indexed label, string indexed name, address holder, uint block);\n  event deleted(string indexed label, string indexed name, address holder, uint block);\n  \n  // ""value"" should be a comma-separated list of values. Solidity\n  // public functions cannot use arrays of strings :-( TODO: solve it\n  // when we'll have strings.\n  function register(string name, string value) {\n    /* TODO: pay the price */\n    uint i;\n    if (records[name].exists) {\n      if (msg.sender != records[name].holder) { // TODO: use modifiers instead\n	throw;\n      }\n      else {\n	i = records[name].idx;\n      }\n    }\n    else {\n      records[name].idx = maxRecords;\n      i = maxRecords;\n      maxRecords++;\n    }\n    records[name].value = value;\n    records[name].holder = msg.sender;\n    records[name].exists = true;\n    currentRecords++;\n    index[i] = name;\n    created(""CREATION"", name, msg.sender, block.number);	  \n  }\n\n  function transfer(string name, address to) {\n    if (records[name].exists) {\n      if (msg.sender != records[name].holder) {\n	throw;\n      }\n      records[name].holder = to;\n    }\n    else {\n      throw;\n    }\n  }\n  \n  function get(string name) constant returns(bool exists, string value) {\n    if (records[name].exists) {\n      exists = true;\n      value = records[name].value;\n    } else {\n      exists = false;\n    }\n  }\n\n  // Constructor\n  function Registry() {\n    nic = msg.sender;\n    currentRecords = 0;\n    maxRecords = 0;\n    register(""NIC"", ""Automatically created by for the registry""); // TODO may fail if not\n    // enough gas in the creating transaction?\n  }\n  \n\n  function whois(string name) constant returns(bool exists, string value, address holder) {\n    if (records[name].exists) {\n      exists = true;\n      value = records[name].value;\n      holder = records[name].holder;\n    } else {\n      exists = false;\n    }\n  }\n\n  function remove(string name) {\n    uint i;\n    if (records[name].exists) {\n      if (msg.sender != records[name].holder) {\n	throw;\n      }\n      else {\n	i = records[name].idx;\n      }\n    }\n    else {\n      throw; // 404. Too bad we cannot add content to throw.\n    }\n    records[name].exists = false;\n    currentRecords--;\n    deleted(""DELETION"", name, msg.sender, block.number);	  \n  }\n\n  function download() returns(string all) {\n    if (msg.sender != nic) {\n	throw;\n      }\n    all = ""NOT YET IMPLEMENTED"";\n    // Looping over all the records is easy:\n    //for uint (i = 0; i < maxRecords; i++) {\n    //	if (records[index[i]].exists) {\n    \n    // Or we could use an iterable mapping may\n    // be this library\n    // <https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol>\n\n    // The difficult part is to construct an answer, since Solidity\n    // does not provide string concatenation, or the ability to return\n    // arrays.\n\n	// TODO: provide a function to access one item, using its index,\n	// and to let the caller loops from 0 to maxRecords\n	// http://stackoverflow.com/questions/37606839/how-to-return-mapping-list-in-solidity-ethereum-contract/37643972#37643972\n  }\n  \n}",1,実用的なコードで、標準的な名前レジストリの実装を目指している。芸術的要素は少ない。
1836214,0x3039d0a94d51c67a4f35e742b571874e53467804,false,false,contract Vote {\n    event LogVote(address indexed addr);\n\n    function() {\n        LogVote(msg.sender);\n\n        if (msg.value > 0) {\n            msg.sender.send(msg.value);\n        }\n    }\n},1,基本的な投票機能を持つが、特に芸術的な要素はない。
1837364,0xbe7193779e3239781e49faafbdd0a9efa938f389,false,false,"contract EscrowContract {\n\n    // TYPES\n    enum state {Funding, Paid, Accepted, Dispute, Closed}\n    \n    // PRIVATE VARIABLES\n    address private developer;\n    bool private mutex;\n    uint256 private dispute_limit;\n    \n    // PUBLIC VARIABLES\n    address public buyer;\n    address public seller;\n    address public escrow;\n    uint256 public amount;\n    uint256 public fee;\n    uint256 public tip;\n    uint256 public dispute_end;\n    state public status;\n    \n    // EVENTS\n    event CurrentStatus(uint8 s);\n    \n    // CONSTRUCTOR\n    function EscrowContract(address _developer, address _buyer, address _seller, address _escrow, uint256 _amount, uint256 _fee, uint256 _tip ,uint256 _dispute_limit)\n        private\n    {\n        developer = _developer;\n        mutex = false;\n        dispute_limit = _dispute_limit;     \n        buyer = _buyer;\n        seller = _seller;\n        escrow = _escrow;\n        amount = _amount;\n        fee = _fee;\n        tip = _tip;\n        dispute_end = 0;\n        status = state.Funding;\n        CurrentStatus(uint8(status));\n    }\n\n    // MODIFIERS\n    modifier only_when(state s) {\n        if (status != s)  throw;\n        _\n    }\n    modifier only_before(state s) {\n        if (status >= s)  throw;\n        _\n    }\n    modifier only_buyer() {\n        if (msg.sender != buyer) throw;\n        _\n    }\n    modifier only_seller() {\n        if (msg.sender != seller) throw;\n        _\n    }\n    modifier only_buyer_seller() {\n        if (msg.sender != buyer && msg.sender != seller) throw;\n        _\n    }\n    modifier only_escrow() {\n        if (msg.sender != escrow) throw;\n        _\n    }\n    modifier only_no_value() {\n        if (msg.value != 0)  throw;\n        _\n    }\n    modifier check_mutex() {\n        if (mutex) throw;\n        mutex = true;\n        _\n        mutex = false;\n    }\n    \n    // VALIDATE PERCENT\n    function validate_percent(uint8 val)\n        private\n        constant\n    {\n        if (val > 100) throw;\n    }   \n\n    // BUYER CANCEL\n    function buyer_cancel()\n        public\n        only_before(state.Accepted)\n        only_buyer()\n        only_no_value()\n        check_mutex()\n    {\n        if (this.balance > 0)\n            if (!buyer.send(this.balance)) throw;\n        status = state.Closed;\n        CurrentStatus(uint8(status));\n    }\n    \n    // SELLER ACCEPT\n    function seller_accept()\n        public\n        only_when(state.Paid)\n        only_seller()\n        only_no_value()\n        check_mutex()\n    {\n        status = state.Accepted;\n        CurrentStatus(uint8(status));\n    }\n\n    // BUYER PAY\n    function buyer_pay()\n        public\n        only_when(state.Accepted)\n        only_buyer()\n        only_no_value()\n        check_mutex()\n    {\n        if (amount > 0)\n            if (!seller.send(amount)) throw;\n        if (fee > 0)\n            if (!buyer.send(fee)) throw;\n        if (tip > 0)\n            if (!developer.send(tip)) throw;\n        status = state.Closed;\n        CurrentStatus(uint8(status));\n    }\n\n    // DISPUTE\n    function dispute()\n        public\n        only_when(state.Accepted)\n        only_buyer_seller()\n        only_no_value()\n        check_mutex()\n    {\n        status = state.Dispute;\n        dispute_end = block.timestamp + dispute_limit;\n        CurrentStatus(uint8(status));\n    }\n\n    // RESOLVE\n    function resolve(uint8 percent_buyer, uint8 percent_tip)\n        public\n        only_when(state.Dispute)\n        only_escrow()\n        only_no_value()\n        check_mutex()\n    {\n        validate_percent(percent_buyer);\n        validate_percent(percent_tip);\n        uint256 buyer_amount = uint256(amount * percent_buyer)/100;\n        uint256 seller_amount = amount - buyer_amount;\n        uint256 tip_amount = uint256(fee * percent_tip)/100;\n        uint256 escrow_amount = fee - tip_amount;\n        tip_amount = tip_amount + tip;\n        if (buyer_amount > 0)\n            if (!buyer.send(buyer_amount)) throw;\n        if (seller_amount > 0)\n            if (!seller.send(seller_amount)) throw;\n        if (escrow_amount > 0)\n            if (!escrow.send(escrow_amount)) throw;\n        if (tip_amount > 0)\n            if (!developer.send(tip_amount)) throw;\n        status = state.Closed;\n        CurrentStatus(uint8(status));\n    }\n\n    // FIFTY FIFTY\n    function fifty_fifty()\n        public\n        only_when(state.Dispute)\n        only_buyer_seller()\n        only_no_value()\n        check_mutex()\n    {\n        if (block.timestamp < dispute_end) throw;\n        uint256 buyer_amount = uint256(amount * 50)/100;\n        uint256 seller_amount = amount - buyer_amount;\n        buyer_amount = buyer_amount + fee;\n        if (buyer_amount > 0)\n            if (!buyer.send(buyer_amount)) throw;\n        if (seller_amount > 0)\n            if (!seller.send(seller_amount)) throw;\n        if (tip > 0)\n            if (!developer.send(tip)) throw;\n        status = state.Closed;\n        CurrentStatus(uint8(status));\n    }\n    \n    // DEFAULT FUNCTION\n    function()\n        public\n        only_before(state.Closed)\n        check_mutex()\n    {\n        if (status == state.Funding) {\n            if (this.balance >= (amount + fee + tip)) {\n                status = state.Paid;\n                CurrentStatus(uint8(status));\n            }\n        }\n        if (status >= state.Paid) tip = this.balance - (amount + fee);\n    }\n    \n}\n\n\ncontract EscrowFoundry {\n    \n    // PRIVATE VARIABLES\n    address private developer;\n    \n    // EVENTS\n    event NewContract(address a);\n    \n    // CONSTRUCTOR\n    function EscrowFoundry() \n        private\n    {\n        developer = msg.sender;\n    }\n    \n    // MODIFIERS\n    modifier only_no_value() {\n        if (msg.value != 0)  throw;\n        _\n    }\n\n    // VALIDATE PERCENT\n    function validate_percent(uint8 val)\n        private\n        constant\n    {\n        if (val > 100) throw;\n    }\n    \n    // CREATE\n    function create(address _buyer, address _seller, address _escrow, uint256 _amount, uint8 _percent_fee, uint8 _percent_tip, uint256 _dispute_limit)\n        public\n        constant\n        only_no_value()\n        returns (address)\n    {\n        validate_percent(_percent_fee);\n        validate_percent(_percent_tip);\n        uint256 fee = uint256(_amount * _percent_fee)/100;\n        uint256 tip = uint256(_amount * _percent_tip)/100;\n        EscrowContract c = new EscrowContract(developer, _buyer, _seller, _escrow, _amount, fee, tip, _dispute_limit);\n        NewContract(c);\n        return c;\n    }\n    \n    // DEFAULT FUNCTION\n    function()\n        public\n    {\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1838061,0xe9da10f1aba727bfb3641846ed4d5bbf2add39c4,false,false,"/* \nBased on a contract built by Vlad and Vitalik for Ether signal\nIf you need a license, refer to WTFPL.\n*/\n\ncontract EtherVote {\n    event LogVote(bytes32 indexed proposalHash, bool pro, address addr);\n    function vote(bytes32 proposalHash, bool pro) {\n        // don't accept ether\n        if (msg.value > 0) throw;\n        // Log the vote\n        LogVote(proposalHash, pro, msg.sender);\n    }\n}",1,標準的な投票機能を持つ実用的なスマートコントラクトです。
1838115,0xde5ebd0b8879b0a42b23b37e4d76a5e21a0bef4b,false,false,"/* This contract is the API for blockchain2email.com, \n   which allows you to send emails from your smart contract.\n   Check out http://blockchain2email.com/ fpr info on how to\n   include API reference into your contract.\n   \n   Version 1.1      */\n   \n\ncontract depletable {\n    address owner;\n    function depletable() { \n        owner = msg.sender;\n    }\n    function withdraw() { \n        if (msg.sender == owner) {\n            while(!owner.send(this.balance)){}\n        }\n    }\n}\n\ncontract blockchain2email is depletable {\n	event EmailSent(address Sender, string EmailAddress, string Message);\n	\n	function SendEmail(string EmailAddress, string Message) returns (bool) { \n		if(msg.value>999999999999999){\n			EmailSent(msg.sender, EmailAddress, Message);\n			return (true);\n		}else{\n		    while(!msg.sender.send(msg.value)){}\n		    return (false);\n		}\n    } \n}",1,実用的な機能を持つが、特に芸術的な要素はない標準的なスマートコントラクト。
1843656,0x1e9d5e4ed8ef31cfece10b4c92c9057f991f36bc,false,false,"/* \nBased on a contract built by Vlad and Vitalik for Ether signal\nIf you need a license, refer to WTFPL.\n*/\n\ncontract EtherVote {\n    event LogVote(bytes32 indexed proposalHash, bool pro, address addr);\n    function vote(bytes32 proposalHash, bool pro) {\n        // don't accept ether\n        if (msg.value > 0) throw;\n        // Log the vote\n        LogVote(proposalHash, pro, msg.sender);\n    }\n\n    // again, no ether\n    function () { throw; }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1844195,0x5aeb532bee61decd393d60b615cf1c101ed5ea0a,false,false,"contract Token {\n\n    /// @return total amount of tokens\n    function totalSupply() constant returns (uint256 supply) {}\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        if (balancesVersions[version].balances[msg.sender] >= _value && balancesVersions[version].balances[_to] + _value > balancesVersions[version].balances[_to]) {\n        //if (balancesVersions[version].balances[msg.sender] >= _value && _value > 0) {\n            balancesVersions[version].balances[msg.sender] -= _value;\n            balancesVersions[version].balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        if (balancesVersions[version].balances[_from] >= _value && allowedVersions[version].allowed[_from][msg.sender] >= _value && balancesVersions[version].balances[_to] + _value > balancesVersions[version].balances[_to]) {\n        //if (balancesVersions[version].balances[_from] >= _value && allowedVersions[version].allowed[_from][msg.sender] >= _value && _value > 0) {\n            balancesVersions[version].balances[_to] += _value;\n            balancesVersions[version].balances[_from] -= _value;\n            allowedVersions[version].allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balancesVersions[version].balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowedVersions[version].allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowedVersions[version].allowed[_owner][_spender];\n    }\n\n    //this is so we can reset the balances while keeping track of old versions\n    uint public version = 0;\n\n    struct BalanceStruct {\n      mapping(address => uint256) balances;\n    }\n    mapping(uint => BalanceStruct) balancesVersions;\n\n    struct AllowedStruct {\n      mapping (address => mapping (address => uint256)) allowed;\n    }\n    mapping(uint => AllowedStruct) allowedVersions;\n\n    uint256 public totalSupply;\n\n}\n\ncontract ReserveToken is StandardToken {\n    address public minter;\n    function setMinter() {\n        if (minter==0x0000000000000000000000000000000000000000) {\n            minter = msg.sender;\n        }\n    }\n    modifier onlyMinter { if (msg.sender == minter) _ }\n    function create(address account, uint amount) onlyMinter {\n        balancesVersions[version].balances[account] += amount;\n        totalSupply += amount;\n    }\n    function destroy(address account, uint amount) onlyMinter {\n        if (balancesVersions[version].balances[account] < amount) throw;\n        balancesVersions[version].balances[account] -= amount;\n        totalSupply -= amount;\n    }\n    function reset() onlyMinter {\n        version++;\n        totalSupply = 0;\n    }\n}\n\ncontract EtherDelta {\n\n  mapping (address => mapping (address => uint)) tokens; //mapping of token addresses to mapping of account balances\n  //ether balances are held in the token=0 account\n  mapping (bytes32 => uint) orderFills;\n  address public feeAccount;\n  uint public feeMake; //percentage times (1 ether)\n  uint public feeTake; //percentage times (1 ether)\n\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n  event Deposit(address token, address user, uint amount, uint balance);\n  event Withdraw(address token, address user, uint amount, uint balance);\n\n  function EtherDelta(address feeAccount_, uint feeMake_, uint feeTake_) {\n    feeAccount = feeAccount_;\n    feeMake = feeMake_;\n    feeTake = feeTake_;\n  }\n\n  function() {\n    throw;\n  }\n\n  function deposit() {\n    tokens[0][msg.sender] += msg.value;\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n  }\n\n  function withdraw(uint amount) {\n    if (msg.value>0) throw;\n    if (tokens[0][msg.sender] < amount) throw;\n    tokens[0][msg.sender] -= amount;\n    if (!msg.sender.call.value(amount)()) throw;\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n  }\n\n  function depositToken(address token, uint amount) {\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n    if (msg.value>0 || token==0) throw;\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n    tokens[token][msg.sender] += amount;\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  function withdrawToken(address token, uint amount) {\n    if (msg.value>0 || token==0) throw;\n    if (tokens[token][msg.sender] < amount) throw;\n    tokens[token][msg.sender] -= amount;\n    if (!Token(token).transfer(msg.sender, amount)) throw;\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  function balanceOf(address token, address user) constant returns (uint) {\n    return tokens[token][user];\n  }\n\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n    if (msg.value>0) throw;\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n  }\n\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n    //amount is in amountGet terms\n    if (msg.value>0) throw;\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      ecrecover(hash,v,r,s) == user &&\n      block.number <= expires &&\n      orderFills[hash] + amount <= amountGet &&\n      tokens[tokenGet][msg.sender] >= amount &&\n      tokens[tokenGive][user] >= amountGive * amount / amountGet\n    )) throw;\n    tokens[tokenGet][msg.sender] -= amount;\n    tokens[tokenGet][user] += amount * ((1 ether) - feeMake) / (1 ether);\n    tokens[tokenGet][feeAccount] += amount * feeMake / (1 ether);\n    tokens[tokenGive][user] -= amountGive * amount / amountGet;\n    tokens[tokenGive][msg.sender] += ((1 ether) - feeTake) * amountGive * amount / amountGet / (1 ether);\n    tokens[tokenGive][feeAccount] += feeTake * amountGive * amount / amountGet / (1 ether);\n    orderFills[hash] += amount;\n    Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n  }\n\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n    if (!(\n      tokens[tokenGet][sender] >= amount &&\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n    )) return false;\n    return true;\n  }\n\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      ecrecover(hash,v,r,s) == user &&\n      block.number <= expires\n    )) return 0;\n    uint available1 = amountGet - orderFills[hash];\n    uint available2 = tokens[tokenGive][user] * amountGet / amountGive;\n    if (available1<available2) return available1;\n    return available2;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1847471,0x6e7f987907320630b7880eecc26b17c0d9afa7b4,false,false,"contract ValidetherOracle {\n\n  //  Name of the institution to Ethereum address of the institution\n  mapping (string => address) nameToAddress;\n    //  Ethereum address of the institution to Name of the institution\n  mapping (address => string) addressToName;\n\n  address admin;\n\n  modifier onlyAdmin {\n     if (msg.sender != admin) throw;\n     _\n  }\n\n  /*\n    Constructor Function\n  */\n  function ValidetherOracle() {\n    admin = msg.sender;\n  }\n\n  /*\n    Function which adds an institution\n    */\n  function addInstitution(address institutionAddress, string institutionName) onlyAdmin {\n    nameToAddress[institutionName] = institutionAddress;\n    addressToName[institutionAddress] = institutionName;\n  }\n\n  /*\n    Function which validates an institution address and returns its name\n    @param institutionAddress Ethereum Address of the institution\n    @return """" if the address is not valid and the institution name if the address is valid.\n    */\n  function getInstitutionByAddress(address institutionAddress) constant returns(string) {\n    return addressToName[institutionAddress];\n  }\n\n  /*\n    Function which validates an institution name and returns its address\n    @param institutionName Name of the institution\n    @return 0x0000000000000000000000000000000000000000 if the name is not valid and the institution Ethereum Address if the name is valid.\n  */\n  function getInstitutionByName(string institutionName) constant returns(address) {\n    return nameToAddress[institutionName];\n  }\n\n  /*\n    Function which changes the admin address of the contract\n    @param newAdmin Ethereum address of the new admin\n  */\n  function setNewAdmin(address newAdmin) onlyAdmin {\n    admin = newAdmin;\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1849608,0x08d698358b31ca6926e329879db9525504802abf,false,false,"contract DaoChallenge\n{\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	event notifySellToken(uint256 n, address buyer);\n	event notifyRefundToken(uint256 n, address tokenHolder);\n	event notifyTranferToken(uint256 n, address sender, address recipient);\n	event notifyTerminate(uint256 finalBalance);\n\n	/* This creates an array with all balances */\n  mapping (address => uint256) public tokenBalanceOf;\n\n	uint256 constant tokenPrice = 1000000000000000; // 1 finney\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address owner;\n\n	function DaoChallenge () {\n		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () {\n		address sender = msg.sender;\n		uint256 amount = msg.value;\n\n		// No fractional tokens:\n		if (amount % tokenPrice != 0) {\n			throw;\n		}\n		tokenBalanceOf[sender] += amount / tokenPrice;\n		notifySellToken(amount, sender);\n	}\n\n	// This uses call.value()() rather than send(), but only sends to msg.sender\n	function withdrawEtherOrThrow(uint256 amount) {\n		bool result = msg.sender.call.value(amount)();\n		if (!result) {\n			throw;\n		}\n	}\n\n	function refund() noEther {\n		address sender = msg.sender;\n		uint256 tokenBalance = tokenBalanceOf[sender];\n		if (tokenBalance == 0) { throw; }\n		tokenBalanceOf[sender] = 0;\n		withdrawEtherOrThrow(tokenBalance * tokenPrice);\n		notifyRefundToken(tokenBalance, sender);\n	}\n\n	function transfer(address recipient, uint256 tokens) noEther {\n		address sender = msg.sender;\n\n		if (tokenBalanceOf[sender] < tokens) throw;\n		if (tokenBalanceOf[recipient] + tokens < tokenBalanceOf[recipient]) throw; // Check for overflows\n		tokenBalanceOf[sender] -= tokens;\n		tokenBalanceOf[recipient] += tokens;\n		notifyTranferToken(tokens, sender, recipient);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyOwner {\n		notifyTerminate(this.balance);\n		suicide(owner);\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1853229,0x80f84866d4872f1ea412ddf10e2ed7af0b8ca8fb,false,false,"/*\nThis smartcontract used to store documents text on the Ethereum blockchain\nand to get the document by document's hash (sha256).\n\n*/\n\ncontract ProofOfExistence{\n\n    /* ---- Public variables: */\n    string public created;\n    address public manager; // account that adds info to this smartcontract\n    uint256 public docIndex;   // record's numbers and number of records\n\n    mapping (uint256 => Doc) public indexedDocs; // docIndex => Doc\n    // to get Doc obj call ProofOfExistence.indexedDocs(docIndex);\n\n    mapping (bytes32 => Doc) public sha256Docs; // docHash => Doc\n    // to get Doc obj call ProofOfExistence.docs(docHash);\n    mapping (bytes32 => Doc) public sha3Docs; // docHash => Doc\n    // to get Doc obj call ProofOfExistence.docs(docHash);\n\n\n    /* ---- Stored document structure: */\n\n    struct Doc {\n        uint256 docIndex; // .............................................1\n        string publisher; // publisher's email............................2\n        uint256 publishedOnUnixTime; // block timestamp (block.timestamp).3\n        uint256 publishedInBlockNumber; // block.number...................4\n        string docText; // text of the document...........................5\n        bytes32 sha256Hash; // ...........................................6\n        bytes32 sha3Hash; // .............................................7\n    }\n\n    /* ---- Constructor: */\n\n    function ProofOfExistence(){\n        manager = msg.sender;\n        created = ""cryptonomica.net"";\n    }\n\n    /* ---- Event:  */\n    // This generates a public event on the blockchain that will notify clients.\n    // In 'Mist' SmartContract page enable 'Watch contract events'\n    event DocumentAdded(uint256 docIndex,\n                        string publisher,\n                        uint256 publishedOnUnixTime);\n\n\n    /* ----- Main method: */\n\n    function addDoc(\n                    string _publisher,\n                    string _docText) returns (bytes32) {\n        // authorization\n        if (msg.sender != manager){\n            // throw;\n            return sha3(""not authorized""); //\n            // <- is 'bytes32' too:\n            // ""0x8aed0440c9cacb4460ecdd12f6aff03c27cace39666d71f0946a6f3e9022a4a1""\n        }\n\n        // chech if exists\n        if (sha256Docs[sha256(_docText)].docIndex > 0){\n            // throw;\n            return sha3(""text already exists""); //\n            // <- is 'bytes32' too:\n            // ""0xd42b321cfeadc9593d0a28c4d013aaad8e8c68fc8e0450aa419a130a53175137""\n        }\n        // document number\n        docIndex = docIndex + 1;\n        // add document data:\n        indexedDocs[docIndex] = Doc(docIndex,\n                                    _publisher,\n                                    now,\n                                    block.number,\n                                    _docText,\n                                    sha256(_docText),\n                                    sha3(_docText)\n                                    );\n        sha256Docs[sha256(_docText)] = indexedDocs[docIndex];\n        sha3Docs[sha3(_docText)]   = indexedDocs[docIndex];\n        // add event\n        DocumentAdded(indexedDocs[docIndex].docIndex,\n                      indexedDocs[docIndex].publisher,\n                      indexedDocs[docIndex].publishedOnUnixTime\n                      );\n        // return sha3 of the stored document\n        // (sha3 is better for in web3.js)\n        return indexedDocs[docIndex].sha3Hash;\n    }\n\n    /* ---- Utilities: */\n\n    function () {\n        // This function gets executed if a\n        // transaction with invalid data is sent to\n        // the contract or just ether without data.\n        // We revert the send so that no-one\n        // accidentally loses money when using the\n        // contract.\n        throw;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ドキュメント管理に特化している。
1854856,0x15e745a2e3b677ec6421291b212d3917b3738dee,false,false,"contract Multisend {\n    mapping(address => uint) public balances;\n    mapping(address => uint) public nonces;\n\n    \n    function send(address[] addrs, uint[] amounts, uint nonce) {\n        if(addrs.length != amounts.length || nonce != nonces[msg.sender]) throw;\n        uint val = msg.value;\n        \n        for(uint i = 0; i<addrs.length; i++){\n            if(val < amounts[i]) throw;\n            \n            if(!addrs[i].send(amounts[i])){\n                balances[addrs[i]] += amounts[i];\n            }\n            val -= amounts[i];\n        }\n        \n        if(!msg.sender.send(val)){\n            balances[msg.sender] += val;\n        }\n        nonces[msg.sender]++;\n    }\n    \n    function withdraw(){\n        uint balance = balances[msg.sender];\n        balances[msg.sender] = 0;\n        if(!msg.sender.send(balance)) throw;\n    }\n    \n    function(){\n        withdraw();\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1865709,0x872b91913dc7279702b7591c970b02519c4615cf,false,false,"contract mortal {\n    /* Define variable owner of the type address*/\n    address owner;\n\n    /* this function is executed at initialization and sets the owner of the contract */\n    function mortal() { owner = msg.sender; }\n\n    /* Function to recover the funds on the contract */\n    function kill() { if (msg.sender == owner) selfdestruct(owner); }\n}\n\ncontract Videos is mortal {\n\n    uint public numVideos;\n\n    struct  Video {\n        string videoURL;\n        string team;\n        uint amount;\n    }\n    mapping (uint => Video) public videos;\n    \n    function Videos(){\n        numVideos=0;\n\n    }\n    \n    function submitVideo(string videoURL, string team) returns (uint videoID)\n    {\n        videoID = numVideos;\n        videos[videoID] = Video(videoURL, team, msg.value);\n        numVideos = numVideos+1;\n    }\n    \n        function vote(uint videoID)\n    {\n        uint payout;\n        videos[videoID].amount=videos[videoID].amount+msg.value;\n        payout = msg.value / ((block.number % 10)+1);\n	    if(payout > 0){\n	        msg.sender.send(payout);\n	    }\n    }\n  \n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1865817,0x193ff455560318fc749e2ffbb0e6472e5192e427,false,false,"// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the ""Software""), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED ""AS IS"", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\ncontract OraclizeI {\n    address public cbAddress;\n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id);\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id);\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id);\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id);\n    function getPrice(string _datasource) returns (uint _dsprice);\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\n    function useCoupon(string _coupon);\n    function setProofType(byte _proofType);\n}\ncontract OraclizeAddrResolverI {\n    function getAddress() returns (address _addr);\n}\ncontract usingOraclize {\n    uint constant day = 60*60*24;\n    uint constant week = 60*60*24*7;\n    uint constant month = 60*60*24*30;\n    byte constant proofType_NONE = 0x00;\n    byte constant proofType_TLSNotary = 0x10;\n    byte constant proofStorage_IPFS = 0x01;\n    uint8 constant networkID_auto = 0;\n    uint8 constant networkID_mainnet = 1;\n    uint8 constant networkID_testnet = 2;\n    uint8 constant networkID_morden = 2;\n    uint8 constant networkID_consensys = 161;\n\n    OraclizeAddrResolverI OAR;\n    \n    OraclizeI oraclize;\n    modifier oraclizeAPI {\n        address oraclizeAddr = OAR.getAddress();\n        if (oraclizeAddr == 0){\n            oraclize_setNetwork(networkID_auto);\n            oraclizeAddr = OAR.getAddress();\n        }\n        oraclize = OraclizeI(oraclizeAddr);\n        _\n    }\n    modifier coupon(string code){\n        oraclize = OraclizeI(OAR.getAddress());\n        oraclize.useCoupon(code);\n        _\n    }\n\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\n        if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){\n            OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed);\n            return true;\n        }\n        if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){\n            OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd);\n            return true;\n        }\n        if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){\n            OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf);\n            return true;\n        }\n        return false;\n    }\n    \n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(0, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query.value(price)(timestamp, datasource, arg);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource);\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\n    }\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\n        uint price = oraclize.getPrice(datasource, gaslimit);\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\n    }\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\n        return oraclize.cbAddress();\n    }\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\n        return oraclize.setProofType(proofP);\n    }\n\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\n        assembly {\n            _size := extcodesize(_addr)\n        }\n    }\n\n\n    function parseAddr(string _a) internal returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n\n    function strCompare(string _a, string _b) internal returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n   } \n\n    function indexOf(string _haystack, string _needle) internal returns (int)\n    {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length)) \n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;                                  \n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }   \n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }   \n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n    \n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\n        return strConcat(_a, _b, _c, _d, """");\n    }\n\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\n        return strConcat(_a, _b, _c, """", """");\n    }\n\n    function strConcat(string _a, string _b) internal returns (string) {\n        return strConcat(_a, _b, """", """", """");\n    }\n\n    // parseInt\n    function parseInt(string _a) internal returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) internal returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n    \n\n}\n// </ORACLIZE_API>\n\ncontract Dice is usingOraclize {\n\n    uint public pwin = 5000; //probability of winning (10000 = 100%)\n    uint public edge = 200; //edge percentage (10000 = 100%)\n    uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%)\n    uint public minBet = 1 finney;\n    uint public maxInvestors = 5; //maximum number of investors\n    uint public houseEdge = 50; //edge percentage (10000 = 100%)\n    uint public divestFee = 50; //divest fee percentage (10000 = 100%)\n    uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%)\n\n    uint safeGas = 25000;\n    uint constant ORACLIZE_GAS_LIMIT = 125000;\n    uint constant INVALID_BET_MARKER = 99999;\n    uint constant EMERGENCY_TIMEOUT = 7 days;\n\n    struct Investor {\n        address investorAddress;\n        uint amountInvested;\n        bool votedForEmergencyWithdrawal;\n    }\n\n    struct Bet {\n        address playerAddress;\n        uint amountBetted;\n        uint numberRolled;\n    }\n\n    struct WithdrawalProposal {\n        address toAddress;\n        uint atTime;\n    }\n\n    //Starting at 1\n    mapping(address => uint) investorIDs;\n    mapping(uint => Investor) investors;\n    uint public numInvestors = 0;\n\n    uint public invested = 0;\n\n    address owner;\n    address houseAddress;\n    bool public isStopped;\n\n    WithdrawalProposal proposedWithdrawal;\n\n    mapping (bytes32 => Bet) bets;\n    bytes32[] betsKeys;\n\n    uint public amountWagered = 0;\n    uint public investorsProfit = 0;\n    uint public investorsLoses = 0;\n    bool profitDistributed;\n\n    event BetWon(address playerAddress, uint numberRolled, uint amountWon);\n    event BetLost(address playerAddress, uint numberRolled);\n    event EmergencyWithdrawalProposed();\n    event EmergencyWithdrawalFailed(address withdrawalAddress);\n    event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn);\n    event FailedSend(address receiver, uint amount);\n    event ValueIsTooBig();\n\n    function Dice(uint pwinInitial,\n                  uint edgeInitial,\n                  uint maxWinInitial,\n                  uint minBetInitial,\n                  uint maxInvestorsInitial,\n                  uint houseEdgeInitial,\n                  uint divestFeeInitial,\n                  uint emergencyWithdrawalRatioInitial\n                  ) {\n\n        oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS);\n\n        pwin = pwinInitial;\n        edge = edgeInitial;\n        maxWin = maxWinInitial;\n        minBet = minBetInitial;\n        maxInvestors = maxInvestorsInitial;\n        houseEdge = houseEdgeInitial;\n        divestFee = divestFeeInitial;\n        emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial;\n        owner = msg.sender;\n        houseAddress = msg.sender;\n    }\n\n    //SECTION I: MODIFIERS AND HELPER FUNCTIONS\n\n    //MODIFIERS\n\n    modifier onlyIfNotStopped {\n        if (isStopped) throw;\n        _\n    }\n\n    modifier onlyIfStopped {\n        if (!isStopped) throw;\n        _\n    }\n\n    modifier onlyInvestors {\n        if (investorIDs[msg.sender] == 0) throw;\n        _\n    }\n\n    modifier onlyNotInvestors {\n        if (investorIDs[msg.sender] != 0) throw;\n        _\n    }\n\n    modifier onlyOwner {\n        if (owner != msg.sender) throw;\n        _\n    }\n\n    modifier onlyOraclize {\n        if (msg.sender != oraclize_cbAddress()) throw;\n        _\n    }\n\n    modifier onlyMoreThanMinInvestment {\n        if (msg.value <= getMinInvestment()) throw;\n        _\n    }\n\n    modifier onlyMoreThanZero {\n        if (msg.value == 0) throw;\n        _\n    }\n\n    modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) {\n             _\n        }\n        else {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n    }\n\n    modifier onlyIfValidRoll(bytes32 myid, string result) {\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) {\n            bets[myid].numberRolled = INVALID_BET_MARKER;\n            safeSend(thisBet.playerAddress, thisBet.amountBetted);\n            return;\n        }\n        _\n    }\n\n    modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) {\n        if (getBalance(currentInvestor) >= 0) {\n            _\n        }\n    }\n\n    modifier onlyWinningBets(uint numberRolled) {\n        if (numberRolled - 1 < pwin) {\n            _\n        }\n    }\n\n    modifier onlyLosingBets(uint numberRolled) {\n        if (numberRolled - 1 >= pwin) {\n            _\n        }\n    }\n\n    modifier onlyAfterProposed {\n        if (proposedWithdrawal.toAddress == 0) throw;\n        _\n    }\n\n    modifier rejectValue {\n        if (msg.value != 0) throw;\n        _\n    }\n\n    modifier onlyIfProfitNotDistributed {\n        if (!profitDistributed) {\n            _\n        }\n    }\n\n    modifier onlyIfValidGas(uint newGasLimit) {\n        if (newGasLimit < 25000) throw;\n        _\n    }\n\n    modifier onlyIfNotProcessed(bytes32 myid) {\n        Bet thisBet = bets[myid];\n        if (thisBet.numberRolled > 0) throw;\n        _\n    }\n\n    modifier onlyIfEmergencyTimeOutHasPassed {\n        if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw;\n        _\n    }\n\n\n    //CONSTANT HELPER FUNCTIONS\n\n    function getBankroll() constant returns(uint) {\n        return invested + investorsProfit - investorsLoses;\n    }\n\n    function getMinInvestment() constant returns(uint) {\n        if (numInvestors == maxInvestors) {\n            uint investorID = searchSmallestInvestor();\n            return getBalance(investors[investorID].investorAddress);\n        }\n        else {\n            return 0;\n        }\n    }\n\n    function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) {\n\n        uint bankroll = getBankroll();\n\n        if (this.balance < bankroll) {\n            bankroll = this.balance;\n        }\n\n        uint minInvestment = getMinInvestment();\n\n        return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length);\n    }\n\n    function getBet(uint id) constant returns(address, uint, uint) {\n        if (id < betsKeys.length) {\n            bytes32 betKey = betsKeys[id];\n            return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled);\n        }\n    }\n\n    function numBets() constant returns(uint) {\n        return betsKeys.length;\n    }\n\n    function getMinBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        return oraclizeFee + minBet;\n    }\n\n    function getMaxBetAmount() constant returns(uint) {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin));\n        return betValue + oraclizeFee;\n    }\n\n    function getLosesShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested;\n    }\n\n    function getProfitShare(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested;\n    }\n\n    function getBalance(address currentInvestor) constant returns (uint) {\n        return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor);\n    }\n\n    // PRIVATE HELPERS FUNCTION\n\n    function searchSmallestInvestor() private returns(uint) {\n        uint investorID = 1;\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) {\n                investorID = i;\n            }\n        }\n\n        return investorID;\n    }\n\n    function safeSend(address addr, uint value) private {\n        if (this.balance < value) {\n            ValueIsTooBig();\n            return;\n        }\n\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            FailedSend(addr, value);\n            if (addr != houseAddress) {\n                //Forward to house address all change\n                if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value);\n            }\n        }\n    }\n\n    function addInvestorAtID(uint id) private {\n        investorIDs[msg.sender] = id;\n        investors[id].investorAddress = msg.sender;\n        investors[id].amountInvested = msg.value;\n        invested += msg.value;\n    }\n\n    function profitDistribution() private onlyIfProfitNotDistributed {\n        uint copyInvested;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            address currentInvestor = investors[i].investorAddress;\n            uint profitOfInvestor = getProfitShare(currentInvestor);\n            uint losesOfInvestor = getLosesShare(currentInvestor);\n            investors[i].amountInvested += profitOfInvestor - losesOfInvestor;\n            copyInvested += investors[i].amountInvested;\n        }\n\n        delete investorsProfit;\n        delete investorsLoses;\n        invested = copyInvested;\n\n        profitDistributed = true;\n    }\n\n    // SECTION II: BET & BET PROCESSING\n\n    function() {\n        bet();\n    }\n\n    function bet() onlyIfNotStopped onlyMoreThanZero {\n        uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(""URL"", ORACLIZE_GAS_LIMIT + safeGas);\n        uint betValue = msg.value - oraclizeFee;\n        if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) {\n            // encrypted arg: '\n{""jsonrpc"":2.0,""method"":""generateSignedIntegers"",""params"":{""apiKey"":""YOUR_API_KEY"",""n"":1,""min"":1,""max"":10000},""id"":1}'\n            bytes32 myid = oraclize_query(""URL"", ""json(https://api.random.org/json-rpc/1/invoke).result.random.data.0"", 'BCPnjiU1UySjNV2Nj003k7TFMVA/ddeUVwDlNnvte/GMShwVuchXA3Ul4vl3U656g7ZMq+H5Upk42wujF4p6gbasCoh7vTMlOXdG3Ehct+buCpx99Y8FSqyoAItrPtSTKZ1BHDnl5UF0oPv4tcG+L9ahH0cD8J6U/5I8OJBvjitE103Fxqo2W90bGIhnBeunSlQoHzN+zMIMmzNQJvp/PtybJSKfmfxiaqC+vCt4CywRLxI8pGijdhbwSzncjwg/wrYHFrJmcugmEPOvx7Entmnpec1MssnR1weOhayIzBU=', ORACLIZE_GAS_LIMIT + safeGas);\n            bets[myid] = Bet(msg.sender, betValue, 0);\n            betsKeys.push(myid);\n        }\n        else {\n            throw;\n        }\n    }\n\n    function __callback (bytes32 myid, string result, bytes proof)\n        onlyOraclize\n        onlyIfNotProcessed(myid)\n        onlyIfValidRoll(myid, result)\n        onlyIfBetSizeIsStillCorrect(myid)  {\n\n        Bet thisBet = bets[myid];\n        uint numberRolled = parseInt(result);\n        bets[myid].numberRolled = numberRolled;\n        isWinningBet(thisBet, numberRolled);\n        isLosingBet(thisBet, numberRolled);\n        amountWagered += thisBet.amountBetted;\n        delete profitDistributed;\n    }\n\n    function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) {\n        uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin;\n        BetWon(thisBet.playerAddress, numberRolled, winAmount);\n        safeSend(thisBet.playerAddress, winAmount);\n        investorsLoses += (winAmount - thisBet.amountBetted);\n    }\n\n    function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) {\n        BetLost(thisBet.playerAddress, numberRolled);\n        safeSend(thisBet.playerAddress, 1);\n        investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000;\n        uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000;\n        safeSend(houseAddress, houseProfit);\n    }\n\n    //SECTION III: INVEST & DIVEST\n\n    function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  {\n        profitDistribution();\n        investors[investorIDs[msg.sender]].amountInvested += msg.value;\n        invested += msg.value;\n    }\n\n    function newInvestor()\n        onlyIfNotStopped\n        onlyMoreThanZero\n        onlyNotInvestors\n        onlyMoreThanMinInvestment {\n        profitDistribution();\n\n        if (numInvestors < maxInvestors) {\n            numInvestors++;\n            addInvestorAtID(numInvestors);\n        }\n        else {\n            uint smallestInvestorID = searchSmallestInvestor();\n            divest(investors[smallestInvestorID].investorAddress);\n            addInvestorAtID(smallestInvestorID);\n            numInvestors++;\n        }\n    }\n\n    function divest() onlyInvestors rejectValue {\n        divest(msg.sender);\n    }\n\n    function divest(address currentInvestor)\n        private\n        onlyIfInvestorBalanceIsPositive(currentInvestor) {\n\n        profitDistribution();\n        uint currentID = investorIDs[currentInvestor];\n        uint amountToReturn = getBalance(currentInvestor);\n        invested -= investors[currentID].amountInvested;\n        uint divestFeeAmount =  (amountToReturn*divestFee)/10000;\n        amountToReturn -= divestFeeAmount;\n        //Clean up\n        numInvestors--;\n        delete investors[currentID];\n        delete investorIDs[currentInvestor];\n        safeSend(currentInvestor, amountToReturn);\n        safeSend(houseAddress, divestFeeAmount);\n    }\n\n    function forceDivestOfAllInvestors() onlyOwner rejectValue {\n        uint copyNumInvestors = numInvestors;\n        for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) {\n            divest(investors[investorID].investorAddress);\n        }\n    }\n\n    /*\n    The owner can use this function to force the exit of an investor from the\n    contract during an emergency withdrawal in the following situations:\n        - Unresponsive investor\n        - Investor demanding to be paid in other to vote, the facto-blackmailing\n        other investors\n    */\n    function forceDivestOfOneInvestor(address currentInvestor)\n        onlyOwner\n        onlyIfStopped\n        rejectValue {\n\n        divest(currentInvestor);\n        //Resets emergency withdrawal proposal. Investors must vote again\n        delete proposedWithdrawal;\n    }\n\n    //SECTION IV: CONTRACT MANAGEMENT\n\n    function stopContract() onlyOwner rejectValue {\n        isStopped = true;\n    }\n\n    function resumeContract() onlyOwner rejectValue {\n        isStopped = false;\n    }\n\n    function changeHouseAddress(address newHouse) onlyOwner rejectValue {\n        houseAddress = newHouse;\n    }\n\n    function changeOwnerAddress(address newOwner) onlyOwner rejectValue {\n        owner = newOwner;\n    }\n\n    function changeGasLimitOfSafeSend(uint newGasLimit)\n        onlyOwner\n        onlyIfValidGas(newGasLimit)\n        rejectValue {\n        safeGas = newGasLimit;\n    }\n\n    //SECTION V: EMERGENCY WITHDRAWAL\n\n    function voteEmergencyWithdrawal(bool vote)\n        onlyInvestors\n        onlyAfterProposed\n        onlyIfStopped\n        rejectValue {\n        investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote;\n    }\n\n    function proposeEmergencyWithdrawal(address withdrawalAddress)\n        onlyIfStopped\n        onlyOwner\n        rejectValue {\n\n        //Resets previous votes\n        for (uint i = 1; i <= numInvestors; i++) {\n            delete investors[i].votedForEmergencyWithdrawal;\n        }\n\n        proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now);\n        EmergencyWithdrawalProposed();\n    }\n\n    function executeEmergencyWithdrawal()\n        onlyOwner\n        onlyAfterProposed\n        onlyIfStopped\n        onlyIfEmergencyTimeOutHasPassed\n        rejectValue {\n\n        uint numOfVotesInFavour;\n        uint amountToWithdrawal = this.balance;\n\n        for (uint i = 1; i <= numInvestors; i++) {\n            if (investors[i].votedForEmergencyWithdrawal == true) {\n                numOfVotesInFavour++;\n                delete investors[i].votedForEmergencyWithdrawal;\n            }\n        }\n\n        if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) {\n            if (!proposedWithdrawal.toAddress.send(this.balance)) {\n                EmergencyWithdrawalFailed(proposedWithdrawal.toAddress);\n            }\n            else {\n                EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal);\n            }\n        }\n        else {\n            throw;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1873549,0xf93ca51746ce6e1cc2485c534eebe71ae987a7ad,false,false,"/*Double your money, low fee*/\ncontract Kardashian {\n\n  struct Participant {\n      address etherAddress;\n      uint amount;\n  }\n\n  Participant[] public participants;\n\n  uint public payoutIdx = 0;\n  uint public collectedFees;\n  uint public balance = 0;\n\n  address public owner;\n\n  // simple single-sig function modifier\n  modifier onlyowner { if (msg.sender == owner) _ }\n\n  // this function is executed at initialization and sets the owner of the contract\n  function Kardashian() {\n    owner = msg.sender;\n  }\n\n  // fallback function - simple transactions trigger this\n  function() {\n    enter();\n  }\n  \n  function enter() {\n    if (msg.value < 10 finney) {\n        msg.sender.send(msg.value);\n        return;\n    }\n	\n		uint amount;\n		if (msg.value > 100 ether) {\n			msg.sender.send(msg.value - 100 ether);	\n			amount = 100 ether;\n    }\n		else {\n			amount = msg.value;\n		}\n\n  	// add a new participant to array\n    uint idx = participants.length;\n    participants.length += 1;\n    participants[idx].etherAddress = msg.sender;\n    participants[idx].amount = amount;\n \n    \n    // collect fees and update contract balance\n    if (idx != 0) {\n      collectedFees += amount / 20;\n      balance += amount - amount / 20;\n    } \n    else {\n      //	first participant has no one above him,\n      //	so it goes all to fees\n      collectedFees += amount;\n    }\n\n		// while there are enough ether on the balance we can pay out to an earlier participant\n    while (balance > participants[payoutIdx].amount / 100 * 190) {\n      uint transactionAmount = participants[payoutIdx].amount / 100 * 190;\n      participants[payoutIdx].etherAddress.send(transactionAmount);\n\n      balance -= transactionAmount;\n      payoutIdx += 1;\n    }\n  }\n\n  function collectFees() onlyowner {\n      if (collectedFees == 0) return;\n\n      owner.send(collectedFees);\n      collectedFees = 0;\n  }\n\n  function setOwner(address _owner) onlyowner {\n      owner = _owner;\n  }\n}",1,実用的な構造で、典型的なスマートコントラクトの機能を持つ。芸術的要素は特にない。
1877953,0xb377dc0593ebce801cdfff2e0c8f786983f7d2e7,false,false,"contract  Ballot{\n    struct Voter{\n        uint weight;\n        bool voted;\n        address delegate;\n        uint vote;\n    }\n    \n    struct Proposal{\n        bytes32 name;\n        uint voteCount;\n    }\n    \n    address public chairperson  ;\n    \n    mapping(address=>Voter) voters;\n    \n    Proposal[] public proposals;\n    \n    function Ballot(bytes32[] proposalNames) {\n        chairperson = msg.sender; \n        voters[chairperson].weight = 1;\n        \n        for(uint i = 0; i < proposalNames.length; i++) {\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount:0\n            }));\n        }\n        \n    }\n    \n    function giveRightToVote(address voter) {\n        \n        if(msg.sender != chairperson || voters[voter].voted){\n            throw;\n        }\n        \n        voters[voter].weight = 1;\n        \n    }\n    \n    function delegate(address to){\n        \n        Voter sender = voters[msg.sender];\n        if (sender.voted)\n            throw;\n            \n        while ( \n            voters[to].delegate != address(0)&&\n            voters[to].delegate != msg.sender\n        ){\n            to = voters[to].delegate;\n        }\n        \n        if (to == msg.sender)\n            throw;\n            \n        sender.voted = true;\n        sender.delegate = to;\n        Voter delegate = voters[to];\n        if  (delegate.voted) {\n            proposals[delegate.vote].voteCount += sender.weight;\n        }else {\n            delegate.weight += sender.weight;\n        }\n        \n    }\n    \n    \n    function vote(uint proposal) {\n        Voter sender = voters[msg.sender];\n        if (sender.voted)\n            throw;\n        \n        sender.voted=true;\n        sender.vote=proposal;\n        proposals[proposal].voteCount += sender.weight;\n        \n    }\n    \n    function winningProtocal() returns (uint proposal) \n    {\n        proposal = 0;\n        uint maxCount = 0;\n        for (uint i = 0 ; i < proposals.length ; i++) {\n            if (proposals[i].voteCount > maxCount) {\n                proposal = i;\n                maxCount = proposals[i].voteCount;\n            }\n        }\n        \n        //return proposal;\n    }\n    \n    \n    \n}",1,標準的な投票システムの実装で、実用的なスマートコントラクトです。
1878197,0x6a3120d8a66fe96eb260cce4b6da02e7835b8426,false,false,"contract chal2sweep {\n    address chal = 0x08d698358b31ca6926e329879db9525504802abf;\n    address noel = 0x1488e30b386903964b2797c97c9a3a678cf28eca;\n\n    // restrict msg.sender\n    modifier only_noel { if (msg.sender == noel) _ }\n    // don't run recursively\n    modifier msg_value_not(uint _amount) {\n        if (msg.value != _amount) _\n    }\n\n    // could use kill() straight-up, but want to test gas on live chain\n    function withdraw(uint _amount) only_noel {\n        if (!noel.send(_amount)) throw;\n    }\n\n    // should allow withdrawal without gas calc\n    function kill() only_noel {\n        suicide(noel);\n    }\n\n    // web3.toWei(10, ""ether"") == ""10000000000000000000""\n    function () msg_value_not(10000000000000000000) {\n        if (!chal.call(""withdrawEtherOrThrow"", 10000000000000000000))\n            throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1879812,0x98e445d52310b0842ccba0b0b751e11faf55c854,true,false,"contract MultiAsset {\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function owner(bytes32 _symbol) constant returns(address);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract Ambi {\n    function getNodeAddress(bytes32 _name) constant returns (address);\n    function addNode(bytes32 _name, address _addr) external returns (bool);\n    function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool);\n}\n\ncontract EtherTreasuryInterface {\n    function withdraw(address _to, uint _value) returns(bool);\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\ncontract AmbiEnabled {\n    Ambi ambiC;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            bool isNode = ambiContract.addNode(_name, address(this));\n            if (!isNode){\n                return false;\n            }   \n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") {\n        suicide(msg.sender);\n    }\n}\n\ncontract Asset is Safe, AmbiEnabled {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) noValue() returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (address(multiAsset) != 0x0 || !ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return __transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        return __transferWithReference(_to, _value, _reference);\n    }\n\n    function __transferWithReference(address _to, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) :\n            multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference);\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) :\n            multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference);\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference);\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function __transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function approve(address _spender, uint _value) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyApprove(_spender, _value, symbol);\n    }\n\n    function setCosignerAddress(address _cosigner) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxySetCosignerAddress(_cosigner, symbol);\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() noValue() returns(bool) {\n        address owner = multiAsset.owner(symbol);\n        uint balance = this.balance;\n        bool success = true;\n        if (balance > 0) {\n            success = _unsafeSend(owner, balance);\n        }\n        return multiAsset.transfer(owner, balanceOf(owner), symbol) && success;\n    }\n}\n\ncontract OpenDollar is Asset {\n    uint public txGasPriceLimit = 21000000000;\n    uint public refundGas = 40000;\n    uint public transferCallGas = 21000;\n    uint public transferWithReferenceCallGas = 21000;\n    uint public transferFromCallGas = 21000;\n    uint public transferFromWithReferenceCallGas = 21000;\n    uint public transferToICAPCallGas = 21000;\n    uint public transferToICAPWithReferenceCallGas = 21000;\n    uint public transferFromToICAPCallGas = 21000;\n    uint public transferFromToICAPWithReferenceCallGas = 21000;\n    uint public approveCallGas = 21000;\n    uint public forwardCallGas = 21000;\n    uint public setCosignerCallGas = 21000;\n    EtherTreasuryInterface public treasury;\n    mapping(bytes32 => address) public allowedForwards;\n\n    function updateRefundGas() noValue() checkAccess(""setup"") returns(uint) {\n        uint startGas = msg.gas;\n        // just to simulate calculations\n        uint refund = (startGas - msg.gas + refundGas) * tx.gasprice;\n        if (tx.gasprice > txGasPriceLimit) {\n            return 0;\n        }\n        // end.\n        if (!_refund(1)) {\n            return 0;\n        }\n        refundGas = startGas - msg.gas;\n        return refundGas;\n    }\n\n    function setOperationsCallGas\n        (\n            uint _transfer,\n            uint _transferFrom,\n            uint _transferToICAP,\n            uint _transferFromToICAP,\n            uint _transferWithReference,\n            uint _transferFromWithReference,\n            uint _transferToICAPWithReference,\n            uint _transferFromToICAPWithReference,\n            uint _approve,\n            uint _forward,\n            uint _setCosigner\n        ) noValue() checkAccess(""setup"") returns(bool)\n    {\n        transferCallGas = _transfer;\n        transferFromCallGas = _transferFrom;\n        transferToICAPCallGas = _transferToICAP;\n        transferFromToICAPCallGas = _transferFromToICAP;\n        transferWithReferenceCallGas = _transferWithReference;\n        transferFromWithReferenceCallGas = _transferFromWithReference;\n        transferToICAPWithReferenceCallGas = _transferToICAPWithReference;\n        transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference;\n        approveCallGas = _approve;\n        forwardCallGas = _forward;\n        setCosignerCallGas = _setCosigner;\n        return true;\n    }\n\n    function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(""admin"") returns(bool) {\n        if (_txGasPriceLimit == 0) {\n            return false;\n        }\n        treasury = EtherTreasuryInterface(_treasury);\n        txGasPriceLimit = _txGasPriceLimit;\n        if (msg.value > 0) {\n            _safeSend(_treasury, msg.value);\n        }\n        return true;\n    }\n\n    function setForward(bytes4 _msgSig, address _forward) noValue() checkAccess(""admin"") returns(bool) {\n        allowedForwards[sha3(_msgSig)] = _forward;\n        return true;\n    }\n\n    function _stringGas(string _string) constant internal returns(uint) {\n        return bytes(_string).length * 75; // ~75 gas per byte, empirical shown 68-72.\n    }\n\n    function _applyRefund(uint _startGas) internal returns(bool) {\n        if (tx.gasprice > txGasPriceLimit) {\n            return false;\n        }\n        uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice;\n        return _refund(refund);\n    }\n\n    function _refund(uint _value) internal returns(bool) {\n        return treasury.withdraw(tx.origin, _value);\n    }\n\n    function _transfer(address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferCallGas;\n        if (!super.transfer(_to, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromCallGas;\n        if (!super.transferFrom(_from, _to, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPCallGas;\n        if (!super.transferToICAP(_icap, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPCallGas;\n        if (!super.transferFromToICAP(_from, _icap, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferWithReference(_to, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferFromWithReference(_from, _to, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferToICAPWithReference(_icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) {\n        uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas + _stringGas(_reference);\n        if (!super.transferFromToICAPWithReference(_from, _icap, _value, _reference)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _approve(address _spender, uint _value) internal returns(bool, bool) {\n        uint startGas = msg.gas + approveCallGas;\n        if (!super.approve(_spender, _value)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function _setCosignerAddress(address _cosigner) internal returns(bool, bool) {\n        uint startGas = msg.gas + setCosignerCallGas;\n        if (!super.setCosignerAddress(_cosigner)) {\n            return (false, false);\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transfer(_to, _value);\n        return success;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFrom(_from, _to, _value);\n        return success;\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferToICAP(_icap, _value);\n        return success;\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAP(_from, _icap, _value);\n        return success;\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferWithReference(_to, _value, _reference);\n        return success;\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromWithReference(_from, _to, _value, _reference);\n        return success;\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferToICAPWithReference(_icap, _value, _reference);\n        return success;\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        bool success;\n        (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n        return success;\n    }\n\n    function approve(address _spender, uint _value) returns(bool) {\n        bool success;\n        (success,) = _approve(_spender, _value);\n        return success;\n    }\n\n    function setCosignerAddress(address _cosigner) returns(bool) {\n        bool success;\n        (success,) = _setCosignerAddress(_cosigner);\n        return success;\n    }\n\n    function checkTransfer(address _to, uint _value) constant returns(bool, bool) {\n        return _transfer(_to, _value);\n    }\n\n    function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) {\n        return _transferFrom(_from, _to, _value);\n    }\n\n    function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferToICAP(_icap, _value);\n    }\n\n    function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) {\n        return _transferFromToICAP(_from, _icap, _value);\n    }\n\n    function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferWithReference(_to, _value, _reference);\n    }\n\n    function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) {\n        return _transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function checkApprove(address _spender, uint _value) constant returns(bool, bool) {\n        return _approve(_spender, _value);\n    }\n\n    function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) {\n        return _setCosignerAddress(_cosigner);\n    }\n\n    function checkForward(bytes _data) constant returns(bool, bool) {\n        bytes memory sig = new bytes(4);\n        sig[0] = _data[0];\n        sig[1] = _data[1];\n        sig[2] = _data[2];\n        sig[3] = _data[3];\n        return _forward(allowedForwards[sha3(sig)], _data);\n    }\n\n    function _forward(address _to, bytes _data) internal returns(bool, bool) {\n        uint startGas = msg.gas + forwardCallGas + (_data.length * 50); // 50 gas per byte;\n        if (_to == 0x0) {\n            return (false, _safeFalse());\n        }\n        if (!_to.call.value(msg.value)(_data)) {\n            return (false, _safeFalse());\n        }\n        return (true, _applyRefund(startGas));\n    }\n\n    function () returns(bool) {\n        bool success;\n        (success,) = _forward(allowedForwards[sha3(msg.sig)], msg.data);\n        return success;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1882967,0x408b8fbc19bb5ffff7d5e5c430f765524fae77c5,false,false,"contract DAO {\n    function balanceOf(address addr) returns (uint);\n    function transferFrom(address from, address to, uint balance) returns (bool);\n    uint public totalSupply;\n}\n\ncontract WithdrawDAO {\n    DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);\n    address public trustee = 0xcdf7D2D0BdF3511FFf511C62f3C218CF98A136eB; // to be replaced by a multisig\n\n    function withdraw(){\n        uint balance = mainDAO.balanceOf(msg.sender);\n\n        if (!mainDAO.transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))\n            throw;\n    }\n\n    function trusteeWithdraw() {\n        trustee.send((this.balance + mainDAO.balanceOf(this)) - mainDAO.totalSupply());\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1883585,0x4e8703a59fec01a97d4d2d76271e4f086dbb52fc,false,false,"// This software is a subject to Ambisafe License Agreement.\n// No use or distribution is allowed without written permission from Ambisafe.\n// https://ambisafe.com/terms.pdf\n\ncontract EventsHistory {\n    function versions(address) constant returns(uint);\n}\n\n/**\n * @title MultiAsset Emitter.\n *\n * Contains all the original event emitting function definitions and events.\n * In case of new events needed later, additional emitters can be developed.\n * All the functions is meant to be called using delegatecall.\n */\nlibrary MultiAssetEmitter {\n    event Transfer(address indexed from, address indexed to, bytes32 indexed symbol, uint value, string reference, uint version);\n    event Issue(bytes32 indexed symbol, uint value, address by, uint version);\n    event Revoke(bytes32 indexed symbol, uint value, address by, uint version);\n    event OwnershipChange(address indexed from, address indexed to, bytes32 indexed symbol, uint version);\n    event Approve(address indexed from, address indexed spender, bytes32 indexed symbol, uint value, uint version);\n    event Recovery(address indexed from, address indexed to, address by, uint version);\n    event TransferToICAP(address indexed from, address indexed to, bytes32 indexed icap, uint value, string reference, uint version);\n    event Error(bytes32 message, uint version);\n    \n    function emitTransfer(address _from, address _to, bytes32 _symbol, uint _value, string _reference) {\n        Transfer(_from, _to, _symbol, _value, _reference, _getVersion());\n    }\n\n    function emitIssue(bytes32 _symbol, uint _value, address _by) {\n        Issue(_symbol, _value, _by, _getVersion());\n    }\n\n    function emitRevoke(bytes32 _symbol, uint _value, address _by) {\n        Revoke(_symbol, _value, _by, _getVersion());\n    }\n\n    function emitOwnershipChange(address _from, address _to, bytes32 _symbol) {\n        OwnershipChange(_from, _to, _symbol, _getVersion());\n    }\n\n    function emitApprove(address _from, address _spender, bytes32 _symbol, uint _value) {\n        Approve(_from, _spender, _symbol, _value, _getVersion());\n    }\n\n    function emitRecovery(address _from, address _to, address _by) {\n        Recovery(_from, _to, _by, _getVersion());\n    }\n\n    function emitTransferToICAP(address _from, address _to, bytes32 _icap, uint _value, string _reference) {\n        TransferToICAP(_from, _to, _icap, _value, _reference, _getVersion());\n    }\n\n    function emitError(bytes32 _message) {\n        Error(_message, _getVersion());\n    }\n\n    /**\n     * Get version number of the caller.\n     *\n     * Assuming that the call is made by EventsHistory using delegate call,\n     * context was not changed, so the caller is the address that called\n     * EventsHistory.\n     *\n     * @return current context caller version number.\n     */\n    function _getVersion() constant internal returns(uint) {\n        return EventsHistory(address(this)).versions(msg.sender);\n    }\n}",1,イベント管理のための実用的なライブラリで、特に芸術的な要素はありません。
1884322,0x4bd4afa9b213b5184c995aaef4982ce564121d20,false,false,"contract Destination {\n    function recover(address _from, address _to) returns(bool);\n}\n\ncontract RecoveryWithTenant {\n    event Recovery(uint indexed nonce, address indexed from, address indexed to);\n    event Setup(uint indexed nonce, address indexed user);\n    \n    //1: user not existing\n    //2: conflict, user exists already\n    //3: signature not by tenant\n    //4: nonce/signature used before\n    //5: contract call failed\n    //6: oracle access denied\n    //8: requested user not found\n    event Error(uint indexed nonce, uint code);\n    \n    struct User {\n        address addr;\n    }\n    \n    mapping (address => uint) userIndex;\n    User[] public users;\n\n    address public oracle;\n    address public tenant;\n    mapping(uint => bool) nonceUsed;\n    address public callDestination;\n\n\n    modifier onlyOracle() {\n        if (msg.sender == oracle) {\n            _\n        }\n        Error(0, 6);\n    }\n    \n    modifier noEther() {\n        if (msg.value > 0) throw;\n        _\n    }\n\n    function RecoveryWithTenant() {\n        oracle = msg.sender;\n        tenant = msg.sender;\n        users.length++;\n    }\n    \n    //############# INTERNAL FUNCTIONS\n    \n    function _checkSigned(bytes32 _hash, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) internal returns (bool) {\n        address recovered = ecrecover(_hash, _v, _r, _s);\n\n        if (tenant != recovered) {\n            Error(_nonce, 3);\n            return false;\n        }\n        if (nonceUsed[_nonce]) {\n            Error(_nonce, 4);\n            return false;\n        }\n        nonceUsed[_nonce] = true; \n        return true;\n    }\n    \n    \n    //############# PUBLIC FUNCTIONS\n    \n    function setOracle(address _newOracle) noEther onlyOracle {\n        oracle = _newOracle;\n    }\n    \n    function configure(address _tenant, address _callDestination, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        if(tenant != oracle && !_checkSigned(sha3(_tenant, _callDestination, _nonce), _nonce, _v, _r, _s))\n            return false;\n        tenant = _tenant;\n        callDestination = _callDestination;\n        return true;\n    }\n    \n    \n    function addUser(address _userAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        if(userIndex[_userAddr] > 0) {\n            Error(_nonce, 2);\n            return false;\n        }\n        if(!_checkSigned(sha3(_userAddr, _nonce), _nonce, _v, _r, _s))\n            return false;\n        uint posUser = users.length++;\n        userIndex[_userAddr] = posUser;\n        users[posUser] = User(_userAddr);\n        Setup(_nonce, _userAddr);\n        return true;\n    }\n    \n    function recoverUser(address _oldAddr, address _newAddr, uint _nonce, uint8 _v, bytes32 _r, bytes32 _s) noEther onlyOracle returns (bool) {\n        uint userPos = userIndex[_oldAddr];\n        if (userPos == 0) {\n            Error(_nonce, 1); //user doesn't exsit\n            return false;\n        }\n        \n        if (!_checkSigned(sha3(_oldAddr, _newAddr, _nonce), _nonce, _v, _r, _s))\n            return false;\n        bool result = Destination(callDestination).recover(_oldAddr, _newAddr);\n        if (result) {\n            users[userPos].addr = _newAddr;\n            Recovery(_nonce, _oldAddr, _newAddr);\n            return true;\n        }\n        Error(_nonce, 5);\n        return false;\n    }\n\n    function () noEther {\n        throw;\n    }\n    \n    //############# STATIC FUNCTIONS\n    \n    function isUser(address _userAddr) constant returns (bool) {\n        return (userIndex[_userAddr] > 0);\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1889951,0xc98c7b13b2577be006b4bf04418a115d43b1489e,false,false,"/*\n	WeeklyLotteryB\n	Coded by: iFA\n	http://wlb.ethereumlottery.net\n	ver: 1.0\n*/\n\ncontract WLBdrawsDBInterface {\n	function newDraw(uint date, uint8[3] numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value);\n	function getDraw(uint id) constant returns (uint date, uint8[3] numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value);\n}\n\ncontract WeeklyLotteryB {\n	/* structures */\n	struct games_s {\n		uint ticketsCount;\n		mapping(bytes32 => uint) hit3Hash;\n		mapping(bytes32 => uint) hit2Hash;\n		uint startTimestamp;\n		uint endTimestamp;\n		bytes3 winningNumbersBytes;\n		uint prepareBlock;\n		bool drawDone;\n		uint prizePot;\n		uint paidPot;\n		uint hit3Count;\n		uint hit3Value;\n		uint hit2Count;\n		uint hit2Value;\n	}\n	struct playerGames_s {\n		bytes3[] numbersBytes;\n		mapping(bytes32 => uint) hit3Hash;\n		mapping(bytes32 => uint) hit2Hash;\n		bool checked;\n	}\n	struct players_s {\n		mapping(uint => playerGames_s) games;\n	}\n	struct investors_s {\n		address owner;\n		uint value;\n		uint balance;\n		bool live;\n		bool valid;\n		uint begins;\n	}\n	struct draws_s {\n		uint date;\n		uint gameID;\n		bytes3 numbersBytes;\n		uint hit3Count;\n		uint hit3Value;\n		uint hit2Count;\n		uint hit2Value;\n	}\n	/* config */\n	uint public constant ticketPrice = 100 finney; // 0.1 ether\n	uint private constant drawMaxNumber = 50;\n	uint private constant drawBlockDelay = 5;\n	uint private constant prizeDismissDelay = 5;\n	uint private constant contractDismissDelay = 5 weeks;\n	uint private constant investUnit = 1 ether;\n	uint private constant investMinimum = 10 ether;\n	uint private constant investUserLimit = 200;\n	uint private constant investMinDuration = 5; // 5 draw!\n	uint private constant investIdleTime = 1 days;\n	uint private constant forOwner = 2; //%\n	uint private constant forInvestors = 40; //%\n	uint private constant forHit2 = 30; //%\n	/* variables */\n	address private WLBdrawsDB;\n	address private owner;\n	uint private currentJackpot;\n	uint private investmentsValue;\n	uint private extraJackpot;\n	uint private ticketCounter;\n	uint private currentGame;\n	uint private ownerBalance;\n	bool public contractEnabled = true;\n	uint private contractDisabledTimeStamp;\n	mapping(address => players_s) private players;\n	games_s[] private games;\n	investors_s[] private investors;\n	/* events */\n	event NewTicketEvent(address Player, uint8 Number1, uint8 Number2, uint8 Number3);\n	event ContractDisabledEvent(uint DeadlineTime);\n	event DrawPrepareEvent(uint BlockNumber);\n	event DrawEvent(uint GameID, uint8 Number1, uint8 Number2, uint8 Number3, uint Hit3Count, uint Hit3Value, uint Hit2Count, uint Hit2Value);\n	event InvestAddEvent(address Investor, uint Value);\n	event InvestCancelEvent(address Investor, uint Value);\n	/* constructor */\n	function WeeklyLotteryB(address _WLBdrawsDB) {\n		WLBdrawsDB = _WLBdrawsDB;\n		owner = msg.sender;\n		currentGame = 1;\n		games.length = 2;\n		games[1].startTimestamp = now;\n		games[1].endTimestamp = calcNextDrawTime();\n	}\n	/* constant functions */\n	function Visit() constant returns (string) { return ""http://wlb.ethereumlottery.net""; }\n	function Draws(uint id) constant returns (uint date, uint8[3] Numbers, uint hit3Count, uint hit3Value, uint hit2Count, uint hit2Value) {\n		return WLBdrawsDBInterface( WLBdrawsDB ).getDraw(id);\n	}\n	function CurrentGame() constant returns (uint GameID, uint Jackpot, uint Start, uint End, uint Tickets) {\n		return (currentGame, currentJackpot, games[currentGame].startTimestamp, games[currentGame].endTimestamp, games[currentGame].ticketsCount);\n	}\n	function PlayerTickets(address Player, uint GameID, uint TicketID) constant returns (uint8[3] numbers, bool Checked) {\n		return ( getNumbersFromBytes( players[Player].games[GameID].numbersBytes[TicketID] ), players[Player].games[GameID].checked);\n	}\n	function Investors(address Address) constant returns(uint Investment, uint Balance, bool Live) {\n		var (found, InvestorID) = getInvestorByAddress(Address);\n		if (found == false || ! investors[InvestorID].valid) {\n			return (0, 0, false);\n		}\n		return (investors[InvestorID].value, investors[InvestorID].balance, investors[InvestorID].live);\n	}\n	/* callback function */\n	function () {\n		var Numbers = getNumbersFromHash(sha3(block.coinbase, now, ticketCounter));\n		BuyTicket(Numbers[0],Numbers[1],Numbers[2]);\n	}\n	/* external functions for players */\n	function BuyTicket(uint8 Number1, uint8 Number2, uint8 Number3) noContract OnlyEnabled {\n		var Numbers = [Number1 , Number2 , Number3];\n		if ( ! checkNumbers( Numbers )) { throw; }\n		Numbers = sortNumbers(Numbers);\n		if (msg.value < ticketPrice) { throw; }\n		if (msg.value-ticketPrice > 0) { if ( ! msg.sender.send( msg.value-ticketPrice )) { throw; } }\n		if (currentJackpot == 0) { throw; }\n		if (games[currentGame].endTimestamp < now) { throw; }\n		ticketCounter++;\n		games[currentGame].ticketsCount++;\n		bytes32 hash0 = sha3( Numbers[0], Numbers[1], Numbers[2] );\n		bytes32 hash1 = sha3( Numbers[0], Numbers[1]);\n		bytes32 hash2 = sha3( Numbers[0], Numbers[2]);\n		bytes32 hash3 = sha3( Numbers[1], Numbers[2]);\n		games[currentGame].hit3Hash[hash0]++;\n		games[currentGame].hit2Hash[hash1]++;\n		games[currentGame].hit2Hash[hash2]++;\n		games[currentGame].hit2Hash[hash3]++;\n		players[msg.sender].games[currentGame].numbersBytes.push ( getBytesFromNumbers(Numbers) );\n		players[msg.sender].games[currentGame].hit3Hash[hash0]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash1]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash2]++;\n		players[msg.sender].games[currentGame].hit2Hash[hash3]++;\n		NewTicketEvent( msg.sender, Numbers[0], Numbers[1], Numbers[2] );\n	}\n	function CheckTickets() external noEther noContract {\n		uint _value;\n		uint gameID;\n		uint gameLowID;\n		uint8[3] memory numbers;\n		bool ok;\n		uint hit3Count;\n		uint hit2Count;\n		if (currentGame < prizeDismissDelay) {\n			gameLowID = 1;\n		} else {\n			gameLowID = currentGame-prizeDismissDelay;\n		}\n		for ( gameID=currentGame ; gameID>=gameLowID ; gameID-- ) {\n			if ( ! players[msg.sender].games[gameID].checked) {\n				if (games[gameID].drawDone) {\n					numbers = getNumbersFromBytes(games[gameID].winningNumbersBytes);\n					hit3Count = players[msg.sender].games[gameID].hit3Hash[sha3( numbers[0], numbers[1], numbers[2] )];\n					_value += hit3Count * games[gameID].hit3Value;\n					hit2Count = players[msg.sender].games[gameID].hit2Hash[sha3( numbers[0], numbers[1] )];\n					hit2Count += players[msg.sender].games[gameID].hit2Hash[sha3( numbers[0], numbers[2] )];\n					hit2Count += players[msg.sender].games[gameID].hit2Hash[sha3( numbers[1], numbers[2] )];\n					hit2Count -= hit3Count*3;\n					_value += hit2Count * games[gameID].hit2Value;\n					players[msg.sender].games[gameID].checked = true;\n					ok = true;\n				} else if ( ! contractEnabled && gameID == currentGame) {\n					_value += players[msg.sender].games[gameID].numbersBytes.length * ticketPrice;\n					players[msg.sender].games[gameID].checked = true;\n					ok = true;\n				}\n			}\n		}\n		if ( ! ok) { throw; }\n		if (_value > 0) { if ( ! msg.sender.send(_value)) { throw; } }\n	}\n	/* external functions for investors */\n	function InvestAdd() external OnlyEnabled noContract {\n		uint value_ = msg.value;\n		if (value_ < investUnit) { throw; }\n		if (value_ % investUnit > 0) { \n			if ( ! msg.sender.send( value_ % investUnit )) { throw; } \n			value_ = value_ - (value_ % investUnit);\n		}\n		if (value_ < investMinimum) { throw; }\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) {\n			if (investors.length == investUserLimit) { throw; }\n			InvestorID = investors.length;\n			investors.length++;\n		}\n		if (investors[InvestorID].valid && investors[InvestorID].live) {\n			investors[InvestorID].value += value_;\n		} else {\n			investors[InvestorID].value = value_;\n		}\n		investors[InvestorID].begins = currentGame;\n		investors[InvestorID].valid = true;\n		investors[InvestorID].live = true;\n		investors[InvestorID].owner = msg.sender;\n		investmentsValue += value_;\n		setJackpot();\n		InvestAddEvent(msg.sender, value_);\n	}\n	function InvestWithdraw() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		uint _balance = investors[InvestorID].balance;\n		if (_balance == 0) { throw; }\n		investors[InvestorID].balance = 0;\n		if ( ! msg.sender.send( _balance )) { throw; }\n	}\n	function InvestCancel() external noEther {\n		var (found, InvestorID) = getInvestorByAddress(msg.sender);\n		if (found == false) { throw; }\n		if ( ! investors[InvestorID].valid) { throw; }\n		if (contractEnabled) {\n			if (investors[InvestorID].begins+investMinDuration > now) { throw; }\n			if (games[currentGame].startTimestamp+investIdleTime > now) { throw; }\n		}\n		uint balance_;\n		if (investors[InvestorID].live) {\n			investmentsValue -= investors[InvestorID].value;\n			balance_ = investors[InvestorID].value;\n			setJackpot();\n			InvestCancelEvent(msg.sender, investors[InvestorID].value);\n		}\n		if (investors[InvestorID].balance > 0) {\n			balance_ += investors[InvestorID].balance;\n		}\n		delete investors[InvestorID];\n		if ( ! msg.sender.send( balance_ )) { throw; }\n	}\n	/* draw functions for everyone*/\n	function DrawPrepare() noContract OnlyEnabled noEther {\n		if (games[currentGame].endTimestamp > now || games[currentGame].prepareBlock != 0) { throw; }\n		games[currentGame].prepareBlock = block.number+drawBlockDelay;\n		DrawPrepareEvent(games[currentGame].prepareBlock);\n	}\n	function Draw() noContract OnlyEnabled noEther {\n		if (games[currentGame].prepareBlock == 0 || games[currentGame].prepareBlock > block.number) { throw; }\n		bytes32 _hash;\n		uint hit3Value;\n		uint hit3Count;\n		uint hit2Value;\n		uint hit2Count;\n		uint a;\n		for ( a = 1 ; a <= drawBlockDelay ; a++ ) {\n			_hash = sha3(_hash, block.blockhash(games[currentGame].prepareBlock - drawBlockDelay+a));\n		}\n		var numbers = getNumbersFromHash(_hash);\n		games[currentGame].winningNumbersBytes = getBytesFromNumbers( numbers );\n		hit3Count += games[currentGame].hit3Hash[ sha3( numbers[0], numbers[1],numbers[2] ) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[0], numbers[1]) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[0], numbers[2]) ];\n		hit2Count += games[currentGame].hit2Hash[ sha3( numbers[1], numbers[2]) ];\n		hit2Count -= hit3Count*3;\n		uint totalPot = games[currentGame].ticketsCount*ticketPrice;\n		hit2Value = ( totalPot * forHit2 / 100 );\n		games[currentGame].prizePot = hit2Value;\n		hit2Value = hit2Value / hit2Count;\n		totalPot -= hit2Value;\n		uint _ownerBalance = totalPot * forHit2 / 100;\n		totalPot -= _ownerBalance;\n		ownerBalance += _ownerBalance;\n		uint _addInvestorsValue = totalPot * forInvestors / 100;\n		addInvestorsValue(_addInvestorsValue);\n		totalPot -= _addInvestorsValue;\n		if (hit3Count > 0) {\n			games[currentGame].prizePot += currentJackpot;\n			for ( a=0 ; a < investors.length ; a++ ) {\n				delete investors[a].live;\n			}\n			hit3Value = currentJackpot / hit3Count;\n			extraJackpot = 0;\n			investmentsValue = 0;\n		}\n		extraJackpot += totalPot;\n		setJackpot();\n		DrawEvent(currentGame, numbers[0], numbers[1], numbers[2], hit3Count, hit3Value, hit2Count, hit2Value);\n		WLBdrawsDBInterface( WLBdrawsDB ).newDraw( now, numbers, hit3Count, hit3Value, hit2Count, hit2Value);\n		games[currentGame].hit3Count = hit3Count;\n		games[currentGame].hit3Value = hit3Value;\n		games[currentGame].hit2Count = hit2Count;\n		games[currentGame].hit2Value = hit2Value;\n		games[currentGame].drawDone = true;\n		newGame();\n	}\n	/* owner functions */\n	function OwnerGetFee() external OnlyOwner {\n		if (ownerBalance == 0) { throw; }\n		if (owner.send(ownerBalance) == false) { throw; }\n		ownerBalance = 0;\n	}\n	function OwnerCloseContract() external OnlyOwner noEther {\n		if ( ! contractEnabled) {\n			if (contractDisabledTimeStamp+contractDismissDelay < now) {\n				suicide(owner);\n			}\n		} else {\n			contractEnabled = false;\n			contractDisabledTimeStamp = now;\n			ContractDisabledEvent(contractDisabledTimeStamp+contractDismissDelay);\n			ownerBalance += extraJackpot;\n			extraJackpot = 0;\n		}\n	}\n	/* private functions */\n	function addInvestorsValue(uint value) private {\n		bool done;\n		uint a;\n		for ( a=0 ; a < investors.length ; a++ ) {\n			if (investors[a].live && investors[a].valid) {\n				investors[a].balance += value * investors[a].value / investmentsValue;\n				done = true;\n			}\n		}\n		if ( ! done) {\n			ownerBalance += value;\n		}\n	}\n	function newGame() private {\n		currentGame++;\n		uint gamesID = games.length;\n		games.length++;\n		games[gamesID].startTimestamp = now;\n		games[gamesID].endTimestamp = calcNextDrawTime();\n		if (games.length > prizeDismissDelay) {\n			ownerBalance += games[currentGame-prizeDismissDelay].prizePot;\n			delete games[currentGame-prizeDismissDelay];\n		}\n	}\n	function getNumbersFromHash(bytes32 hash) private returns (uint8[3] numbers) {\n		bool ok = true;\n		uint8 num = 0;\n		uint hashpos = 0;\n		uint8 a;\n		uint8 b;\n		for (a = 0 ; a < numbers.length ; a++) {\n			while (true) {\n				ok = true;\n				if (hashpos == 32) {\n					hashpos = 0;\n					hash = sha3(hash);\n				}\n				num = getPart( hash, hashpos );\n				num = num % uint8(drawMaxNumber) + 1;\n				hashpos += 1;\n				for (b = 0 ; b < numbers.length ; b++) {\n					if (numbers[b] == num) {\n						ok = false;\n						break; \n					}\n				}\n				if (ok == true) {\n					numbers[a] = num;\n					break;\n				}\n			}\n		}\n		numbers = sortNumbers( numbers );\n	}\n	function getPart(bytes32 a, uint i) private returns (uint8) { return uint8(byte(bytes32(uint(a) * 2 ** (8 * i)))); }\n	function setJackpot() private {\n		currentJackpot = investmentsValue + extraJackpot;\n	}\n	function getInvestorByAddress(address Address) private returns (bool found, uint id) {\n		for ( id=0 ; id < investors.length ; id++ ) {\n			if (investors[id].owner == Address) {\n				return (true, id);\n			}\n		}\n		return (false, 0);\n	}\n	function checkNumbers(uint8[3] Numbers) private returns (bool) {\n		for ( uint a = 0 ; a < Numbers.length ; a++ ) {\n			if (Numbers[a] > drawMaxNumber || Numbers[a] == 0) { return; }\n			for ( uint b = 0 ; a < Numbers.length ; a++ ) {\n				if (a != b && Numbers[a] == Numbers[b]) { return; }\n			}\n		}\n		return true;\n	}\n	function calcNextDrawTime() private returns (uint ret) {\n		ret = 1468152000;\n		while (ret < now) {\n			ret += 1 weeks;\n		}\n	}\n	function sortNumbers(uint8[3] numbers) private returns(uint8[3] sNumbers) {\n		sNumbers = numbers;\n		for (uint8 i=0; i<numbers.length; i++) {\n			for (uint8 j=i+1; j<numbers.length; j++) {\n				if (sNumbers[i] > sNumbers[j]) {\n					uint8 t = sNumbers[i];\n					sNumbers[i] = sNumbers[j];\n					sNumbers[j] = t;\n				}\n			}\n		}\n	}\n	function getNumbersFromBytes(bytes3 Bytes) private returns (uint8[3] Numbers){\n		Numbers[0] = uint8(Bytes);\n		Numbers[1] = uint8(uint24(Bytes) /256);\n		Numbers[2] = uint8(uint24(Bytes) /256/256);\n	}\n	function getBytesFromNumbers(uint8[3] Numbers) private returns (bytes3 Bytes) {\n		return bytes3(uint(Numbers[0])+uint(Numbers[1])*256+uint(Numbers[2])*256*256);\n	}\n	/* modifiers */\n	modifier noContract() {if (tx.origin != msg.sender) { throw; } _ }\n	modifier noEther() { if (msg.value > 0) { throw; } _ }\n	modifier OnlyOwner() { if (owner != msg.sender) { throw; } _ }\n	modifier OnlyEnabled() { if ( ! contractEnabled) { throw; } _ }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1901712,0xb671c3883307cf05bb3dff77a9754e87b4347195,false,false,contract HFConditionalTransfer {\n    function transferIfHF(address to) {\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance > 1000000 ether)\n            to.send(msg.value);\n        else\n            msg.sender.send(msg.value);\n    }\n    function transferIfNoHF(address to) {\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance <= 1000000 ether)\n            to.send(msg.value);\n        else\n            msg.sender.send(msg.value);\n    }\n},1,実用的な条件付き送金ロジックを持つが、特に芸術的要素はない。
1903115,0xe0b8fce1183e31c995b40460e6cb6712fa929f59,false,false,contract AmIOnTheFork {\n    bool public forked = false;\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    // Check the fork condition during creation of the contract.\n    // This function should be called between block 1920000 and 1930000.\n    // After that the status will be locked in.\n    function update() {\n        if (block.number >= 1920000 && block.number <= 1930000) {\n            forked = darkDAO.balance < 3600000 ether;\n        }\n    }\n    function() {\n        throw;\n    }\n},1,実用的なフォーク検出機能を持つ標準的なスマートコントラクト。
1903391,0x3e72548c1535beadcdf084ec13fd7850c49050ed,false,false,"contract testExpensiveFallback {\n    address constant WithdrawDAO = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\n    address constant DarkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    address constant veox = 0x1488e30b386903964b2797c97c9a3a678cf28eca;\n\n    // public, so accessors available\n    bool public ran;\n    bool public forked;\n    bool public notforked;\n    \n    modifier before_dao_hf_block {\n        if (block.number >= 1920000) throw;\n        _\n    }\n    \n    modifier run_once {\n        if (ran) throw;\n        _\n    }\n\n    modifier has_millions(address _addr, uint _millions) {\n        if (_addr.balance >= (_millions * 1000000 ether)) _\n    }\n\n    // 10M ether is ~ 2M less than would be available for a short\n    // while in WithdrawDAO after the HF, but probably more than\n    // anyone is willing to drop into WithdrawDAO in Classic\n    function check_withdrawdao() internal\n        has_millions(WithdrawDAO, 10) {\n        forked = true;\n    }\n\n    // failsafe: if the above assumption is incorrect, HF tine\n    // won't have balance in DarkDAO anyway, and Classic has a\n    // sliver of time before DarkDAO split happens\n    function check_darkdao() internal\n        has_millions(DarkDAO, 3) {\n        notforked = true;\n    }\n\n    function kill1() { suicide(veox); }\n    function kill2() { selfdestruct(veox); }\n    \n    // running is possible only once\n    // after that the dapp can only throw\n    function ()\n        before_dao_hf_block run_once {\n        ran = true;\n\n        check_withdrawdao();\n        check_darkdao();\n\n        // if both flags are same, then something went wrong\n        if (forked == notforked) throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1903875,0x33ada680b83d86b8d20067785222bb752efb56a8,false,false,"contract DataService {\n    event NewDataRequest(uint id, bool initialized, string dataUrl); \n    event GetDataRequestLength(uint length);\n    event GetDataRequest(uint id, bool initialized, string dataurl, uint dataPointsLength);\n\n    event AddDataPoint(uint dataRequestId, bool success, string response);\n    event GetDataPoint(uint dataRequestId, uint id, bool success, string response);\n\n    struct DataPoint {\n        bool initialized;\n        bool success;\n        string response; \n    }\n    struct DataRequest {\n        bool initialized;\n        string dataUrl;\n        DataPoint[] dataPoints;\n    }\n\n    address private organizer;\n    DataRequest[] private dataRequests;\n\n    // Create a new lottery with numOfBets supported bets.\n    function DataService() {\n        organizer = msg.sender;\n    }\n    \n    // Fallback function returns ether\n    function() {\n        throw;\n    }\n    \n    // Lets the organizer add a new data request\n    function addDataRequest(string dataUrl) {\n        // Only let organizer add requests for now\n        if(msg.sender != organizer) { throw; }\n\n        // Figure out where to store the new DataRequest (next available element)\n        uint nextIndex = dataRequests.length++;\n    \n        // Init the data request and save it\n        DataRequest newDataRequest = dataRequests[nextIndex];\n        newDataRequest.initialized = true;\n        newDataRequest.dataUrl = dataUrl;\n\n        NewDataRequest(dataRequests.length - 1, newDataRequest.initialized, newDataRequest.dataUrl);\n    }\n\n    // Returns the amount of dataRequests currently present\n    function getDataRequestLength() {\n        GetDataRequestLength(dataRequests.length);\n    }\n\n    // Logs the data request with the requested ID\n    function getDataRequest(uint id) {\n        DataRequest dataRequest = dataRequests[id];\n        GetDataRequest(id, dataRequest.initialized, dataRequest.dataUrl, dataRequest.dataPoints.length);\n    }\n\n    // Gets the data point associated with the provided dataRequest.\n    function getDataPoint(uint dataRequestId, uint dataPointId) {\n        DataRequest dataRequest = dataRequests[dataRequestId];\n        DataPoint dataPoint = dataRequest.dataPoints[dataPointId];\n\n        GetDataPoint(dataRequestId, dataPointId, dataPoint.success, dataPoint.response);\n    }\n\n    // Lets the organizer add a new data point\n    function addDataPoint(uint dataRequestId, bool success, string response) {\n        if(msg.sender != organizer) { throw; }\n        \n        // Get the DataRequest to edit, only allow adding a data point if initialized\n        DataRequest dataRequest = dataRequests[dataRequestId];\n        if(!dataRequest.initialized) { throw; }\n\n        // Init the new DataPoint and save it\n        DataPoint newDataPoint = dataRequest.dataPoints[dataRequest.dataPoints.length++];\n        newDataPoint.initialized = true;\n        newDataPoint.success = success;\n        newDataPoint.response = response;\n\n        AddDataPoint(dataRequestId, success, response);\n    }\n\n    // Suicide :(\n    function destroy() {\n        if(msg.sender != organizer) { throw; }\n        \n        suicide(organizer);\n    }\n}",1,標準的なデータ管理スマートコントラクトで、特に芸術的要素はありません。
1904232,0x2bd2326c993dfaef84f696526064ff22eba5b362,false,false,contract AmIOnTheFork {\n    bool public forked = false;\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    // Check the fork condition during creation of the contract.\n    // This function should be called between block 1920000 and 1921200.\n    // Approximately between 2016-07-20 12:00:00 UTC and 2016-07-20 17:00:00 UTC.\n    // After that the status will be locked in.\n    function update() {\n        if (block.number >= 1920000 && block.number <= 1921200) {\n            forked = darkDAO.balance < 3600000 ether;\n        }\n    }\n    function() {\n        throw;\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1908696,0xe7f4f5abba4a0ae18eaa31796876d137e19b93ad,false,false,contract ChainSensitive {\n    // store the data for long-term usability\n    uint256 public afterForkBlockNumber;\n    uint256 public afterForkRescueContractBalance;\n\n    // pre-fork: return 0\n    // puritanical: return 1\n    // dao-rescue (hard forked): return 2\n    function whichChainIsThis() internal returns (uint8) {\n        if (block.number >= 1920000) {\n            if (afterForkBlockNumber == 0) { // default\n                afterForkBlockNumber = block.number;\n                afterForkRescueContractBalance = address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance;\n            }\n            if (afterForkRescueContractBalance < 1000000 ether) {\n                return 1; // puritanical chain\n            } else {\n                return 2; // hard-forked dao-rescue chain\n            }\n        } else {\n            return 0; // pre-fork\n        }\n    }\n\n    function() {\n        secureSend(msg.sender);\n        whichChainIsThis();  // store data if not stored yet\n    }\n\n    function secureSend(address to) internal {\n        if (!to.send(msg.value))\n            throw;\n    }\n\n    function isThisPreforkVersion() returns (bool) {\n        secureSend(msg.sender);\n        return whichChainIsThis() == 0;\n    }\n    \n    function isThisPuritanicalVersion() returns (bool) {\n        secureSend(msg.sender);\n        return whichChainIsThis() == 1;\n    }\n\n    function isThisHardforkedVersion() returns (bool) {\n        secureSend(msg.sender);\n        return whichChainIsThis() == 2;\n    }\n\n    function transferIfPuritanical(address to) {\n        if (whichChainIsThis() == 1) {\n            secureSend(to);\n        } else {\n            secureSend(msg.sender);\n        }\n    }\n\n    function transferIfHardForked(address to) {\n        if (whichChainIsThis() == 2) {\n            secureSend(to);\n        } else {\n            secureSend(msg.sender);\n        }\n    }\n},1,DAOハードフォークを識別する実用的なコードで、特に芸術的な要素はありません。
1909252,0x60bf91ac87fee5a78c28f7b67701fbcfa79c18ec,false,false,"// This software is a subject to Ambisafe License Agreement.\n// No use or distribution is allowed without written permission from Ambisafe.\n// https://ambisafe.com/terms.pdf\n\ncontract Ambi {\n    function getNodeAddress(bytes32 _nodeName) constant returns(address);\n    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);\n    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);\n}\n\ncontract AmbiEnabled {\n    Ambi public ambiC;\n    bool public isImmortal;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            if (!ambiContract.addNode(_name, address(this))){\n                return false;\n            }\n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function immortality() checkAccess(""owner"") returns(bool) {\n        isImmortal = true;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") returns(bool) {\n        if (isImmortal) {\n            return false;\n        }\n        selfdestruct(msg.sender);\n        return true;\n    }\n}\n\nlibrary StackDepthLib {\n    // This will probably work with a value of 390 but no need to cut it\n    // that close in the case that the optimizer changes slightly or\n    // something causing that number to rise slightly.\n    uint constant GAS_PER_DEPTH = 400;\n\n    function checkDepth(address self, uint n) constant returns(bool) {\n        if (n == 0) return true;\n        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n    }\n\n    function __dig(uint n) constant {\n        if (n == 0) return;\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n    }\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\n/**\n * @title Events History universal contract.\n *\n * Contract serves as an Events storage and version history for a particular contract type.\n * Events appear on this contract address but their definitions provided by other contracts/libraries.\n * Version info is provided for historical and informational purposes.\n *\n * Note: all the non constant functions return false instead of throwing in case if state change\n * didn't happen yet.\n */\ncontract EventsHistory is AmbiEnabled, Safe {\n    // Event emitter signature to address with Event definiton mapping.\n    mapping(bytes4 => address) public emitters;\n\n    // Calling contract address to version mapping.\n    mapping(address => uint) public versions;\n\n    // Version to info mapping.\n    mapping(uint => VersionInfo) public versionInfo;\n\n    // Latest verion number.\n    uint public latestVersion;\n\n    struct VersionInfo {\n        uint block;        // Block number in which version has been introduced.\n        address by;        // Contract owner address who added version.\n        address caller;    // Address of this version calling contract.\n        string name;       // Version name, informative.\n        string changelog;  // Version changelog, informative.\n    }\n\n    /**\n     * Assign emitter address to a specified emit function signature.\n     *\n     * Can be set only once for each signature, and only by contract owner.\n     * Caller contract should be sure that emitter for a particular signature will never change.\n     *\n     * @param _eventSignature signature of the event emitting function.\n     * @param _emitter address with Event definition.\n     *\n     * @return success.\n     */\n    function addEmitter(bytes4 _eventSignature, address _emitter) noValue() checkAccess(""admin"") returns(bool) {\n        if (emitters[_eventSignature] != 0x0) {\n            return false;\n        }\n        emitters[_eventSignature] = _emitter;\n        return true;\n    }\n\n    /**\n     * Introduce new caller contract version specifing version information.\n     *\n     * Can be set only once for each caller, and only by contract owner.\n     * Name and changelog should not be empty.\n     *\n     * @param _caller address of the new caller.\n     * @param _name version name.\n     * @param _changelog version changelog.\n     *\n     * @return success.\n     */\n    function addVersion(address _caller, string _name, string _changelog) noValue() checkAccess(""admin"") returns(bool) {\n        if (versions[_caller] != 0) {\n            return false;\n        }\n        if (bytes(_name).length == 0) {\n            return false;\n        }\n        if (bytes(_changelog).length == 0) {\n            return false;\n        }\n        uint version = ++latestVersion;\n        versions[_caller] = version;\n        versionInfo[version] = VersionInfo(block.number, msg.sender, _caller, _name, _changelog);\n        return true;\n    }\n\n    /**\n     * Event emitting fallback.\n     *\n     * Can be and only called caller with assigned version.\n     * Resolves msg.sig to an emitter address, and calls it to emit an event.\n     *\n     * Throws if emit function signature is not registered, or call failed.\n     */\n    function () noValue() {\n        if (versions[msg.sender] == 0) {\n            return;\n        }\n        // Internal Out Of Gas/Throw: revert this transaction too;\n        // Call Stack Depth Limit reached: revert this transaction too;\n        // Recursive Call: safe, all changes already made.\n        if (!emitters[msg.sig].delegatecall(msg.data)) {\n            throw;\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1909268,0x96a51938cfb22565e0d40694fe103675c63ae218,false,false,"// This software is a subject to Ambisafe License Agreement.\n// No use or distribution is allowed without written permission from Ambisafe.\n// https://ambisafe.com/terms.pdf\n\ncontract Ambi {\n    function getNodeAddress(bytes32 _nodeName) constant returns(address);\n    function hasRelation(bytes32 _nodeName, bytes32 _relation, address _to) constant returns(bool);\n    function addNode(bytes32 _nodeName, address _nodeAddress) constant returns(bool);\n}\n\ncontract AmbiEnabled {\n    Ambi public ambiC;\n    bool public isImmortal;\n    bytes32 public name;\n\n    modifier checkAccess(bytes32 _role) {\n        if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){\n            _\n        }\n    }\n    \n    function getAddress(bytes32 _name) constant returns (address) {\n        return ambiC.getNodeAddress(_name);\n    }\n\n    function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){\n        if(address(ambiC) != 0x0){\n            return false;\n        }\n        Ambi ambiContract = Ambi(_ambi);\n        if(ambiContract.getNodeAddress(_name)!=address(this)) {\n            if (!ambiContract.addNode(_name, address(this))){\n                return false;\n            }\n        }\n        name = _name;\n        ambiC = ambiContract;\n        return true;\n    }\n\n    function immortality() checkAccess(""owner"") returns(bool) {\n        isImmortal = true;\n        return true;\n    }\n\n    function remove() checkAccess(""owner"") returns(bool) {\n        if (isImmortal) {\n            return false;\n        }\n        selfdestruct(msg.sender);\n        return true;\n    }\n}\n\nlibrary StackDepthLib {\n    // This will probably work with a value of 390 but no need to cut it\n    // that close in the case that the optimizer changes slightly or\n    // something causing that number to rise slightly.\n    uint constant GAS_PER_DEPTH = 400;\n\n    function checkDepth(address self, uint n) constant returns(bool) {\n        if (n == 0) return true;\n        return self.call.gas(GAS_PER_DEPTH * n)(0x21835af6, n - 1);\n    }\n\n    function __dig(uint n) constant {\n        if (n == 0) return;\n        if (!address(this).delegatecall(0x21835af6, n - 1)) throw;\n    }\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\ncontract RegistryICAP is AmbiEnabled, Safe {\n    function decodeIndirect(bytes _bban) constant returns(string, string, string) {\n        bytes memory asset = new bytes(3);\n        bytes memory institution = new bytes(4);\n        bytes memory client = new bytes(9);\n\n        uint8 k = 0;\n\n        for (uint8 i = 0; i < asset.length; i++) {\n            asset[i] = _bban[k++];\n        }\n        for (i = 0; i < institution.length; i++) {\n            institution[i] = _bban[k++];\n        }\n        for (i = 0; i < client.length; i++) {\n            client[i] = _bban[k++];\n        }\n        return (string(asset), string(institution), string(client));\n    }\n\n    function parse(bytes32 _icap) constant returns(address, bytes32, bool) {\n        // Should start with XE.\n        if (_icap[0] != 88 || _icap[1] != 69) {\n            return (0, 0, false);\n        }\n        // Should have 12 zero bytes at the end.\n        for (uint8 j = 20; j < 32; j++) {\n            if (_icap[j] != 0) {\n                return (0, 0, false);\n            }\n        }\n        bytes memory bban = new bytes(18);\n        for (uint8 i = 0; i < 16; i++) {\n             bban[i] = _icap[i + 4];\n        }\n        var (asset, institution, _) = decodeIndirect(bban);\n\n        bytes32 assetInstitutionHash = sha3(asset, institution);\n\n        uint8 parseChecksum = (uint8(_icap[2]) - 48) * 10 + (uint8(_icap[3]) - 48);\n        uint8 calcChecksum = 98 - mod9710(prepare(bban));\n        if (parseChecksum != calcChecksum) {\n            return (institutions[assetInstitutionHash], assets[sha3(asset)], false);\n        }\n        return (institutions[assetInstitutionHash], assets[sha3(asset)], registered[assetInstitutionHash]);\n    }\n\n    function prepare(bytes _bban) constant returns(bytes) {\n        for (uint8 i = 0; i < 16; i++) {\n            uint8 charCode = uint8(_bban[i]);\n            if (charCode >= 65 && charCode <= 90) {\n                _bban[i] = byte(charCode - 65 + 10);\n            }\n        }\n        _bban[16] = 33; // X\n        _bban[17] = 14; // E\n        //_bban[18] = 48; // 0\n        //_bban[19] = 48; // 0\n        return _bban;\n    }\n\n    function mod9710(bytes _prepared) constant returns(uint8) {\n        uint m = 0;\n        for (uint8 i = 0; i < 18; i++) {\n            uint8 charCode = uint8(_prepared[i]);\n            if (charCode >= 48) {\n                m *= 10;\n                m += charCode - 48; // number\n                m %= 97;\n            } else {\n                m *= 10;\n                m += charCode / 10; // part1\n                m %= 97;\n                m *= 10;\n                m += charCode % 10; // part2\n                m %= 97;\n            }\n        }\n        m *= 10;\n        //m += uint8(_prepared[18]) - 48;\n        m %= 97;\n        m *= 10;\n        //m += uint8(_prepared[19]) - 48;\n        m %= 97;\n        return uint8(m);\n    }\n\n    mapping(bytes32 => bool) public registered;\n    mapping(bytes32 => address) public institutions;\n    mapping(bytes32 => address) public institutionOwners;\n    mapping(bytes32 => bytes32) public assets;\n\n    modifier onlyInstitutionOwner(string _institution) {\n        if (msg.sender == institutionOwners[sha3(_institution)]) {\n            _\n        }\n    }\n\n    function changeInstitutionOwner(string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n        institutionOwners[sha3(_institution)] = _address;\n        return true;\n    }\n\n    // web3js sendIBANTransaction interface\n    function addr(bytes32 _institution) constant returns(address) {\n        return institutions[sha3(""ETH"", _institution[0], _institution[1], _institution[2], _institution[3])];\n    }\n\n    function registerInstitution(string _institution, address _address) noValue() checkAccess(""admin"") returns(bool) {\n        if (bytes(_institution).length != 4) {\n            return false;\n        }\n        if (institutionOwners[sha3(_institution)] != 0) {\n            return false;\n        }\n        institutionOwners[sha3(_institution)] = _address;\n        return true;\n    }\n\n    function registerInstitutionAsset(string _asset, string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n        if (!registered[sha3(_asset)]) {\n            return false;\n        }\n        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n        if (registered[assetInstitutionHash]) {\n            return false;\n        }\n        registered[assetInstitutionHash] = true;\n        institutions[assetInstitutionHash] = _address;\n        return true;\n    }\n\n    function updateInstitutionAsset(string _asset, string _institution, address _address) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n        if (!registered[assetInstitutionHash]) {\n            return false;\n        }\n        institutions[assetInstitutionHash] = _address;\n        return true;\n    }\n\n    function removeInstitutionAsset(string _asset, string _institution) noValue() onlyInstitutionOwner(_institution) returns(bool) {\n        bytes32 assetInstitutionHash = sha3(_asset, _institution);\n        if (!registered[assetInstitutionHash]) {\n            return false;\n        }\n        delete registered[assetInstitutionHash];\n        delete institutions[assetInstitutionHash];\n        return true;\n    }\n\n    function registerAsset(string _asset, bytes32 _symbol) noValue() checkAccess(""admin"") returns(bool) {\n        if (bytes(_asset).length != 3) {\n            return false;\n        }\n        bytes32 asset = sha3(_asset);\n        if (registered[asset]) {\n            return false;\n        }\n        registered[asset] = true;\n        assets[asset] = _symbol;\n        return true;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1912483,0x5b2ff75d7eaa47db475707dae12a688102ef4290,false,false,"//Simple Msg XChange Registrar (does not provide validateion!)\ncontract Message {\n	address public registrar;	\n	address public from;\n	address public to;\n	string public hash_msg;\n	string public hash_ack;\n	uint256 public timestamp_msg;\n	uint256 public timestamp_ack;\n	\n	\n	function Message(address _registrar,address _from,address _to,string _hash_msg) {\n		registrar=_registrar;\n		from=_from;\n		to=_to;\n		hash_msg=_hash_msg;\n		timestamp_msg=now;\n	}\n	\n	function ack(string _hash) {\n		if(msg.sender!=to) throw;\n		if(timestamp_ack>0) throw;\n		hash_ack=_hash;\n		timestamp_ack=now;		\n	}\n	\n	function() {\n		if(msg.value>0) {\n			if(msg.sender==from) {			\n				to.send(msg.value);\n			} else {\n				from.send(msg.value);\n			}\n		}\n	}\n	\n}\ncontract Registrar\n{\n	address public registrar;		\n	\n	uint256 public fee_registration;\n	uint256 public fee_msg;\n	uint256 public cnt_registrations;\n	\n	struct Registration {\n		address adr;\n		string hash;\n		string gnid;\n	}	\n	\n	mapping(address=>Registration) public regadr;	\n	mapping(address=>Message[]) public msgs;\n	mapping(address=>Message[]) public sent;\n	mapping(address=>bool) public preregister;	\n	\n	Registration[] public regs;\n	\n	function Registrar() {\n		registrar=msg.sender;\n	}\n	\n	function register(string hash) {\n		updateRegistration(hash,'');		\n	}\n	\n	function unregister() {\n		delete regadr[msg.sender];\n	}\n	\n	function updateRegistration(string hash,string gnid) {		\n		if((msg.value>=fee_registration)||(preregister[msg.sender])) {			\n			regadr[msg.sender]=Registration(msg.sender,hash,gnid);\n			regs.push(regadr[msg.sender]);\n			if(fee_registration>0) registrar.send(this.balance);\n			preregister[msg.sender]=false;\n			cnt_registrations++;\n		} else throw;\n	}\n	\n	function preRegister(address preReg) {\n		if(msg.sender!=registrar) throw;\n		preReg.send(msg.value);		\n		preregister[preReg]=true;\n	}\n	\n	function getMsgs() returns (Message[]) {\n		return msgs[msg.sender];	\n	}\n	\n	function setRegistrationPrice(uint256 price) {\n		if(msg.sender!=registrar) throw;\n		fee_registration=price;\n	}\n	\n	function setMsgPrice(uint256 price) {\n		if(msg.sender!=registrar) throw;\n		fee_msg=price;\n	}\n	\n	function sendMsg(address to,string hash) {\n		if(msg.value>=fee_msg) {	\n			    Message m = new  Message(this,msg.sender,to,hash);\n				msgs[to].push(m);	\n			    sent[msg.sender].push(m);\n			if(fee_msg>0) registrar.send(this.balance);\n		} else throw;		\n	}\n	\n	function ackMsg(uint256 msgid,string hash) {\n		Message message =Message(msgs[msg.sender][msgid]);\n		message.ack(hash);\n	}\n	\n	function() {\n		if(msg.value>0) {\n			registrar.send(msg.value);\n		}\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1914761,0xe4c7b738421cf218c2542d392cbde4623c62702a,false,false,"/*\nCopyright (c) 2015-2016 Oraclize srl, Thomas Bertani\n*/\n\ncontract AmIOnTheFork{\n    function forked() constant returns(bool);\n}\n\n\ncontract Oraclize {\n    mapping (address => uint) reqc;\n    \n    address public cbAddress = 0x26588a9301b0428d95e6fc3a5024fce8bec12d51;\n    \n    address constant AmIOnTheForkAddress = 0x2bd2326c993dfaef84f696526064ff22eba5b362;\n    \n    event Log1(address sender, bytes32 cid, uint timestamp, string datasource, string arg, uint gaslimit, byte proofType, uint gasPrice);\n    event Log2(address sender, bytes32 cid, uint timestamp, string datasource, string arg1, string arg2, uint gaslimit, byte proofType, uint gasPrice);\n    \n    address owner;\n    \n    modifier onlyadmin {\n        if ((msg.sender != owner)&&(msg.sender != cbAddress)) throw;\n        _\n    }\n    \n    function addDSource(string dsname, uint multiplier) {\n        addDSource(dsname, 0x00, multiplier);\n    }\n    \n    function addDSource(string dsname, byte proofType, uint multiplier) onlyadmin {\n        bytes32 dsname_hash = sha3(dsname, proofType);\n        dsources[dsources.length++] = dsname_hash;\n        price_multiplier[dsname_hash] = multiplier;\n    }\n\n    mapping (bytes32 => bool) coupons;\n    bytes32 coupon;\n    \n    function createCoupon(string _code) onlyadmin {\n        coupons[sha3(_code)] = true;\n    }\n    \n    function deleteCoupon(string _code) onlyadmin {\n        coupons[sha3(_code)] = false;\n    }\n    \n    function multisetProofType(uint[] _proofType, address[] _addr) onlyadmin {\n        for (uint i=0; i<_addr.length; i++) addr_proofType[_addr[i]] = byte(_proofType[i]);\n    }\n    \n    function multisetCustomGasPrice(uint[] _gasPrice, address[] _addr) onlyadmin {\n        for (uint i=0; i<_addr.length; i++) addr_gasPrice[_addr[i]] = _gasPrice[i];\n    }\n\n    uint gasprice = 20000000000;\n    \n    function setGasPrice(uint newgasprice) onlyadmin {\n        gasprice = newgasprice;\n    }\n    \n    function setBasePrice(uint new_baseprice) onlyadmin { //0.001 usd in ether\n        baseprice = new_baseprice;\n        for (uint i=0; i<dsources.length; i++) price[dsources[i]] = new_baseprice*price_multiplier[dsources[i]];\n    }\n\n    function setBasePrice(uint new_baseprice, bytes proofID) onlyadmin { //0.001 usd in ether\n        baseprice = new_baseprice;\n        for (uint i=0; i<dsources.length; i++) price[dsources[i]] = new_baseprice*price_multiplier[dsources[i]];\n    }\n    \n    function withdrawFunds(address _addr) onlyadmin {\n        _addr.send(this.balance);\n    }\n    \n    function() onlyadmin {}\n    \n    function Oraclize() {\n        owner = msg.sender;\n    }\n    \n    modifier costs(string datasource, uint gaslimit) {\n        uint price = getPrice(datasource, gaslimit, msg.sender);\n        if (msg.value >= price){\n            uint diff = msg.value - price;\n            if (diff > 0) msg.sender.send(diff);\n            _\n        } else throw;\n    }\n\n    mapping (address => byte) addr_proofType;\n    mapping (address => uint) addr_gasPrice;\n    uint public baseprice;\n    mapping (bytes32 => uint) price;\n    mapping (bytes32 => uint) price_multiplier;\n    bytes32[] dsources;\n    function useCoupon(string _coupon) {\n        coupon = sha3(_coupon);\n    }\n    \n    function setProofType(byte _proofType) {\n        addr_proofType[msg.sender] = _proofType;\n    }\n    \n    function setCustomGasPrice(uint _gasPrice) {\n        addr_gasPrice[msg.sender] = _gasPrice;\n    }\n    \n    function getPrice(string _datasource) public returns (uint _dsprice) {\n        return getPrice(_datasource, msg.sender);\n    }\n    \n    function getPrice(string _datasource, uint _gaslimit) public returns (uint _dsprice) {\n        return getPrice(_datasource, _gaslimit, msg.sender);\n    }\n    \n    function getPrice(string _datasource, address _addr) private returns (uint _dsprice) {\n        return getPrice(_datasource, 200000, _addr);\n    }\n    \n    function getPrice(string _datasource, uint _gaslimit, address _addr) private returns (uint _dsprice) {\n        if ((_gaslimit <= 200000)&&(reqc[_addr] == 0)&&(tx.origin != cbAddress)) return 0;\n        if ((coupon != 0)&&(coupons[coupon] == true)) return 0;\n        _dsprice = price[sha3(_datasource, addr_proofType[_addr])];\n        uint gasprice_ = addr_gasPrice[_addr];\n        if (gasprice_ == 0) gasprice_ = gasprice; \n        _dsprice += _gaslimit*gasprice_;\n        return _dsprice;\n    }\n    \n    function query(string _datasource, string _arg) returns (bytes32 _id) {\n        return query1(0, _datasource, _arg, 200000);\n    }\n    \n    function query1(string _datasource, string _arg) returns (bytes32 _id) {\n        return query1(0, _datasource, _arg, 200000);\n    }\n    \n    function query2(string _datasource, string _arg1, string _arg2) returns (bytes32 _id) {\n        return query2(0, _datasource, _arg1, _arg2, 200000);\n    }\n    \n    function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id) {\n        return query1(_timestamp, _datasource, _arg, 200000);\n    }\n    \n    function query1(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id) {\n        return query1(_timestamp, _datasource, _arg, 200000);\n    }\n    \n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id) {\n        return query2(_timestamp, _datasource, _arg1, _arg2, 200000);\n    }\n    \n    function query(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\n    }\n    \n    function query1(uint _timestamp, string _datasource, string _arg, uint _gaslimit) costs(_datasource, _gaslimit) returns (bytes32 _id) {\n	if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;\n	bool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();\n        _id = sha3(forkFlag, this, msg.sender, reqc[msg.sender]);\n        reqc[msg.sender]++;\n        Log1(msg.sender, _id, _timestamp, _datasource, _arg, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\n        return _id;\n    }\n    \n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) costs(_datasource, _gaslimit) returns (bytes32 _id) {\n	if ((_timestamp > now+3600*24*60)||(_gaslimit > block.gaslimit)) throw;\n	bool forkFlag = AmIOnTheFork(AmIOnTheForkAddress).forked();\n        _id = sha3(forkFlag, this, msg.sender, reqc[msg.sender]);\n        reqc[msg.sender]++;\n        Log2(msg.sender, _id, _timestamp, _datasource, _arg1, _arg2, _gaslimit, addr_proofType[msg.sender], addr_gasPrice[msg.sender]);\n        return _id;\n    }\n    \n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\n        return query(_timestamp, _datasource, _arg, _gaslimit);\n    }\n    \n    function query1_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id) {\n        return query1(_timestamp, _datasource, _arg, _gaslimit);\n    }\n    \n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id) {\n        return query2(_timestamp, _datasource, _arg1, _arg2, _gaslimit);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1914926,0x6a6581a884c4729586479307e5694bf836617517,false,false,"// DAO>9000 (http://dao9000.com) under CC0\n\ncontract Dao9000 {\n    string message; //This is variable is first for easier interaction with outside world (offset 0x0), contains latest member message\n    address[] public members;\n\n    function Dao9000 () {\n        members.push (msg.sender); //The contact owner is added as the first member\n        message = ""Message not yet defined"";\n    }\n    \n    //These two functions are for easier external interaction via api.etherscan.io:\n    function getMembers () constant returns (uint256 retVal) {\n        return members.length;\n    }\n    \n    function getMessage () constant returns (string retVal) {\n        return message;\n    }\n    \n    //This is the default function, this is called when normal transaction is made\n    function () {\n        //Since this is a DAO parody, we really do not let people invest more than 1.5 ETH max.\n        if (msg.value < 1500000000000000000 && msg.value > 1) {\n            //RNG happens here: for the ""seed"" hash of the previous block is taken, and current timestamp is added\n            uint256 randomIndex = (uint256(block.blockhash(block.number-1)) + now) % members.length;\n            if (members[randomIndex].send(msg.value)) {\n                if (msg.data.length > 0)\n                    message = string(msg.data); //If additional message is defined, we save it here\n                members.push (msg.sender); //After a successful transaction, new member is added, multiple entries for same member are permitted\n            } else {\n                throw;\n            }\n        } else {\n            throw;\n        }\n    }\n}",1,DAOのパロディとしての実用的なスマートコントラクトで、特に芸術的な要素はない。
1916421,0x017bc6ceadee1223026a6bb9b6dcdb43f8173abe,false,false,"//                       , ; ,   .-'""""""'-.   , ; ,\n//                       \\|/  .'          '.  \|//\n//                        \-;-/   ()   ()   \-;-/\n//                        // ;               ; \\\n//                       //__; :.         .; ;__\\\n//                      `-----\'.'-.....-'.'/-----'\n//                             '.'.-.-,_.'.'\n//                               '(  (..-'\n//                                 '-'\n//  ROULETH \n//\n//  Play the Roulette on ethereum blockchain !\n//  (or become a member of Rouleth's Decentralized Organisation  and contribute to the bankroll.) \n//\n//\n//\n//   check latest contract address version on the current website interface\n//   V 2\n//\n//\n//\n\ncontract Rouleth\n{\n    //Game and Global Variables, Structure of gambles\n    address developer;\n    uint8 blockDelay; //nb of blocks to wait before spin\n    uint8 blockExpiration; //nb of blocks before bet expiration (due to hash storage limits)\n    uint256 maxGamble; //max gamble value manually set by config\n    uint256 minGamble; //min gamble value manually set by config\n    uint maxBetsPerBlock; //limits the number of bets per blocks to prevent miner cheating\n    uint nbBetsCurrentBlock; //counts the nb of bets in the block\n    uint casinoStatisticalLimit; //ratio payroll and max win\n    //Current gamble value possibly lower than limit auto\n    uint256 currentMaxGamble; \n    //Gambles\n    enum BetTypes{number, color, parity, dozen, column, lowhigh} \n    struct Gamble\n    {\n	address player;\n        bool spinned; //Was the rouleth spinned ?\n	bool win;\n	//Possible bet types\n        BetTypes betType;\n	uint8 input; //stores number, color, dozen or oddeven\n	uint256 wager;\n	uint256 blockNumber; //block of bet\n	uint256 blockSpinned; //block of spin\n        uint8 wheelResult;\n    }\n    Gamble[] private gambles;\n    uint totalGambles; \n    //Tracking progress of players\n    mapping (address=>uint) gambleIndex; //current gamble index of the player\n    //records current status of player\n    enum Status {waitingForBet, waitingForSpin} mapping (address=>Status) playerStatus; \n\n\n    //**********************************************\n    //        Management & Config FUNCTIONS        //\n    //**********************************************\n\n    function  Rouleth() private //creation settings\n    { \n        developer = msg.sender;\n        blockDelay=1; //indicates which block after bet will be used for RNG\n	blockExpiration=200; //delay after which gamble expires\n        minGamble=50 finney; //configurable min bet\n        maxGamble=500 finney; //configurable max bet\n        maxBetsPerBlock=5; // limit of bets per block, to prevent multiple bets per miners\n        casinoStatisticalLimit=100; //we are targeting at least 400\n    }\n    \n    modifier onlyDeveloper() \n    {\n	if (msg.sender!=developer) throw;\n	_\n    }\n    \n    function changeDeveloper_only_Dev(address new_dev)\n    noEthSent\n    onlyDeveloper\n    {\n	developer=new_dev;\n    }\n\n    //Prevents accidental sending of Eth when you shouldn't\n    modifier noEthSent()\n    {\n        if (msg.value>0) \n	{\n	    throw;\n	}\n        _\n    }\n\n\n    //Activate, Deactivate Betting\n    enum States{active, inactive} States private contract_state;\n    \n    function disableBetting_only_Dev()\n    noEthSent\n    onlyDeveloper\n    {\n        contract_state=States.inactive;\n    }\n\n\n    function enableBetting_only_Dev()\n    noEthSent\n    onlyDeveloper\n    {\n        contract_state=States.active;\n\n    }\n    \n    modifier onlyActive()\n    {\n        if (contract_state==States.inactive) throw;\n        _\n    }\n\n\n\n    //Change some settings within safety bounds\n    function changeSettings_only_Dev(uint newCasinoStatLimit, uint newMaxBetsBlock, uint256 newMinGamble, uint256 newMaxGamble, uint16 newMaxInvestor, uint256 newMinInvestment,uint256 newMaxInvestment, uint256 newLockPeriod, uint8 newBlockDelay, uint8 newBlockExpiration)\n    noEthSent\n    onlyDeveloper\n    {\n\n\n        // changes the statistical multiplier that guarantees the long run casino survival\n        if (newCasinoStatLimit<100) throw;\n        casinoStatisticalLimit=newCasinoStatLimit;\n        //Max number of bets per block to prevent miner cheating\n        maxBetsPerBlock=newMaxBetsBlock;\n        //MAX BET : limited by payroll/(casinoStatisticalLimit*35)\n        if (newMaxGamble<newMinGamble) throw;  \n	else { maxGamble=newMaxGamble; }\n        //Min Bet\n        if (newMinGamble<0) throw; \n	else { minGamble=newMinGamble; }\n        //MAX NB of DAO members (can only increase (within bounds) or stay equal)\n        //this number of members can only increase after 25k spins on Rouleth\n        //refuse change of max number of members if less than 25k spins played\n        if (newMaxInvestor!=setting_maxInvestors && gambles.length<25000) throw;\n        if ( newMaxInvestor<setting_maxInvestors \n             || newMaxInvestor>investors.length) throw;\n        else { setting_maxInvestors=newMaxInvestor;}\n        //computes the results of the vote of the VIP members, fees to apply to new members\n        computeResultVoteExtraInvestFeesRate();\n        if (newMaxInvestment<newMinInvestment) throw;\n        //MIN INVEST : \n        setting_minInvestment=newMinInvestment;\n        //MAX INVEST : \n        setting_maxInvestment=newMaxInvestment;\n        //Invest LOCK PERIOD\n	//1 year max\n	//can also serve as a failsafe to shutdown withdraws for a period\n        if (setting_lockPeriod>360 days) throw; \n        setting_lockPeriod=newLockPeriod;\n        //Delay before spin :\n	blockDelay=newBlockDelay;\n	if (newBlockExpiration<blockDelay+20) throw;\n	blockExpiration=newBlockExpiration;\n        updateMaxBet();\n    }\n\n\n    //**********************************************\n    //                 Nicknames FUNCTIONS                    //\n    //**********************************************\n\n    //User set nickname\n    mapping (address => string) nicknames;\n    function setNickname(string name) \n    noEthSent\n    {\n        if (bytes(name).length >= 2 && bytes(name).length <= 30)\n            nicknames[msg.sender] = name;\n    }\n    function getNickname(address _address) constant returns(string _name) {\n        _name = nicknames[_address];\n    }\n\n    \n    //**********************************************\n    //                 BETTING FUNCTIONS                    //\n    //**********************************************\n\n    //***//basic betting without Mist or contract call\n    //activates when the player only sends eth to the contract\n    //without specifying any type of bet.\n    function () \n    {\n	//defaut bet : bet on red\n	betOnColor(true,false);\n    } \n\n    //Admin function that\n    //recalculates max bet\n    //updated after each bet and change of bankroll\n    function updateMaxBet() private\n    {\n	//check that setting is still within safety bounds\n        if (payroll/(casinoStatisticalLimit*35) > maxGamble) \n	{ \n	    currentMaxGamble=maxGamble;\n        }\n	else\n	{ \n	    currentMaxGamble = payroll/(casinoStatisticalLimit*35);\n	}\n    }\n\n\n    //***//Guarantees that gamble is under max bet and above min.\n    // returns bet value\n    function checkBetValue() private returns(uint256 playerBetValue)\n    {\n        if (msg.value < minGamble) throw;\n	if (msg.value > currentMaxGamble) //if above max, send difference back\n	{\n            playerBetValue=currentMaxGamble;\n	}\n        else\n        { playerBetValue=msg.value; }\n        return;\n    }\n\n\n    //check number of bets in block (to prevent miner cheating)\n    modifier checkNbBetsCurrentBlock()\n    {\n        if (gambles.length!=0 && block.number==gambles[gambles.length-1].blockNumber) nbBetsCurrentBlock+=1;\n        else nbBetsCurrentBlock=0;\n        if (nbBetsCurrentBlock>=maxBetsPerBlock) throw;\n        _\n    }\n\n\n    //Function record bet called by all others betting functions\n    function placeBet(BetTypes betType_, uint8 input_) private\n    {\n	// Before we record, we may have to spin the past bet if the croupier bot \n	// is down for some reason or if the player played again too quickly.\n	// This would fail though if the player tries too play to quickly (in consecutive block).\n	// gambles should be spaced by at least a block\n	// the croupier bot should spin within 2 blocks (~30 secs) after your bet.\n	// if the bet expires it is added to casino profit, otherwise it would be a way to cheat\n	if (playerStatus[msg.sender]!=Status.waitingForBet)\n	{\n            SpinTheWheel(msg.sender);\n	}\n        //Once this is done, we can record the new bet\n	playerStatus[msg.sender]=Status.waitingForSpin;\n	gambleIndex[msg.sender]=gambles.length;\n        totalGambles++;\n        //adapts wager to casino limits\n        uint256 betValue = checkBetValue();\n	gambles.push(Gamble(msg.sender, false, false, betType_, input_, betValue, block.number, 0, 37)); //37 indicates not spinned yet\n	//refund excess bet (at last step vs re-entry)\n        if (betValue<msg.value) \n        {\n 	    if (msg.sender.send(msg.value-betValue)==false) throw;\n        }\n    }\n\n\n    //***//bet on Number	\n    function betOnNumber(uint8 numberChosen)\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        //check that number chosen is valid and records bet\n        if (numberChosen>36) throw;\n        placeBet(BetTypes.number, numberChosen);\n    }\n\n    //***// function betOnColor\n    //bet type : color\n    //input : 0 for red\n    //input : 1 for black\n    function betOnColor(bool Red, bool Black)\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Red) \n        { \n            count+=1; \n            input=0;\n        }\n        if (Black) \n        {\n            count+=1; \n            input=1;\n        }\n        if (count!=1) throw;\n        placeBet(BetTypes.color, input);\n    }\n\n    //***// function betOnLow_High\n    //bet type : lowhigh\n    //input : 0 for low\n    //input : 1 for low\n    function betOnLowHigh(bool Low, bool High)\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Low) \n        { \n            count+=1; \n            input=0;\n        }\n        if (High) \n        {\n            count+=1; \n            input=1;\n        }\n        if (count!=1) throw;\n        placeBet(BetTypes.lowhigh, input);\n    }\n\n    //***// function betOnOddEven\n    //bet type : parity\n    //input : 0 for even\n    //input : 1 for odd\n    function betOnOddEven(bool Odd, bool Even)\n    onlyActive\n    checkNbBetsCurrentBlock\n    {\n        uint8 count;\n        uint8 input;\n        if (Even) \n        { \n            count+=1; \n            input=0;\n        }\n        if (Odd) \n        {\n            count+=1; \n            input=1;\n        }\n        if (count!=1) throw;\n        placeBet(BetTypes.parity, input);\n    }\n\n\n    //***// function betOnDozen\n    //     //bet type : dozen\n    //     //input : 0 for first dozen\n    //     //input : 1 for second dozen\n    //     //input : 2 for third dozen\n    function betOnDozen(bool First, bool Second, bool Third)\n    {\n        betOnColumnOrDozen(First,Second,Third, BetTypes.dozen);\n    }\n\n\n    // //***// function betOnColumn\n    //     //bet type : column\n    //     //input : 0 for first column\n    //     //input : 1 for second column\n    //     //input : 2 for third column\n    function betOnColumn(bool First, bool Second, bool Third)\n    {\n        betOnColumnOrDozen(First, Second, Third, BetTypes.column);\n    }\n\n    function betOnColumnOrDozen(bool First, bool Second, bool Third, BetTypes bet) private\n    onlyActive\n    checkNbBetsCurrentBlock\n    { \n        uint8 count;\n        uint8 input;\n        if (First) \n        { \n            count+=1; \n            input=0;\n        }\n        if (Second) \n        {\n            count+=1; \n            input=1;\n        }\n        if (Third) \n        {\n            count+=1; \n            input=2;\n        }\n        if (count!=1) throw;\n        placeBet(bet, input);\n    }\n\n\n    //**********************************************\n    // Spin The Wheel & Check Result FUNCTIONS//\n    //**********************************************\n\n    event Win(address player, uint8 result, uint value_won, bytes32 bHash, bytes32 sha3Player, uint gambleId);\n    event Loss(address player, uint8 result, uint value_loss, bytes32 bHash, bytes32 sha3Player, uint gambleId);\n\n    //***//function to spin callable\n    // no eth allowed\n    function spinTheWheel(address spin_for_player)\n    noEthSent\n    {\n        SpinTheWheel(spin_for_player);\n    }\n\n\n    function SpinTheWheel(address playerSpinned) private\n    {\n        if (playerSpinned==0)\n	{\n	    playerSpinned=msg.sender;         //if no index spins for the sender\n	}\n\n	//check that player has to spin\n        if (playerStatus[playerSpinned]!=Status.waitingForSpin) throw;\n        //redundent double check : check that gamble has not been spinned already\n        if (gambles[gambleIndex[playerSpinned]].spinned==true) throw;\n        //check that the player waited for the delay before spin\n        //and also that the bet is not expired\n	uint playerblock = gambles[gambleIndex[playerSpinned]].blockNumber;\n        //too early to spin\n	if (block.number<=playerblock+blockDelay) throw;\n        //too late, bet expired, player lost\n        else if (block.number>playerblock+blockExpiration)  solveBet(playerSpinned, 255, false, 1, 0, 0) ;\n	//spin !\n        else\n	{\n	    uint8 wheelResult;\n            //Spin the wheel, \n            bytes32 blockHash= block.blockhash(playerblock+blockDelay);\n            //security check that the Hash is not empty\n            if (blockHash==0) throw;\n	    // generate the hash for RNG from the blockHash and the player's address\n            bytes32 shaPlayer = sha3(playerSpinned, blockHash);\n	    // get the final wheel result\n	    wheelResult = uint8(uint256(shaPlayer)%37);\n            //check result against bet and pay if win\n	    checkBetResult(wheelResult, playerSpinned, blockHash, shaPlayer);\n	}\n    }\n    \n\n    //CHECK BETS FUNCTIONS private\n    function checkBetResult(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        BetTypes betType=gambles[gambleIndex[player]].betType;\n        //bet on Number\n        if (betType==BetTypes.number) checkBetNumber(result, player, blockHash, shaPlayer);\n        else if (betType==BetTypes.parity) checkBetParity(result, player, blockHash, shaPlayer);\n        else if (betType==BetTypes.color) checkBetColor(result, player, blockHash, shaPlayer);\n	else if (betType==BetTypes.lowhigh) checkBetLowhigh(result, player, blockHash, shaPlayer);\n	else if (betType==BetTypes.dozen) checkBetDozen(result, player, blockHash, shaPlayer);\n        else if (betType==BetTypes.column) checkBetColumn(result, player, blockHash, shaPlayer);\n        updateMaxBet();  //at the end, update the Max possible bet\n    }\n\n    // function solve Bet once result is determined : sends to winner, adds loss to profit\n    function solveBet(address player, uint8 result, bool win, uint8 multiplier, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        //Update status and record spinned\n        playerStatus[player]=Status.waitingForBet;\n        gambles[gambleIndex[player]].wheelResult=result;\n        gambles[gambleIndex[player]].spinned=true;\n        gambles[gambleIndex[player]].blockSpinned=block.number;\n	uint bet_v = gambles[gambleIndex[player]].wager;\n	\n        if (win)\n        {\n	    gambles[gambleIndex[player]].win=true;\n	    uint win_v = (multiplier-1)*bet_v;\n            lossSinceChange+=win_v;\n            Win(player, result, win_v, blockHash, shaPlayer, gambleIndex[player]);\n            //send win!\n	    //safe send vs potential callstack overflowed spins\n            if (player.send(win_v+bet_v)==false) throw;\n        }\n        else\n        {\n	    Loss(player, result, bet_v-1, blockHash, shaPlayer, gambleIndex[player]);\n            profitSinceChange+=bet_v-1;\n            //send 1 wei to confirm spin if loss\n            if (player.send(1)==false) throw;\n        }\n\n    }\n\n    // checkbeton number(input)\n    // bet type : number\n    // input : chosen number\n    function checkBetNumber(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool win;\n        //win\n	if (result==gambles[gambleIndex[player]].input)\n	{\n            win=true;  \n        }\n        solveBet(player, result,win,36, blockHash, shaPlayer);\n    }\n\n\n    // checkbet on oddeven\n    // bet type : parity\n    // input : 0 for even, 1 for odd\n    function checkBetParity(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool win;\n        //win\n	if (result%2==gambles[gambleIndex[player]].input && result!=0)\n	{\n            win=true;                \n        }\n        solveBet(player,result,win,2, blockHash, shaPlayer);\n    }\n    \n    // checkbet on lowhigh\n    // bet type : lowhigh\n    // input : 0 low, 1 high\n    function checkBetLowhigh(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool win;\n        //win\n	if (result!=0 && ( (result<19 && gambles[gambleIndex[player]].input==0)\n			   || (result>18 && gambles[gambleIndex[player]].input==1)\n			 ) )\n	{\n            win=true;\n        }\n        solveBet(player,result,win,2, blockHash, shaPlayer);\n    }\n\n    // checkbet on color\n    // bet type : color\n    // input : 0 red, 1 black\n    uint[18] red_list=[1,3,5,7,9,12,14,16,18,19,21,23,25,27,30,32,34,36];\n    function checkBetColor(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool red;\n        //check if red\n        for (uint8 k; k<18; k++)\n        { \n            if (red_list[k]==result) \n            { \n                red=true; \n                break;\n            }\n        }\n        bool win;\n        //win\n        if ( result!=0\n             && ( (gambles[gambleIndex[player]].input==0 && red)  \n                  || ( gambles[gambleIndex[player]].input==1 && !red)  ) )\n        {\n            win=true;\n        }\n        solveBet(player,result,win,2, blockHash, shaPlayer);\n    }\n\n    // checkbet on dozen\n    // bet type : dozen\n    // input : 0 first, 1 second, 2 third\n    function checkBetDozen(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    { \n        bool win;\n        //win on first dozen\n     	if ( result!=0 &&\n             ( (result<13 && gambles[gambleIndex[player]].input==0)\n     	       ||\n               (result>12 && result<25 && gambles[gambleIndex[player]].input==1)\n               ||\n               (result>24 && gambles[gambleIndex[player]].input==2) ) )\n     	{\n            win=true;                \n        }\n        solveBet(player,result,win,3, blockHash, shaPlayer);\n    }\n\n    // checkbet on column\n    // bet type : column\n    // input : 0 first, 1 second, 2 third\n    function checkBetColumn(uint8 result, address player, bytes32 blockHash, bytes32 shaPlayer) private\n    {\n        bool win;\n        //win\n        if ( result!=0\n             && ( (gambles[gambleIndex[player]].input==0 && result%3==1)  \n                  || ( gambles[gambleIndex[player]].input==1 && result%3==2)\n                  || ( gambles[gambleIndex[player]].input==2 && result%3==0)  ) )\n        {\n            win=true;\n        }\n        solveBet(player,result,win,3, blockHash, shaPlayer);\n    }\n\n\n    //D.A.O. FUNCTIONS\n\n\n    //total casino payroll\n    uint256 payroll;\n    //Profit Loss since last investor change\n    uint256 profitSinceChange;\n    uint256 lossSinceChange;\n    //DAO members struct array (hard capped to 777 members (77 VIP + 700 extra members) )\n    struct Investor\n    {\n	address investor;\n	uint256 time;\n    }	\n    \n    Investor[777] private investors; //array of 777 elements (max Rouleth's members nb.)\n    uint16 setting_maxInvestors = 77; //Initially restricted to 77 VIP Members\n    //Balances of the DAO members\n    mapping (address=>uint256) balance; \n    //lockPeriod\n    //minimum membership time\n    uint256 setting_lockPeriod=30 days ;\n    uint256 setting_minInvestment=100 ether; //min amount to send when using ""invest()""\n    uint256 setting_maxInvestment=200 ether; //max amount to send when using ""invest()""\n    \n    event newInvest(address player, uint invest_v, uint net_invest_v);\n\n\n    //Become a DAO member.\n    function invest()\n    {\n        // update balances before altering the shares            \n        updateBalances();\n        uint256 netInvest;\n        uint excess;\n        // reset the open position counter to values out of bounds\n        // =999 if full\n        uint16 openPosition=999;\n        bool alreadyInvestor;\n        // loop over array to find if already member, \n        // and record a potential openPosition\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\n        { \n            // captures an index of an open position\n            if (investors[k].investor==0) openPosition=k; \n            // captures if already a member \n            else if (investors[k].investor==msg.sender)\n            {\n                alreadyInvestor=true;\n                break;\n            }\n        }\n        //new Member\n        if (!alreadyInvestor)\n        {\n            // check that more than min is sent (variable setting)\n            if (msg.value<setting_minInvestment) throw;\n            // check that less than max is sent (variable setting)\n            // otherwise refund\n            if (msg.value>setting_maxInvestment)\n            {\n                excess=msg.value-setting_maxInvestment;\n  		netInvest=setting_maxInvestment;\n            }\n	    else\n	    {\n		netInvest=msg.value;\n	    }\n            //members can't become a VIP member after the initial period\n            if (setting_maxInvestors >77 && openPosition<77) throw;\n            //case : array not full, record new member\n            else if (openPosition!=999) investors[openPosition]=Investor(msg.sender, now);\n            //case : array full\n            else\n            {\n                throw;\n            }\n        }\n        //already a member\n        else\n        {\n            netInvest=msg.value;\n            //is already above the max balance allowed or is sending\n	    // too much refuse additional invest\n            if (balance[msg.sender]+msg.value>setting_maxInvestment)\n            {\n                throw;\n            }\n	    // this additionnal amount should be of at least 1/5 of ""setting_minInvestment"" (vs spam)\n	    if (msg.value<setting_minInvestment/5) throw;\n        }\n\n        // add to balance of member and to bankroll\n        // 10% of initial 77 VIP members investment is allocated to\n        // game developement provider chosen by Rouleth DAO\n	// 90% to bankroll\n        //share that will be allocated to game dev\n        uint256 developmentAllocation;\n        developmentAllocation=10*netInvest/100; \n        netInvest-=developmentAllocation;\n        //send game development allocation to Rouleth DAO or tech provider\n        if (developer.send(developmentAllocation)==false) throw;\n\n	// Apply extra entry fee once casino has been opened to extra members\n	// that fee will be shared between the VIP members and represents the increment of\n	// market value of their shares in Rouleth to outsiders\n	// warning if a VIP adds to its initial invest after the casino has been opened to \n	// extra members he will pay have to pay this fee.\n        if (setting_maxInvestors>77)\n        {\n            // % of extra member's investment that rewards VIP funders\n            // Starts at 100%\n            // is set by a vote and computed when settings are changed\n            // to allow more investors\n            uint256 entryExtraCost=voted_extraInvestFeesRate*netInvest/100;\n            // add to VIP profit (to be shared by later call by dev.)\n            profitVIP += entryExtraCost;\n            netInvest-=entryExtraCost;\n        }\n        newInvest(msg.sender, msg.value, netInvest);//event log\n        balance[msg.sender]+=netInvest; //add to balance\n        payroll+=netInvest; //add to bankroll\n        updateMaxBet();\n        //refund potential excess\n        if (excess>0) \n        {\n            if (msg.sender.send(excess)==false) throw;\n        }\n    }\n\n\n    //Allows to transfer your DAO account to another address\n    //target should not be currently a DAO member of rouleth\n    //enter twice the address to make sure you make no mistake.\n    //this can't be reversed if you don't own the target account\n    function transferInvestorAccount(address newInvestorAccountOwner, address newInvestorAccountOwner_confirm)\n    noEthSent\n    {\n        if (newInvestorAccountOwner!=newInvestorAccountOwner_confirm) throw;\n        if (newInvestorAccountOwner==0) throw;\n        //retrieve investor ID\n        uint16 investorID=999;\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\n        {\n	    //new address cant be of a current investor\n            if (investors[k].investor==newInvestorAccountOwner) throw;\n\n	    //retrieve investor id\n            if (investors[k].investor==msg.sender)\n            {\n                investorID=k;\n            }\n        }\n        if (investorID==999) throw; //stop if not a member\n	else\n	    //accept and execute change of address\n	    //votes on entryFeesRate are not transfered\n	    //new address should vote again\n	{\n	    balance[newInvestorAccountOwner]=balance[msg.sender];\n	    balance[msg.sender]=0;\n            investors[investorID].investor=newInvestorAccountOwner;\n	}\n    }\n    \n    //***// Withdraw function (only after lockPeriod)\n    // input : amount to withdraw in Wei (leave empty for full withdraw)\n    // if your withdraw brings your balance under the min required,\n    // your balance is fully withdrawn\n    event withdraw(address player, uint withdraw_v);\n    \n    function withdrawInvestment(uint256 amountToWithdrawInWei)\n    noEthSent\n    {\n	//vs spam withdraw min 1/10 of min\n	if (amountToWithdrawInWei!=0 && amountToWithdrawInWei<setting_minInvestment/10) throw;\n        //before withdraw, update balances with the Profit and Loss sinceChange\n        updateBalances();\n	//check that amount requested is authorized  \n	if (amountToWithdrawInWei>balance[msg.sender]) throw;\n        //retrieve member ID\n        uint16 investorID=999;\n        for (uint16 k = 0; k<setting_maxInvestors; k++)\n        {\n            if (investors[k].investor==msg.sender)\n            {\n                investorID=k;\n                break;\n            }\n        }\n        if (investorID==999) throw; //stop if not a member\n        //check if investment lock period is over\n        if (investors[investorID].time+setting_lockPeriod>now) throw;\n        //if balance left after withdraw is still above min accept partial withdraw\n        if (balance[msg.sender]-amountToWithdrawInWei>=setting_minInvestment && amountToWithdrawInWei!=0)\n        {\n            balance[msg.sender]-=amountToWithdrawInWei;\n            payroll-=amountToWithdrawInWei;\n            //send amount to investor (with security if transaction fails)\n            if (msg.sender.send(amountToWithdrawInWei)==false) throw;\n	    withdraw(msg.sender, amountToWithdrawInWei);\n        }\n        else\n            //if amountToWithdraw=0 : user wants full withdraw\n            //if balance after withdraw is < min invest, withdraw all and delete member\n        {\n            //send amount to member (with security if transaction fails)\n            uint256 fullAmount=balance[msg.sender];\n            payroll-=fullAmount;\n            balance[msg.sender]=0;\n\n	    //delete member\n            delete investors[investorID];\n            if (msg.sender.send(fullAmount)==false) throw;\n   	    withdraw(msg.sender, fullAmount);\n        }\n        updateMaxBet();\n    }\n\n    //***// updates balances with Profit Losses when there is a withdraw/deposit\n    // can be called by dev for accounting when there are no more changes\n    function manualUpdateBalances_only_Dev()\n    noEthSent\n    onlyDeveloper\n    {\n	updateBalances();\n    }\n    function updateBalances() private\n    {\n        //split Profits\n        uint256 profitToSplit;\n        uint256 lossToSplit;\n        if (profitSinceChange==0 && lossSinceChange==0)\n        { return; }\n        \n        else\n        {\n            // Case : Global profit (more win than losses)\n            // 20% fees for game development on global profit (if profit>loss)\n            if (profitSinceChange>lossSinceChange)\n            {\n                profitToSplit=profitSinceChange-lossSinceChange;\n                uint256 developerFees=profitToSplit*20/100;\n                profitToSplit-=developerFees;\n                if (developer.send(developerFees)==false) throw;\n            }\n            else\n            {\n                lossToSplit=lossSinceChange-profitSinceChange;\n            }\n            \n            //share the loss and profits between all DAO members \n            //(proportionnaly. to each one's balance)\n\n            uint totalShared;\n            for (uint16 k=0; k<setting_maxInvestors; k++)\n            {\n                address inv=investors[k].investor;\n                if (inv==0) continue;\n                else\n                {\n                    if (profitToSplit!=0) \n                    {\n                        uint profitShare=(profitToSplit*balance[inv])/payroll;\n                        balance[inv]+=profitShare;\n                        totalShared+=profitShare;\n                    }\n                    else if (lossToSplit!=0) \n                    {\n                        uint lossShare=(lossToSplit*balance[inv])/payroll;\n                        balance[inv]-=lossShare;\n                        totalShared+=lossShare;\n                        \n                    }\n                }\n            }\n            // update bankroll\n	    // and handle potential very small left overs from integer div.\n            if (profitToSplit !=0) \n            {\n		payroll+=profitToSplit;\n		balance[developer]+=profitToSplit-totalShared;\n            }\n            else if (lossToSplit !=0) \n            {\n		payroll-=lossToSplit;\n		balance[developer]-=lossToSplit-totalShared;\n            }\n            profitSinceChange=0; //reset Profit;\n            lossSinceChange=0; //reset Loss ;\n        }\n    }\n    \n\n    //VIP Voting on Extra Invest Fees Rate\n    //mapping records 100 - vote\n    mapping (address=>uint) hundredminus_extraInvestFeesRate;\n    // max fee is 99%\n    // a fee of 100% indicates that the VIP has never voted.\n    function voteOnNewEntryFees_only_VIP(uint8 extraInvestFeesRate_0_to_99)\n    noEthSent\n    {\n        if (extraInvestFeesRate_0_to_99<1 || extraInvestFeesRate_0_to_99>99) throw;\n        hundredminus_extraInvestFeesRate[msg.sender]=100-extraInvestFeesRate_0_to_99;\n    }\n\n    uint256 payrollVIP;\n    uint256 voted_extraInvestFeesRate;\n    function computeResultVoteExtraInvestFeesRate() private\n    {\n        payrollVIP=0;\n        voted_extraInvestFeesRate=0;\n        //compute total payroll of the VIPs\n        //compute vote results among VIPs\n        for (uint8 k=0; k<77; k++)\n        {\n            if (investors[k].investor==0) continue;\n            else\n            {\n                //don't count vote if the VIP never voted\n                if (hundredminus_extraInvestFeesRate[investors[k].investor]==0) continue;\n                else\n                {\n                    payrollVIP+=balance[investors[k].investor];\n                    voted_extraInvestFeesRate+=hundredminus_extraInvestFeesRate[investors[k].investor]*balance[investors[k].investor];\n                }\n            }\n        }\n	//compute final result\n	    if (payrollVIP!=0)\n	    {\n            voted_extraInvestFeesRate=100-voted_extraInvestFeesRate/payrollVIP;\n     	    }\n    }\n\n\n    //Split the profits of the VIP members on extra members' contribution\n    uint profitVIP;\n    function splitProfitVIP_only_Dev()\n    noEthSent\n    onlyDeveloper\n    {\n        payrollVIP=0;\n        //compute total payroll of the VIPs\n        for (uint8 k=0; k<77; k++)\n        {\n            if (investors[k].investor==0) continue;\n            else\n            {\n                payrollVIP+=balance[investors[k].investor];\n            }\n        }\n        //split the profits of the VIP members on extra member's contribution\n	uint totalSplit;\n        for (uint8 i=0; i<77; i++)\n        {\n            if (investors[i].investor==0) continue;\n            else\n            {\n		uint toSplit=balance[investors[i].investor]*profitVIP/payrollVIP;\n                balance[investors[i].investor]+=toSplit;\n		totalSplit+=toSplit;\n            }\n        }\n	//take care of Integer Div remainders, and add to bankroll\n	balance[developer]+=profitVIP-totalSplit;\n	payroll+=profitVIP;\n	//reset var profitVIP\n        profitVIP=0;\n    }\n\n    \n    //INFORMATION FUNCTIONS\n    function checkProfitLossSinceInvestorChange() constant returns(uint profit_since_update_balances, uint loss_since_update_balances, uint profit_VIP_since_update_balances)\n    {\n        profit_since_update_balances=profitSinceChange;\n        loss_since_update_balances=lossSinceChange;\n        profit_VIP_since_update_balances=profitVIP;	\n        return;\n    }\n\n    function checkInvestorBalance(address investor) constant returns(uint balanceInWei)\n    {\n        balanceInWei=balance[investor];\n        return;\n    }\n\n    function getInvestorList(uint index) constant returns(address investor, uint endLockPeriod)\n    {\n        investor=investors[index].investor;\n        endLockPeriod=investors[index].time+setting_lockPeriod;\n        return;\n    }\n    \n    function investmentEntryInfos() constant returns(uint current_max_nb_of_investors, uint investLockPeriod, uint voted_Fees_Rate_on_extra_investments)\n    {\n    	investLockPeriod=setting_lockPeriod;\n    	voted_Fees_Rate_on_extra_investments=voted_extraInvestFeesRate;\n    	current_max_nb_of_investors=setting_maxInvestors;\n    	return;\n    }\n    \n    function getSettings() constant returns(uint maxBet, uint8 blockDelayBeforeSpin)\n    {\n    	maxBet=currentMaxGamble;\n    	blockDelayBeforeSpin=blockDelay;\n    	return ;\n    }\n\n    function getTotalGambles() constant returns(uint _totalGambles)\n    {\n        _totalGambles=totalGambles;\n    	return ;\n    }\n    \n    function getPayroll() constant returns(uint payroll_at_last_update_balances)\n    {\n        payroll_at_last_update_balances=payroll;\n    	return ;\n    }\n\n    \n    function checkMyBet(address player) constant returns(Status player_status, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin, uint gambleID)\n    {\n        player_status=playerStatus[player];\n        bettype=gambles[gambleIndex[player]].betType;\n        input=gambles[gambleIndex[player]].input;\n        value=gambles[gambleIndex[player]].wager;\n        result=gambles[gambleIndex[player]].wheelResult;\n        wheelspinned=gambles[gambleIndex[player]].spinned;\n        win=gambles[gambleIndex[player]].win;\n        blockNb=gambles[gambleIndex[player]].blockNumber;\n        blockSpin=gambles[gambleIndex[player]].blockSpinned;\n    	gambleID=gambleIndex[player];\n    	return;\n    }\n    \n    function getGamblesList(uint256 index) constant returns(address player, BetTypes bettype, uint8 input, uint value, uint8 result, bool wheelspinned, bool win, uint blockNb, uint blockSpin)\n    {\n        player=gambles[index].player;\n        bettype=gambles[index].betType;\n        input=gambles[index].input;\n        value=gambles[index].wager;\n        result=gambles[index].wheelResult;\n        wheelspinned=gambles[index].spinned;\n        win=gambles[index].win;\n    	blockNb=gambles[index].blockNumber;\n        blockSpin=gambles[index].blockSpinned;\n    	return;\n    }\n\n} //end of contract",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ルーレットゲームの実装に焦点を当てている。
1918776,0x684282178b1d61164febcf9609ca195bef9a33b5,false,false,"/*\nCorporation SmartContract.\ndeveloped by: cryptonomica.net, 2016\n\nused sources:\nhttps://www.ethereum.org/token // example of the token standart\nhttps://github.com/ethereum/EIPs/issues/20 // token standart description\nhttps://www.ethereum.org/dao // voting example\n*/\n\n/*\nHow to deploy (estimated: 1,641,268 gas):\n1) For development: use https://ethereum.github.io/browser-solidity/\n2) For testing on Testnet: Open the default ('Mist') wallet (if you are only testing, go to the menu develop > network > testnet), go to the Contracts tab and then press deploy contract, and on the solidity code box, paste the code above.\n3) For prodaction, like in 2) but on Main Network.\nTo verify your deployed smartcontract source code for public go to:\nhttps://etherscan.io/verifyContract\n*/\n\n// 'interface':\n//  this is expected from another contract,\n//  if it wants to spend tokens (shares) of behalf of the token owner\n//  in our contract\n//  f.e.: a 'multisig' SmartContract for transfering shares from seller\n//  to buyer\ncontract tokenRecipient {\n    function receiveApproval(address _from,     // sharehoder\n                             uint256 _value,    // number of shares\n                             address _share,    // - will be this contract\n                             bytes _extraData); //\n}\n\ncontract Corporation {\n\n    /* Standard public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    /* ------------------- Corporate Stock Ledger ---------- */\n    // Shares, shareholders, balances ect.\n\n    // list of all sharehoders (represented by Ethereum accounts)\n    // in this Corporation's history, # is ID\n    address[] public shareholder;\n    // this helps to find address by ID without loop\n    mapping (address => uint256) public shareholderID;\n    // list of adresses, that who currently own at least share\n    // not public, use getCurrentShareholders()\n    address[] activeShareholdersArray;\n    // balances:\n    mapping (address => uint256) public balanceOf;\n    // shares that have to be managed by external contract\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    /*  --------------- Constructor --------- */\n    // Initializes contract with initial supply tokens to the creator of the contract\n    function Corporation () { // - truffle compiles only no args Constructor\n        uint256 initialSupply = 12000; // shares quantity, constant\n        balanceOf[msg.sender] = initialSupply; // Give the creator all initial tokens\n        totalSupply = initialSupply;  // Update total supply\n        name = ""shares""; //tokenName; // Set the name for display purposes\n        symbol = ""sh""; // tokenSymbol; // Set the symbol for display purposes\n        decimals = 0; // Amount of decimals for display purposes\n\n        // -- start corporate stock ledger\n        shareholderID[this] = shareholder.push(this)-1; // # 0\n        shareholderID[msg.sender] = shareholder.push(msg.sender)-1; // #1\n        activeShareholdersArray.push(msg.sender); // add to active shareholders\n    }\n\n    /* --------------- Shares management ------ */\n\n    // This generates a public event on the blockchain that will notify clients. In 'Mist' SmartContract page enable 'Watch contract events'\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    function getCurrentShareholders() returns (address[]){\n        delete activeShareholdersArray;\n        for (uint256 i=0; i < shareholder.length; i++){\n            if (balanceOf[shareholder[i]] > 0){\n                activeShareholdersArray.push(shareholder[i]);\n            }\n            } return activeShareholdersArray;\n        }\n\n    /*  -- can be used to transfer shares to new contract\n    together with getCurrentShareholders() */\n    function getBalanceByAdress(address _address) returns (uint256) {\n        return balanceOf[_address];\n    }\n\n    function getMyShareholderID() returns (uint256) {\n        return shareholderID[msg.sender];\n    }\n\n    function getShareholderAdressByID(uint256 _id) returns (address){\n        return shareholder[_id];\n    }\n\n    function getMyShares() returns (uint256) {\n        return balanceOf[msg.sender];\n    }\n\n\n    /* ---- Transfer shares to another adress ----\n    (shareholder's address calls this)\n    */\n    function transfer(address _to, uint256 _value) {\n        // check arguments:\n        if (_value < 1) throw;\n        if (this == _to) throw; // do not send shares to contract itself;\n        if (balanceOf[msg.sender] < _value) throw; // Check if the sender has enough\n\n        // make transaction\n        balanceOf[msg.sender] -= _value; // Subtract from the sender\n        balanceOf[_to] += _value;       // Add the same to the recipient\n\n        // if new address, add it to shareholders history (stock ledger):\n        if (shareholderID[_to] == 0){ // ----------- check if works\n            shareholderID[_to] = shareholder.push(_to)-1;\n        }\n\n        // Notify anyone listening that this transfer took place\n        Transfer(msg.sender, _to, _value);\n    }\n\n    /* Allow another contract to spend some shares in your behalf\n    (shareholder calls this) */\n    function approveAndCall(address _spender, // another contract's adress\n                            uint256 _value, // number of shares\n                            bytes _extraData) // data for another contract\n    returns (bool success) {\n        // msg.sender - account owner who gives allowance\n        // _spender   - address of another contract\n        // it writes in ""allowance"" that this owner allows another\n        // contract (_spender) to spend thi amont (_value) of shares\n        // in his behalf\n        allowance[msg.sender][_spender] = _value;\n        // 'spender' is another contract that implements code\n        //  prescribed in 'shareRecipient' above\n        tokenRecipient spender = tokenRecipient(_spender);\n        // this contract calls 'receiveApproval' function\n        // of another contract to send information about\n        // allowance\n        spender.receiveApproval(msg.sender, // shares owner\n                                _value,     // number of shares\n                                this,       // this contract's adress\n                                _extraData);// data from shares owner\n        return true;\n    }\n\n    /* this function can be called from another contract, after it\n    have allowance to transfer shares in behalf of sharehoder  */\n    function transferFrom(address _from,\n                          address _to,\n                          uint256 _value)\n    returns (bool success) {\n\n        // Check arguments:\n        // should one share or more\n        if (_value < 1) throw;\n        // do not send shares to this contract itself;\n        if (this == _to) throw;\n        // Check if the sender has enough\n        if (balanceOf[_from] < _value) throw;\n\n        // Check allowance\n        if (_value > allowance[_from][msg.sender]) throw;\n\n        // if transfer to new address -- add him to ledger\n        if (shareholderID[_to] == 0){\n            shareholderID[_to] = shareholder.push(_to)-1; // push function returns the new length\n        }\n\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n\n        // Change allowances correspondingly\n        allowance[_from][msg.sender] -= _value;\n        // Notify anyone listening that this transfer took place\n        Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n\n    /*  --------- Voting  --------------  */\n    // we only count 'yes' votes, not voting 'yes'\n    // considered as voting 'no' (as stated in Bylaws)\n\n    // each proposal should contain it's text\n    // index of text in this array is a proposal ID\n    string[] public proposalText;\n    // proposalID => (shareholder => ""if already voted for this proposal"")\n    mapping (uint256 => mapping (address => bool)) voted;\n    // proposalID => addresses voted 'yes'\n    // exact number of votes according to shares will be counted\n    // after deadline\n    mapping (uint256 => address[]) public votes;\n    // proposalID => deadline\n    mapping (uint256 => uint256) public deadline;\n    // proposalID => final 'yes' votes\n    mapping (uint256 => uint256) public results;\n    // proposals of every shareholder\n    mapping (address => uint256[]) public proposalsByShareholder;\n\n\n    event ProposalAdded(uint256 proposalID,\n                        address initiator,\n                        string description,\n                        uint256 deadline);\n\n    event VotingFinished(uint256 proposalID, uint256 votes);\n\n    function makeNewProposal(string _proposalDescription,\n                             uint256 _debatingPeriodInMinutes)\n    returns (uint256){\n        // only shareholder with one or more shares can make a proposal\n        // !!!! can be more then one share required\n        if (balanceOf[msg.sender] < 1) throw;\n\n        uint256 id = proposalText.push(_proposalDescription)-1;\n        deadline[id] = now + _debatingPeriodInMinutes * 1 minutes;\n\n        // add to proposals of this shareholder:\n        proposalsByShareholder[msg.sender].push(id);\n\n        // initiator always votes 'yes'\n        votes[id].push(msg.sender);\n        voted[id][msg.sender] = true;\n\n        ProposalAdded(id, msg.sender, _proposalDescription, deadline[id]);\n\n        return id; // returns proposal id\n    }\n\n    function getMyProposals() returns (uint256[]){\n        return proposalsByShareholder[msg.sender];\n    }\n\n    function voteForProposal(uint256 _proposalID) returns (string) {\n\n        // if no shares currently owned - no right to vote\n        if (balanceOf[msg.sender] < 1) return ""no shares, vote not accepted"";\n\n        // if already voted - throw, else voting can be spammed\n        if (voted[_proposalID][msg.sender]){\n            return ""already voted, vote not accepted"";\n        }\n\n        // no votes after deadline\n        if (now > deadline[_proposalID] ){\n            return ""vote not accepted after deadline"";\n        }\n\n        // add to list of voted 'yes'\n        votes[_proposalID].push(msg.sender);\n        voted[_proposalID][msg.sender] = true;\n        return ""vote accepted"";\n    }\n\n    // to count votes this transaction should be started manually\n    // from _any_ Ethereum address after deadline\n    function countVotes(uint256 _proposalID) returns (uint256){\n\n        // if not after deadline - throw\n        if (now < deadline[_proposalID]) throw;\n\n        // if already counted return result;\n        if (results[_proposalID] > 0) return results[_proposalID];\n\n        // else should count results and store in public variable\n        uint256 result = 0;\n        for (uint256 i = 0; i < votes[_proposalID].length; i++){\n\n            address voter = votes[_proposalID][i];\n            result = result + balanceOf[voter];\n        }\n\n        // Log and notify anyone listening that this voting finished\n        // with 'result' - number of 'yes' votes\n        VotingFinished(_proposalID, result);\n\n        return result;\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。コメントが多く、教育的な要素がある。
1919766,0x4b902704026d14117b5e9efa7fdafdff4ba610ef,false,false,"contract DaoAccount\n{\n	/**************************\n			    Constants\n	***************************/\n\n	uint256 constant tokenPrice = 1000000000000000; // 1 finney\n\n	/**************************\n					Events\n	***************************/\n\n	// No events\n	\n	/**************************\n	     Public variables\n	***************************/\n\n  uint256 public tokenBalance; // number of tokens in this account\n\n	/**************************\n	     Private variables\n	***************************/\n\n  address owner;        // owner of the otkens\n	address daoChallenge; // the DaoChallenge this account belongs to\n\n  // Owner of the challenge with backdoor access.\n  // Remove for a real DAO contract:\n  address challengeOwner;\n\n	/**************************\n			     Modifiers\n	***************************/\n\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\n\n	/**************************\n	 Constructor and fallback\n	**************************/\n\n  function DaoAccount (address _owner, address _challengeOwner) {\n    owner = _owner;\n    daoChallenge = msg.sender;\n\n    // Remove for a real DAO contract:\n    challengeOwner = _challengeOwner;\n	}\n\n  // Only owner can fund:\n	function () onlyOwner returns (uint256 newBalance){\n		uint256 amount = msg.value;\n\n		// No fractional tokens:\n		if (amount % tokenPrice != 0) {\n			throw;\n		}\n\n    uint256 tokens = amount / tokenPrice;\n\n		tokenBalance += tokens;\n\n    return tokenBalance;\n	}\n\n	/**************************\n	     Private functions\n	***************************/\n\n	// This uses call.value()() rather than send(), but only sends to msg.sender\n  // who is also the owner.\n	function withdrawEtherOrThrow(uint256 amount) private {\n    if (msg.sender != owner) throw;\n		bool result = owner.call.value(amount)();\n		if (!result) {\n			throw;\n		}\n	}\n\n	/**************************\n			 Public functions\n	***************************/\n\n	function refund() noEther onlyOwner {\n		if (tokenBalance == 0) throw;\n		tokenBalance = 0;\n		withdrawEtherOrThrow(tokenBalance * tokenPrice);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyChallengeOwner {\n		suicide(challengeOwner);\n	}\n}\ncontract DaoChallenge\n{\n	/**************************\n					Constants\n	***************************/\n\n	// No Constants\n\n	/**************************\n					Events\n	***************************/\n\n	event notifyTerminate(uint256 finalBalance);\n\n	/**************************\n	     Public variables\n	***************************/\n\n	/**************************\n			 Private variables\n	***************************/\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address owner;\n\n	mapping (address => DaoAccount) private daoAccounts;\n\n	/**************************\n					 Modifiers\n	***************************/\n\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	/**************************\n	 Constructor and fallback\n	**************************/\n\n	function DaoChallenge () {\n		owner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () noEther {\n	}\n\n	/**************************\n	     Private functions\n	***************************/\n\n	// No private functions\n\n	/**************************\n	     Public functions\n	***************************/\n\n	function createAccount () noEther returns (DaoAccount account) {\n		address accountOwner = msg.sender;\n		address challengeOwner = owner; // Don't use in a real DAO\n\n		// One account per address:\n		if(daoAccounts[accountOwner] != DaoAccount(0x00)) throw;\n\n		daoAccounts[accountOwner] = new DaoAccount(accountOwner, challengeOwner);\n		return daoAccounts[accountOwner];\n	}\n\n	function myAccount () noEther returns (DaoAccount) {\n		address accountOwner = msg.sender;\n		return daoAccounts[accountOwner];\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyOwner {\n		notifyTerminate(this.balance);\n		suicide(owner);\n	}\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。コメントが多いが、芸術的要素は少ない。
1919996,0x341e790174e3a4d35b65fdc067b6b5634a61caea,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\n/**\n * \n */\ncontract ReplaySafeSplit {\n    // Fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    // Splits the funds into 2 addresses\n    function split(address targetFork, address targetNoFork) returns(bool) {\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\n            return true;\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\n            return true;\n        }\n        return false;\n    }\n\n    // Reject value transfers.\n    function() {\n        throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1920012,0x23141df767233776f7cbbec497800ddedaa4c684,false,false,"// Simple smart contract that allows anyone to send ether from one address to\n// another in certain branch of the blockchain only.  This contract is supposed\n// to be used after hard forks to clearly separate ""classic"" ether from ""new""\n// ether.\ncontract BranchSender {\n  // Is set to true if and only if we are currently in the ""right"" branch of\n  // the blockchain, i.e. the branch this contract allows sending money in.\n  bool public isRightBranch;\n\n  // Instantiate the contract.\n  //\n  // @param blockNumber number of block in the ""right"" blockchain whose hash is\n  //        known\n  // @param blockHash known hash of the given block in the ""right"" blockchain\n  function BranchSender(uint blockNumber, bytes32 blockHash) {\n    if (msg.value > 0) throw; // We do not accept any money here\n\n    isRightBranch = (block.number < 256 || blockNumber > block.number - 256) &&\n                    (blockNumber < block.number) &&\n                    (block.blockhash (blockNumber) == blockHash);\n  }\n\n  // Default function just throw.\n  function () {\n    throw;\n  }\n\n  // If we are currently in the ""right"" branch of the blockchain, send money to\n  // the given recipient.  Otherwise, throw.\n  //\n  // @param recipient address to send money to if we are currently in the\n  //                  ""right"" branch of the blockchain\n  function send (address recipient) {\n    if (!isRightBranch) throw;\n    if (!recipient.send (msg.value)) throw;\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1920419,0xaa1a6e3e6ef20068f7f8d8c835d2d22fd5116444,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract ReplaySafeSplit {\n    // Fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    // Splits the funds into 2 addresses\n    function split(address targetFork, address targetNoFork) returns(bool) {\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\n            return true;\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\n            return true;\n        }\n        throw; // don't accept value transfer, otherwise it would be trapped.\n    }\n\n    // Reject value transfers.\n    function() {\n        throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1923379,0x8f058d8a161f5be34b47149d70c47d6c60252eee,false,false,"contract AmIOnTheFork {\n    bool public forked = false;\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    // Check the fork condition during creation of the contract.\n    // This function should be called between block 1920000 and 1921200.\n    // Approximately between 2016-07-20 12:00:00 UTC and 2016-07-20 17:00:00 UTC.\n    // After that the status will be locked in.\n    function update() {\n        if (block.number >= 1920000 && block.number <= 1921200) {\n            forked = darkDAO.balance < 3600000 ether;\n        }\n    }\n    function() {\n        throw;\n    }\n}\ncontract ReplaySafeSplit {\n    // Fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    // Splits the funds into 2 addresses\n    function split(address targetFork, address targetNoFork) returns(bool) {\n        if (amIOnTheFork.forked() && targetFork.send(msg.value)) {\n            return true;\n        } else if (!amIOnTheFork.forked() && targetNoFork.send(msg.value)) {\n            return true;\n        }\n        throw;\n    }\n\n    // Reject value transfers.\n    function() {\n        throw;\n    }\n}",1,DAOハードフォーク対応の実用的なスマートコントラクトで、芸術的要素は少ないです。
1925153,0xf53e7f01371c6fc0e1c821d3c3c8b30be366bb6e,false,false,"contract owned {\n    address public owner;\n\n    function owned() {\n        owner = msg.sender;\n    }\n\n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n        _\n    }\n\n    function transferOwnership(address newOwner) onlyOwner {\n        owner = newOwner;\n    }\n}\n\ncontract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); }\n\ncontract token {\n    /* Public variables of the token */\n    string public standard = 'Token 0.1';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    /* This creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function token(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol\n        ) {\n        balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens\n        totalSupply = initialSupply;                        // Update total supply\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n        decimals = decimalUnits;                            // Amount of decimals for display purposes\n    }\n\n    /* Send coins */\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n\n    /* Allow another contract to spend some tokens in your behalf */\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        tokenRecipient spender = tokenRecipient(_spender);\n        spender.receiveApproval(msg.sender, _value, this, _extraData);\n        return true;\n    }\n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    /* This unnamed function is called whenever someone tries to send ether to it */\n    function () {\n        throw;     // Prevents accidental sending of ether\n    }\n}\n\ncontract MyAdvancedToken is owned, token {\n\n    uint256 public totalSupply;\n\n    mapping (address => bool) public frozenAccount;\n\n    /* This generates a public event on the blockchain that will notify clients */\n    event FrozenFunds(address target, bool frozen);\n\n    /* Initializes contract with initial supply tokens to the creator of the contract */\n    function MyAdvancedToken(\n        uint256 initialSupply,\n        string tokenName,\n        uint8 decimalUnits,\n        string tokenSymbol,\n        address centralMinter\n    ) token (initialSupply, tokenName, decimalUnits, tokenSymbol) {\n        if(centralMinter != 0 ) owner = centralMinter;      // Sets the owner as specified (if centralMinter is not specified the owner is msg.sender)\n        balanceOf[owner] = initialSupply;                   // Give the owner all initial tokens\n    }\n\n    /* Send coins */\n    function transfer(address _to, uint256 _value) {\n        if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows\n        if (frozenAccount[msg.sender]) throw;                // Check if frozen\n        balanceOf[msg.sender] -= _value;                     // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place\n    }\n\n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (frozenAccount[_from]) throw;                        // Check if frozen            \n        if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows\n        if (_value > allowance[_from][msg.sender]) throw;   // Check allowance\n        balanceOf[_from] -= _value;                          // Subtract from the sender\n        balanceOf[_to] += _value;                            // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function mintToken(address target, uint256 mintedAmount) onlyOwner {\n        balanceOf[target] += mintedAmount;\n        totalSupply += mintedAmount;\n        Transfer(0, owner, mintedAmount);\n        Transfer(owner, target, mintedAmount);\n    }\n\n    function freezeAccount(address target, bool freeze) onlyOwner {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1926230,0x63bf4b83d9888bfffade6e1d1a3c03208a6872d4,false,false,contract AmIOnTheFork {\n    bool public forked = false;\n    address constant darkDAO = 0x304a554a310c7e546dfe434669c62820b7d83490;\n    // Check the fork condition during creation of the contract.\n    // This function should be called between block 1920000 and 1921200.\n    // Approximately between 2016-07-20 12:00:00 UTC and 2016-07-20 17:00:00 UTC.\n    // After that the status will be locked in.\n    function update() {\n        if (block.number >= 1920000 && block.number <= 1921200) {\n            forked = darkDAO.balance < 3600000 ether;\n        }\n    }\n    function() {\n        throw;\n    }\n}\n\ncontract MyReplaySafeProxy {\n    \n    address eth_target = 0x447F7556C8D2E5281438358087DdD368B6bCb824; \n    address ethc_target = 0xCd76f273d307551016452724241EA3C1775270a2;\n\n	address public target;\n	\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    \n    function MyReplaySafeProxy () {\n			if (amIOnTheFork.forked())\n				target =  eth_target;\n			else\n				target =  ethc_target;\n    }\n\n    function() {\n        if(!target.send(msg.value))\n            throw;\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1930912,0x5c353a8dde7c400a84a673719cc0a0800108ea73,false,false,"contract Assertive {\n    function assert(bool assertion) internal {\n        if (!assertion) throw;\n    }\n}\n\ncontract MutexUser {\n    bool private lock;\n    modifier exclusive {\n        if (lock) throw;\n        lock = true;\n        _\n        lock = false;\n    }\n}\ncontract ERC20 {\n    function totalSupply() constant returns (uint);\n    function balanceOf(address who) constant returns (uint);\n    function allowance(address owner, address spender) constant returns (uint);\n\n    function transfer(address to, uint value) returns (bool ok);\n    function transferFrom(address from, address to, uint value) returns (bool ok);\n    function approve(address spender, uint value) returns (bool ok);\n\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approval(address indexed owner, address indexed spender, uint value);\n}\ncontract FallbackFailer {\n  function () {\n    throw;\n  }\n}\n\n// A simple direct exchange order manager.\n\ncontract EventfulMarket {\n    event ItemUpdate( uint id );\n    event Trade( uint sell_how_much, address indexed sell_which_token,\n                 uint buy_how_much, address indexed buy_which_token );\n}\ncontract SimpleMarket is EventfulMarket\n                       , Assertive\n                       , FallbackFailer\n                       , MutexUser\n{\n    struct OfferInfo {\n        uint sell_how_much;\n        ERC20 sell_which_token;\n        uint buy_how_much;\n        ERC20 buy_which_token;\n        address owner;\n        bool active;\n    }\n    mapping( uint => OfferInfo ) public offers;\n\n    uint public last_offer_id;\n\n    function next_id() internal returns (uint) {\n        last_offer_id++; return last_offer_id;\n    }\n\n    modifier can_offer {\n        _\n    }\n    modifier can_buy(uint id) {\n        assert(isActive(id));\n        _\n    }\n    modifier can_cancel(uint id) {\n        assert(isActive(id));\n        assert(getOwner(id) == msg.sender);\n        _\n    }\n    function isActive(uint id) constant returns (bool active) {\n        return offers[id].active;\n    }\n    function getOwner(uint id) constant returns (address owner) {\n        return offers[id].owner;\n    }\n    function getOffer( uint id ) constant returns (uint, ERC20, uint, ERC20) {\n      var offer = offers[id];\n      return (offer.sell_how_much, offer.sell_which_token,\n              offer.buy_how_much, offer.buy_which_token);\n    }\n\n    // non underflowing subtraction\n    function safeSub(uint a, uint b) internal returns (uint) {\n        assert(b <= a);\n        return a - b;\n    }\n    // non overflowing multiplication\n    function safeMul(uint a, uint b) internal returns (uint c) {\n        c = a * b;\n        assert(a == 0 || c / a == b);\n    }\n\n    function trade( address seller, uint sell_how_much, ERC20 sell_which_token,\n                    address buyer,  uint buy_how_much,  ERC20 buy_which_token )\n        internal\n    {\n        var seller_paid_out = buy_which_token.transferFrom( buyer, seller, buy_how_much );\n        assert(seller_paid_out);\n        var buyer_paid_out = sell_which_token.transfer( buyer, sell_how_much );\n        assert(buyer_paid_out);\n        Trade( sell_how_much, sell_which_token, buy_how_much, buy_which_token );\n    }\n\n    // ---- Public entrypoints ---- //\n\n    // Make a new offer. Takes funds from the caller into market escrow.\n    function offer( uint sell_how_much, ERC20 sell_which_token\n                  , uint buy_how_much,  ERC20 buy_which_token )\n        can_offer\n        exclusive\n        returns (uint id)\n    {\n        assert(sell_how_much > 0);\n        assert(sell_which_token != ERC20(0x0));\n        assert(buy_how_much > 0);\n        assert(buy_which_token != ERC20(0x0));\n        assert(sell_which_token != buy_which_token);\n\n        OfferInfo memory info;\n        info.sell_how_much = sell_how_much;\n        info.sell_which_token = sell_which_token;\n        info.buy_how_much = buy_how_much;\n        info.buy_which_token = buy_which_token;\n        info.owner = msg.sender;\n        info.active = true;\n        id = next_id();\n        offers[id] = info;\n\n        var seller_paid = sell_which_token.transferFrom( msg.sender, this, sell_how_much );\n        assert(seller_paid);\n\n        ItemUpdate(id);\n    }\n    // Accept given `quantity` of an offer. Transfers funds from caller to\n    // offer maker, and from market to caller.\n    function buy( uint id, uint quantity )\n        can_buy(id)\n        exclusive\n        returns ( bool success )\n    {\n        // read-only offer. Modify an offer by directly accessing offers[id]\n        OfferInfo memory offer = offers[id];\n\n        // inferred quantity that the buyer wishes to spend\n        uint spend = safeMul(quantity, offer.buy_how_much) / offer.sell_how_much;\n\n        if ( spend > offer.buy_how_much || quantity > offer.sell_how_much ) {\n            // buyer wants more than is available\n            success = false;\n        } else if ( spend == offer.buy_how_much && quantity == offer.sell_how_much ) {\n            // buyer wants exactly what is available\n            delete offers[id];\n\n            trade( offer.owner, quantity, offer.sell_which_token,\n                   msg.sender, spend, offer.buy_which_token );\n\n            ItemUpdate(id);\n            success = true;\n        } else if ( spend > 0 && quantity > 0 ) {\n            // buyer wants a fraction of what is available\n            offers[id].sell_how_much = safeSub(offer.sell_how_much, quantity);\n            offers[id].buy_how_much = safeSub(offer.buy_how_much, spend);\n\n            trade( offer.owner, quantity, offer.sell_which_token,\n                    msg.sender, spend, offer.buy_which_token );\n\n            ItemUpdate(id);\n            success = true;\n        } else {\n            // buyer wants an unsatisfiable amount (less than 1 integer)\n            success = false;\n        }\n    }\n    // Cancel an offer. Refunds offer maker.\n    function cancel( uint id )\n        can_cancel(id)\n        exclusive\n        returns ( bool success )\n    {\n        // read-only offer. Modify an offer by directly accessing offers[id]\n        OfferInfo memory offer = offers[id];\n        delete offers[id];\n\n        var seller_refunded = offer.sell_which_token.transfer( offer.owner , offer.sell_how_much );\n        assert(seller_refunded);\n\n        ItemUpdate(id);\n        success = true;\n    }\n}\n\n// Simple Market with a market lifetime. When the lifetime has elapsed,\n// offers can only be cancelled (offer and buy will throw).\n\ncontract ExpiringMarket is SimpleMarket {\n    uint public close_time;\n    function ExpiringMarket(uint lifetime) {\n        close_time = getTime() + lifetime;\n    }\n    function getTime() constant returns (uint) {\n        return block.timestamp;\n    }\n    function isClosed() constant returns (bool closed) {\n        return (getTime() > close_time);\n    }\n\n    // after market lifetime has elapsed, no new offers are allowed\n    modifier can_offer {\n        assert(!isClosed());\n        _\n    }\n    // after close, no new buys are allowed\n    modifier can_buy(uint id) {\n        assert(isActive(id));\n        assert(!isClosed());\n        _\n    }\n    // after close, anyone can cancel an offer\n    modifier can_cancel(uint id) {\n        assert(isActive(id));\n        assert(isClosed() || (msg.sender == getOwner(id)));\n        _\n    }\n}\n\n// Flat file implementation of `dappsys/token/base.sol::DSTokenBase`\n\n// Everything throws instead of returning false on failure.\n\ncontract ERC20Base is ERC20\n{\n    mapping( address => uint ) _balances;\n    mapping( address => mapping( address => uint ) ) _approvals;\n    uint _supply;\n    function ERC20Base( uint initial_balance ) {\n        _balances[msg.sender] = initial_balance;\n        _supply = initial_balance;\n    }\n    function totalSupply() constant returns (uint supply) {\n        return _supply;\n    }\n    function balanceOf( address who ) constant returns (uint value) {\n        return _balances[who];\n    }\n    function transfer( address to, uint value) returns (bool ok) {\n        if( _balances[msg.sender] < value ) {\n            throw;\n        }\n        if( !safeToAdd(_balances[to], value) ) {\n            throw;\n        }\n        _balances[msg.sender] -= value;\n        _balances[to] += value;\n        Transfer( msg.sender, to, value );\n        return true;\n    }\n    function transferFrom( address from, address to, uint value) returns (bool ok) {\n        // if you don't have enough balance, throw\n        if( _balances[from] < value ) {\n            throw;\n        }\n        // if you don't have approval, throw\n        if( _approvals[from][msg.sender] < value ) {\n            throw;\n        }\n        if( !safeToAdd(_balances[to], value) ) {\n            throw;\n        }\n        // transfer and return true\n        _approvals[from][msg.sender] -= value;\n        _balances[from] -= value;\n        _balances[to] += value;\n        Transfer( from, to, value );\n        return true;\n    }\n    function approve(address spender, uint value) returns (bool ok) {\n        _approvals[msg.sender][spender] = value;\n        Approval( msg.sender, spender, value );\n        return true;\n    }\n    function allowance(address owner, address spender) constant returns (uint _allowance) {\n        return _approvals[owner][spender];\n    }\n    function safeToAdd(uint a, uint b) internal returns (bool) {\n        return (a + b >= a);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1943645,0x6ff323e36bfdb20502b23780695f4e77e36cde95,false,false,"// Single-owner wallet that keeps ETC and ETH separately and helps preventing\n// replaying both, incoming and outgoing transactions.\n//\n// Once instantiated, the contract sets up three addressed:\n// 1. Address to be used to send and receive ETC.  This address will reject all\n//    incoming ETH transfers, so its ETH balance will always be zero;\n// 2. Address to be used to send and receive ETH.  This address will reject all\n//    incoming ETC transfers, so its ETC balance will always be zero;\n// 3. Address to be used to receive payments in both flavors of ether or even\n//    unsplit replayable ETC+ETH payments.  Ether coming to this address will\n//    be automatically classified and distributed among address 1 and address 2.\ncontract TriWallet {\n  // Is set to true in the forked branch and to false in classic branch.\n  bool public thisIsFork;\n\n  // Address of ETC subwallet.\n  address public etcWallet;\n\n  // Address of ETH subwallet.\n  address public ethWallet;\n\n  // Log address of ETC subwallet\n  event ETCWalletCreated(address etcWalletAddress);\n\n  // Log address of ETH subwallet\n  event ETHWalletCreated(address ethWalletAddress);\n\n  // Instantiate the contract.\n  function TriWallet () {\n    // Check whether we are in fork branch or in classic one\n    thisIsFork = BranchSender (0x23141df767233776f7cbbec497800ddedaa4c684).isRightBranch ();\n    \n    // Create ETC subwallet\n    etcWallet = new BranchWallet (msg.sender, !thisIsFork);\n    \n    // Create ETH subwallet\n    ethWallet = new BranchWallet (msg.sender, thisIsFork);\n  \n    // Log address of ETC subwallet\n    ETCWalletCreated (etcWallet);\n\n    // Log address of ETH subwallet\n    ETHWalletCreated (ethWallet);\n  }\n\n  // Distribute pending balance between ETC and ETH subwallets.\n  function distribute () {\n    if (thisIsFork) {\n      // Send all ETH to ETH subwallet\n      if (!ethWallet.send (this.balance)) throw;\n    } else {\n      // Send all ETC to ETC subwallet\n      if (!etcWallet.send (this.balance)) throw;\n    }\n  }\n}\n\n// Wallet contract that operates only in ""right"" branch.\ncontract BranchWallet {\n  // Owner of the wallet\n  address public owner;\n    \n  // Is set to true if and only if we are currently in the ""right"" branch of\n  // the blockchain, i.e. the branch this wallet is operating in.\n  bool public isRightBranch;\n\n  // Instantiate the contract.\n  //\n  // @param owner owner of the contract\n  // @isRightBranch whether we are currently in the ""right"" branch\n  function BranchWallet (address _owner, bool _isRightBranch) {\n    owner = _owner;\n    isRightBranch = _isRightBranch;\n  }\n\n  // Only accept money in ""right"" branch.\n  function () {\n    if (!isRightBranch) throw;\n  }\n\n  // Execute a transaction using money from this wallet.\n  //\n  // @param to transaction destination\n  // @param value transaction value\n  // @param data transaction data\n  function send (address _to, uint _value) {\n    if (!isRightBranch) throw;\n    if (msg.sender != owner) throw;\n    if (!_to.send (_value)) throw;\n  }\n\n  // Execute a transaction using money from this wallet.\n  //\n  // @param to transaction destination\n  // @param value transaction value\n  // @param data transaction data\n  function execute (address _to, uint _value, bytes _data) {\n    if (!isRightBranch) throw;\n    if (msg.sender != owner) throw;\n    if (!_to.call.value (_value)(_data)) throw;\n  }\n}\n\n// Simple smart contract that allows anyone to tell where we are currently in the\n// ""right"" branch of blockchain.\ncontract BranchSender {\n  // Is set to true if and only if we are currently in the ""right"" branch of\n  // the blockchain.\n  bool public isRightBranch;\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1943656,0x536c2622748118a82bc9fb15a450d828966d9761,false,false,contract Prism {\n    address constant theWithdraw = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\n    function Prism() {\n        forked = theWithdraw.balance > 1 ether;\n    }\n    \n    function transferETC(address to) {\n        if (forked)\n            throw;\n        if (!to.send(msg.value))\n            throw;\n    }\n\n    function transferETH(address to) {\n        if (!forked)\n            throw;\n        if (!to.send(msg.value))\n            throw;\n    }\n    \n    bool public forked;\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1951285,0x48c1afa27188dd4ee1a461e1cdc169ab95e32c39,false,false,contract Switch {\n    address constant theWithdraw = 0xbf4ed7b27f1d666546e30d74d50d173d20bca754;\n    function Switch() {\n        forked = theWithdraw.balance > 10000 ether;\n    }\n    \n    function transferringETC(address to) {\n        if (forked)\n            throw;\n        if (!to.send(msg.value))\n            throw;\n    }\n\n    function transferringETH(address to) {\n        if (!forked)\n            throw;\n        if (!to.send(msg.value))\n            throw;\n    }\n    \n    bool public forked;\n},1,実用的なコードで、特定の条件で資金を送信するシンプルなスマートコントラクトです。
1951489,0x5f0d0c4c159970fda5adc93a6b7f17706fd3255c,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract SellETCSafely {\n    // fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    \n    // recipient of the 1 % fee on the ETC side\n    address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54;\n    \n    function split(address ethDestination, address etcDestination) {\n        if (amIOnTheFork.forked()) {\n            // The following happens on the forked chain:\n            // 100 % is forwarded to the provided destination for ETH\n            ethDestination.call.value(msg.value);\n        } else {\n            // The following happens on the classic chain:\n            // 1 % is forwarded to the fee recipient\n            // 99 % is forwarded to the provided destination for ETC\n            uint fee = msg.value / 100;\n            feeRecipient.send(fee);\n            etcDestination.call.value(msg.value - fee)();\n        }\n    }\n    \n    function () {\n        throw;  // do not accept value transfers\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1951697,0x8086fb1d6457b94c920cfcd7fb4ca14ef2218108,false,false,contract ClassicCheck {\n    \n    bool public classic;\n \n    function ClassicCheck(){\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance > 1000000 ether)\n            classic = false;\n        else\n            classic = true;\n    }   \n    \n    function isClassic() constant returns (bool isClassic) {\n        return classic;\n    }\n},1,実用的な構造で、特定のアドレスのETH残高をチェックするシンプルな機能を持つ。
1952428,0x1e143b2588705dfea63a17f2032ca123df995ce0,false,false,contract ClassicCheck {\n       function isClassic() constant returns (bool isClassic);\n}\n\ncontract SafeConditionalHFTransfer {\n\n    bool classic;\n    \n    function SafeConditionalHFTransfer() {\n        classic = ClassicCheck(0x882fb4240f9a11e197923d0507de9a983ed69239).isClassic();\n    }\n    \n    function classicTransfer(address to) {\n        if (!classic) \n            msg.sender.send(msg.value);\n        else\n            to.send(msg.value);\n    }\n    \n    function transfer(address to) {\n        if (classic)\n            msg.sender.send(msg.value);\n        else\n            to.send(msg.value);\n    }\n    \n},1,実用的な構造で、特に芸術的な要素は見られません。
1955043,0xc8d9890df1ff2e87be05e9edab3cca26f054b611,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract SellETCSafely {\n    // fork oracle to use\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n    // recipient of the 1 % fee on the ETC side\n    address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54;\n\n    function split(address ethDestination, address etcDestination) {\n        if (amIOnTheFork.forked()) {\n            // The following happens on the forked chain:\n            // 100 % is forwarded to the provided destination for ETH\n            ethDestination.call.value(msg.value)();\n        } else {\n            // The following happens on the classic chain:\n            // 1 % is forwarded to the fee recipient\n            // 99 % is forwarded to the provided destination for ETC\n            uint fee = msg.value / 100;\n            feeRecipient.send(fee);\n            etcDestination.call.value(msg.value - fee)();\n        }\n    }\n\n    function () {\n        throw;  // do not accept value transfers\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1962298,0x6c8060507273a0ff175361c6bf9f86e97f8cf2c8,false,false,"// version 1.0\ncontract Randao {\n  struct Participant {\n      uint256   secret;\n      bytes32   commitment;\n      uint256   reward;\n      bool      revealed;\n      bool      rewarded;\n  }\n\n  struct Consumer {\n    address caddr;\n    uint256 bountypot;\n  }\n\n  struct Campaign {\n      uint32    bnum;\n      uint96    deposit;\n      uint16    commitBalkline;\n      uint16    commitDeadline;\n\n      uint256   random;\n      bool      settled;\n      uint256   bountypot;\n      uint32    commitNum;\n      uint32    revealsNum;\n\n      mapping (address => Consumer) consumers;\n      mapping (address => Participant) participants;\n  }\n\n  uint256 public numCampaigns;\n  Campaign[] public campaigns;\n  address public founder;\n\n  uint256 public bounty          = 1 ether;\n\n  // Prevents methods from perfoming any value transfer\n  modifier noEther() { if (msg.value > 0) throw; _}\n\n  modifier blankAddress(address _n) { if (_n != 0) throw; _}\n\n  modifier checkBounty { if (msg.value < bounty) throw; _}\n\n  modifier moreThanZero(uint256 _deposit) { if (_deposit <= 0) throw; _}\n\n  modifier notBeBlank(bytes32 _s) { if (_s == """") throw;  _}\n\n  modifier beBlank(bytes32 _s) { if (_s != """") throw; _}\n\n  modifier beFalse(bool _t) { if (_t) throw; _}\n\n  function Randao() {\n      founder = msg.sender;\n  }\n\n  event CampaignAdded(uint256 indexed campaignID,\n                      address indexed from,\n                      uint32 indexed bnum,\n                      uint96 deposit,\n                      uint16 commitBalkline,\n                      uint16 commitDeadline,\n                      uint256 bountypot);\n\n  modifier timeLineCheck(uint32 _bnum, uint16 _commitBalkline, uint16 _commitDeadline) {\n      if (block.number >= _bnum) throw;\n      if (_commitBalkline <= 0) throw;\n      if (_commitDeadline <= 0) throw;\n      if (_commitDeadline >= _commitBalkline) throw;\n      if (block.number >= _bnum - _commitBalkline) throw;\n      _\n  }\n\n  function newCampaign(\n      uint32 _bnum,\n      uint96 _deposit,\n      uint16 _commitBalkline,\n      uint16 _commitDeadline\n  ) timeLineCheck(_bnum, _commitBalkline, _commitDeadline)\n    checkBounty moreThanZero(_deposit) external returns (uint256 _campaignID) {\n      _campaignID = campaigns.length++;\n      Campaign c = campaigns[_campaignID];\n      numCampaigns++;\n      c.bnum = _bnum;\n      c.deposit = _deposit;\n      c.commitBalkline = _commitBalkline;\n      c.commitDeadline = _commitDeadline;\n      c.bountypot = msg.value;\n      c.consumers[msg.sender] = Consumer(msg.sender, msg.value);\n      CampaignAdded(_campaignID, msg.sender, _bnum, _deposit, _commitBalkline, _commitDeadline, msg.value);\n  }\n\n  event Follow(uint256 indexed CampaignId, address indexed from, uint256 bountypot);\n\n  function follow(uint256 _campaignID)\n    checkBounty external returns (bool) {\n      Campaign c = campaigns[_campaignID];\n      Consumer consumer = c.consumers[msg.sender];\n      return followCampaign(_campaignID, c, consumer);\n  }\n\n  modifier checkFollowPhase(uint256 _bnum, uint16 _commitDeadline) {\n      if (block.number > _bnum - _commitDeadline) throw;\n      _\n  }\n\n  function followCampaign(\n      uint256 _campaignID,\n      Campaign storage c,\n      Consumer storage consumer\n  ) checkFollowPhase(c.bnum, c.commitDeadline)\n    blankAddress(consumer.caddr) internal returns (bool) {\n      c.bountypot += msg.value;\n      c.consumers[msg.sender] = Consumer(msg.sender, msg.value);\n      Follow(_campaignID, msg.sender, msg.value);\n      return true;\n  }\n\n  event Commit(uint256 indexed CampaignId, address indexed from, bytes32 commitment);\n\n  function commit(uint256 _campaignID, bytes32 _hs) notBeBlank(_hs) external {\n      Campaign c = campaigns[_campaignID];\n      commitmentCampaign(_campaignID, _hs, c);\n  }\n\n  modifier checkDeposit(uint256 _deposit) { if (msg.value != _deposit) throw; _}\n\n  modifier checkCommitPhase(uint256 _bnum, uint16 _commitBalkline, uint16 _commitDeadline) {\n      if (block.number < _bnum - _commitBalkline) throw;\n      if (block.number > _bnum - _commitDeadline) throw;\n      _\n  }\n\n  function commitmentCampaign(\n      uint256 _campaignID,\n      bytes32 _hs,\n      Campaign storage c\n  ) checkDeposit(c.deposit)\n    checkCommitPhase(c.bnum, c.commitBalkline, c.commitDeadline)\n    beBlank(c.participants[msg.sender].commitment) internal {\n      c.participants[msg.sender] = Participant(0, _hs, 0, false, false);\n      c.commitNum++;\n      Commit(_campaignID, msg.sender, _hs);\n  }\n\n  // For test\n  function getCommitment(uint256 _campaignID) noEther external returns (bytes32) {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      return p.commitment;\n  }\n\n  event Reveal(uint256 indexed CampaignId, address indexed from, uint256 secret);\n\n  function reveal(uint256 _campaignID, uint256 _s) noEther external {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      revealCampaign(_campaignID, _s, c, p);\n  }\n\n  modifier checkRevealPhase(uint256 _bnum, uint16 _commitDeadline) {\n      if (block.number <= _bnum - _commitDeadline) throw;\n      if (block.number >= _bnum) throw;\n      _\n  }\n\n  modifier checkSecret(uint256 _s, bytes32 _commitment) {\n      if (sha3(_s) == _commitment) throw;\n      _\n  }\n\n  function revealCampaign(\n    uint256 _campaignID,\n    uint256 _s,\n    Campaign storage c,\n    Participant storage p\n  ) checkRevealPhase(c.bnum, c.commitDeadline)\n    checkSecret(_s, p.commitment)\n    beFalse(p.revealed) internal {\n      p.secret = _s;\n      p.revealed = true;\n      c.revealsNum++;\n      c.random ^= p.secret;\n      Reveal(_campaignID, msg.sender, _s);\n  }\n\n  modifier bountyPhase(uint256 _bnum){ if (block.number < _bnum) throw; _}\n\n  function getRandom(uint256 _campaignID) noEther external returns (uint256) {\n      Campaign c = campaigns[_campaignID];\n      return returnRandom(c);\n  }\n\n  function returnRandom(Campaign storage c) bountyPhase(c.bnum) internal returns (uint256) {\n      if (c.revealsNum == c.commitNum) {\n          c.settled = true;\n          return c.random;\n      }\n  }\n\n  // The commiter get his bounty and deposit, there are three situations\n  // 1. Campaign succeeds.Every revealer gets his deposit and the bounty.\n  // 2. Someone revels, but some does not,Campaign fails.\n  // The revealer can get the deposit and the fines are distributed.\n  // 3. Nobody reveals, Campaign fails.Every commiter can get his deposit.\n  function getMyBounty(uint256 _campaignID) noEther external {\n      Campaign c = campaigns[_campaignID];\n      Participant p = c.participants[msg.sender];\n      transferBounty(c, p);\n  }\n\n  function transferBounty(\n      Campaign storage c,\n      Participant storage p\n    ) bountyPhase(c.bnum)\n      beFalse(p.rewarded) internal {\n      if (c.revealsNum > 0) {\n          if (p.revealed) {\n              uint256 share = calculateShare(c);\n              returnReward(share, c, p);\n          }\n      // Nobody reveals\n      } else {\n          returnReward(0, c, p);\n      }\n  }\n\n  function calculateShare(Campaign c) internal returns (uint256 _share) {\n      // Someone does not reveal. Campaign fails.\n      if (c.commitNum > c.revealsNum) {\n          _share = fines(c) / c.revealsNum;\n      // Campaign succeeds.\n      } else {\n          _share = c.bountypot / c.revealsNum;\n      }\n  }\n\n  function returnReward(\n      uint256 _share,\n      Campaign storage c,\n      Participant storage p\n  ) internal {\n      p.reward = _share;\n      p.rewarded = true;\n      if (!msg.sender.send(_share + c.deposit)) {\n          p.reward = 0;\n          p.rewarded = false;\n      }\n  }\n\n  function fines(Campaign c) internal returns (uint256) {\n      return (c.commitNum - c.revealsNum) * c.deposit;\n  }\n\n  // If the campaign fails, the consumers can get back the bounty.\n  function refundBounty(uint256 _campaignID) noEther external {\n      Campaign c = campaigns[_campaignID];\n      returnBounty(_campaignID, c);\n  }\n\n  modifier campaignFailed(uint32 _commitNum, uint32 _revealsNum) {\n      if (_commitNum == _revealsNum && _commitNum != 0) throw;\n      _\n  }\n\n  modifier beConsumer(address _caddr) {\n      if (_caddr != msg.sender) throw;\n      _\n  }\n\n  function returnBounty(uint256 _campaignID, Campaign storage c)\n    bountyPhase(c.bnum)\n    campaignFailed(c.commitNum, c.revealsNum)\n    beConsumer(c.consumers[msg.sender].caddr) internal {\n      uint256 bountypot = c.consumers[msg.sender].bountypot;\n      c.consumers[msg.sender].bountypot = 0;\n      if (!msg.sender.send(bountypot)) {\n          c.consumers[msg.sender].bountypot = bountypot;\n      }\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1962460,0xf868a1d3de6edf1f33065da994580b4e82a40044,true,false,"contract MultiAsset {\n    function isCreated(bytes32 _symbol) constant returns(bool);\n    function owner(bytes32 _symbol) constant returns(address);\n    function totalSupply(bytes32 _symbol) constant returns(uint);\n    function balanceOf(address _holder, bytes32 _symbol) constant returns(uint);\n    function transfer(address _to, uint _value, bytes32 _symbol) returns(bool);\n    function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool);\n    function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint);\n    function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool);\n    function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool);\n    function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool);\n}\n\ncontract Safe {\n    // Should always be placed as first modifier!\n    modifier noValue {\n        if (msg.value > 0) {\n            // Internal Out Of Gas/Throw: revert this transaction too;\n            // Call Stack Depth Limit reached: revert this transaction too;\n            // Recursive Call: safe, no any changes applied yet, we are inside of modifier.\n            _safeSend(msg.sender, msg.value);\n        }\n        _\n    }\n\n    modifier onlyHuman {\n        if (_isHuman()) {\n            _\n        }\n    }\n\n    modifier noCallback {\n        if (!isCall) {\n            _\n        }\n    }\n\n    modifier immutable(address _address) {\n        if (_address == 0) {\n            _\n        }\n    }\n\n    address stackDepthLib;\n    function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) {\n        stackDepthLib = _stackDepthLib;\n        return true;\n    }\n\n    modifier requireStackDepth(uint16 _depth) {\n        if (stackDepthLib == 0x0) {\n            throw;\n        }\n        if (_depth > 1023) {\n            throw;\n        }\n        if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) {\n            throw;\n        }\n        _\n    }\n\n    // Must not be used inside the functions that have noValue() modifier!\n    function _safeFalse() internal noValue() returns(bool) {\n        return false;\n    }\n\n    function _safeSend(address _to, uint _value) internal {\n        if (!_unsafeSend(_to, _value)) {\n            throw;\n        }\n    }\n\n    function _unsafeSend(address _to, uint _value) internal returns(bool) {\n        return _to.call.value(_value)();\n    }\n\n    function _isContract() constant internal returns(bool) {\n        return msg.sender != tx.origin;\n    }\n\n    function _isHuman() constant internal returns(bool) {\n        return !_isContract();\n    }\n\n    bool private isCall = false;\n    function _setupNoCallback() internal {\n        isCall = true;\n    }\n\n    function _finishNoCallback() internal {\n        isCall = false;\n    }\n}\n\ncontract KUNA_SHARES is Safe {\n    event Transfer(address indexed from, address indexed to, uint value);\n    event Approve(address indexed from, address indexed spender, uint value);\n\n    MultiAsset public multiAsset;\n    bytes32 public symbol;\n\n    function init(address _multiAsset, bytes32 _symbol) noValue() immutable(address(multiAsset)) returns(bool) {\n        MultiAsset ma = MultiAsset(_multiAsset);\n        if (!ma.isCreated(_symbol)) {\n            return false;\n        }\n        multiAsset = ma;\n        symbol = _symbol;\n        return true;\n    }\n\n    modifier onlyMultiAsset() {\n        if (msg.sender == address(multiAsset)) {\n            _\n        }\n    }\n\n    function totalSupply() constant returns(uint) {\n        return multiAsset.totalSupply(symbol);\n    }\n\n    function balanceOf(address _owner) constant returns(uint) {\n        return multiAsset.balanceOf(_owner, symbol);\n    }\n\n    function allowance(address _from, address _spender) constant returns(uint) {\n        return multiAsset.allowance(_from, _spender, symbol);\n    }\n\n    function transfer(address _to, uint _value) returns(bool) {\n        return __transferWithReference(_to, _value, """");\n    }\n\n    function transferWithReference(address _to, uint _value, string _reference) returns(bool) {\n        return __transferWithReference(_to, _value, _reference);\n    }\n\n    function __transferWithReference(address _to, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) :\n            multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference);\n    }\n\n    function transferToICAP(bytes32 _icap, uint _value) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, """");\n    }\n\n    function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferToICAPWithReference(_icap, _value, _reference);\n    }\n\n    function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private noValue() returns(bool) {\n        return _isHuman() ?\n            multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) :\n            multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference);\n    }\n    \n    function transferFrom(address _from, address _to, uint _value) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, """");\n    }\n\n    function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) {\n        return __transferFromWithReference(_from, _to, _value, _reference);\n    }\n\n    function __transferFromWithReference(address _from, address _to, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference);\n    }\n\n    function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, """");\n    }\n\n    function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) {\n        return __transferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function __transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) private noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference);\n    }\n\n    function approve(address _spender, uint _value) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxyApprove(_spender, _value, symbol);\n    }\n\n    function setCosignerAddress(address _cosigner) noValue() onlyHuman() returns(bool) {\n        return multiAsset.proxySetCosignerAddress(_cosigner, symbol);\n    }\n\n    function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() {\n        Transfer(_from, _to, _value);\n    }\n\n    function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() {\n        Approve(_from, _spender, _value);\n    }\n\n    function sendToOwner() noValue() returns(bool) {\n        address owner = multiAsset.owner(symbol);\n        uint balance = this.balance;\n        bool success = true;\n        if (balance > 0) {\n            success = _unsafeSend(owner, balance);\n        }\n        return multiAsset.transfer(owner, balanceOf(owner), symbol) && success;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1963148,0xae0680c49df146e18b2bc19635e5e402494b5d67,false,false,"contract DaoAccount\n{\n	/**************************\n			    Constants\n	***************************/\n\n	/**************************\n					Events\n	***************************/\n\n	// No events\n\n	/**************************\n	     Public variables\n	***************************/\n\n\n	/**************************\n	     Private variables\n	***************************/\n\n	uint256 tokenBalance; // number of tokens in this account\n  address owner;        // owner of the otkens\n	address daoChallenge; // the DaoChallenge this account belongs to\n	uint256 tokenPrice;\n\n  // Owner of the challenge with backdoor access.\n  // Remove for a real DAO contract:\n  address challengeOwner;\n\n	/**************************\n			     Modifiers\n	***************************/\n\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyOwner() {if (owner != msg.sender) throw; _}\n\n	modifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _}\n\n	modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\n\n	/**************************\n	 Constructor and fallback\n	**************************/\n\n  function DaoAccount (address _owner, uint256 _tokenPrice, address _challengeOwner) noEther {\n    owner = _owner;\n		tokenPrice = _tokenPrice;\n    daoChallenge = msg.sender;\n		tokenBalance = 0;\n\n    // Remove for a real DAO contract:\n    challengeOwner = _challengeOwner;\n	}\n\n	function () {\n		throw;\n	}\n\n	/**************************\n	     Private functions\n	***************************/\n\n	/**************************\n			 Public functions\n	***************************/\n\n	function getTokenBalance() constant returns (uint256 tokens) {\n		return tokenBalance;\n	}\n\n	function buyTokens() onlyDaoChallenge returns (uint256 tokens) {\n		uint256 amount = msg.value;\n\n		// No free tokens:\n		if (amount == 0) throw;\n\n		// No fractional tokens:\n		if (amount % tokenPrice != 0) throw;\n\n		tokens = amount / tokenPrice;\n\n		tokenBalance += tokens;\n\n		return tokens;\n	}\n\n	function withdraw(uint256 tokens) noEther onlyDaoChallenge {\n		if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw;\n		tokenBalance -= tokens;\n		if(!owner.call.value(tokens * tokenPrice)()) throw;\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyChallengeOwner {\n		suicide(challengeOwner);\n	}\n}\n\ncontract DaoChallenge\n{\n	/**************************\n					Constants\n	***************************/\n\n	uint256 constant public tokenPrice = 1000000000000000; // 1 finney\n\n	/**************************\n					Events\n	***************************/\n\n	event notifyTerminate(uint256 finalBalance);\n\n	event notifyNewAccount(address owner, address account);\n	event notifyBuyToken(address owner, uint256 tokens, uint256 price);\n	event notifyWithdraw(address owner, uint256 tokens);\n\n	/**************************\n	     Public variables\n	***************************/\n\n	mapping (address => DaoAccount) public daoAccounts;\n\n	/**************************\n			 Private variables\n	***************************/\n\n	// Owner of the challenge; a real DAO doesn't an owner.\n	address challengeOwner;\n\n	/**************************\n					 Modifiers\n	***************************/\n\n	modifier noEther() {if (msg.value > 0) throw; _}\n\n	modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _}\n\n	/**************************\n	 Constructor and fallback\n	**************************/\n\n	function DaoChallenge () {\n		challengeOwner = msg.sender; // Owner of the challenge. Don't use this in a real DAO.\n	}\n\n	function () noEther {\n	}\n\n	/**************************\n	     Private functions\n	***************************/\n\n	function accountFor (address accountOwner, bool createNew) private returns (DaoAccount) {\n		DaoAccount account = daoAccounts[accountOwner];\n\n		if(account == DaoAccount(0x00) && createNew) {\n			account = new DaoAccount(accountOwner, tokenPrice, challengeOwner);\n			daoAccounts[accountOwner] = account;\n			notifyNewAccount(accountOwner, address(account));\n		}\n\n		return account;\n	}\n\n	/**************************\n	     Public functions\n	***************************/\n\n	function getTokenBalance () constant noEther returns (uint256 tokens) {\n		DaoAccount account = accountFor(msg.sender, false);\n		if (account == DaoAccount(0x00)) return 0;\n		return account.getTokenBalance();\n	}\n\n	function buyTokens () returns (uint256 tokens) {\n	  DaoAccount account = accountFor(msg.sender, true);\n		tokens = account.buyTokens.value(msg.value)();\n\n		notifyBuyToken(msg.sender, tokens, msg.value);\n		return tokens;\n 	}\n\n	function withdraw(uint256 tokens) noEther {\n		DaoAccount account = accountFor(msg.sender, false);\n		if (account == DaoAccount(0x00)) throw;\n\n		account.withdraw(tokens);\n		notifyWithdraw(msg.sender, tokens);\n	}\n\n	// The owner of the challenge can terminate it. Don't use this in a real DAO.\n	function terminate() noEther onlyChallengeOwner {\n		notifyTerminate(this.balance);\n		suicide(challengeOwner);\n	}\n}",1,実用的なDAOスマートコントラクトで、特に芸術的な要素は見られません。
1964677,0xcf00354366bca2f2cd49007bfaeac49d97463200,false,false,"contract ConnectSix {\n\n  uint8 constant public board_size = 19;\n\n  Game[] public games;\n\n  struct Game {\n      mapping(uint8 => mapping(uint8 => uint8)) board;\n      uint8[] move_history;\n      address[3] players;\n      // 0 means game did not start yet\n      uint8 turn;\n      // Either 1 or 2. 0 means not finished\n      uint8 winner;\n      // true if players agreed to a draw\n      uint time_per_move;\n      // if move is not made by this time, opponent can claim victory\n      uint deadline;\n      // amount player 1 put in\n      uint player_1_stake;\n      // amount player 2 must send to join\n      uint player_2_stake;\n  }\n\n  event LogGameCreated(uint game_num);\n  event LogGameStarted(uint game_num);\n  event LogVictory(uint game_num, uint8 winner);\n  event LogMoveMade(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2);\n\n  function new_game(uint _time_per_move, uint opponent_stake) {\n    games.length++;\n    Game g = games[games.length - 1];\n    g.players[1] = msg.sender;\n    g.time_per_move = _time_per_move;\n    g.player_1_stake = msg.value;\n    g.player_2_stake = opponent_stake;\n    // make the first move in the center of the board\n    g.board[board_size / 2][board_size / 2] = 1;\n    LogGameCreated(games.length - 1);\n  }\n\n  function join_game(uint game_num) {\n    Game g = games[game_num];\n    if (g.turn != 0 || g.player_2_stake != msg.value) {\n      throw;\n    }\n    g.players[2] = msg.sender;\n    // It's the second player's turn because the first player automatically makes a single move in the center\n    g.turn = 2;\n    g.deadline = now + g.time_per_move;\n    LogGameStarted(game_num);\n  }\n\n  function player_1(uint game_num) constant returns (address) {\n    return games[game_num].players[1];\n  }\n  \n  function player_2(uint game_num) constant returns (address) {\n    return games[game_num].players[2];\n  }\n\n  function board(uint game_num, uint8 x, uint8 y) constant returns (uint8) {\n    return games[game_num].board[x][y];\n  }\n\n  function move_history(uint game_num) constant returns (uint8[]) {\n      return games[game_num].move_history;\n  }\n\n  function single_move(uint game_num, uint8 x, uint8 y) internal {\n    if (x > board_size || y > board_size) {\n      throw;\n    }\n    Game g = games[game_num];\n    if (g.board[x][y] != 0) {\n      throw;\n    }\n    g.board[x][y] = g.turn;\n  }\n\n  function make_move(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2) {\n    Game g = games[game_num];\n    if (g.winner != 0 || msg.sender != g.players[g.turn]) {\n      throw;\n    }\n    single_move(game_num, x1, y1);\n    single_move(game_num, x2, y2);\n    g.turn = 3 - g.turn;\n    g.deadline = now + g.time_per_move;\n    g.move_history.length++;\n    g.move_history[g.move_history.length - 1] = x1;\n    g.move_history.length++;\n    g.move_history[g.move_history.length - 1] = y1;\n    g.move_history.length++;\n    g.move_history[g.move_history.length - 1] = x2;\n    g.move_history.length++;\n    g.move_history[g.move_history.length - 1] = y2;\n    LogMoveMade(game_num, x1, y1, x2, y2);\n  }\n\n  function make_move_and_claim_victory(uint game_num, uint8 x1, uint8 y1, uint8 x2, uint8 y2, uint8 wx, uint8 wy, uint8 dir) {\n    make_move(game_num, x1, y1, x2, y2);\n    claim_victory(game_num, wx, wy, dir);\n  }\n  \n  function pay_winner(uint game_num) internal {\n    Game g = games[game_num];\n    uint amount = g.player_1_stake + g.player_2_stake;\n    if (amount > 0 && !g.players[g.winner].send(amount)) {\n      throw;\n    }\n  }\n\n  function claim_time_victory(uint game_num) {\n    Game g = games[game_num];\n    if (g.winner != 0 || g.deadline == 0 || now <= g.deadline) {\n      throw;\n    }\n    g.winner = 3 - g.turn;\n    pay_winner(game_num);\n    LogVictory(game_num, g.winner);\n  }\n\n  function claim_victory(uint game_num, uint8 x, uint8 y, uint8 dir) {\n    Game g = games[game_num];\n    if (x > board_size \n        || y > board_size\n        || g.winner != 0\n        || g.board[x][y] == 0\n        || dir > 3) {\n      throw;\n    }\n    // We don't have to worry about overflow and underflows here because all the values outside the \n    // 19 x 19 board are 0\n    if (dir == 3) {\n      // this is going diagonal (10:30pm)\n      for (uint8 j = 1; j < 6; j++) {\n        if (g.board[x - j*dx][y + j*dy] != g.board[x][y]) {\n          throw;\n        }\n      }\n    } else {\n      uint8 dx = 0;\n      uint8 dy = 0;\n      if (dir == 2) {\n        // diagonal - 1:30pm\n        dx = 1;\n        dy = 1;\n      } else if (dir == 1) {\n        // 12:00pm\n        dy = 1;\n      } else {\n        // 3 pm\n        dx = 1;\n      }\n      for (uint8 i = 1; i < 6; i++) {\n        if (g.board[x + i*dx][y + i*dy] != g.board[x][y]) {\n          throw;\n        }\n      }\n    }\n    g.winner = g.board[x][y];\n    pay_winner(game_num);\n    LogVictory(game_num, g.winner);\n  }\n}",1,ConnectSixゲームの実装で、実用的なスマートコントラクトとしての構造を持っています。
1964717,0xa35fc4d3ea15e0d9272dc181ee1c2761d5d0cabd,false,false,contract UsernameRegistry {\n\n  mapping(address => string) addr_to_str;\n  mapping(string => address) str_to_addr;\n\n  function register(string username) {\n    if (str_to_addr[username] != address(0)) {\n      // username taken\n      throw;\n    }\n    str_to_addr[addr_to_str[msg.sender]] = address(0);\n    addr_to_str[msg.sender] = username;\n    str_to_addr[username] = msg.sender;\n  }\n\n  function get_username(address addr) constant returns (string) {\n    return addr_to_str[addr];\n  }\n\n  function get_address(string username) constant returns (address) {\n    return str_to_addr[username];\n  }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1970363,0x3474627d4f63a678266bc17171d87f8570936622,false,false,"contract Splitter {\n    \n    bool _classic;\n    address _owner;\n    \n    function Splitter() {\n        _owner = msg.sender;\n\n        // Balance on classic is 0.000007625764205414 (at the time of this contract)\n        if (address(0xbf4ed7b27f1d666546e30d74d50d173d20bca754).balance < 1 ether) {\n            _classic = true;\n        }\n    }\n\n    function isClassic() constant returns (bool) {\n        return _classic;\n    }\n    \n    // Returns the ether on the real network to the sender, while forwarding\n    // the classic ether to a new address.\n    function split(address classicAddress) {\n        if (_classic){\n            if (!(classicAddress.send(msg.value))) {\n                throw;\n            }\n        } else {\n            if (!(msg.sender.send(msg.value))) {\n                throw;\n            }\n        }\n    }\n\n    function claimDonations(uint balance) {\n        if (_owner != msg.sender) { return; }\n        if (!(_owner.send(balance))) {\n            throw;\n        }\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
1974383,0x5d4c95284d7b0a271c2c030cf803b24646ee0dcb,false,false,"// This MasterRegistry keeps a list of all registries created using Regis.\n// From it, you can search registries by its name, tags or owner and retrieve\n// registries info.\n\ncontract MasterRegistry {\n\n    // This struct keeps a list of attributes that all registries have.\n    struct RegistryAttributes {\n        uint      creationTime;\n        string    description;\n        address   owner;\n        string    name;\n        bytes32[] tags;\n        uint      version; // To keep backward compatibility\n        uint      addressIndex; // Index in the addresses array for quick lookup.\n\n        // Keeps the solidity source of the registry\n        // Storing the source on the blockchain is expensive but it is worth it. \n        // Previous version didn't store and was able to rebuild the registry\n        // source from its parameters. But this showed to be problematic in \n        // some cases.\n        string source; \n        // To keep backward compatibility with version 1, source will have \n        // keyType and recordAttributes stored in the source variable and the\n        // solidity source for those old registries will be unavailable.\n    }\n\n    // Maps registry's address to its record.\n    mapping (address => RegistryAttributes) public registries;\n    uint public numRegistries;\n\n    // Keeps a list of all registries' addresses\n    address[] public addresses;\n\n    // maps owner -> list of registries' addresses\n    mapping (address => address[]) public indexedByOwner;\n\n    // maps tag -> list of registries' addresses\n    mapping (bytes32 => address[]) public indexedByTag;\n\n    // maps name -> list of registries' addresses\n    mapping (string => address[]) indexedByName; // cant use public here because it's indexed by string\n\n    modifier onlyOwner(address regAddress) {\n        if (registries[regAddress].owner != msg.sender) throw;\n        _\n    }\n\n    function addRegistryIntoOwnerIndex(address regAddress, address owner) internal {\n        address[] regs = indexedByOwner[owner];\n        regs.length++;\n        regs[regs.length - 1] = regAddress;\n    }\n\n    function addRegistryIntoNameIndex(address regAddress) internal {\n        address[] regs = indexedByName[registries[regAddress].name];\n        regs.length++;\n        regs[regs.length - 1] = regAddress;\n    }\n\n    function addRegistryIntoTagsIndex(address regAddress) internal {\n        bytes32[] tags = registries[regAddress].tags;\n        for (uint i = 0; i < tags.length; i++) {\n            address[] regs = indexedByTag[tags[i]];\n            regs.length++;\n            regs[regs.length - 1] = regAddress;\n        }\n    }\n\n    function register(address regAddress, address owner, string name, string description, \n                      bytes32[] tags, uint version, string source) {\n\n        if (registries[regAddress].creationTime != 0) {\n            // throw;\n            return;\n        }\n\n        registries[regAddress].creationTime = now;\n        //registries[regAddress].owner        = msg.sender;\n        registries[regAddress].owner        = owner;\n        registries[regAddress].description  = description;\n        registries[regAddress].name         = name;\n        registries[regAddress].version      = version;\n        registries[regAddress].tags         = tags;\n        registries[regAddress].source       = source;\n        registries[regAddress].addressIndex = numRegistries;\n        numRegistries++;\n\n        addresses.length++;\n        addresses[numRegistries - 1] = regAddress;\n\n        addRegistryIntoOwnerIndex(regAddress, owner);\n\n        addRegistryIntoNameIndex(regAddress);\n\n        addRegistryIntoTagsIndex(regAddress);\n\n    }\n\n    function removeRegistryFromOwnerIndex(address regAddress) internal {\n        address[] regs = indexedByOwner[msg.sender];\n        for (uint i = 0; i < regs.length; i++) {\n            if (regs[i] == regAddress) {\n                regs[i] = regs[regs.length - 1];\n                regs.length--;\n                break;\n            }\n        }\n    }\n\n    function removeRegistryFromNameIndex(address regAddress) internal {\n        address[] regs = indexedByName[registries[regAddress].name];\n        for (uint j = 0; j < regs.length; j++) {\n            if (regs[j] == regAddress) {\n                regs[j] = regs[regs.length - 1];\n                regs.length--;\n                break;\n            }\n        }\n    }\n\n    function removeRegistryFromTagsIndex(address regAddress) internal {\n        uint numTags = registries[regAddress].tags.length;\n        for (uint k = 0; k < numTags; k++) {\n            address[] regs = indexedByTag[registries[regAddress].tags[k]];\n            for (uint l = 0; l < regs.length; l++) {\n                if (regs[l] == regAddress) {\n                    regs[l] = regs[regs.length - 1];\n                    regs.length--;\n                    break;\n                }\n            }\n        }\n    }\n\n    function unregister(address regAddress) onlyOwner(regAddress) {\n\n        removeRegistryFromOwnerIndex(regAddress);\n        removeRegistryFromNameIndex(regAddress);\n        removeRegistryFromTagsIndex(regAddress);\n\n        addresses[registries[regAddress].addressIndex] = addresses[addresses.length - 1];\n        addresses.length--;\n\n        delete registries[regAddress];\n        numRegistries--;\n    }\n\n    function changeDescription(address regAddress, string newDescription) onlyOwner(regAddress) {\n        registries[regAddress].description = newDescription;\n    }\n\n    function changeName(address regAddress, string newName) onlyOwner(regAddress) {\n        removeRegistryFromNameIndex(regAddress);\n        registries[regAddress].name = newName;\n        addRegistryIntoNameIndex(regAddress);\n    }\n\n    function transfer(address regAddress, address newOwner) onlyOwner(regAddress) {\n        removeRegistryFromOwnerIndex(regAddress);\n        registries[regAddress].owner = newOwner;\n        addRegistryIntoOwnerIndex(regAddress, newOwner);\n    }\n\n    function searchByName(string name) constant returns (address[]) {\n        return indexedByName[name];\n    }\n\n    function searchByTag(bytes32 tag) constant returns (address[]) {\n        return indexedByTag[tag];\n    }\n\n    function searchByOwner(address owner) constant returns (address[]) {\n        return indexedByOwner[owner];\n    }\n\n    function getRegInfo(address regAddress) constant returns (address owner, uint creationTime, \n                        string name, string description, uint version, bytes32[] tags, string source) {\n        owner        = registries[regAddress].owner;\n        creationTime = registries[regAddress].creationTime;\n        name         = registries[regAddress].name;\n        description  = registries[regAddress].description;\n        version      = registries[regAddress].version;\n        tags         = registries[regAddress].tags;\n        source       = registries[regAddress].source;\n    }\n\n    // This function is only valid for a very small amount of time\n    // after which it will become useless!\n    // It was used to migrate registries from old MasterRegistry\n    // into this new one and fix old registries creation_time (which\n    // are now inside the registry itself).\n    function setTime(address regAddress, uint time) {\n        if (now < 1469830946) { // Valid up to 29-Jul-2016 19:22:26\n            registries[regAddress].creationTime = time;\n        }\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。データ管理に焦点を当てた設計。
1975020,0x74c1e4b8cae59269ec1d85d3d4f324396048f4ac,true,false,"/**\n * Author: Nick Johnson (arachnid at notdot.net)\n * Copyright 2016; licensed CC-BY-SA.\n * \n * BeerCoin is a new cryptocurrency intended to encapsulate and record the\n * concept of ""I owe you a beer"". Did someone answer a difficult question you\n * had? Send them a BeerCoin. Did they help you carry something heavy? Send\n * them a BeerCoin. Someone buy you a beer? Send them a BeerCoin.\n * \n * Unlike traditional currency, anyone can issue BeerCoin simply by sending it\n * to someone else. A person's BeerCoin is only as valuable as the recipient's\n * belief that they're good for the beer, should it ever be redeemed; a beer\n * owed to you by Vitalik Buterin is probably worth more than a beer owed to you\n * by the DAO hacker (but your opinions may differ on that point).\n * \n * BeerCoin is implemented as an ERC20 compatible token, with a few extensions.\n * Regular ERC20 transfers will create or resolve obligations between the two\n * parties; they will never transfer third-party BeerCoins. Additional methods\n * are provided to allow you transfer beers someone owes you to a third party;\n * if Satoshi Nakamoto owes you a beer, you can transfer that obligation to your\n * friend who just bought you one down at the pub. Methods are also provided for\n * determining the total number of beers a person owes, to help determine if\n * they're good for it, and for getting a list of accounts that owe someone a\n * beer.\n * \n * BeerCoin may confuse some wallets, such as Mist, that expect you can only\n * send currency up to your current total balance; since BeerCoin operates as\n * individual IOUs, that restriction doesn't apply. As a result, you will\n * sometimes need to call the 'transfer' function on the contract itself\n * instead of using the wallet's built in token support.\n * \n * If anyone finds a bug in the contract, I'll buy you a beer. If you find a bug\n * you can exploit to adjust balances without users' consent, I'll buy you two\n * (or more).\n * \n * If you feel obliged to me for creating this, send me a ? at\n * 0x5fC8A61e097c118cE43D200b3c4dcf726Cf783a9. Don't do it unless you mean it;\n * if we meet I'll surely redeem it.\n */\ncontract BeerCoin {\n    using Itmap for Itmap.AddressUintMap;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n    struct UserAccount {\n        bool exists;\n        Itmap.AddressUintMap debtors; // People who owe you a beer\n        mapping(address=>uint) allowances;\n        uint maxCredit; // Most beers any individual may owe you\n        uint beersOwed; // Beers owed by this person\n        uint beersOwing; // Beers owed to this person\n    }\n    uint beersOwing;\n    uint defaultMaxCredit;\n    \n    function() {\n        throw;\n    }\n    \n    function BeerCoin(uint _defaultMaxCredit) {\n        defaultMaxCredit = _defaultMaxCredit;\n    }\n    \n    mapping(address=>UserAccount) accounts;\n\n    function maximumCredit(address owner) constant returns (uint) {\n        if(accounts[owner].exists) {\n            return accounts[owner].maxCredit;\n        } else {\n            return defaultMaxCredit;\n        }\n    }\n\n    function setMaximumCredit(uint credit) {\n        //640k ought to be enough for anyone\n        if(credit > 655360)\n            return;\n\n        if(!accounts[msg.sender].exists)\n            accounts[msg.sender].exists = true;\n        accounts[msg.sender].maxCredit = credit;\n    }\n    \n    function numDebtors(address owner) constant returns (uint) {\n        return accounts[owner].debtors.size();\n    }\n    \n    function debtor(address owner, uint idx) constant returns (address) {\n        return accounts[owner].debtors.index(idx);\n    }\n    \n    function debtors(address owner) constant returns (address[]) {\n        return accounts[owner].debtors.keys;\n    }\n\n    function totalSupply() constant returns (uint256 supply) {\n        return beersOwing;   \n    }\n    \n    function balanceOf(address owner) constant returns (uint256 balance) {\n        return accounts[owner].beersOwing;\n    }\n    \n    function balanceOf(address owner, address debtor) constant returns (uint256 balance) {\n        return accounts[owner].debtors.get(debtor);\n    }\n    \n    function totalDebt(address owner) constant returns (uint256 balance) {\n        return accounts[owner].beersOwed;\n    }\n    \n    function transfer(address to, uint256 value) returns (bool success) {\n        return doTransfer(msg.sender, to, value);\n    }\n    \n    function transferFrom(address from, address to, uint256 value) returns (bool) {\n        if(accounts[from].allowances[msg.sender] >= value && doTransfer(from, to, value)) {\n            accounts[from].allowances[msg.sender] -= value;\n            return true;\n        }\n        return false;\n    }\n    \n    function doTransfer(address from, address to, uint value) internal returns (bool) {\n        if(from == to)\n            return false;\n            \n        if(!accounts[to].exists) {\n            accounts[to].exists = true;\n            accounts[to].maxCredit = defaultMaxCredit;\n        }\n        \n        // Don't allow transfers that would exceed the recipient's credit limit.\n        if(value > accounts[to].maxCredit + accounts[from].debtors.get(to))\n            return false;\n        \n        Transfer(from, to, value);\n\n        value -= reduceDebt(to, from, value);\n        createDebt(from, to, value);\n\n        return true;\n    }\n    \n    // Transfers beers owed to you by `debtor` to `to`.\n    function transferOther(address to, address debtor, uint value) returns (bool) {\n        return doTransferOther(msg.sender, to, debtor, value);\n    }\n\n    // Allows a third party to transfer debt owed to you by `debtor` to `to`.    \n    function transferOtherFrom(address from, address to, address debtor, uint value) returns (bool) {\n        if(accounts[from].allowances[msg.sender] >= value && doTransferOther(from, to, debtor, value)) {\n            accounts[from].allowances[msg.sender] -= value;\n            return true;\n        }\n        return false;\n    }\n    \n    function doTransferOther(address from, address to, address debtor, uint value) internal returns (bool) {\n        if(from == to || to == debtor)\n            return false;\n            \n        if(!accounts[to].exists) {\n            accounts[to].exists = true;\n            accounts[to].maxCredit = defaultMaxCredit;\n        }\n        \n        if(transferDebt(from, to, debtor, value)) {\n            Transfer(from, to, value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    // Creates debt owed by `debtor` to `creditor` of amount `value`.\n    // Returns false without making changes if this would exceed `creditor`'s\n    // credit limit.\n    function createDebt(address debtor, address creditor, uint value) internal returns (bool) {\n        if(value == 0)\n            return true;\n        \n        if(value > accounts[creditor].maxCredit)\n            return false;\n\n        accounts[creditor].debtors.set(\n            debtor, accounts[creditor].debtors.get(debtor) + value);\n        accounts[debtor].beersOwed += value;\n        accounts[creditor].beersOwing += value;\n        beersOwing += value;\n        \n        return true;\n    }\n    \n    // Reduces debt owed by `debtor` to `creditor` by `value` or the total amount,\n    // whichever is less. Returns the amount of debt erased.\n    function reduceDebt(address debtor, address creditor, uint value) internal returns (uint) {\n        var owed = accounts[creditor].debtors.get(debtor);\n        if(value >= owed) {\n            value = owed;\n            \n            accounts[creditor].debtors.remove(debtor);\n        } else {\n            accounts[creditor].debtors.set(debtor, owed - value);\n        }\n        \n        accounts[debtor].beersOwed -= value;\n        accounts[creditor].beersOwing -= value;\n        beersOwing -= value;\n        \n        return value;\n    }\n    \n    // Transfers debt owed by `debtor` from `oldCreditor` to `newCreditor`.\n    // Returns false without making any changes if `value` exceeds the amount\n    // owed or if the transfer would exceed `newCreditor`'s credit limit.\n    function transferDebt(address oldCreditor, address newCreditor, address debtor, uint value) internal returns (bool) {\n        var owedOld = accounts[oldCreditor].debtors.get(debtor);\n        if(owedOld < value)\n            return false;\n        \n        var owedNew = accounts[newCreditor].debtors.get(debtor);\n        if(value + owedNew > accounts[newCreditor].maxCredit)\n            return false;\n        \n        \n        if(owedOld == value) {\n            accounts[oldCreditor].debtors.remove(debtor);\n        } else {\n            accounts[oldCreditor].debtors.set(debtor, owedOld - value);\n        }\n        accounts[oldCreditor].beersOwing -= value;\n        \n        accounts[newCreditor].debtors.set(debtor, owedNew + value);\n        accounts[newCreditor].beersOwing += value;\n        \n        return true;\n    }\n\n    function approve(address spender, uint256 value) returns (bool) {\n        accounts[msg.sender].allowances[spender] = value;\n        Approval(msg.sender, spender, value);\n        return true;\n    }\n    \n    function allowance(address owner, address spender) constant returns (uint256) {\n        return accounts[owner].allowances[spender];\n    }\n}\n\n\nlibrary Itmap {\n    struct AddressUintMapEntry {\n        uint value;\n        uint idx;\n    }\n    \n    struct AddressUintMap {\n        mapping(address=>AddressUintMapEntry) entries;\n        address[] keys;\n    }\n    \n    function set(AddressUintMap storage self, address k, uint v) internal {\n        var entry = self.entries[k];\n        if(entry.idx == 0) {\n            entry.idx = self.keys.length + 1;\n            self.keys.push(k);\n        }\n        entry.value = v;\n    }\n    \n    function get(AddressUintMap storage self, address k) internal returns (uint) {\n        return self.entries[k].value;\n    }\n    \n    function contains(AddressUintMap storage self, address k) internal returns (bool) {\n        return self.entries[k].idx > 0;\n    }\n    \n    function remove(AddressUintMap storage self, address k) internal {\n        var entry = self.entries[k];\n        if(entry.idx > 0) {\n            var otherkey = self.keys[self.keys.length - 1];\n            self.keys[entry.idx - 1] = otherkey;\n            self.keys.length -= 1;\n            \n            self.entries[otherkey].idx = entry.idx;\n            entry.idx = 0;\n            entry.value = 0;\n        }\n    }\n    \n    function size(AddressUintMap storage self) internal returns (uint) {\n        return self.keys.length;\n    }\n    \n    function index(AddressUintMap storage self, uint idx) internal returns (address) {\n        return self.keys[idx];\n    }\n}",2,ビールをテーマにしたユニークなコンセプトが詩的で、実用性と遊び心を兼ね備えています。
1977161,0x7f9af66163461009e9a4c57f6d3c6421bc47a663,false,false,contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract ClassicOnlyTransfer {\n\n  // Fork oracle to use\n  AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n\n  address public transferTo = 0x502f9aa95d45426915bff7b92ef90468b100cc9b;\n  \n  function () {\n    if ( amIOnTheFork.forked() ) throw;\n\n    transferTo.send( msg.value );\n  }\n  \n},1,フォーク検出と送金を行う実用的なスマートコントラクト。標準的な構造です。
1978437,0x9d0135658dd0472310e44bcd520fd0a141db0bbb,false,false,"contract DAO {\n    function balanceOf(address addr) returns (uint);\n    function transferFrom(address from, address to, uint balance) returns (bool);\n    function getNewDAOAddress(uint _proposalID) constant returns(address _newDAO);\n    uint public totalSupply;\n}\n\n/**\n * @title trustedChildRefund\n * @author Paul Szczesny, Alexey Akhunov\n * A simple refund contract for trusted childDAOs affected by the hard fork.\n * Based on the official WithdrawDAO contract found here: https://etherscan.io/address/0xbf4ed7b27f1d666546e30d74d50d173d20bca754#code\n */\ncontract trustedChildRefund {\n\n  DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);\n  uint[] public trustedProposals = [7, 10, 16, 20, 23, 26, 27, 28, 29, 31, 34, 37, 39, 41, 44, 52, 54, 56, 57, 60, 61, 63, 64, 65, 66];\n  mapping (uint => DAO) public whiteList;\n\n  /**\n  * Populates the whiteList based on the list of trusted proposal Ids.\n  */\n  function trustedChildRefund() {\n      for(uint i=0; i<trustedProposals.length; i++) {\n          uint proposalId = trustedProposals[i];\n          whiteList[proposalId] = DAO(mainDAO.getNewDAOAddress(proposalId));\n      }\n  }\n\n  /**\n  * Convienience function for the Curator to calculate the required amount of Wei\n  * that needs to be transferred to this contract.\n  */\n  function requiredEndowment() constant returns (uint endowment) {\n      uint sum = 0;\n      for(uint i=0; i<trustedProposals.length; i++) {\n          uint proposalId = trustedProposals[i];\n          DAO childDAO = whiteList[proposalId];\n          sum += childDAO.totalSupply();\n      }\n      return sum;\n  }\n\n  /**\n   * Function call to refund ETH by burning childDao tokens.\n   * @param proposalId The split proposal ID which created the childDao\n   * @dev This requires that the token-holder authorizes this contract's address using the approve() function.\n   */\n  function refund(uint proposalId) {\n    //Check the token balance\n    uint balance = whiteList[proposalId].balanceOf(msg.sender);\n\n    // Transfer childDao tokens first, then send Ether back in return\n    if (!whiteList[proposalId].transferFrom(msg.sender, this, balance) || !msg.sender.send(balance))\n      throw;\n  }\n\n}",1,実用的なコードで、特定の目的を持つ標準的なスマートコントラクトです。
1981227,0xc5b2508e878af367ba4957bdbeb2bbc6da5bb349,false,false,"contract AmIOnTheFork {\n    function forked() constant returns(bool);\n}\n\ncontract Ethsplit {\n\n    function split(address ethAddress, address etcAddress) {\n\n        if (amIOnTheFork.forked()) {\n            // if on the forked chain send ETH to ethAddress\n            ethAddress.call.value(msg.value)();\n        } \n        else {\n            // if not on the forked chain send ETC to etcAddress less fee\n            uint fee = msg.value/100;\n            fees.send(fee);\n            etcAddress.call.value(msg.value-fee)();\n        }\n    }\n\n    // Reject deposits to the contract\n    function () {\n        throw;  \n    }\n\n    // AmIOnTheFork oracle by _tr\n    AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362);\n    address fees = 0xdE17a240b031a4607a575FE13122d5195B43d6fC;\n}",1,フォークチェーンの判定と送金を行う実用的なスマートコントラクト。標準的な構造です。
1981932,0xcc9724b345887827cb5eae025cad9f4ccc3c90f6,false,false,"// King of the Ether Throne Contracts.\n// Copyright (c) 2016 Kieran Elby. Released under the MIT License.\n// Version 0.9.9.2, July 2016.\n//\n// See also http://www.kingoftheether.com and\n// https://github.com/kieranelby/KingOfTheEtherThrone .\n// \n// This file contains a number of contracts, of which only\n// these three are normally created:\n//\n// - Kingdom        = maintains the throne for a kingdom\n// - World          = runs the world, which is a collection of kingdoms\n// - KingdomFactory = used internally by the World contract\n//\n// The ""Mixin"" contracts (ThroneRulesMixin, ReentryProtectorMixin,\n// CarefulSenderMixin, FundsHolderMixin, MoneyRounderMixin,\n// NameableMixin) contain functions / data / structures used\n// by the three main contracts.\n// The ExposedInternalsForTesting contract is used by automated tests.\n\n\n/// @title Mixin to help avoid recursive-call attacks.\ncontract ReentryProtectorMixin {\n\n    // true if we are inside an external function\n    bool reentryProtector;\n\n    // Mark contract as having entered an external function.\n    // Throws an exception if called twice with no externalLeave().\n    // For this to work, Contracts MUST:\n    //  - call externalEnter() at the start of each external function\n    //  - call externalLeave() at the end of each external function\n    //  - never use return statements in between enter and leave\n    //  - never call an external function from another function\n    // WARN: serious risk of contract getting stuck if used wrongly.\n    function externalEnter() internal {\n        if (reentryProtector) {\n            throw;\n        }\n        reentryProtector = true;\n    }\n\n    // Mark contract as having left an external function.\n    // Do this after each call to externalEnter().\n    function externalLeave() internal {\n        reentryProtector = false;\n    }\n\n}\n\n\n/// @title Mixin to help send ether to untrusted addresses.\ncontract CarefulSenderMixin {\n\n    // Seems a reasonable amount for a well-written fallback function.\n    uint constant suggestedExtraGasToIncludeWithSends = 23000;\n\n    // Send `_valueWei` of our ether to `_toAddress`, including\n    // `_extraGasIncluded` gas above the usual 2300 gas stipend\n    // with the send call.\n    //\n    // This needs care because there is no way to tell if _toAddress\n    // is externally owned or is another contract - and sending ether\n    // to a contract address will invoke its fallback function; this\n    // has three implications:\n    //\n    // 1) Danger of recursive attack.\n    //  The destination contract's fallback function (or another\n    //  contract it calls) may call back into this contract (including\n    //  our fallback function and external functions inherited, or into\n    //  other contracts in our stack), leading to unexpected behaviour.\n    //  Mitigations:\n    //   - protect all external functions against re-entry into\n    //     any of them (see ReentryProtectorMixin);\n    //   - program very defensively (e.g. debit balance before send).\n    //\n    // 2) Destination fallback function can fail.\n    //  If the destination contract's fallback function fails, ether\n    //  will not be sent and may be locked into the sending contract.\n    //  Unlike most errors, it will NOT cause this contract to throw.\n    //  Mitigations:\n    //   - check the return value from this function (see below).\n    //\n    // 3) Gas usage.\n    //  The destination fallback function will consume the gas supplied\n    //  in this transaction (which is fixed and set by the transaction\n    //  starter, though some clients do a good job of estimating it.\n    //  This is a problem for lottery-type contracts where one very\n    //  expensive-to-call receiving contract could 'poison' the lottery\n    //  contract by preventing it being invoked by another person who\n    //  cannot supply enough gas.\n    //  Mitigations:\n    //    - choose sensible value for _extraGasIncluded (by default\n    //      only 2300 gas is supplied to the destination function);\n    //    - if call fails consider whether to throw or to ring-fence\n    //      funds for later withdrawal.\n    //\n    // Returns:\n    //\n    //  True if-and-only-if the send call was made and did not throw\n    //  an error. In this case, we will no longer own the _valueWei\n    //  ether. Note that we cannot get the return value of the fallback\n    //  function called (if any).\n    //\n    //  False if the send was made but the destination fallback function\n    //  threw an error (or ran out of gas). If this hapens, we still own\n    //  _valueWei ether and the destination's actions were undone.\n    //\n    //  This function should not normally throw an error unless:\n    //    - not enough gas to make the send/call\n    //    - max call stack depth reached\n    //    - insufficient ether\n    //\n    function carefulSendWithFixedGas(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGasIncluded\n    ) internal returns (bool success) {\n        return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)();\n    }\n\n}\n\n\n/// @title Mixin to help track who owns our ether and allow withdrawals.\ncontract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin {\n\n    // Record here how much wei is owned by an address.\n    // Obviously, the entries here MUST be backed by actual ether\n    // owned by the contract - we cannot enforce that in this mixin.\n    mapping (address => uint) funds;\n\n    event FundsWithdrawnEvent(\n        address fromAddress,\n        address toAddress,\n        uint valueWei\n    );\n\n    /// @notice Amount of ether held for `_address`.\n    function fundsOf(address _address) constant returns (uint valueWei) {\n        return funds[_address];\n    }\n\n    /// @notice Send the caller (`msg.sender`) all ether they own.\n    function withdrawFunds() {\n        externalEnter();\n        withdrawFundsRP();\n        externalLeave();\n    }\n\n    /// @notice Send `_valueWei` of the ether owned by the caller\n    /// (`msg.sender`) to `_toAddress`, including `_extraGas` gas\n    /// beyond the normal stipend.\n    function withdrawFundsAdvanced(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGas\n    ) {\n        externalEnter();\n        withdrawFundsAdvancedRP(_toAddress, _valueWei, _extraGas);\n        externalLeave();\n    }\n\n    /// @dev internal version of withdrawFunds()\n    function withdrawFundsRP() internal {\n        address fromAddress = msg.sender;\n        address toAddress = fromAddress;\n        uint allAvailableWei = funds[fromAddress];\n        withdrawFundsAdvancedRP(\n            toAddress,\n            allAvailableWei,\n            suggestedExtraGasToIncludeWithSends\n        );\n    }\n\n    /// @dev internal version of withdrawFundsAdvanced(), also used\n    /// by withdrawFundsRP().\n    function withdrawFundsAdvancedRP(\n        address _toAddress,\n        uint _valueWei,\n        uint _extraGasIncluded\n    ) internal {\n        if (msg.value != 0) {\n            throw;\n        }\n        address fromAddress = msg.sender;\n        if (_valueWei > funds[fromAddress]) {\n            throw;\n        }\n        funds[fromAddress] -= _valueWei;\n        bool sentOk = carefulSendWithFixedGas(\n            _toAddress,\n            _valueWei,\n            _extraGasIncluded\n        );\n        if (!sentOk) {\n            throw;\n        }\n        FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei);\n    }\n\n}\n\n\n/// @title Mixin to help make nicer looking ether amounts.\ncontract MoneyRounderMixin {\n\n    /// @notice Make `_rawValueWei` into a nicer, rounder number.\n    /// @return A value that:\n    ///   - is no larger than `_rawValueWei`\n    ///   - is no smaller than `_rawValueWei` * 0.999\n    ///   - has no more than three significant figures UNLESS the\n    ///     number is very small or very large in monetary terms\n    ///     (which we define as < 1 finney or > 10000 ether), in\n    ///     which case no precision will be lost.\n    function roundMoneyDownNicely(uint _rawValueWei) constant internal\n    returns (uint nicerValueWei) {\n        if (_rawValueWei < 1 finney) {\n            return _rawValueWei;\n        } else if (_rawValueWei < 10 finney) {\n            return 10 szabo * (_rawValueWei / 10 szabo);\n        } else if (_rawValueWei < 100 finney) {\n            return 100 szabo * (_rawValueWei / 100 szabo);\n        } else if (_rawValueWei < 1 ether) {\n            return 1 finney * (_rawValueWei / 1 finney);\n        } else if (_rawValueWei < 10 ether) {\n            return 10 finney * (_rawValueWei / 10 finney);\n        } else if (_rawValueWei < 100 ether) {\n            return 100 finney * (_rawValueWei / 100 finney);\n        } else if (_rawValueWei < 1000 ether) {\n            return 1 ether * (_rawValueWei / 1 ether);\n        } else if (_rawValueWei < 10000 ether) {\n            return 10 ether * (_rawValueWei / 10 ether);\n        } else {\n            return _rawValueWei;\n        }\n    }\n    \n    /// @notice Convert `_valueWei` into a whole number of finney.\n    /// @return The smallest whole number of finney which is equal\n    /// to or greater than `_valueWei` when converted to wei.\n    /// WARN: May be incorrect if `_valueWei` is above 2**254.\n    function roundMoneyUpToWholeFinney(uint _valueWei) constant internal\n    returns (uint valueFinney) {\n        return (1 finney + _valueWei - 1 wei) / 1 finney;\n    }\n\n}\n\n\n/// @title Mixin to help allow users to name things.\ncontract NameableMixin {\n\n    // String manipulation is expensive in the EVM; keep things short.\n\n    uint constant minimumNameLength = 1;\n    uint constant maximumNameLength = 25;\n    string constant nameDataPrefix = ""NAME:"";\n\n    /// @notice Check if `_name` is a reasonable choice of name.\n    /// @return True if-and-only-if `_name_` meets the criteria\n    /// below, or false otherwise:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    ///   - at least one non-punctuation character\n    /// Note that we deliberately exclude characters which may cause\n    /// security problems for websites and databases if escaping is\n    /// not performed correctly, such as < > "" and '.\n    /// Apologies for the lack of non-English language support.\n    function validateNameInternal(string _name) constant internal\n    returns (bool allowed) {\n        bytes memory nameBytes = bytes(_name);\n        uint lengthBytes = nameBytes.length;\n        if (lengthBytes < minimumNameLength ||\n            lengthBytes > maximumNameLength) {\n            return false;\n        }\n        bool foundNonPunctuation = false;\n        for (uint i = 0; i < lengthBytes; i++) {\n            byte b = nameBytes[i];\n            if (\n                (b >= 48 && b <= 57) || // 0 - 9\n                (b >= 65 && b <= 90) || // A - Z\n                (b >= 97 && b <= 122)   // a - z\n            ) {\n                foundNonPunctuation = true;\n                continue;\n            }\n            if (\n                b == 32 || // space\n                b == 33 || // !\n                b == 40 || // (\n                b == 41 || // )\n                b == 45 || // -\n                b == 46 || // .\n                b == 95    // _\n            ) {\n                continue;\n            }\n            return false;\n        }\n        return foundNonPunctuation;\n    }\n\n    // Extract a name from bytes `_data` (presumably from `msg.data`),\n    // or throw an exception if the data is not in the expected format.\n    // \n    // We want to make it easy for people to name things, even if\n    // they're not comfortable calling functions on contracts.\n    //\n    // So we allow names to be sent to the fallback function encoded\n    // as message data.\n    //\n    // Unfortunately, the way the Ethereum Function ABI works means we\n    // must be careful to avoid clashes between message data that\n    // represents our names and message data that represents a call\n    // to an external function - otherwise:\n    //   a) some names won't be usable;\n    //   b) small possibility of a phishing attack where users are\n    //     tricked into using certain names which cause an external\n    //     function call - e.g. if the data sent to the contract is\n    //     keccak256(""withdrawFunds()"") then a withdrawal will occur.\n    //\n    // So we require a prefix ""NAME:"" at the start of the name (encoded\n    // in ASCII) when sent via the fallback function - this prefix\n    // doesn't clash with any external function signature hashes.\n    //\n    // e.g. web3.fromAscii('NAME:' + 'Joe Bloggs')\n    //\n    // WARN: this does not check the name for ""reasonableness"";\n    // use validateNameInternal() for that.\n    //\n    function extractNameFromData(bytes _data) constant internal\n    returns (string extractedName) {\n        // check prefix present\n        uint expectedPrefixLength = (bytes(nameDataPrefix)).length;\n        if (_data.length < expectedPrefixLength) {\n            throw;\n        }\n        uint i;\n        for (i = 0; i < expectedPrefixLength; i++) {\n            if ((bytes(nameDataPrefix))[i] != _data[i]) {\n                throw;\n            }\n        }\n        // copy data after prefix\n        uint payloadLength = _data.length - expectedPrefixLength;\n        if (payloadLength < minimumNameLength ||\n            payloadLength > maximumNameLength) {\n            throw;\n        }\n        string memory name = new string(payloadLength);\n        for (i = 0; i < payloadLength; i++) {\n            (bytes(name))[i] = _data[expectedPrefixLength + i];\n        }\n        return name;\n    }\n\n    // Turn a short name into a ""fuzzy hash"" with the property\n    // that extremely similar names will have the same fuzzy hash.\n    //\n    // This is useful to:\n    //  - stop people choosing names which differ only in case or\n    //    punctuation and would lead to confusion.\n    //  - faciliate searching by name without needing exact match\n    //\n    // For example, these names all have the same fuzzy hash:\n    //\n    //  ""Banana""\n    //  ""BANANA""\n    //  ""Ba-na-na""\n    //  ""  banana  ""\n    //  ""Banana                        .. so long the end is ignored""\n    //\n    // On the other hand, ""Banana1"" and ""A Banana"" are different to\n    // the above.\n    //\n    // WARN: this is likely to work poorly on names that do not meet\n    // the validateNameInternal() test.\n    //\n    function computeNameFuzzyHash(string _name) constant internal\n    returns (uint fuzzyHash) {\n        bytes memory nameBytes = bytes(_name);\n        uint h = 0;\n        uint len = nameBytes.length;\n        if (len > maximumNameLength) {\n            len = maximumNameLength;\n        }\n        for (uint i = 0; i < len; i++) {\n            uint mul = 128;\n            byte b = nameBytes[i];\n            uint ub = uint(b);\n            if (b >= 48 && b <= 57) {\n                // 0-9\n                h = h * mul + ub;\n            } else if (b >= 65 && b <= 90) {\n                // A-Z\n                h = h * mul + ub;\n            } else if (b >= 97 && b <= 122) {\n                // fold a-z to A-Z\n                uint upper = ub - 32;\n                h = h * mul + upper;\n            } else {\n                // ignore others\n            }\n        }\n        return h;\n    }\n\n}\n\n\n/// @title Mixin to help define the rules of a throne.\ncontract ThroneRulesMixin {\n\n    // See World.createKingdom(..) for documentation.\n    struct ThroneRules {\n        uint startingClaimPriceWei;\n        uint maximumClaimPriceWei;\n        uint claimPriceAdjustPercent;\n        uint curseIncubationDurationSeconds;\n        uint commissionPerThousand;\n    }\n\n}\n\n\n/// @title Maintains the throne of a kingdom.\ncontract Kingdom is\n  ReentryProtectorMixin,\n  CarefulSenderMixin,\n  FundsHolderMixin,\n  MoneyRounderMixin,\n  NameableMixin,\n  ThroneRulesMixin {\n\n    // e.g. ""King of the Ether""\n    string public kingdomName;\n\n    // The World contract used to create this kingdom, or 0x0 if none.\n    address public world;\n\n    // The rules that govern this kingdom - see ThroneRulesMixin.\n    ThroneRules public rules;\n\n    // Someone who has ruled (or is ruling) our kingdom.\n    struct Monarch {\n        // where to send their compensation\n        address compensationAddress;\n        // their name\n        string name;\n        // when they became our ruler\n        uint coronationTimestamp;\n        // the claim price paid (excluding any over-payment)\n        uint claimPriceWei;\n        // the compensation sent to or held for them so far\n        uint compensationWei;\n    }\n\n    // The first ruler is number 1; the zero-th entry is a dummy entry.\n    Monarch[] public monarchsByNumber;\n\n    // The topWizard earns half the commission.\n    // They are normally the owner of the World contract.\n    address public topWizard;\n\n    // The subWizard earns half the commission.\n    // They are normally the creator of this Kingdom.\n    // The topWizard and subWizard can be the same address.\n    address public subWizard;\n\n    // NB: we also have a `funds` mapping from FundsHolderMixin,\n    // and a rentryProtector from ReentryProtectorMixin.\n\n    event ThroneClaimedEvent(uint monarchNumber);\n    event CompensationSentEvent(address toAddress, uint valueWei);\n    event CompensationFailEvent(address toAddress, uint valueWei);\n    event CommissionEarnedEvent(address byAddress, uint valueWei);\n    event WizardReplacedEvent(address oldWizard, address newWizard);\n    // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin\n\n    // WARN - does NOT validate arguments; you MUST either call\n    // KingdomFactory.validateProposedThroneRules() or create\n    // the Kingdom via KingdomFactory/World's createKingdom().\n    // See World.createKingdom(..) for parameter documentation.\n    function Kingdom(\n        string _kingdomName,\n        address _world,\n        address _topWizard,\n        address _subWizard,\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) {\n        kingdomName = _kingdomName;\n        world = _world;\n        topWizard = _topWizard;\n        subWizard = _subWizard;\n        rules = ThroneRules(\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n        // We number the monarchs starting from 1; it's sometimes useful\n        // to use zero = invalid, so put in a dummy entry for number 0.\n        monarchsByNumber.push(\n            Monarch(\n                0,\n                """",\n                0,\n                0,\n                0\n            )\n        );\n    }\n\n    function numberOfMonarchs() constant returns (uint totalCount) {\n        // zero-th entry is invalid\n        return monarchsByNumber.length - 1;\n    }\n\n    // False if either there are no monarchs, or if the latest monarch\n    // has reigned too long and been struck down by the curse.\n    function isLivingMonarch() constant returns (bool alive) {\n        if (numberOfMonarchs() == 0) {\n            return false;\n        }\n        uint reignStartedTimestamp = latestMonarchInternal().coronationTimestamp;\n        if (now < reignStartedTimestamp) {\n            // Should not be possible, think miners reject blocks with\n            // timestamps that go backwards? But some drift possible and\n            // it needs handling for unsigned overflow audit checks ...\n            return true;\n        }\n        uint elapsedReignDurationSeconds = now - reignStartedTimestamp;\n        if (elapsedReignDurationSeconds > rules.curseIncubationDurationSeconds) {\n            return false;\n        } else {\n            return true;\n        }\n    }\n\n    /// @notice How much you must pay to claim the throne now, in wei.\n    function currentClaimPriceWei() constant returns (uint priceInWei) {\n        if (!isLivingMonarch()) {\n            return rules.startingClaimPriceWei;\n        } else {\n            uint lastClaimPriceWei = latestMonarchInternal().claimPriceWei;\n            // no danger of overflow because claim price never gets that high\n            uint newClaimPrice =\n              (lastClaimPriceWei * (100 + rules.claimPriceAdjustPercent)) / 100;\n            newClaimPrice = roundMoneyDownNicely(newClaimPrice);\n            if (newClaimPrice < rules.startingClaimPriceWei) {\n                newClaimPrice = rules.startingClaimPriceWei;\n            }\n            if (newClaimPrice > rules.maximumClaimPriceWei) {\n                newClaimPrice = rules.maximumClaimPriceWei;\n            }\n            return newClaimPrice;\n        }\n    }\n\n    /// @notice How much you must pay to claim the throne now, in finney.\n    function currentClaimPriceInFinney() constant\n    returns (uint priceInFinney) {\n        uint valueWei = currentClaimPriceWei();\n        return roundMoneyUpToWholeFinney(valueWei);\n    }\n\n    /// @notice Check if a name can be used as a monarch name.\n    /// @return True if the name satisfies the criteria of:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    function validateProposedMonarchName(string _monarchName) constant\n    returns (bool allowed) {\n        return validateNameInternal(_monarchName);\n    }\n\n    // Get details of the latest monarch (even if they are dead).\n    //\n    // We don't expose externally because returning structs is not well\n    // supported in the ABI (strange that monarchsByNumber array works\n    // fine though). Note that the reference returned is writable - it\n    // can be used to update details of the latest monarch.\n    // WARN: you should check numberOfMonarchs() > 0 first.\n    function latestMonarchInternal() constant internal\n    returns (Monarch storage monarch) {\n        return monarchsByNumber[monarchsByNumber.length - 1];\n    }\n\n    /// @notice Claim throne by sending funds to the contract.\n    /// Any future compensation earned will be sent to the sender's\n    /// address (`msg.sender`).\n    /// Sending from a contract is not recommended unless you know\n    /// what you're doing (and you've tested it).\n    /// If no message data is supplied, the throne will be claimed in\n    /// the name of ""Anonymous"". To supply a name, send data encoded\n    /// using web3.fromAscii('NAME:' + 'your_chosen_valid_name').\n    /// Sender must include payment equal to currentClaimPriceWei().\n    /// Will consume up to ~300,000 gas.\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedMonarchName(string)`)\n    ///   - payment is too low or too high\n    /// Produces events:\n    ///   - `ThroneClaimedEvent`\n    ///   - `CompensationSentEvent` / `CompensationFailEvent`\n    ///   - `CommissionEarnedEvent`\n    function () {\n        externalEnter();\n        fallbackRP();\n        externalLeave();\n    }\n\n    /// @notice Claim throne in the given `_monarchName`.\n    /// Any future compensation earned will be sent to the caller's\n    /// address (`msg.sender`).\n    /// Caller must include payment equal to currentClaimPriceWei().\n    /// Calling from a contract is not recommended unless you know\n    /// what you're doing (and you've tested it).\n    /// Will consume up to ~300,000 gas.\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedMonarchName(string)`)\n    ///   - payment is too low or too high\n    /// Produces events:\n    ///   - `ThroneClaimedEvent\n    ///   - `CompensationSentEvent` / `CompensationFailEvent`\n    ///   - `CommissionEarnedEvent`\n    function claimThrone(string _monarchName) {\n        externalEnter();\n        claimThroneRP(_monarchName);\n        externalLeave();\n    }\n\n    /// @notice Used by either the topWizard or subWizard to transfer\n    /// all rights to future commissions to the `_replacement` wizard.\n    /// WARN: The original wizard retains ownership of any past\n    /// commission held for them in the `funds` mapping, which they\n    /// can still withdraw.\n    /// Produces event WizardReplacedEvent.\n    function replaceWizard(address _replacement) {\n        externalEnter();\n        replaceWizardRP(_replacement);\n        externalLeave();\n    }\n\n    function fallbackRP() internal {\n        if (msg.data.length == 0) {\n            claimThroneRP(""Anonymous"");\n        } else {\n            string memory _monarchName = extractNameFromData(msg.data);\n            claimThroneRP(_monarchName);\n        }\n    }\n    \n    function claimThroneRP(\n        string _monarchName\n    ) internal {\n\n        address _compensationAddress = msg.sender;\n\n        if (!validateNameInternal(_monarchName)) {\n            throw;\n        }\n\n        if (_compensationAddress == 0 ||\n            _compensationAddress == address(this)) {\n            throw;\n        }\n\n        uint paidWei = msg.value;\n        uint priceWei = currentClaimPriceWei();\n        if (paidWei < priceWei) {\n            throw;\n        }\n        // Make it easy for people to pay using a whole number of finney,\n        // which could be a teeny bit higher than the raw wei value.\n        uint excessWei = paidWei - priceWei;\n        if (excessWei > 1 finney) {\n            throw;\n        }\n        \n        uint compensationWei;\n        uint commissionWei;\n        if (!isLivingMonarch()) {\n            // dead men get no compensation\n            commissionWei = paidWei;\n            compensationWei = 0;\n        } else {\n            commissionWei = (paidWei * rules.commissionPerThousand) / 1000;\n            compensationWei = paidWei - commissionWei;\n        }\n\n        if (commissionWei != 0) {\n            recordCommissionEarned(commissionWei);\n        }\n\n        if (compensationWei != 0) {\n            compensateLatestMonarch(compensationWei);\n        }\n\n        // In case of any teeny excess, we use the official price here\n        // since that should determine the new claim price, not paidWei.\n        monarchsByNumber.push(Monarch(\n            _compensationAddress,\n            _monarchName,\n            now,\n            priceWei,\n            0\n        ));\n\n        ThroneClaimedEvent(monarchsByNumber.length - 1);\n    }\n\n    function replaceWizardRP(address replacement) internal {\n        if (msg.value != 0) {\n            throw;\n        }\n        bool replacedOk = false;\n        address oldWizard;\n        if (msg.sender == topWizard) {\n            oldWizard = topWizard;\n            topWizard = replacement;\n            WizardReplacedEvent(oldWizard, replacement);\n            replacedOk = true;\n        }\n        // Careful - topWizard and subWizard can be the same address,\n        // in which case we must replace both.\n        if (msg.sender == subWizard) {\n            oldWizard = subWizard;\n            subWizard = replacement;\n            WizardReplacedEvent(oldWizard, replacement);\n            replacedOk = true;\n        }\n        if (!replacedOk) {\n            throw;\n        }\n    }\n\n    // Allow commission funds to build up in contract for the wizards\n    // to withdraw (carefully ring-fenced).\n    function recordCommissionEarned(uint _commissionWei) internal {\n        // give the subWizard any ""odd"" single wei\n        uint topWizardWei = _commissionWei / 2;\n        uint subWizardWei = _commissionWei - topWizardWei;\n        funds[topWizard] += topWizardWei;\n        CommissionEarnedEvent(topWizard, topWizardWei);\n        funds[subWizard] += subWizardWei;\n        CommissionEarnedEvent(subWizard, subWizardWei);\n    }\n\n    // Send compensation to latest monarch (or hold funds for them\n    // if cannot through no fault of current caller).\n    function compensateLatestMonarch(uint _compensationWei) internal {\n        address compensationAddress =\n          latestMonarchInternal().compensationAddress;\n        // record that we compensated them\n        latestMonarchInternal().compensationWei = _compensationWei;\n        // WARN: if the latest monarch is a contract whose fallback\n        // function needs more 25300 gas than then they will NOT\n        // receive compensation automatically.\n        bool sentOk = carefulSendWithFixedGas(\n            compensationAddress,\n            _compensationWei,\n            suggestedExtraGasToIncludeWithSends\n        );\n        if (sentOk) {\n            CompensationSentEvent(compensationAddress, _compensationWei);\n        } else {\n            // This should only happen if the latest monarch is a contract\n            // whose fallback-function failed or ran out of gas (despite\n            // us including a fair amount of gas).\n            // We do not throw since we do not want the throne to get\n            // 'stuck' (it's not the new usurpers fault) - instead save\n            // the funds we could not send so can be claimed later.\n            // Their monarch contract would need to have been designed\n            // to call our withdrawFundsAdvanced(..) function mind you.\n            funds[compensationAddress] += _compensationWei;\n            CompensationFailEvent(compensationAddress, _compensationWei);\n        }\n    }\n\n}\n\n\n/// @title Used by the World contract to create Kingdom instances.\n/// @dev Mostly exists so topWizard can potentially replace this\n/// contract to modify the Kingdom contract and/or rule validation\n/// logic to be used for *future* Kingdoms created by the World.\n/// We do not implement rentry protection because we don't send/call.\n/// We do not charge a fee here - but if you bypass the World then\n/// you won't be listed on the official World page of course.\ncontract KingdomFactory {\n\n    function KingdomFactory() {\n    }\n\n    function () {\n        // this contract should never have a balance\n        throw;\n    }\n\n    // See World.createKingdom(..) for parameter documentation.\n    function validateProposedThroneRules(\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) constant returns (bool allowed) {\n        // I suppose there is a danger that massive deflation/inflation could\n        // change the real-world sanity of these checks, but in that case we\n        // can deploy a new factory and update the world.\n        if (_startingClaimPriceWei < 1 finney ||\n            _startingClaimPriceWei > 100 ether) {\n            return false;\n        }\n        if (_maximumClaimPriceWei < 1 ether ||\n            _maximumClaimPriceWei > 100000 ether) {\n            return false;\n        }\n        if (_startingClaimPriceWei * 20 > _maximumClaimPriceWei) {\n            return false;\n        }\n        if (_claimPriceAdjustPercent < 1 ||\n            _claimPriceAdjustPercent > 900) {\n            return false;\n        }\n        if (_curseIncubationDurationSeconds < 2 hours ||\n            _curseIncubationDurationSeconds > 10000 days) {\n            return false;\n        }\n        if (_commissionPerThousand < 10 ||\n            _commissionPerThousand > 100) {\n            return false;\n        }\n        return true;\n    }\n\n    /// @notice Create a new Kingdom. Normally called by World contract.\n    /// WARN: Does NOT validate the _kingdomName or _world arguments.\n    /// Will consume up to 1,800,000 gas (!)\n    /// Will throw an error if:\n    ///   - rules invalid (see validateProposedThroneRules)\n    ///   - wizard addresses ""obviously"" wrong\n    ///   - out of gas quite likely (perhaps in future should consider\n    ///     using solidity libraries to reduce Kingdom size?)\n    // See World.createKingdom(..) for parameter documentation.\n    function createKingdom(\n        string _kingdomName,\n        address _world,\n        address _topWizard,\n        address _subWizard,\n        uint _startingClaimPriceWei,\n        uint _maximumClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) returns (Kingdom newKingdom) {\n        if (msg.value > 0) {\n            // this contract should never have a balance\n            throw;\n        }\n        // NB: topWizard and subWizard CAN be the same as each other.\n        if (_topWizard == 0 || _subWizard == 0) {\n            throw;\n        }\n        if (_topWizard == _world || _subWizard == _world) {\n            throw;\n        }\n        if (!validateProposedThroneRules(\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        )) {\n            throw;\n        }\n        return new Kingdom(\n            _kingdomName,\n            _world,\n            _topWizard,\n            _subWizard,\n            _startingClaimPriceWei,\n            _maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n    }\n\n}\n\n\n/// @title Runs the world, which is a collection of Kingdoms.\ncontract World is\n  ReentryProtectorMixin,\n  NameableMixin,\n  MoneyRounderMixin,\n  FundsHolderMixin,\n  ThroneRulesMixin {\n\n    // The topWizard runs the world. They charge for the creation of\n    // kingdoms and become the topWizard in each kingdom created.\n    address public topWizard;\n\n    // How much one must pay to create a new kingdom (in wei).\n    // Can be changed by the topWizard.\n    uint public kingdomCreationFeeWei;\n\n    struct KingdomListing {\n        uint kingdomNumber;\n        string kingdomName;\n        address kingdomContract;\n        address kingdomCreator;\n        uint creationTimestamp;\n        address kingdomFactoryUsed;\n    }\n    \n    // The first kingdom is number 1; the zero-th entry is a dummy.\n    KingdomListing[] public kingdomsByNumber;\n\n    // For safety, we cap just how high the price can get.\n    // Can be changed by the topWizard, though it will only affect\n    // kingdoms created after that.\n    uint public maximumClaimPriceWei;\n\n    // Helper contract for creating Kingdom instances. Can be\n    // upgraded by the topWizard (won't affect existing ones).\n    KingdomFactory public kingdomFactory;\n\n    // Avoids duplicate kingdom names and allows searching by name.\n    mapping (uint => uint) kingdomNumbersByfuzzyHash;\n\n    // NB: we also have a `funds` mapping from FundsHolderMixin,\n    // and a rentryProtector from ReentryProtectorMixin.\n\n    event KingdomCreatedEvent(uint kingdomNumber);\n    event CreationFeeChangedEvent(uint newFeeWei);\n    event FactoryChangedEvent(address newFactory);\n    event WizardReplacedEvent(address oldWizard, address newWizard);\n    // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin\n\n    // Create the world with no kingdoms yet.\n    // Costs about 1.9M gas to deploy.\n    function World(\n        address _topWizard,\n        uint _kingdomCreationFeeWei,\n        KingdomFactory _kingdomFactory,\n        uint _maximumClaimPriceWei\n    ) {\n        if (_topWizard == 0) {\n            throw;\n        }\n        if (_maximumClaimPriceWei < 1 ether) {\n            throw;\n        }\n        topWizard = _topWizard;\n        kingdomCreationFeeWei = _kingdomCreationFeeWei;\n        kingdomFactory = _kingdomFactory;\n        maximumClaimPriceWei = _maximumClaimPriceWei;\n        // We number the kingdoms starting from 1 since it's sometimes\n        // useful to use zero = invalid. Create dummy zero-th entry.\n        kingdomsByNumber.push(KingdomListing(0, """", 0, 0, 0, 0));\n    }\n\n    function numberOfKingdoms() constant returns (uint totalCount) {\n        return kingdomsByNumber.length - 1;\n    }\n\n    /// @return index into kingdomsByNumber if found, or zero if not. \n    function findKingdomCalled(string _kingdomName) constant\n    returns (uint kingdomNumber) {\n        uint fuzzyHash = computeNameFuzzyHash(_kingdomName);\n        return kingdomNumbersByfuzzyHash[fuzzyHash];\n    }\n\n    /// @notice Check if a name can be used as a kingdom name.\n    /// @return True if the name satisfies the criteria of:\n    ///   - no fewer than 1 character\n    ///   - no more than 25 characters\n    ///   - no characters other than:\n    ///     - ""roman"" alphabet letters (A-Z and a-z)\n    ///     - western digits (0-9)\n    ///     - ""safe"" punctuation: ! ( ) - . _ SPACE\n    ///\n    /// WARN: does not check if the name is already in use;\n    /// use `findKingdomCalled(string)` for that afterwards.\n    function validateProposedKingdomName(string _kingdomName) constant\n    returns (bool allowed) {\n        return validateNameInternal(_kingdomName);\n    }\n\n    // Check if rules would be allowed for a new custom Kingdom.\n    // Typically used before calling `createKingdom(...)`.\n    function validateProposedThroneRules(\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) constant returns (bool allowed) {\n        return kingdomFactory.validateProposedThroneRules(\n            _startingClaimPriceWei,\n            maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n    }\n\n    // How much one must pay to create a new kingdom (in finney).\n    // Can be changed by the topWizard.\n    function kingdomCreationFeeInFinney() constant\n    returns (uint feeInFinney) {\n        return roundMoneyUpToWholeFinney(kingdomCreationFeeWei);\n    }\n\n    // Reject funds sent to the contract - wizards who cannot interact\n    // with it via the API won't be able to withdraw their commission.\n    function () {\n        throw;\n    }\n\n    /// @notice Create a new kingdom using custom rules.\n    /// @param _kingdomName \\n    ///   e.g. ""King of the Ether Throne""\n    /// @param _startingClaimPriceWei \\n    ///   How much it will cost the first monarch to claim the throne\n    ///   (and also the price after the death of a monarch).\n    /// @param _claimPriceAdjustPercent \\n    ///   Percentage increase after each claim - e.g. if claim price\n    ///   was 200 ETH, and `_claimPriceAdjustPercent` is 50, the next\n    ///   claim price will be 200 ETH + (50% of 200 ETH) => 300 ETH.\n    /// @param _curseIncubationDurationSeconds \\n    ///   The maximum length of a time a monarch can rule before the\n    ///   curse strikes and they are removed without compensation.\n    /// @param _commissionPerThousand \\n    ///   How much of each payment is given to the wizards to share,\n    ///   expressed in parts per thousand - e.g. 25 means 25/1000,\n    ///   or 2.5%.\n    /// \n    /// Caller must include payment equal to kingdomCreationFeeWei.\n    /// The caller will become the 'sub-wizard' and will earn half\n    /// any commission charged by the Kingdom.  Note however they\n    /// will need to call withdrawFunds() on the Kingdom contract\n    /// to get their commission - it's not send automatically.\n    ///\n    /// Will consume up to 1,900,000 gas (!)\n    /// Will throw an error if:\n    ///   - name is invalid (see `validateProposedKingdomName(string)`)\n    ///   - name is already in use (see `findKingdomCalled(string)`)\n    ///   - rules are invalid (see `validateProposedKingdomRules(...)`)\n    ///   - payment is too low or too high\n    ///   - insufficient gas (quite likely!)\n    /// Produces event KingdomCreatedEvent.\n    function createKingdom(\n        string _kingdomName,\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) {\n        externalEnter();\n        createKingdomRP(\n            _kingdomName,\n            _startingClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to transfer all rights to future\n    /// fees and future kingdom wizardships to `_replacement` wizard.\n    /// WARN: The original wizard retains ownership of any past fees\n    /// held for them in the `funds` mapping, which they can still\n    /// withdraw. They also remain topWizard in any existing Kingdoms.\n    /// Produces event WizardReplacedEvent.\n    function replaceWizard(address _replacement) {\n        externalEnter();\n        replaceWizardRP(_replacement);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the fee for creating kingdoms.\n    function setKingdomCreationFeeWei(uint _kingdomCreationFeeWei) {\n        externalEnter();\n        setKingdomCreationFeeWeiRP(_kingdomCreationFeeWei);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the cap on claim price.\n    function setMaximumClaimPriceWei(uint _maximumClaimPriceWei) {\n        externalEnter();\n        setMaximumClaimPriceWeiRP(_maximumClaimPriceWei);\n        externalLeave();\n    }\n\n    /// @notice Used by topWizard to vary the factory contract which\n    /// will be used to create future Kingdoms.\n    function setKingdomFactory(KingdomFactory _kingdomFactory) {\n        externalEnter();\n        setKingdomFactoryRP(_kingdomFactory);\n        externalLeave();\n    }\n\n    function createKingdomRP(\n        string _kingdomName,\n        uint _startingClaimPriceWei,\n        uint _claimPriceAdjustPercent,\n        uint _curseIncubationDurationSeconds,\n        uint _commissionPerThousand\n    ) internal {\n\n        address subWizard = msg.sender;\n\n        if (!validateNameInternal(_kingdomName)) {\n            throw;\n        }\n\n        uint newKingdomNumber = kingdomsByNumber.length;\n        checkUniqueAndRegisterNewKingdomName(\n            _kingdomName,\n            newKingdomNumber\n        );\n\n        uint paidWei = msg.value;\n        if (paidWei < kingdomCreationFeeWei) {\n            throw;\n        }\n        // Make it easy for people to pay using a whole number of finney,\n        // which could be a teeny bit higher than the raw wei value.\n        uint excessWei = paidWei - kingdomCreationFeeWei;\n        if (excessWei > 1 finney) {\n            throw;\n        }\n        funds[topWizard] += paidWei;\n        \n        // This will perform rule validation.\n        Kingdom kingdomContract = kingdomFactory.createKingdom(\n            _kingdomName,\n            address(this),\n            topWizard,\n            subWizard,\n            _startingClaimPriceWei,\n            maximumClaimPriceWei,\n            _claimPriceAdjustPercent,\n            _curseIncubationDurationSeconds,\n            _commissionPerThousand\n        );\n\n        kingdomsByNumber.push(KingdomListing(\n            newKingdomNumber,\n            _kingdomName,\n            kingdomContract,\n            msg.sender,\n            now,\n            kingdomFactory\n        ));\n    }\n\n    function replaceWizardRP(address replacement) internal { \n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        address oldWizard = topWizard;\n        topWizard = replacement;\n        WizardReplacedEvent(oldWizard, replacement);\n    }\n\n    function setKingdomCreationFeeWeiRP(uint _kingdomCreationFeeWei) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        kingdomCreationFeeWei = _kingdomCreationFeeWei;\n        CreationFeeChangedEvent(kingdomCreationFeeWei);\n    }\n\n    function setMaximumClaimPriceWeiRP(uint _maximumClaimPriceWei) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (_maximumClaimPriceWei < 1 ether) {\n            throw;\n        }\n        maximumClaimPriceWei = _maximumClaimPriceWei;\n    }\n\n    function setKingdomFactoryRP(KingdomFactory _kingdomFactory) internal {\n        if (msg.sender != topWizard) {\n            throw;\n        }\n        if (msg.value != 0) {\n            throw;\n        }\n        kingdomFactory = _kingdomFactory;\n        FactoryChangedEvent(kingdomFactory);\n    }\n\n    // If there is no existing kingdom called `_kingdomName`, create\n    // a record mapping that name to kingdom no. `_newKingdomNumber`.\n    // Throws an error if an existing kingdom with the same (or\n    // fuzzily similar - see computeNameFuzzyHash) name exists.\n    function checkUniqueAndRegisterNewKingdomName(\n        string _kingdomName,\n        uint _newKingdomNumber\n    ) internal {\n        uint fuzzyHash = computeNameFuzzyHash(_kingdomName);\n        if (kingdomNumbersByfuzzyHash[fuzzyHash] != 0) {\n            throw;\n        }\n        kingdomNumbersByfuzzyHash[fuzzyHash] = _newKingdomNumber;\n    }\n\n}\n\n\n/// @title Used on the testnet to allow automated testing of internals.\ncontract ExposedInternalsForTesting is\n  MoneyRounderMixin, NameableMixin {\n\n    function roundMoneyDownNicelyET(uint _rawValueWei) constant\n    returns (uint nicerValueWei) {\n        return roundMoneyDownNicely(_rawValueWei);\n    }\n\n    function roundMoneyUpToWholeFinneyET(uint _valueWei) constant\n    returns (uint valueFinney) {\n        return roundMoneyUpToWholeFinney(_valueWei);\n    }\n\n    function validateNameInternalET(string _name) constant\n    returns (bool allowed) {\n        return validateNameInternal(_name);\n    }\n\n    function extractNameFromDataET(bytes _data) constant\n    returns (string extractedName) {\n        return extractNameFromData(_data);\n    }\n    \n    function computeNameFuzzyHashET(string _name) constant\n    returns (uint fuzzyHash) {\n        return computeNameFuzzyHash(_name);\n    }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。多くの機能を持つが、芸術的表現はない。
1993773,0x6ac85d0408044afb786a6d631d4d3426ce0e031a,false,false,"contract DAO {\n    function balanceOf(address addr) returns (uint);\n    function transferFrom(address from, address to, uint balance) returns (bool);\n    function getNewDAOAddress(uint _proposalID) constant returns(address _newDAO);\n    uint public totalSupply;\n}\n\n/**\n * @title untrustedChildWithdraw\n * @author Paul Szczesny, Alexey Akhunov\n * A withdraw contract for untrusted childDAOs affected by the hard fork.\n * Based on the official WithdrawDAO contract found here: https://etherscan.io/address/0xbf4ed7b27f1d666546e30d74d50d173d20bca754#code\n */\ncontract untrustedChildWithdraw {\n\n  struct childDAO {\n	  DAO dao;\n    uint numerator;\n	}\n\n  DAO constant public mainDAO = DAO(0xbb9bc244d798123fde783fcc1c72d3bb8c189413);\n  uint[] public untrustedProposals = [35, 36, 53, 62, 67, 68, 70, 71, 73, 76, 87];\n  uint public ratioDenominator = 1000000000;\n  uint[] public untrustedTokenNumerator = [1458321331, 1458321331, 1399760834, 1457994374, 1457994374, 1146978827, 1457994374, 1458321336, 1458307000, 1458328768, 1458376290];\n  mapping (uint => childDAO) public whiteList;\n\n  /**\n  * Populates the whiteList based on the list of trusted proposal Ids.\n  */\n  function untrustedChildWithdraw() {\n      for(uint i=0; i<untrustedProposals.length; i++) {\n          uint proposalId = untrustedProposals[i];\n          whiteList[proposalId] = childDAO(DAO(mainDAO.getNewDAOAddress(proposalId)), untrustedTokenNumerator[i]);\n      }\n  }\n\n  /**\n  * Convienience function for the Curator to calculate the required amount of Wei\n  * that needs to be transferred to this contract.\n  */\n  function requiredEndowment() constant returns (uint endowment) {\n      uint sum = 0;\n      for(uint i=0; i<untrustedProposals.length; i++) {\n          uint proposalId = untrustedProposals[i];\n          DAO child = whiteList[proposalId].dao;\n          sum += (child.totalSupply() * (untrustedTokenNumerator[i] / ratioDenominator) );\n      }\n      return sum;\n  }\n\n  /**\n   * Function call to withdraw ETH by burning childDao tokens.\n   * @param proposalId The split proposal ID which created the childDao\n   * @dev This requires that the token-holder authorizes this contract's address using the approve() function.\n   */\n  function withdraw(uint proposalId) {\n    //Check the token balance\n    uint balance = whiteList[proposalId].dao.balanceOf(msg.sender);\n    uint adjustedBalance = balance * (whiteList[proposalId].numerator / ratioDenominator);\n\n    // Transfer childDao tokens first, then send Ether back in return\n    if (!whiteList[proposalId].dao.transferFrom(msg.sender, this, balance) || !msg.sender.send(adjustedBalance))\n      throw;\n  }\n\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
2000473,0x7d3ae940eb73dc9131758ad2e326c7d863b0916a,false,false,contract Doubler {\n\n    struct Participant {\n        address etherAddress;\n        uint amount;\n    }\n\n    Participant[] public participants;\n\n	uint public payoutIdx = 0;\n	uint public collectedFees = 0;\n	uint balance = 0;\n\n  // only owner modifier\n	address public owner;\n    modifier onlyowner { if (msg.sender == owner) _ }\n\n  // contract Constructor\n    function Doubler() {\n        owner = msg.sender;\n    }\n\n // fallback function\n    function(){\n        enter();\n    }\n\n	function enter(){\n      // collect fee\n        uint fee = msg.value / 40; // 2.5 % fee\n        collectedFees += fee;\n\n      // add a new participant\n		uint idx = participants.length;\n        participants.length++;\n        participants[idx].etherAddress = msg.sender;\n        participants[idx].amount = msg.value - fee;\n\n      // update available balance\n      	balance += msg.value - fee;\n      	\n	  // if there are enough ether on the balance we can pay out to an earlier participant\n	  	uint txAmount = participants[payoutIdx].amount * 2;\n        if(balance >= txAmount){\n        	if(!participants[payoutIdx].etherAddress.send(txAmount)) throw;\n\n            balance -= txAmount;\n            payoutIdx++;\n        }\n    }\n\n    function collectFees() onlyowner {\n        if(collectedFees == 0)return;\n\n        if(!owner.send(collectedFees))throw;\n        collectedFees = 0;\n    }\n\n    function setOwner(address _owner) onlyowner {\n        owner = _owner;\n    }\n},1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
2004436,0x181eec6b050ac30dff0c8b258ba0695339766734,false,false,"contract Token { \n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success);\n}\n\n// replay protection\ncontract ReplayProtection {\n    bool public isMainChain;\n\n    function ReplayProtection() {\n        bytes32 blockHash = 0xcf9055c648b3689a2b74e980fc6fa27817622fa9ac0749d60a6489a7fbcfe831;\n        // creates a unique signature with the latest 16 blocks\n        for (uint i = 1; i < 64; i++) {\n            if (blockHash == block.blockhash(block.number - i)) isMainChain = true;\n        }\n    }\n\n    // Splits the funds into 2 addresses\n    function etherSplit(address recipient, address altChainRecipient) returns(bool) {\n        if (isMainChain && recipient.send(msg.value)) {\n            return true;\n        } else if (!isMainChain && altChainRecipient > 0 && altChainRecipient.send(msg.value)) {\n            return true;\n        }\n        throw; // don't accept value transfer, otherwise it would be trapped.\n    }\n\n\n    function tokenSplit(address recipient, address altChainRecipient, address tokenAddress, uint amount) returns (bool) {\n        if (msg.value > 0 ) throw;\n\n        Token token = Token(tokenAddress);\n\n        if (isMainChain && token.transferFrom(msg.sender, recipient, amount)) {\n            return true;\n        } else if (!isMainChain && altChainRecipient > 0 && token.transferFrom(msg.sender, altChainRecipient, amount)) {\n            return true;\n        }\n        throw;\n    }\n\n    function () {\n        throw;\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
2008140,0x2136bbba2edca21afdddee838fff19ea70d10f03,false,false,"//last compiled with soljson-v0.3.5-2016-07-21-6610add.js\n\ncontract SafeMath {\n  //internals\n\n  function safeMul(uint a, uint b) internal returns (uint) {\n    uint c = a * b;\n    assert(a == 0 || c / a == b);\n    return c;\n  }\n\n  function safeSub(uint a, uint b) internal returns (uint) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  function safeAdd(uint a, uint b) internal returns (uint) {\n    uint c = a + b;\n    assert(c>=a && c>=b);\n    return c;\n  }\n\n  function assert(bool assertion) internal {\n    if (!assertion) throw;\n  }\n}\n\ncontract Token {\n\n    /// @return total amount of tokens\n    function totalSupply() constant returns (uint256 supply) {}\n\n    /// @param _owner The address from which the balance will be retrieved\n    /// @return The balance\n    function balanceOf(address _owner) constant returns (uint256 balance) {}\n\n    /// @notice send `_value` token to `_to` from `msg.sender`\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transfer(address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\n    /// @param _from The address of the sender\n    /// @param _to The address of the recipient\n    /// @param _value The amount of token to be transferred\n    /// @return Whether the transfer was successful or not\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\n\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @param _value The amount of wei to be approved for transfer\n    /// @return Whether the approval was successful or not\n    function approve(address _spender, uint256 _value) returns (bool success) {}\n\n    /// @param _owner The address of the account owning tokens\n    /// @param _spender The address of the account able to transfer the tokens\n    /// @return Amount of remaining tokens allowed to spent\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n\n}\n\ncontract StandardToken is Token {\n\n    function transfer(address _to, uint256 _value) returns (bool success) {\n        //Default assumes totalSupply can't be over max (2^256 - 1).\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\n        //Replace the if with this one instead.\n        if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n        //if (balances[msg.sender] >= _value && _value > 0) {\n            balances[msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(msg.sender, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\n        if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) {\n            balances[_to] += _value;\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else { return false; }\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n      return allowed[_owner][_spender];\n    }\n\n    mapping(address => uint256) balances;\n\n    mapping (address => mapping (address => uint256)) allowed;\n\n    uint256 public totalSupply;\n\n}\n\ncontract ReserveToken is StandardToken, SafeMath {\n    address public minter;\n    function ReserveToken() {\n      minter = msg.sender;\n    }\n    function create(address account, uint amount) {\n      if (msg.sender != minter) throw;\n      balances[account] = safeAdd(balances[account], amount);\n      totalSupply = safeAdd(totalSupply, amount);\n    }\n    function destroy(address account, uint amount) {\n      if (msg.sender != minter) throw;\n      if (balances[account] < amount) throw;\n      balances[account] = safeSub(balances[account], amount);\n      totalSupply = safeSub(totalSupply, amount);\n    }\n}\n\ncontract EtherDelta is SafeMath {\n\n  mapping (address => mapping (address => uint)) tokens; //mapping of token addresses to mapping of account balances\n  //ether balances are held in the token=0 account\n  mapping (bytes32 => uint) orderFills;\n  address public feeAccount;\n  uint public feeMake; //percentage times (1 ether)\n  uint public feeTake; //percentage times (1 ether)\n\n  event Order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n  event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s);\n  event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give);\n  event Deposit(address token, address user, uint amount, uint balance);\n  event Withdraw(address token, address user, uint amount, uint balance);\n\n  function EtherDelta(address feeAccount_, uint feeMake_, uint feeTake_) {\n    feeAccount = feeAccount_;\n    feeMake = feeMake_;\n    feeTake = feeTake_;\n  }\n\n  function() {\n    throw;\n  }\n\n  function deposit() {\n    tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value);\n    Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]);\n  }\n\n  function withdraw(uint amount) {\n    if (msg.value>0) throw;\n    if (tokens[0][msg.sender] < amount) throw;\n    tokens[0][msg.sender] = safeSub(tokens[0][msg.sender], amount);\n    if (!msg.sender.call.value(amount)()) throw;\n    Withdraw(0, msg.sender, amount, tokens[0][msg.sender]);\n  }\n\n  function depositToken(address token, uint amount) {\n    //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf.\n    if (msg.value>0 || token==0) throw;\n    if (!Token(token).transferFrom(msg.sender, this, amount)) throw;\n    tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount);\n    Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  function withdrawToken(address token, uint amount) {\n    if (msg.value>0 || token==0) throw;\n    if (tokens[token][msg.sender] < amount) throw;\n    tokens[token][msg.sender] = safeSub(tokens[token][msg.sender], amount);\n    if (!Token(token).transfer(msg.sender, amount)) throw;\n    Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\n  }\n\n  function balanceOf(address token, address user) constant returns (uint) {\n    return tokens[token][user];\n  }\n\n  function order(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s) {\n    if (msg.value>0) throw;\n    Order(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n  }\n\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {\n    //amount is in amountGet terms\n    if (msg.value>0) throw;\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      ecrecover(hash,v,r,s) == user &&\n      block.number <= expires &&\n      safeAdd(orderFills[hash], amount) <= amountGet &&\n      tokens[tokenGet][msg.sender] >= amount &&\n      tokens[tokenGive][user] >= safeMul(amountGive, amount) / amountGet\n    )) throw;\n    tokens[tokenGet][msg.sender] = safeSub(tokens[tokenGet][msg.sender], amount);\n    tokens[tokenGet][user] = safeAdd(tokens[tokenGet][user], safeMul(amount, ((1 ether) - feeMake)) / (1 ether));\n    tokens[tokenGet][feeAccount] = safeAdd(tokens[tokenGet][feeAccount], safeMul(amount, feeMake) / (1 ether));\n    tokens[tokenGive][user] = safeSub(tokens[tokenGive][user], safeMul(amountGive, amount) / amountGet);\n    tokens[tokenGive][msg.sender] = safeAdd(tokens[tokenGive][msg.sender], safeMul(safeMul(((1 ether) - feeTake), amountGive), amount) / amountGet / (1 ether));\n    tokens[tokenGive][feeAccount] = safeAdd(tokens[tokenGive][feeAccount], safeMul(safeMul(feeTake, amountGive), amount) / amountGet / (1 ether));\n    orderFills[hash] = safeAdd(orderFills[hash], amount);\n    Trade(tokenGet, amount, tokenGive, amountGive * amount / amountGet, user, msg.sender);\n  }\n\n  function testTrade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount, address sender) constant returns(bool) {\n    if (!(\n      tokens[tokenGet][sender] >= amount &&\n      availableVolume(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s) >= amount\n    )) return false;\n    return true;\n  }\n\n  function availableVolume(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) constant returns(uint) {\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (!(\n      ecrecover(hash,v,r,s) == user &&\n      block.number <= expires\n    )) return 0;\n    uint available1 = safeSub(amountGet, orderFills[hash]);\n    uint available2 = safeMul(tokens[tokenGive][user], amountGet) / amountGive;\n    if (available1<available2) return available1;\n    return available2;\n  }\n\n  function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s) {\n    if (msg.value>0) throw;\n    bytes32 hash = sha256(tokenGet, amountGet, tokenGive, amountGive, expires, nonce);\n    if (user!=msg.sender) throw;\n    orderFills[hash] = amountGet;\n    Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, v, r, s);\n  }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
2009664,0x8a520f5ff71a4de0e075ce2c36045d62eee80dba,false,false,"contract owned {\n    address public owner;\n    \n    function owned() {\n        owner = msg.sender;\n    }\n    \n    function setOwner(address _new) onlyOwner {\n        owner = _new;\n    }\n    \n    modifier onlyOwner {\n        if (msg.sender != owner) throw;\n    }\n}\n\ncontract TheGrid is owned {\n	// The number of the game\n	uint public gameId = 1;\n	// The size of the grid. It will start at 3 and increase\n    uint public size = 4;\n	uint public nextsize = 5;\n	// Number of empty spots. Reaching 0 will create next game\n    uint public empty = 16;\n    \n	// The micro of the owners benefit, i.e. it will gain\n	// money / 1000000 * benefitMicros.\n    uint public benefitMicros = 24900;\n	// The current price for one spot of the grid\n    uint public price = 100 finney;\n	// The price to start with for one spot\n	uint public startPrice = 100 finney;\n	// Micros of the price increase after buy, i.e after each buy\n	// the price will be old / 1000000 * priceIncrease\n	uint public priceIncrease = 15000;\n	// The win for this game\n    uint public win;\n    \n	// A mapping of the pending payouts\n	mapping(address => uint) public pendingPayouts;\n	uint public totalPayouts;\n	// A mapping of the points gained in this game\n    mapping(address => uint) public balanceOf;\n    uint public totalSupply;\n    \n	// State of the grid. Positions are encoded as _x*size+_y.\n    address[] public theGrid;\n	// A list of all players, needed for payouts.\n    address[] public players;\n	// The last player who played. Not allowed to play next turn too.\n	address public lastPlayer;\n	\n	// The timeout interval\n	uint public timeout = 6 hours;\n	// Timestamp of the timeout if no one plays before\n	uint public timeoutAt;\n    \n	// Will be triggered on the end of each game\n	event GameEnded(uint indexed gameId, uint win, uint totalPoints);\n	// Will be triggered on each start of a game\n	event GameStart(uint indexed gameId, uint size);\n	// Will be triggered on each bought position\n	event PositionBought(uint indexed gameId, uint indexed moveNo,\n						 uint where, address who, uint pointsGained, \n						 uint etherPaid);\n	// Will be triggered on each timeout!\n	event Timeout(uint indexed gameId, uint indexed moveNo);\n	// Will be triggered on each payout withdraw\n	event Collect(address indexed who, uint value);\n	\n    function TheGrid() {\n		// Setting the length of theGrid and timeout\n        theGrid.length = empty;        \n		timeoutAt = now + timeout;\n		GameStart(gameId, size);\n    }\n	\n	// The direction count counts the positions hold by this player in ONE\n	// direction, i.e. to determine a line length you have to call it twice\n	// (one time for north direction, one time for south by example)\n	function directionCount(int _x, int _y, int _dx, int _dy)\n			internal returns (uint) {\n		var found = uint(0);\n		var s = int(size);\n		_x += _dx;\n		_y += _dy;\n		// While still on the grid...\n		while (_x < s && _y < s && _x >= 0 && _y >= 0) {\n			// If it is the sender, gain point, else break\n			if (theGrid[getIndex(uint(_x), uint(_y))] == msg.sender) {\n				found ++;\n			} else {\n				break;\n			}\n			// Go to next position\n			_x += _dx;\n			_y += _dy;\n		}\n		return found;\n	}\n    \n    /// Buy the spot at _x, _y if it is available and gain points for every\n    /// connected spot of your color sharing lines with this spot.\n    function buy(uint _x, uint _y) {\n		// Has to be an available position (getIndex will throw off-grid)\n        if (theGrid[getIndex(_x, _y)] != 0) throw;\n		// No one is allowed to play two token right after each other\n		if (msg.sender == lastPlayer) throw;\n		// If there is a timeout, divide the price by two and let the\n		// next game start at 3 again.\n		if (now > timeoutAt) {\n			price = price / 2;\n			// 1 finney is the lowest acceptable price. It makes sure the\n			// calculation of a players share never becomes 0.\n			if (price < 1 finney) price = 1 finney;\n			nextsize = 3;\n			Timeout(gameId, size*size - empty + 1);\n		}\n		// If more than the price per position is sended, add it to the\n		// payouts so it can be withdrawn later\n		if (msg.value < price) {\n			throw;\n		} else {\n			// The owner of the contract gets a little benefit\n			// The sender gets back the overhead\n			var benefit = price / 1000000 * benefitMicros;\n			if (pendingPayouts[owner] + benefit < pendingPayouts[owner]) throw;\n			pendingPayouts[owner] += benefit;\n			if (pendingPayouts[msg.sender] + msg.value - price < pendingPayouts[msg.sender]) throw;\n			pendingPayouts[msg.sender] += msg.value - price;\n			if (totalPayouts + msg.value - price + benefit < totalPayouts) throw;\n			totalPayouts += msg.value - price + benefit;\n			// Add the price to the win\n			if (win + price - benefit < win) throw;\n			win += price - benefit;\n		}\n\n        // Set the position to this address\n        empty --;\n        theGrid[getIndex(_x, _y)] = msg.sender;\n        \n        // Add player on first time and give him his one joining point\n        var found = uint(0);\n		if (balanceOf[msg.sender] == 0) {\n            players.push(msg.sender);\n			found = 1;\n        }\n        \n        // Discover linear connected spots and give the buyer the square\n		// of the lines lengths as points. See the rules.\n		\n		var x = int(_x);\n		var y = int(_y);\n		\n		// East to west\n		var a = 1 + directionCount(x, y, 1, 0) + directionCount(x, y, -1, 0);\n		if (a >= 3) {\n			found += a * a;\n		}\n		\n		// North east to south west\n		a = 1 + directionCount(x, y, 1, 1) + directionCount(x, y, -1, -1);\n		if (a >= 3) {\n			found += a * a;\n		}\n		\n		// North to south\n		a = 1 + directionCount(x, y, 0, 1) + directionCount(x, y, 0, -1);\n		if (a >= 3) {\n			found += a * a;\n		}\n		\n		// North west to south east\n		a = 1 + directionCount(x, y, 1, -1) + directionCount(x, y, -1, 1);\n		if (a >= 3) {\n			found += a * a;\n		}\n        \n        // Add points\n		if (balanceOf[msg.sender] + found < balanceOf[msg.sender]) throw;\n        balanceOf[msg.sender] += found;\n		if (totalSupply + found < totalSupply) throw;\n        totalSupply += found;\n		\n		// Trigger event before the price increases!\n		PositionBought(gameId, size*size-empty, getIndex(_x, _y), msg.sender, found, price);\n		\n		// Increase the price per position by the price Increase\n		price = price / 1000000 * (1000000 + priceIncrease);\n		\n		// Set new timeout and last player played\n		timeoutAt = now + timeout;\n		lastPlayer = msg.sender;\n		\n		// If this was the last empty position, initiate next game\n        if (empty == 0) nextRound();\n    }\n	\n	/// Collect your pending payouts using this method\n	function collect() {\n		var balance = pendingPayouts[msg.sender];\n		pendingPayouts[msg.sender] = 0;\n		totalPayouts -= balance;\n		if (!msg.sender.send(balance)) throw;\n		Collect(msg.sender, balance);\n	}\n    \n	// Returns the in array index of one position and throws on\n	// off-grid position\n    function getIndex(uint _x, uint _y) internal returns (uint) {\n        if (_x >= size) throw;\n        if (_y >= size) throw;\n		return _x * size + _y;\n    }\n    \n	// Will initiate the next game by clearing most of the data\n	// and calculating the payouts.\n    function nextRound() internal {\n        GameEnded(gameId, win, totalSupply);\n		// Calculate share per point\n		if (totalPayouts + win < totalPayouts) throw;\n		totalPayouts += win;\n		// If the totalSupply is 0, no one played, so no one can gain a share\n		// The maximum total Supply is lower than 1.1e9, so the share can't\n		// become 0 because of a too high totalSupply, as a finney is still\n		// bigger.\n		var share = totalSupply == 0 ? 0 : win / totalSupply;\n        // Send balances to the payouts\n		// If the win was not dividable by the number of points, it is kept\n		// for the next game. Most properly only some wei.\n        for (var i = 0; i < players.length; i++) {\n			var amount = share * balanceOf[players[i]];\n			totalSupply -= balanceOf[players[i]];\n			balanceOf[players[i]] = 0;\n			if (pendingPayouts[players[i]] + amount < pendingPayouts[players[i]]) throw;\n            pendingPayouts[players[i]] += amount;\n			win -= amount;\n        }\n		\n        \n        // Delete positions and player\n        delete theGrid;\n        delete players;\n		lastPlayer = 0x0;\n		// The next game will be a bit bigger, but limit it to 64.\n        size = nextsize;\n		if (nextsize < 64) nextsize ++;\n		gameId ++;\n		// Calculate empty spots\n        empty = size * size;\n		theGrid.length = empty;\n		// Reset the price\n		price = startPrice;\n		\n		GameStart(gameId, size);\n    }\n}",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。ゲームロジックを実装しているが、芸術性は低い。
2010210,0xc3ac4f8327750aa96f9fc23a7e311bcb692ebb34,false,false,"contract CMHome {\naddress CMAdmin = 0xD97C2Ecbd1ba8C1785cf416a7111197fd677F638; \n////////////////////COYPRIGHT INFORMATION///////////////	\n/*copyright 2016 @coinmechanics.com. All rights reserved*/	\n///////////////DATA STRUCTURE & STORES/////////\nstruct WhiteList{\nbool Valid;\nbool Created;\nbool Abitration;	\n}\nmapping(address => WhiteList) public whitelist;\n	\nstruct MyContracts {\nbool Created;\naddress Contr;	\n}		\nmapping(uint32 => mapping (address => MyContracts)) public mycontracts;\n\nstruct Factories {\nbool Authorised;\nbool Controlled;\n}\nmapping (address => Factories) public factory;\n\n/////////////CONFIGURE FACTORY//////////////\nfunction Config(uint8 control, address _factory){\nif(msg.sender != CMAdmin)throw;\n\nfactory[_factory].Authorised = true;\n\nif(control == 0){\nfactory[_factory].Controlled = false;\n}\nif(control == 1){\nfactory[_factory].Controlled = true;\n}\n}\n/////////UPDATE ARBITRATION STATUS//////////////\nfunction Auth(uint8 state, address _contract){\nif(msg.sender != CMAdmin)throw;\n\nif(state == 0){\nwhitelist[_contract].Abitration = false;\n}\nif(state == 1){\nwhitelist[_contract].Abitration = true;\n}\n}		\n///////////////START REGISTRATION////////////////\nfunction RegisterOne(uint32 _id, address _owner, address _contract){\nif(factory[msg.sender].Authorised == false) throw;\nwhitelist[_contract].Created = true;\nwhitelist[_contract].Valid = false;\nwhitelist[_contract].Abitration = false;\nmycontracts[_id][_owner].Created = true;\nmycontracts[_id][_owner].Contr = _contract;\n}\n//////////////COMPLETE REGISTERATION//////////\nfunction RegisterTwo(address _contract, address _factr){\nif(whitelist[_contract].Created == false)throw;\nif(whitelist[_contract].Valid == true)throw;\nwhitelist[_contract].Valid = true;\nif(factory[_factr].Controlled == true) {\nwhitelist[_contract].Abitration = false;\n}\nif(factory[_factr].Controlled == false) {\nwhitelist[_contract].Abitration = true;\n}\n}\nfunction(){ throw; }	\n}///////////////////////////////end of cm home contract\n\ncontract MoonrakerFactory {\naddress CMAdmin = 0xD97C2Ecbd1ba8C1785cf416a7111197fd677F638;\n	\n///////////////CONTRACT ADDRESS////\nfunction GetContractAddr() constant returns (address){\nreturn this;\n}	\naddress ContrAddr2 = GetContractAddr();\n	\n//////CREATE MOONRACKER CONTRACT////////////\n\nfunction Create(uint32 pin, address _cmhome){\n\naddress sender = msg.sender;\naddress atlantis = new Moonraker(sender,ContrAddr2);\n\nCMHome\nHomeCall = CMHome(_cmhome);	\n(HomeCall.RegisterOne(pin,sender,atlantis));	\n}\n////////DATA STRUCTURE & STORES////////\n\nstruct Pricing {\nuint32 ServiceFee;\nuint32 DefaultFee;	\n}\nPricing pri;\n\n/////////UPDATE PRICES////////\nfunction UpdatePrice(uint8 component, uint32 price){\nif(msg.sender != CMAdmin) throw;       \nif(component == 1) pri.ServiceFee = price;\nif(component == 2) pri.DefaultFee = price;  \n}\n\n//////////GET PRICES////////\nfunction GetPrice(uint8 get)returns (uint32){\nif(get == 1) return pri.ServiceFee;\nif(get == 2) return pri.DefaultFee;\n}\n\nfunction() { throw; }\n}//////////////////////////end of moonraker factory\n\ncontract Moonraker {\naddress CMAccount = 0x346a16921af2db3788d29FB171604f1251A25aBF;\naddress CMAdmin = 0xD97C2Ecbd1ba8C1785cf416a7111197fd677F638;\nuint256 WeiConverter = 1000000000000000000;\nuint32 Factor = 100000000;\nuint32 ServiceFee;\nuint32 DefaultFee;\nuint256 Fee;	\nuint256 Pay;\nuint256 NetPayout;\n////////////CONTRACT ADDRESS///////////////////////////\nfunction GetContractAddr() constant returns (address){\nreturn this;\n}	\naddress ContrAddr = GetContractAddr();\n\n/////////////CONTRACT DATA STRUCTURE//////////////////\n\nstruct Core {\naddress Owner;\naddress Factory;\naddress Home;\nbool SetUp;\n}\n\nstruct fContr1 {\nuint256 ContractID;	\nstring ContractType;\nstring AssetAndCurrency;\nstring OwnerPosition;\nstring PriceAddress;\n}	\n	\nstruct fContr2 {\nuint32 Units;\nuint32 CounterPartyDeposit;\nuint32 OwnerDeposit;\n}\n\nstruct fContr3 {\nstring MovementRange;	\nstring ActivationTime;\nstring ExpirationTime;\n}\n\nstruct Status {\nbool Dispute;\nbool ActivePro;\nbool ActiveSet;\nbool ActiveArb;\n}\n\nstruct Deposits {\nbool CounterPartyFunded;\nbool OwnerFunded;\naddress CounterPartyAddr;\naddress OwnerAddr;\n}\n\nstruct Settlement {\nbool CounterPartySettled; \nbool OwnerSettled;\nuint32 CounterPartyPayout;\nuint32 OwnerPayout;\n} \n\nstruct Arbitration {\nbool OwnerDefault;\nuint32 PayCounterParty;\nuint32 PayOwner;\n}\n///////////////MAP DATA STORES///////////////////\nmapping (uint256 => fContr1) public contractPartOne;	\nmapping (uint256 => fContr2) public contractPartTwo;\nmapping (uint256 => fContr3) public contractPartThree;\nmapping (uint256 => Settlement) public settlement;\nmapping (uint256 => Arbitration) public arbitration;\nmapping (uint256 => Deposits) public deposits;\nmapping (uint256 => Status) public status;	\n	\n////////////INITIALIZE DATA STORES/////////////\nfContr1 c1;	\nfContr2 c2;\nfContr3 c3;\nSettlement se;\nArbitration ar;\nDeposits de;\nStatus st;\nCore co;\n\n////////////////CONSTRUCTOR///////////////////////\nfunction Moonraker(address _sender,address _factory){\nco.Owner = _sender;\nco.Factory = _factory;\n}\n\n//////////////////COMPLETE REGISTRATION////////////////////\nfunction Register(address cmhome){\nCMHome\nHomeCall = CMHome(cmhome);	\n(HomeCall.RegisterTwo(ContrAddr,co.Factory));\nco.Home = cmhome;\nco.SetUp = true;\n}\n\n//////////////////////////CONTRACT REFERENCE///////////////////\nuint256 ContractNum = 1;	\nevent ProposalLog(uint256 contract_id);			\n////////////////////////////PROPOSAL//////////////////////////\nfunction CreateProposal(\nstring AssetAndCurrency,\nstring OwnerPosition,\nstring PriceAddress,\nuint32 Units,\nstring ActivationTime,\nstring ExpirationTime,\nstring MovementRange,\nuint32 CounterPartyDeposit,\nuint32 OwnerDeposit) {\nif(msg.sender != co.Owner) throw;   \nif(co.SetUp != true) throw;        \nif(st.ActivePro == true) throw;   \nif(st.ActiveSet == true) throw;   \nif(st.ActiveArb == true) throw; \nc1.ContractID = ContractNum;	\nc1.ContractType = 'FORWARD CONTRACT';	\nc1.AssetAndCurrency = AssetAndCurrency;\nc1.OwnerPosition = OwnerPosition;\nc1.PriceAddress = PriceAddress;\nc2.Units = Units;	\nc2.CounterPartyDeposit = CounterPartyDeposit;	\nc2.OwnerDeposit = OwnerDeposit;	\nc3.ActivationTime = ActivationTime ;\nc3.ExpirationTime = ExpirationTime;\nc3.MovementRange = MovementRange;\ncontractPartOne[ContractNum].ContractID = ContractNum;\ncontractPartOne[ContractNum].ContractType = 'FORWARD CONTRACT';	\ncontractPartOne[ContractNum].AssetAndCurrency = AssetAndCurrency; \ncontractPartOne[ContractNum].OwnerPosition = OwnerPosition; \ncontractPartOne[ContractNum].PriceAddress = PriceAddress; \ncontractPartTwo[ContractNum].Units = Units;\ncontractPartTwo[ContractNum].CounterPartyDeposit = CounterPartyDeposit;\ncontractPartTwo[ContractNum].OwnerDeposit = OwnerDeposit;\ncontractPartThree[ContractNum].ActivationTime = ActivationTime;\ncontractPartThree[ContractNum].ExpirationTime = ExpirationTime;\ncontractPartThree[ContractNum].MovementRange = MovementRange;\nst.ActivePro = true;\nstatus[ContractNum].ActivePro = true;\nProposalLog(ContractNum);	\n}\n	\n////////////////OWNER DEPOSIT//////////////\n\nfunction OwnerDeposit(){\nuint256 _OwnerDeposit = c2.OwnerDeposit *  WeiConverter;\n\nif(st.ActivePro == false) throw; \nif(msg.sender != co.Owner) throw;\nif(msg.value != _OwnerDeposit) throw;\nif(deposits[ContractNum].OwnerFunded == true) throw;\nse.OwnerSettled = false;\nde.OwnerAddr = co.Owner;\nde.OwnerFunded = true;\ndeposits[ContractNum].OwnerFunded = true;	\ndeposits[ContractNum].OwnerAddr = co.Owner;\n}\n\n/////////COUNTER PARTY DEPOSIT/////////////\n\nfunction CounterPartyDeposit(){\nuint256 _CounterPartyDeposit = c2.CounterPartyDeposit * WeiConverter ;\n\nif(st.ActivePro == false) throw; \nif(msg.sender == co.Owner) throw;\nif(msg.value != _CounterPartyDeposit) throw;\nif(deposits[ContractNum].CounterPartyFunded == true) throw;\nse.CounterPartySettled = false;\nde.CounterPartyAddr = msg.sender;\nde.CounterPartyFunded = true;\ndeposits[ContractNum].CounterPartyFunded = true;	\ndeposits[ContractNum].CounterPartyAddr = msg.sender;		\n}\n\n////////////////////////////SETTLEMENT//////////////////\n\nfunction Settle (\nuint32 CounterPartyPayout,\nuint32 OwnerPayout){\nif(msg.sender != co.Owner) throw;\nif(st.Dispute == true) throw;	\nif(st.ActivePro == false) throw;   \nif(st.ActiveSet == true) throw;   \nif(de.CounterPartyFunded == false) throw;   \nif(de.OwnerFunded == false) throw;        \nif(CounterPartyPayout < 100) throw; \nif(OwnerPayout < 100) throw;       \nse.CounterPartyPayout = CounterPartyPayout;\nse.OwnerPayout = OwnerPayout;\nsettlement[ContractNum].CounterPartyPayout = CounterPartyPayout;\nsettlement[ContractNum].OwnerPayout = OwnerPayout;\nst.ActiveSet = true;\nstatus[ContractNum].ActiveSet = true;	\n}\n\n///////////SETTLEMENT PAYOUT/////////////////\nfunction Payout (){\nif(st.ActiveSet != true) throw;\nif(st.Dispute == true) throw;\nif(st.ActiveArb == true) throw;\nif((msg.sender != de.CounterPartyAddr) && (msg.sender != de.OwnerAddr))throw; \nif(msg.sender == de.OwnerAddr && se.CounterPartySettled == false)throw;\n\nMoonrakerFactory\nFactoryCall = MoonrakerFactory(co.Factory);	\nServiceFee = (FactoryCall.GetPrice(1));\n	\nif((msg.sender == de.OwnerAddr) && (se.OwnerSettled == false)){\nPay = ((se.OwnerPayout * WeiConverter) / 100);\nse.OwnerSettled = true;\nsettlement[ContractNum].OwnerSettled = true;\nif(!de.OwnerAddr.send(Pay)) throw;\n}\nif((msg.sender == de.CounterPartyAddr) && (se.CounterPartySettled == false)){\nFee = ((se.CounterPartyPayout * ServiceFee * WeiConverter) / Factor);\nPay = ((se.CounterPartyPayout * WeiConverter) / 100);\nNetPayout = Pay - Fee;\nse.CounterPartySettled = true;\nsettlement[ContractNum].CounterPartySettled = true;\nif(!de.CounterPartyAddr.send(NetPayout)) throw;\nif(!CMAccount.send(Fee)) throw;\n}\n}	\n/////////////DISPUTE/////////////////\nfunction Dispute() {\nif((msg.sender != co.Owner) && (msg.sender != de.CounterPartyAddr)) throw;     \nif(st.Dispute == true) throw; \nif(se.CounterPartySettled == true) throw;\nif(se.OwnerSettled == true) throw;\nif(de.OwnerFunded == false && msg.sender == co.Owner)throw; \nif(de.CounterPartyFunded == false && msg.sender == de.CounterPartyAddr)throw;\nif(de.OwnerFunded != true && de.CounterPartyFunded != true)throw; \nst.Dispute = true;\nstatus[ContractNum].Dispute = true;\n}\n////////////////////////////ARBITRATION////////////////////\n\nfunction Arbitrate(\nuint32 PayCounterParty,\nuint32 PayOwner,\nbool OwnerDefault){\nif(msg.sender != CMAdmin) throw;   \nif(st.ActivePro == false) throw;  \nif(st.Dispute == false) throw;    \nif(st.ActiveArb == true) throw;  \nif(PayCounterParty < 100) throw; \nif(PayOwner < 100) throw;       \nar.PayCounterParty = PayCounterParty;\nar.PayOwner = PayOwner;\nar.OwnerDefault = OwnerDefault;	\narbitration[ContractNum].PayCounterParty = PayCounterParty;	\narbitration[ContractNum].PayOwner = PayOwner;\narbitration[ContractNum].OwnerDefault = OwnerDefault;\nst.ActiveArb = true;	\nstatus[ContractNum].ActiveArb = true;	\n}\n\n///////////COUNTER PARTY ARBITRATION PAYOUT/////////////\nfunction CCPayoutArb (){	\nif(st.Dispute == false) throw;\nif(st.ActiveArb == false) throw;\nif(msg.sender != de.CounterPartyAddr)throw; \n\nMoonrakerFactory\nFactoryCall = MoonrakerFactory(co.Factory);	\nServiceFee = (FactoryCall.GetPrice(1));\nDefaultFee = (FactoryCall.GetPrice(2));\n\nif((ar.OwnerDefault == true) && (se.CounterPartySettled == false)){\nFee = ((ar.PayCounterParty * ServiceFee * WeiConverter) / Factor);	\nPay = ((ar.PayCounterParty * WeiConverter) / 100);\nNetPayout = Pay - Fee;\nse.CounterPartySettled = true;\nsettlement[ContractNum].CounterPartySettled = true;\nif(!de.CounterPartyAddr.send(NetPayout)) throw;\nif(!CMAccount.send(Fee)) throw;\n}\nif((ar.OwnerDefault == false) && (se.CounterPartySettled == false)){\nFee = ((ar.PayCounterParty * DefaultFee * WeiConverter) / Factor);\nPay = ((ar.PayCounterParty * WeiConverter) / 100);\nNetPayout = Pay - Fee;\nse.CounterPartySettled = true;\nsettlement[ContractNum].CounterPartySettled = true;\nif(!de.CounterPartyAddr.send(NetPayout)) throw;\nif(!CMAccount.send(Fee)) throw;\n}\n}\n\n//////////////////OWNER ARBITRATION PAYOUT////////////	\nfunction OWPayoutArb (){		\nif(st.Dispute == false) throw;\nif(st.ActiveArb == false) throw;\nif(msg.sender != de.OwnerAddr)throw; \n\nMoonrakerFactory\nFactoryCall = MoonrakerFactory(co.Factory);	\nServiceFee = (FactoryCall.GetPrice(1));\nDefaultFee = (FactoryCall.GetPrice(2));\n\nif((ar.OwnerDefault == false) && (se.OwnerSettled == false)){\nPay = ((ar.PayOwner * WeiConverter) / 100);\nif(!de.OwnerAddr.send(Pay)) throw;\nse.OwnerSettled = true;\nsettlement[ContractNum].OwnerSettled = true;\n}\n\nif((ar.OwnerDefault == true) && (se.OwnerSettled == false)){\nFee = ((ar.PayOwner * DefaultFee * WeiConverter) / Factor);	\nPay = ((ar.PayOwner * WeiConverter) / 100); \nNetPayout = Pay - Fee;\nif(!de.OwnerAddr.send(NetPayout)) throw;\nif(!CMAccount.send(Fee)) throw;\nse.OwnerSettled = true;\nsettlement[ContractNum].OwnerSettled = true;\n}\n}\n	\n//////////////////////////REFUNDS////////////////////////\nfunction Refund(){\nif(st.ActivePro == false) throw;	\nif(st.ActiveSet == true) throw;\nif(st.ActiveArb == true) throw;\nif(st.Dispute == true) throw;\n\nif(msg.sender == co.Owner && de.CounterPartyFunded == false \n&& de.OwnerFunded == true){\nuint256 _OwnerDeposit = c2.OwnerDeposit * WeiConverter;\nif(!de.OwnerAddr.send(_OwnerDeposit)) throw;\ndeposits[ContractNum].OwnerFunded = false;\nde.OwnerFunded = false;\nsettlement[ContractNum].OwnerSettled = true;\nse.OwnerSettled = true;\n}\n\nif(msg.sender == de.CounterPartyAddr && de.CounterPartyFunded == true \n&& de.OwnerFunded == false){\nuint256 _CounterPartyDeposit = c2.CounterPartyDeposit * WeiConverter;\nif(!de.CounterPartyAddr.send(_CounterPartyDeposit)) throw;\ndeposits[ContractNum].CounterPartyFunded = false;\ndeposits[ContractNum].CounterPartyAddr = 0;\nde.CounterPartyFunded = false;\nde.CounterPartyAddr = 0;\nse.CounterPartySettled = true;\nsettlement[ContractNum].CounterPartySettled = true;\n}\n}\n////////////////OWNER ADMINISTRATION////////////////\nfunction Reset(){\nif(msg.sender != co.Owner)throw;\nif(de.CounterPartyFunded == true && se.CounterPartySettled == false) throw;	\nif(de.OwnerFunded == true && se.OwnerSettled == false) throw;\nst.Dispute = false;\nst.ActivePro = false;\nst.ActiveSet = false;\nst.ActiveArb = false;	\nContractNum++;	\n}\n\nfunction() { throw; }		\n}/////////////////////////////end of moonracker contract",1,Solidityの実用的な構造を持つ標準的なスマートコントラクト。
2010259,0x2560bd9f0177ab2f4699f841fd83dfd7dd21d455,false,false,"contract CMHome {\naddress CMAdmin = 0xD97C2Ecbd1ba8C1785cf416a7111197fd677F638; \n////////////////////COYPRIGHT INFORMATION///////////////	\n/*copyright 2016 @coinmechanics.com. All rights reserved*/	\n///////////////DATA STRUCTURE & STORES/////////\nstruct WhiteList{\nbool Valid;\nbool Created;\nbool Abitration;	\n}\nmapping(address => WhiteList) public whitelist;\n	\nstruct MyContracts {\nbool Created;\naddress Contr;	\n}		\nmapping(uint32 => mapping (address => MyContracts)) public mycontracts;\n\nstruct Factories {\nbool Authorised;\nbool Controlled;\n}\nmapping (address => Factories) public factory;\n\n/////////////CONFIGURE FACTORY//////////////\n\nfunction Config(uint8 control, address _factory){\nif(msg.sender != CMAdmin)throw;\n\nfactory[_factory].Authorised = true;\n\nif(control == 0){\nfactory[_factory].Controlled = false;\n}\nif(control == 1){\nfactory[_factory].Controlled = true;\n}\n}\n\n/////////UPDATE ARBITRATION STATUS//////////////\n\nfunction Auth(uint8 state, address _contract){\nif(msg.sender != CMAdmin)throw;\n\nif(state == 0){\nwhitelist[_contract].Abitration = false;\n}\nif(state == 1){\nwhitelist[_contract].Abitration = true;\n}\n}\n		\n///////////////START REGISTRATION////////////////\n\nfunction RegisterOne(uint32 _id, address _owner, address _contract){\n\nif(factory[msg.sender].Authorised == false) throw;\n\nwhitelist[_contract].Created = true;\nwhitelist[_contract].Valid = false;\nwhitelist[_contract].Abitration = false;\nmycontracts[_id][_owner].Created = true;\nmycontracts[_id][_owner].Contr = _contract;\n}\n\n//////////////COMPLETE REGISTERATION//////////\n\nfunction RegisterTwo(address _contract, address _factr){\n\nif(whitelist[_contract].Created == false)throw;\nif(whitelist[_contract].Valid == true)throw;\nwhitelist[_contract].Valid = true;\n\nif(factory[_factr].Controlled == true) {\nwhitelist[_contract].Abitration = false;\n}\n\nif(factory[_factr].Controlled == false) {\nwhitelist[_contract].Abitration = true;\n}\n}\nfunction(){ throw; }	\n}///////////////////////////////end of cm home contract\n\n\ncontract SkywalkerFactory {\naddress CMAdmin = 0xD97C2Ecbd1ba8C1785cf416a7111197fd677F638;\n	\n///////////////CONTRACT ADDRESS////\nfunction GetContractAddr() constant returns (address){\nreturn this;\n}	\naddress ContrAddr2 = GetContractAddr();\n	\n//////CREATE SKYWALKER CONTRACT////////////\n\nfunction Create(uint32 pin, address _cmhome){\n\naddress sender = msg.sender;\naddress atlantis = new Skywalker(sender,ContrAddr2);\n\nCMHome\nHomeCall = CMHome(_cmhome);	\n(HomeCall.RegisterOne(pin,sender,atlantis));	\n}\n\n////////DATA STRUCTURE & STORES////////\n\nstruct Pricing {\nuint32 ServiceFee;\nuint32 DefaultFee;	\n}\nPricing pri;\n\n/////////UPDATE PRICES////////\nfunction UpdatePrice(uint8 component, uint32 price){\nif(msg.sender != CMAdmin) throw;       \nif(component == 1) pri.ServiceFee = price;\nif(component == 2) pri.DefaultFee = price;  \n}\n\n//////////GET PRICES////////\nfunction GetPrice(uint8 get)returns (uint32){\nif(get == 1) return pri.ServiceFee;\nif(get == 2) return pri.DefaultFee;\n}\n\nfunction() { throw; }\n}//////////////////////////end of moonraker factory\n\ncontract Skywalker {\naddress CMAccount = 0x346a16921af2db3788d29FB171604f1251A25aBF;\naddress CMAdmin = 0xD97C2Ecbd1ba8C1785cf416a7111197fd677F638;\nuint256 WeiConverter = 1000000000000000000;\nuint32 Factor = 100000000;\nuint32 ServiceFee;\nuint32 DefaultFee;\nuint256 Fee;	\nuint256 Pay;\nuint256 NetPayout;\n////////////CONTRACT ADDRESS///////////////////////////\nfunction GetContractAddr() constant returns (address){\nreturn this;\n}	\naddress ContrAddr = GetContractAddr();\n\n/////////////CONTRACT DATA STRUCTURE//////////////////\n\nstruct Core {\naddress Owner;\naddress Factory;\naddress Home;\nbool SetUp;\n}\n\nstruct fContr1 {\nuint256 ContractID;	\nstring ContractType;\nstring AssetAndCurrency;\nstring OwnerPosition;\nstring PriceAddress;\n}	\n	\nstruct fContr2 {\nuint32 Units;\nuint32 CounterPartyDeposit;\nuint32 OwnerDeposit;\n}\n\nstruct fContr3 {\nstring MovementRange;	\nstring ActivationTime;\nstring ExpirationTime;\n}\n\nstruct Status {\nbool Dispute;\nbool ActivePro;\nbool ActiveSet;\nbool ActiveArb;\n}\n\nstruct Deposits {\nbool CounterPartyFunded;\nbool OwnerFunded;\naddress CounterPartyAddr;\naddress OwnerAddr;\n}\n\nstruct Settlement {\nbool CounterPartySettled; \nbool OwnerSettled;\nuint32 CounterPartyPayout;\nuint32 OwnerPayout;\n} \n\nstruct Arbitration {\nbool OwnerDefault;\nuint32 PayCounterParty;\nuint32 PayOwner;\n}\n///////////////MAP DATA STORES///////////////////\nmapping (uint256 => fContr1) public contractPartOne;	\nmapping (uint256 => fContr2) public contractPartTwo;\nmapping (uint256 => fContr3) public contractPartThree;\nmapping (uint256 => Settlement) public settlement;\nmapping (uint256 => Arbitration) public arbitration;\nmapping (uint256 => Deposits) public deposits;\nmapping (uint256 => Status) public status;	\n	\n////////////INITIALIZE DATA STORES/////////////\nfContr1 c1;	\nfContr2 c2;\nfContr3 c3;\nSettlement se;\nArbitration ar;\nDeposits de;\nStatus st;\nCore co;\n\n////////////////CONSTRUCTOR///////////////////////\nfunction Skywalker(address _sender,address _factory){\nco.Owner = _sender;\nco.Factory = _factory;\n}\n\n//////////////////COMPLETE REGISTRATION////////////////////\nfunction Register(address cmhome){\nCMHome\nHomeCall = CMHome(cmhome);	\n(HomeCall.RegisterTwo(ContrAddr,co.Factory));\nco.Home = cmhome;\nco.SetUp = true;\n}\n\n//////////////////////////CONTRACT REFERENCE///////////////////\nuint256 ContractNum = 1;	\nevent ProposalLog(uint256 contract_id);			\n////////////////////////////PROPOSAL//////////////////////////\nfunction CreateProposal(\nstring AssetAndCurrency,\nstring OwnerPosition,\nstring PriceAddress,\nuint32 Units,\nstring ActivationTime,\nstring ExpirationTime,\nstring MovementRange,\nuint32 CounterPartyDeposit,\nuint32 OwnerDeposit) {\nif(msg.sender != co.Owner) throw;   \nif(co.SetUp != true) throw;        \nif(st.ActivePro == true) throw;   \nif(st.ActiveSet == true) throw;   \nif(st.ActiveArb == true) throw; \nc1.ContractID = ContractNum;	\nc1.ContractType = 'CONTRACT FOR DIFFERENCE';	\nc1.AssetAndCurrency = AssetAndCurrency;\nc1.OwnerPosition = OwnerPosition;\nc1.PriceAddress = PriceAddress;\nc2.Units = Units;	\nc2.CounterPartyDeposit = CounterPartyDeposit;	\nc2.OwnerDeposit = OwnerDeposit;	\nc3.ActivationTime = ActivationTime ;\nc3.ExpirationTime = ExpirationTime;\nc3.MovementRange = MovementRange;\ncontractPartOne[ContractNum].ContractID = ContractNum;\ncontractPartOne[ContractNum].ContractType = 'CONTRACT FOR DIFFERENCE';	\ncontractPartOne[ContractNum].AssetAndCurrency = AssetAndCurrency; \ncontractPartOne[ContractNum].OwnerPosition = OwnerPosition; \ncontractPartOne[ContractNum].PriceAddress = PriceAddress; \ncontractPartTwo[ContractNum].Units = Units;\ncontractPartTwo[ContractNum].CounterPartyDeposit = CounterPartyDeposit;\ncontractPartTwo[ContractNum].OwnerDeposit = OwnerDeposit;\ncontractPartThree[ContractNum].ActivationTime = ActivationTime;\ncontractPartThree[ContractNum].ExpirationTime = ExpirationTime;\ncontractPartThree[ContractNum].MovementRange = MovementRange;\nst.ActivePro = true;\nstatus[ContractNum].ActivePro = true;\nProposalLog(ContractNum);	\n}\n	\n////////////////OWNER DEPOSIT//////////////\n\nfunction OwnerDeposit(){\nuint256 _OwnerDeposit = c2.OwnerDeposit *  WeiConverter;\n\nif(st.ActivePro == false) throw; \nif(msg.sender != co.Owner) throw;\nif(msg.value != _OwnerDeposit) throw;\nif(deposits[ContractNum].OwnerFunded == true) throw;\nse.OwnerSettled = false;\nde.OwnerAddr = co.Owner;\nde.OwnerFunded = true;\ndeposits[ContractNum].OwnerFunded = true;	\ndeposits[ContractNum].OwnerAddr = co.Owner;\n}\n\n/////////COUNTER PARTY DEPOSIT/////////////\n\nfunction CounterPartyDeposit(){\nuint256 _CounterPartyDeposit = c2.CounterPartyDeposit * WeiConverter ;\n\nif(st.ActivePro == false) throw; \nif(msg.sender == co.Owner) throw;\nif(msg.value != _CounterPartyDeposit) throw;\nif(deposits[ContractNum].CounterPartyFunded == true) throw;\nse.CounterPartySettled = false;\nde.CounterPartyAddr = msg.sender;\nde.CounterPartyFunded = true;\ndeposits[ContractNum].CounterPartyFunded = true;	\ndeposits[ContractNum].CounterPartyAddr = msg.sender;		\n}\n\n////////////////////////////SETTLEMENT//////////////////\n\nfunction Settle (\nuint32 CounterPartyPayout,\nuint32 OwnerPayout){\nif(msg.sender != co.Owner) throw;\nif(st.Dispute == true) throw;	\nif(st.ActivePro == false) throw;   \nif(st.ActiveSet == true) throw;   \nif(de.CounterPartyFunded == false) throw;   \nif(de.OwnerFunded == false) throw;        \nif(CounterPartyPayout < 100) throw; \nif(OwnerPayout < 100) throw;       \nse.CounterPartyPayout = CounterPartyPayout;\nse.OwnerPayout = OwnerPayout;\nsettlement[ContractNum].CounterPartyPayout = CounterPartyPayout;\nsettlement[ContractNum].OwnerPayout = OwnerPayout;\nst.ActiveSet = true;\nstatus[ContractNum].ActiveSet = true;	\n}\n\n///////////SETTLEMENT PAYOUT/////////////////\nfunction Payout (){\nif(st.ActiveSet != true) throw;\nif(st.Dispute == true) throw;\nif(st.ActiveArb == true) throw;\nif((msg.sender != de.CounterPartyAddr) && (msg.sender != de.OwnerAddr))throw; \nif(msg.sender == de.OwnerAddr && se.CounterPartySettled == false)throw;\n\nSkywalkerFactory\nFactoryCall = SkywalkerFactory(co.Factory);	\nServiceFee = (FactoryCall.GetPrice(1));\n	\nif((msg.sender == de.OwnerAddr) && (se.OwnerSettled == false)){\nPay = ((se.OwnerPayout * WeiConverter) / 100);\nse.OwnerSettled = true;\nsettlement[ContractNum].OwnerSettled = true;\nif(!de.OwnerAddr.send(Pay)) throw;\n}\nif((msg.sender == de.CounterPartyAddr) && (se.CounterPartySettled == false)){\nFee = ((se.CounterPartyPayout * ServiceFee * WeiConverter) / Factor);\nPay = ((se.CounterPartyPayout * WeiConverter) / 100);\nNetPayout = Pay - Fee;\nse.CounterPartySettled = true;\nsettlement[ContractNum].CounterPartySettled = true;\nif(!de.CounterPartyAddr.send(NetPayout)) throw;\nif(!CMAccount.send(Fee)) throw;\n}\n}	\n/////////////DISPUTE/////////////////\nfunction Dispute() {\nif((msg.sender != co.Owner) && (msg.sender != de.CounterPartyAddr)) throw;     \nif(st.Dispute == true) throw; \nif(se.CounterPartySettled == true) throw;\nif(se.OwnerSettled == true) throw;\nif(de.OwnerFunded == false && msg.sender == co.Owner)throw; \nif(de.CounterPartyFunded == false && msg.sender == de.CounterPartyAddr)throw;\nif(de.OwnerFunded != true && de.CounterPartyFunded != true)throw; \nst.Dispute = true;\nstatus[ContractNum].Dispute = true;\n}\n////////////////////////////ARBITRATION////////////////////\n\nfunction Arbitrate(\nuint32 PayCounterParty,\nuint32 PayOwner,\nbool OwnerDefault){\nif(msg.sender != CMAdmin) throw;   \nif(st.ActivePro == false) throw;  \nif(st.Dispute == false) throw;    \nif(st.ActiveArb == true) throw;  \nif(PayCounterParty < 100) throw; \nif(PayOwner < 100) throw;       \nar.PayCounterParty = PayCounterParty;\nar.PayOwner = PayOwner;\nar.OwnerDefault = OwnerDefault;	\narbitration[ContractNum].PayCounterParty = PayCounterParty;	\narbitration[ContractNum].PayOwner = PayOwner;\narbitration[ContractNum].OwnerDefault = OwnerDefault;\nst.ActiveArb = true;	\nstatus[ContractNum].ActiveArb = true;	\n}\n\n///////////COUNTER PARTY ARBITRATION PAYOUT/////////////\nfunction CCPayoutArb (){	\nif(st.Dispute == false) throw;\nif(st.ActiveArb == false) throw;\nif(msg.sender != de.CounterPartyAddr)throw; \n\nSkywalkerFactory\nFactoryCall = SkywalkerFactory(co.Factory);	\nServiceFee = (FactoryCall.GetPrice(1));\nDefaultFee = (FactoryCall.GetPrice(2));\n\nif((ar.OwnerDefault == true) && (se.CounterPartySettled == false)){\nFee = ((ar.PayCounterParty * ServiceFee * WeiConverter) / Factor);	\nPay = ((ar.PayCounterParty * WeiConverter) / 100);\nNetPayout = Pay - Fee;\nse.CounterPartySettled = true;\nsettlement[ContractNum].CounterPartySettled = true;\nif(!de.CounterPartyAddr.send(NetPayout)) throw;\nif(!CMAccount.send(Fee)) throw;\n}\nif((ar.OwnerDefault == false) && (se.CounterPartySettled == false)){\nFee = ((ar.PayCounterParty * DefaultFee * WeiConverter) / Factor);\nPay = ((ar.PayCounterParty * WeiConverter) / 100);\nNetPayout = Pay - Fee;\nse.CounterPartySettled = true;\nsettlement[ContractNum].CounterPartySettled = true;\nif(!de.CounterPartyAddr.send(NetPayout)) throw;\nif(!CMAccount.send(Fee)) throw;\n}\n}\n\n//////////////////OWNER ARBITRATION PAYOUT////////////	\nfunction OWPayoutArb (){		\nif(st.Dispute == false) throw;\nif(st.ActiveArb == false) throw;\nif(msg.sender != de.OwnerAddr)throw; \n\nSkywalkerFactory\nFactoryCall = SkywalkerFactory(co.Factory);	\nServiceFee = (FactoryCall.GetPrice(1));\nDefaultFee = (FactoryCall.GetPrice(2));\n\nif((ar.OwnerDefault == false) && (se.OwnerSettled == false)){\nPay = ((ar.PayOwner * WeiConverter) / 100);\nif(!de.OwnerAddr.send(Pay)) throw;\nse.OwnerSettled = true;\nsettlement[ContractNum].OwnerSettled = true;\n}\n\nif((ar.OwnerDefault == true) && (se.OwnerSettled == false)){\nFee = ((ar.PayOwner * DefaultFee * WeiConverter) / Factor);	\nPay = ((ar.PayOwner * WeiConverter) / 100); \nNetPayout = Pay - Fee;\nif(!de.OwnerAddr.send(NetPayout)) throw;\nif(!CMAccount.send(Fee)) throw;\nse.OwnerSettled = true;\nsettlement[ContractNum].OwnerSettled = true;\n}\n}\n	\n//////////////////////////REFUNDS////////////////////////\nfunction Refund(){\nif(st.ActivePro == false) throw;	\nif(st.ActiveSet == true) throw;\nif(st.ActiveArb == true) throw;\nif(st.Dispute == true) throw;\n\nif(msg.sender == co.Owner && de.CounterPartyFunded == false \n&& de.OwnerFunded == true){\nuint256 _OwnerDeposit = c2.OwnerDeposit * WeiConverter;\nif(!de.OwnerAddr.send(_OwnerDeposit)) throw;\ndeposits[ContractNum].OwnerFunded = false;\nde.OwnerFunded = false;\nsettlement[ContractNum].OwnerSettled = true;\nse.OwnerSettled = true;\n}\n\nif(msg.sender == de.CounterPartyAddr && de.CounterPartyFunded == true \n&& de.OwnerFunded == false){\nuint256 _CounterPartyDeposit = c2.CounterPartyDeposit * WeiConverter;\nif(!de.CounterPartyAddr.send(_CounterPartyDeposit)) throw;\ndeposits[ContractNum].CounterPartyFunded = false;\ndeposits[ContractNum].CounterPartyAddr = 0;\nde.CounterPartyFunded = false;\nde.CounterPartyAddr = 0;\nse.CounterPartySettled = true;\nsettlement[ContractNum].CounterPartySettled = true;\n}\n}\n////////////////OWNER ADMINISTRATION////////////////\nfunction Reset(){\nif(msg.sender != co.Owner)throw;\nif(de.CounterPartyFunded == true && se.CounterPartySettled == false) throw;	\nif(de.OwnerFunded == true && se.OwnerSettled == false) throw;\nst.Dispute = false;\nst.ActivePro = false;\nst.ActiveSet = false;\nst.ActiveArb = false;	\nContractNum++;	\n}\n\nfunction() { throw; }		\n}/////////////////////////////end of skywalker contract",1,"Solidityの実用的な構造を持つ標準的なスマートコントラクト。
